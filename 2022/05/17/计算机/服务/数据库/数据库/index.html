<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"flat","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1. 概述1.1 数据库的基本概念1.1.1 几个术语 数据库  数据库（Database，DB）是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据和数据的定义的集合  数据库管理系统  数据库管理系统(DBMS)是指能够对数据库进行有效管理的一个计算机软件，它建立在操作系统的基础上，对数据库进行统一管理和控制。  数据库系统  数据库应用系统简称数据库系统，">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库">
<meta property="og:url" content="http://example.com/2022/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/index.html">
<meta property="og:site_name" content="LZL">
<meta property="og:description" content="1. 概述1.1 数据库的基本概念1.1.1 几个术语 数据库  数据库（Database，DB）是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据和数据的定义的集合  数据库管理系统  数据库管理系统(DBMS)是指能够对数据库进行有效管理的一个计算机软件，它建立在操作系统的基础上，对数据库进行统一管理和控制。  数据库系统  数据库应用系统简称数据库系统，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742105272-a5e5485b-cb63-484b-9fc9-c6a7a1989a83.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742107176-24b88a70-b97a-4bf9-9747-e2962f91cba2.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742674803-2892e942-3661-478e-ba51-3c4f7164482d.jpeg">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652742923641-45000422-4e74-46c7-b57c-76d9ac069683.png#clientId=udaff6168-4c9f-4&from=paste&id=u09c0ecab&originHeight=544&originWidth=932&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u49e342a7-2072-462b-a1a9-00b64324b34&title=">
<meta property="og:image" content="https://s2.loli.net/2022/05/17/H7BFWXbjzK5yxTC.png#id=DPeb4&originHeight=600&originWidth=751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652745838384-4a7b3d37-e348-418f-a162-deea7d252e0f.png#clientId=udaff6168-4c9f-4&from=paste&id=u80a4e231&originHeight=748&originWidth=745&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u931c99de-933d-479c-861d-35d55bd2a5b&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652745859344-2708a5cf-21a2-4945-9d74-e880521aa847.png#clientId=udaff6168-4c9f-4&from=paste&id=ud41c5547&originHeight=720&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1204b37b-e74b-4b7a-bf23-28d0e6c73b4&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652745920475-75e92c00-d6f1-4ed0-9f2b-201b421b23b9.jpeg#clientId=udaff6168-4c9f-4&from=paste&id=u7a777a6c&originHeight=405&originWidth=485&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc431d207-2aa0-4579-b73c-928d90d44b2&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345617641-d617d3e3-690c-4522-bd57-8a45c0c555d6.png#clientId=u736bb5e6-27d0-4&from=paste&id=uf9fb592c&originHeight=77&originWidth=314&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u473c8258-4752-45ab-9998-89ce5b09bd3&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345617599-7e75a78a-ca81-4eb7-bea7-8c98db7931dd.png#clientId=u736bb5e6-27d0-4&from=paste&id=u37d4ad51&originHeight=77&originWidth=175&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua60c8ccc-ca3f-40e0-84a0-65ce5edf61b&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345717033-8737d287-8da7-4928-9e9d-0ceaf575bb03.png#clientId=u736bb5e6-27d0-4&from=paste&id=u38b74b1d&originHeight=53&originWidth=323&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4b46b9c5-a575-42c7-871a-82df9d64dc1&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345717002-8c29f92b-f641-43a7-819d-b354a83e3b93.png#clientId=u736bb5e6-27d0-4&from=paste&id=u73b8b727&originHeight=79&originWidth=315&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23142341-0bd6-451f-9e59-6056c8f733e&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572517064-341243d1-8427-4af2-acca-16b6a71a57c0.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u3e09088b&originHeight=66&originWidth=906&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9929b734-fe1f-41f9-a273-046e92a929f&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572775955-6cdb5c2d-0e61-414f-af0f-b3a36b198c99.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u05be4568&originHeight=317&originWidth=680&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1db0f0b2-bd2c-4457-8b1f-4cc18543c33&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572775998-4951e3f7-a849-47e9-87a2-aee61111ac6b.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u787e88db&originHeight=430&originWidth=680&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u101100ed-c678-41bc-8a23-c9fc934a576&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819171-6bf276cf-0af2-4bb0-9d54-68a0fb7fe631.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u3929182c&originHeight=351&originWidth=845&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udcc94fa6-3994-4292-b969-8f24b47d909&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819196-2d0a04d7-6e04-4fc9-8ff5-fdd0ba33d1fd.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u46e8e81e&originHeight=309&originWidth=674&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u427e85f2-4091-46f9-8138-db8489415e4&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819189-4a1d842d-dd5b-41e7-a9c0-83943c2e2a54.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8d2deae7&originHeight=204&originWidth=223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uaa7bcf7d-90ed-46a5-a620-1d237c86d02&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819157-df519c98-586b-446d-8c57-d272a93e775c.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue5070452&originHeight=193&originWidth=673&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u896f61cb-2d15-4ff2-9fa4-9573195cffe&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819190-1ce5faff-be81-472e-a954-1c4e4c11b085.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u2a4920ee&originHeight=44&originWidth=431&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u80856453-c7c9-41bc-b4cf-51bcb9c5153&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573112631-f9567555-8a7b-49fa-9691-82be0708e6a5.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8c6ecec0&originHeight=122&originWidth=546&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u883a92f2-559a-4dbd-ab72-a0386141271&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573186402-3967a422-db29-42a5-a4c5-1207a0dbd7c6.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9e4cb0db&originHeight=598&originWidth=699&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u78b79890-8778-4fd1-848a-8c376b503f6&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573220679-45a1e8b6-22c2-4c35-b1aa-a1529a49013b.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1bcdaa68&originHeight=546&originWidth=575&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6ca0625-4743-4d35-beff-c8071975156&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236147-74e62cef-be60-488d-bab8-f6f31c3b9e73.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u19ae6dc1&originHeight=331&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua8ca6364-46de-4580-82fd-f9d80632b13&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236100-d6f2b118-75cd-483a-8dd4-e12d6d8a2426.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u5fa71f6e&originHeight=119&originWidth=353&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47ed1e63-2755-4ae5-be8f-3b6fec7e2b6&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236195-d0961f06-730c-45d5-a4ac-905ceb03c10f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u34058ee3&originHeight=39&originWidth=313&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e380e7d-03f9-4a9b-abc0-d70d8d33d6f&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573250887-c05e193b-0105-4b1c-92c4-f24cc82ef23e.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=uc517ff05&originHeight=354&originWidth=552&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u721aecdf-9b53-4756-b0ca-00d9f15d56e&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573280552-8b1760e3-cb83-4498-891b-da9c930ffb93.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1f8d4fe3&originHeight=202&originWidth=677&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7201c300-6e23-4f69-a57d-eb235ad2ab9&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653573289858-f4a4dd86-0cd8-4c8a-b584-4d13c164c80c.png#clientId=ud43d93cd-6fda-4&from=paste&id=ue8cf501f&originHeight=598&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u51ba1d81-e789-4ab5-94ac-87dbac298c9&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653573289819-2ae3892c-b938-466e-9b02-7f731906cf93.png#clientId=ud43d93cd-6fda-4&from=paste&id=u74778b01&originHeight=596&originWidth=1176&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u376d1d41-3b26-4afb-8803-7fc16f25a55&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573289819-5c4e0ff9-c0fc-44d5-a193-c0425a909062.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0d201b78&originHeight=351&originWidth=506&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u858a2e37-15a4-44b2-b777-53e4d6f374a&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573299657-75a2e4e3-b242-40f3-89c3-9399431cb422.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue0f2693c&originHeight=236&originWidth=485&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u74d7e563-e745-4eda-9fcd-954bd724d2f&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573329991-c15840b1-811a-4f26-9a7d-df3ca7ce6f62.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u7d201c52&originHeight=208&originWidth=480&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f7a2087-9616-40e4-a6da-69ba73a2712&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338647-2b678428-50b7-4de5-9b2b-a62a75900d5f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ufb1e60d7&originHeight=50&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u444856ef-3eac-4f3c-b306-9526e7889ea&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338941-5c430d9d-8596-42c7-935d-4eee649722bc.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ua9b9d750&originHeight=58&originWidth=442&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3ae27434-4992-4258-a512-7ef9c144a00&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338609-6ae513e7-b27d-4aee-85aa-3139871e0d59.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u88e4d2e4&originHeight=242&originWidth=474&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u662ef947-40b8-41bb-b172-95d672c195c&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573347962-328ac465-ce00-49fb-9ab2-bb4cfeb9fc08.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u06c41a59&originHeight=640&originWidth=886&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0bde01f9-99b1-48ec-9693-4926a633b37&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348009-999a77bb-f080-455c-9c88-45d51c930486.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9cc7730c&originHeight=57&originWidth=395&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6b4963cd-1c3e-465e-b247-fefb07577d3&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348005-17d551a8-cd40-4502-aedc-bb3146cfbfc4.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue170527f&originHeight=252&originWidth=487&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2b0b6e9f-fe64-41ef-b273-ea5a6359ffb&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573347934-72f4ccd8-24d5-466b-8718-2998f7597375.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u4be0221b&originHeight=161&originWidth=430&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9a2212f8-17b7-46b4-afb6-6045b6d5497&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573349559-52c84b88-dc3d-42cf-b85f-d7c2327f0c34.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=udcd59cd6&originHeight=335&originWidth=460&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f951161-a752-4d5f-9988-35c65ab0fc6&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348641-dede61c9-4036-4fb6-bff2-ef4fcb895a22.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0d5c2c08&originHeight=278&originWidth=799&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6ef58218-dac4-4010-832f-d6f59f4475a&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348878-f5685775-a427-49c0-a6d2-215333cc4e8f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u5f287508&originHeight=151&originWidth=934&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u27266cae-1657-4d7f-baec-6df06b6a774&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348833-a6769b18-be9c-4342-b85a-4f6d2188990d.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9e060a1c&originHeight=508&originWidth=769&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u641694f4-eefc-4b55-a334-6cb8ba146fb&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356668-32b265aa-b1a6-4b74-87e1-c6e66c8ec590.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1223e575&originHeight=1261&originWidth=909&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucbc8f1ee-82d3-4025-a10f-6bd824a57dd&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356630-ef35905d-32bc-48b4-a6b6-62ace57d41da.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u27a44d28&originHeight=421&originWidth=779&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub4fced5e-c3d4-4aa0-9ce9-a7802376548&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356664-35c05a20-5c39-4005-aa2d-63a1a4b13fd3.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u69d4a760&originHeight=300&originWidth=413&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47ad0541-0d3b-4f28-940d-653f9034a36&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356681-6a698e0d-e551-4123-81e1-dd9fca18e32f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8ed701e2&originHeight=445&originWidth=262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb2af69a-42f2-4ac9-a025-9babeef3692&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573365937-273a3ad9-d2f0-4869-b755-55e5797f473a.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0e148467&originHeight=515&originWidth=603&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua20137a6-aa87-4b1a-8c95-85b0c485cec&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573392690-9559cff5-1f47-43c0-b135-0a1714b249b7.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9c4eb90c&originHeight=338&originWidth=385&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2eec520e-fc17-4f14-bd3a-90692538511&title=">
<meta property="og:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573392652-f5cca40e-9f68-44f9-b9d3-972ea50ab3c2.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u81034386&originHeight=198&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u49f528be-ede6-42d2-bf7d-e793e03f35f&title=">
<meta property="article:published_time" content="2022-05-17T07:12:14.000Z">
<meta property="article:modified_time" content="2023-04-23T01:06:00.533Z">
<meta property="article:author" content="liaozonglong">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742105272-a5e5485b-cb63-484b-9fc9-c6a7a1989a83.jpeg">

<link rel="canonical" href="http://example.com/2022/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据库 | LZL</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LZL</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-travel">

    <a href="/tags/%E6%97%85%E8%A1%8C" rel="section"><i class="fa fa-calendar fa-fw"></i>旅行</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-05-17 15:12:14" itemprop="dateCreated datePublished" datetime="2022-05-17T15:12:14+08:00">2022-05-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">服务</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/" itemprop="url" rel="index"><span itemprop="name">数据库</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>96k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:27</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-数据库的基本概念"><a href="#1-1-数据库的基本概念" class="headerlink" title="1.1 数据库的基本概念"></a>1.1 数据库的基本概念</h2><h3 id="1-1-1-几个术语"><a href="#1-1-1-几个术语" class="headerlink" title="1.1.1 几个术语"></a>1.1.1 几个术语</h3><ol>
<li>数据库</li>
</ol>
<p><strong>数据库（Database，DB）是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据和数据的定义的集合</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742105272-a5e5485b-cb63-484b-9fc9-c6a7a1989a83.jpeg"></p>
<ol start="2">
<li>数据库管理系统</li>
</ol>
<p><strong>数据库管理系统(DBMS)是指能够对数据库进行有效管理的一个计算机软件，它建立在操作系统的基础上，对数据库进行统一管理和控制。</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742107176-24b88a70-b97a-4bf9-9747-e2962f91cba2.jpeg"></p>
<ol start="3">
<li>数据库系统</li>
</ol>
<p><strong>数据库应用系统简称数据库系统，是指在计算机应用系统中引入数据库后的系统****数据库管理员(Database Administrator，DBA)对数据库进行规划、设计、维护和监视等，在数据库系统中起着非常重要的作用，数据库的运维工作主要由数据库管理员通过对DBMS的配置和各种操纵来完成。</strong></p>
<h3 id="1-1-2-数据库系统的层次结构"><a href="#1-1-2-数据库系统的层次结构" class="headerlink" title="1.1.2 数据库系统的层次结构"></a>1.1.2 数据库系统的层次结构</h3><p><strong>数据库系统的三级模式结构是指数据库是由外模式、模式、内模式三级构成，外模式与模式之间有映像关系、模式和内模式之间也有映像关系</strong>。  <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742674803-2892e942-3661-478e-ba51-3c4f7164482d.jpeg"></p>
<ul>
<li>物理数据层：它是数据库的最内层，是物理存储设备上实际存储的数据的集合，这些数据是原始数据，是应用系统加工的对象；</li>
<li>概念数据层：它是数据库的中间层，是数据库的整体逻辑表示，指出了每个数据的逻辑定义及数据间的逻辑联系，是存储记录的集合，是数据库管理员概念下的数据库；</li>
<li>用户数据层：它是用户所看到和使用的数据库，表示了一个或一些特定用户使用的数据集合，即逻辑记录的集合。</li>
</ul>
<ol>
<li>模式</li>
</ol>
<p> 模式也称逻辑模式、概念模式，是对数据库中全体数据的逻辑结构和特征的描述   定义模式时不仅要定义数据的逻辑结构，如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等，而且要定义数据之间的联系，定义与数据有关的安全性、完整性的要求，关系数据库中的表（Table）就是模式的典型代表。  </p>
<ol start="2">
<li>外模式</li>
</ol>
<p> 外模式也称子模式或用户模式，它是对数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图  </p>
<ol start="3">
<li>内模式</li>
</ol>
<p> 内模式也称存储模式，是整个数据库的底层表示，它由许多内部记录型中每一类型的许多值组成，用来描述数据实际上是如何存储的   内模式不仅定义各种存储记录，还说明存在什么索引、存储记录怎么表示、存储记录在什么物理队列中等，如记录按什么存储方式存储，索引按什么方式组织，数据是否压缩存储、是否加密，数据的存储记录结构有何规定等。关系数据库中的索引（Index）就属于内模式的范畴。  </p>
<ol start="4">
<li>数据库的两级映像功能</li>
</ol>
<p>数据库的三级模式对应数据的三个抽象级别，它把数据的具体组织留给DBMS管理数据库管理系统在这三个模式之间提供了两级映像：外模式&#x2F;模式映像、模式&#x2F;内模式映像。</p>
<ol>
<li>外模式&#x2F;模式映像。模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对应于同一个模式可以有任意多个外模式，对于每一个外模式，数据库系统都有一个外模式&#x2F;模式映像，它定义了该外模式与模式之间的对应关系，这些映像通常包含在各自外模式的描述中。</li>
</ol>
<p>如果模式改变（如增加新的关系、增加新的属性、改变属性的数据类型等），就要由数据库管理员对各个外模式&#x2F;模式的映像做相应改变，也可以使外模式保持不变，应用程序是依据数据的外模式编写的，因此应用程序也不必修改，从而保证了数据与程序的逻辑独立性，简称<strong>数据的逻辑独立性</strong>。</p>
<ol start="2">
<li>模式&#x2F;内模式映像。模式&#x2F;内模式映像定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的，该映像定义通常包含在模式描述中。</li>
</ol>
<p>当数据库的存储结构改变时（如采用了另外一种存储结构），由数据库管理员对模式&#x2F;内模式做相应改变，可以使模式保持不变，因此应用程序也不必改变。这就保证了数据与程序的物理独立性，简称<strong>数据的物理独立性</strong>。在数据库的三级模式结构中，数据库模式是数据库的中心与关键，它独立于数据库的其他层次，因此设计数据库模式结构时应首先确定数据库的逻辑模式。数据库的两级映像保证了数据库外模式的稳定性，从而从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改。</p>
<h3 id="1-2-数据库系统运行与维护"><a href="#1-2-数据库系统运行与维护" class="headerlink" title="1.2 数据库系统运行与维护"></a>1.2 数据库系统运行与维护</h3><h3 id="1-2-1-数据库系统运维管控"><a href="#1-2-1-数据库系统运维管控" class="headerlink" title="1.2.1 数据库系统运维管控"></a>1.2.1 数据库系统运维管控</h3><p><strong>1．数据库系统运维的主要内容</strong>数据库系统的平稳运行至关重要，系统产生故障甚至宕机则意味着中断业务，产生混乱，丢失数据。系统故障中断的负面影响不仅限于经济损失，公司形象受损是最让人担心的问题。<strong>数据库运维的目标就是保证数据库系统的高性能、高可用****数据库运维服务是指</strong>针对数据库开展的软件安装、配置优化、预防性巡检、故障排除、备份策略选择及实施、数据恢复等一系列服务，主要包括以下几个方面。<strong>（1）数据库安装与配置。</strong>从图1-1中可以看出，应用系统通过DBMS来访问数据库，由DBMS实例和数据库组成数据库服务器，数据库服务器其实就是运行在网络中的一台或多台服务器上的数据库管理系统软件，数据库服务器为客户应用提供服务，这些服务是查询、更新、事务管理、索引、高速缓存、查询优化、安全及多用户存取控制等。数据库服务器需要定制DBMS的安装配置方案，检查软件安装环境，安装DBMS软件，完成数据库配置并测试。<strong>（2）数据库对象管理。</strong>从图1-2中可以看出，数据库包括模式、内模式、外模式，不同的模式对应不同的数据库对象，如表、索引、视图、约束条件等，这些对象需要经常进行维护，维护的过程成为数据库对象的管理，如数据库对象的创建、删除、修改等。<img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652742923641-45000422-4e74-46c7-b57c-76d9ac069683.png#clientId=udaff6168-4c9f-4&from=paste&id=u09c0ecab&originHeight=544&originWidth=932&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u49e342a7-2072-462b-a1a9-00b64324b34&title=">图1-2 基于数据库三级模式两级映像的数据库系统的层次结构<strong>（3）数据库安全性管理<strong><strong>（4）数据库性能优化</strong></strong>（5）数据库备份与恢复<strong><strong>（6）故障排除</strong></strong>（7）预防性巡检。</strong>定期提供预防性巡检，并完成系统参数、配置调优，以及补丁分发、安装服务。</p>
<h1 id="2-数据库服务器的管理与配置"><a href="#2-数据库服务器的管理与配置" class="headerlink" title="2. 数据库服务器的管理与配置"></a>2. 数据库服务器的管理与配置</h1><h2 id="2-1-MySQL数据库服务器安装"><a href="#2-1-MySQL数据库服务器安装" class="headerlink" title="2.1 MySQL数据库服务器安装"></a>2.1 MySQL数据库服务器安装</h2><h3 id="2-1-1-Windows下MySQL的安装"><a href="#2-1-1-Windows下MySQL的安装" class="headerlink" title="2.1.1 Windows下MySQL的安装"></a>2.1.1 Windows下MySQL的安装</h3><p>百度下载，下一步……自行脑补</p>
<h3 id="2-1-2-ubuntu下MySQL的安装"><a href="#2-1-2-ubuntu下MySQL的安装" class="headerlink" title="2.1.2 ubuntu下MySQL的安装"></a>2.1.2 ubuntu下MySQL的安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mysql-client mysql-server</span><br></pre></td></tr></table></figure>
<p>设置配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">配置/etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">!includedir /etc/mysql/mysql.conf.d/</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql的安装目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">basedir=/usr/local/mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">datadir= /var/lib/mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用–skip-external-locking MySQL选项以避免外部锁定。该选项默认开启</span></span><br><span class="line">external-locking = FALSE</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=error.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pid-file=mysqld.pid</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义mysql应该支持的sql语法，数据校验</span></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">[mysql]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[client]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo cat /etc/mysql/debian.cnf	#查看默认密码</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysql restart	#重启服务</span><br></pre></td></tr></table></figure>



<h3 id="2-1-3-启动、连接、断开和停止MySQL服务器"><a href="#2-1-3-启动、连接、断开和停止MySQL服务器" class="headerlink" title="2.1.3 启动、连接、断开和停止MySQL服务器"></a>2.1.3 启动、连接、断开和停止MySQL服务器</h3><p><strong>1.启动和停止MySQL服务器****启动和停止MySQL服务器的方法有两种：系统服务器和命令提示符（DOS）。</strong>（1）选择“开始”→“控制面板”→ “系统和安全”→ “管理工具”→ “服务”，找到【Mysql】服务进行对应操作（2）cmd</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net stop mysql	<span class="comment">#停止mysql</span></span><br><span class="line">net start mysql	<span class="comment">#停止mysql</span></span><br></pre></td></tr></table></figure>
<p><strong>2.连接和断开MySQL服务器</strong>首先你得有一个mysql应用可以执行。去到cmd</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u 账户 -h 主机地址 -p 密码</span><br></pre></td></tr></table></figure>


<h2 id="2-2-MySQL数据库服务器的体系结构"><a href="#2-2-MySQL数据库服务器的体系结构" class="headerlink" title="2.2 MySQL数据库服务器的体系结构"></a>2.2 MySQL数据库服务器的体系结构</h2><h3 id="2-2-1-MySQL数据库服务器的逻辑架构"><a href="#2-2-1-MySQL数据库服务器的逻辑架构" class="headerlink" title="2.2.1 MySQL数据库服务器的逻辑架构"></a>2.2.1 MySQL数据库服务器的逻辑架构</h3><p><strong>数据库</strong>。数据库就是物理操作系统文件或其他形式文件类型的集合，是指以一定方式存储在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。<strong>数据库实例</strong>。数据库实例由后台线程和一个共享内存组成，是位于用户与操作系统之间的一层数据管理软件，用户对数据库的定义、运行控制，及对数据的查询、维护等都是通过数据库实例来完成的。数据库实例概念中所说的数据管理软件就是DBMS软件，启动一个MySQL数据库服务器，就是建立了一个MySQL数据库实例，数据库实例与数据库通常是一对一的关系<strong>1．MySQL数据库服务器的分层结构</strong>MySQL数据库服务器的架构主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。如图2-13所示，MySQL数据库服务器总体可以分为四层，不同的层由不同的组件构成，<strong>MySQL主要分为以下几个组件：连接池组件、管理服务和工具组件、SQL接口组件、分析器组件、优化器组件、缓冲组件、插件式存储引擎、物理文件等。</strong><img src="https://s2.loli.net/2022/05/17/H7BFWXbjzK5yxTC.png#id=DPeb4&originHeight=600&originWidth=751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">（1）第一层是一些客户端和连接服务，包含本地socket通信和大多数基于客户端&#x2F;服务端工具实现的类似于TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）的通信（2）第二层主要完成大多数的核心服务，如SQL接口进行DML、DDL、存储过程、视图、触发器等数据库对象的操作和管理，并完成缓存的查询，以及SQL的分析和优化及部分内置函数的执行（3）第三层是存储引擎层，存储引擎真正负责MySQL中数据的存储和提取，服务器通过API（Application Programming Interface，应用程序编程接口）与存储引擎进行通信。（4）第四层是数据存储层，其主要是将数据存储在文件系统之上，并完成与存储引擎的交互。可在该层查看操作系统上的各种文件，即前面所说的数据的集合。以上四层也可以简单说成是两层，以图2-13中的虚线为分割线，上半部分为SQL层，下半部分的两层为存储引擎层。SQL层主要功能包括权限判断、SQL解析和查询缓存处理等，由存储引擎完成对底层数据库的存储操作<strong>2．MySQL数据库服务器的模块结构</strong>MySQL数据库服务器启动过程首先是初始化，初始化从配置文件中读取系统参数和命令参数（完成缓存、环境的各种设置），并按照参数初始化整个系统，同时启动存储引擎。按照逻辑功能，<strong>MySQL又可以分成连接管理模块、线程模块、用户模块、查询缓存模块、日志缓存模块、查询优化模块、变更管理模块等。</strong>MySQL数据库服务器完成初始化工作启动后，等候客户端的各种请求。用户请求被服务器监听后，根据相应的模块做进一步处理，如图2-15所示。<img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652745838384-4a7b3d37-e348-418f-a162-deea7d252e0f.png#clientId=udaff6168-4c9f-4&from=paste&id=u80a4e231&originHeight=748&originWidth=745&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u931c99de-933d-479c-861d-35d55bd2a5b&title="></p>
<h3 id="2-2-2-MySQL存储引擎"><a href="#2-2-2-MySQL存储引擎" class="headerlink" title="2.2.2 MySQL存储引擎"></a>2.2.2 MySQL存储引擎</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652745859344-2708a5cf-21a2-4945-9d74-e880521aa847.png#clientId=udaff6168-4c9f-4&from=paste&id=ud41c5547&originHeight=720&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1204b37b-e74b-4b7a-bf23-28d0e6c73b4&title=">BlackHole、Archive等，需要特别注意的是，<strong>存储引擎是基于表的，而不是基于数据库的，最常见的两种存储引擎是InnoDB和MyISAM。</strong></p>
<p><strong>数据库事务</strong>数据库事务(Database Transaction)是指作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全不执行。<strong>1．InnoDB存储引擎****InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全，其支持事务，主要面向OLTP（</strong>On-Line Transaction Processing，<strong>联机事务处理）方面的应用</strong>，其特点是行锁设置、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读不产生锁。</p>
<p><strong>OLTP和OLAP</strong>数据库应用系统大致可以分成两大类： OLTP（On-Line Transaction Processing，联机事务处理）和OLAP（On-Line Analytical Processing，联机分析处理）。OLTP表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，主要用于基本的、日常的事务处理。在这样的系统中，单个数据库每秒处理的事务往往超过几百个，或者是几千个，Select语句的执行量每秒有几千甚至几万个。典型的OLTP系统有电子商务系统、银行、证券等。OLTP系统强调数据库的内存效率，强调内存各种指标的命中率，强调绑定变量，强调并发操作。OLAP有的时候也叫决策支持系统（Decision Support System，DSS），就是所谓的数据仓库。在这样的系统中，语句的执行量不是考核标准，其强调SQL的执行效率，强调磁盘I&#x2F;O等。因为一条语句的执行时间可能会非常长，读取的数据也非常多，所以其考核的标准往往是磁盘子系统的吞吐量（带宽），比如该磁盘子系统的吞吐量能达到多少MB&#x2F;s。</p>
<p><strong>关于LRU</strong>LRU的全称是Least Recently Used，也称为最少使用算法。LRU的设计原则是：如果一个数据在最近一段时间没有被访问到，那么它在将来被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</p>
<p><strong>2．MyISAM存储引擎</strong>数据库系统与文件系统的一个很大的不同之处在于对事务的支持，事务是关系型数据库的核心，但在现实应用中（特别是互联网），为了提高性能，在某些场景下（如简单的报表查询）可以摒弃事务。<strong>MyISAM存储引擎的特点是不支持事务、表锁和全文索引，主要面向一些OLAP数据库应用，</strong>操作速度快。</p>
<p><strong>3．Memory存储引擎</strong>Memory存储引擎（之前称为Heap存储引擎）将表中数据存放在内存中，这些特性都与InnoDB、MyISAM存储引擎不同。需要注意的是，服务器需要足够的内存来维持Memory存储引擎的表的使用，如果不需要了，可以释放内存，甚至删除不需要的表。Memory存储引擎默认使用哈希索引，这使得它们对于单值查找非常快速，并且对于创建临时表非常有用。当然如果你想用B型树索引（3.5中有详细解释），可以在创建索引时指定。因此，基于Memory的表的生命周期很短，一般都是一次性的。</p>
<h2 id="2-3-MySQL服务器配置工作原理"><a href="#2-3-MySQL服务器配置工作原理" class="headerlink" title="2.3 MySQL服务器配置工作原理"></a>2.3 MySQL服务器配置工作原理</h2><h3 id="2-3-MySQL配置文件"><a href="#2-3-MySQL配置文件" class="headerlink" title="2.3. MySQL配置文件"></a>2.3. MySQL配置文件</h3><p><strong>my.ini文件就是MySQL数据库服务器的配置文件。</strong>数据库服务器启动的第一项工作就是对整个数据库做的一些初始化操作，如各种系统环境变量的初始化，各种缓存、存储引擎初始化设置等，这些工作的约定来源于配置文件my.ini。Windows平台上的MySQL数据库首先会读取&#x2F;my.ini文件，该选项主要用来设置MySQL全局选项。MySQL读取完my.ini之后，接下来会解析MySQL_HOME&#x2F;my.ini。在这个过程中，服务器会到MySQL安装目录下解析数据库的相关配置。MySQL启动初始化接着会解析default-extra-file附带选项，修改该参数可以指定系统配置文件，接下来数据库会解析有关用户的选项。MySQL系统可以通过“mysqld—verbose–help”命令来查看当前系统所有参数的设置。服务器的配置应该符合它的工作负载、数据，以及应用需求，而并不是仅看硬件的情况。创建一个好配置的最快的方法是从理解MySQL内核和行为开始（对2.2内容的理解非常有利于对配置的把握），然后利用这些知识来指导配置MySQL。理解MySQL的配置机制，首先应该知道的是<strong>MySQL从哪里获得配置信息：命令行参数和配置文件。</strong>可以通过使用操作系统的启动脚本，也可以在命令行指定设置。长期使用的设置都应该写到全局配置文件中，而不是在命令行特别指定，否则如果偶然在启动时忘了设置就会有风险。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@basedir</span>	#可以查询安装目录位置</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@datadir</span>	#可以查询配置文件位置</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">!includedir /etc/mysql/mysql.conf.d/</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql的安装目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">basedir=/usr/local/mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">datadir= /var/lib/mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用–skip-external-locking MySQL选项以避免外部锁定。该选项默认开启</span></span><br><span class="line">external-locking = FALSE</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=error.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pid-file=mysqld.pid</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义mysql应该支持的sql语法，数据校验</span></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">[mysql]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[client]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure>

<p><strong>1．关于InnoDB存储引擎的配置</strong>选择InnoDB作为默认的存储引擎，InnoDB在大多数情况下是最好的选择，但并不总是如此。例如，一些第三方的软件，可能假设默认存储引擎是MyISAM，所以创建表时没有指定存储引擎，这可能会导致软件故障。如果希望持久化的表使用InnoDB，而所有临时表使用MylSAM，那应该确保在CREATE TABLE语句中明确指定了存储引擎。如图2-19给出了创建表时指定存储引擎的示例。接下来将阐述InnoDB的基础配置。如果想让InnoDB运行得很好，配置大小合适的缓冲池（Buffer Pool）和日志文件（Log File）是必须的，一般默认值都偏小，需要调整。其他所有的InnoDB设置都是可选的，配置示例中考虑到可管理性和灵活性，启用了 innodb_file_per table（即每个表对应一个后缀为.ibd的数据文件）。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652745920475-75e92c00-d6f1-4ed0-9f2b-201b421b23b9.jpeg#clientId=udaff6168-4c9f-4&from=paste&id=u7a777a6c&originHeight=405&originWidth=485&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc431d207-2aa0-4579-b73c-928d90d44b2&title=">图2-19 创建表时指定存储引擎一个流行的经验法则是把缓冲池大小设置为服务器内存的75%~80%，更好的办法是按照如下思路进行。（1）从服务器内存总量开始。（2）减去操作系统的内存占用，如果MySQL不是唯一运行在这个服务器上的程序，还要扣除其他程序可能占用的内存空间。（3）减去一些MySQL自身需要的内存空间，例如，为每个查询操作分配的一些缓冲。（4）减去足够让操作系统缓存InnoDB日志文件的内存空间。（5）减去其他配置的MySQL缓存和缓存需要的内存空间，例如，MyISAM的键缓存（Key Cache)或者查询缓存（Query Cache)。（6）除以105%，把结果四舍五入，向下取一个合理的数值，这差不多接近InnoDB管理缓冲池增加的自身管理开销。</p>
<h3 id="2-4-2-MySQL的日志文件"><a href="#2-4-2-MySQL的日志文件" class="headerlink" title="2.4.2 MySQL的日志文件"></a>2.4.2 MySQL的日志文件</h3><p><strong>MySQL数据库拥有的日志文件主要分为二进制日志、错误日志、慢查询日志和通用查询日志****在MySQL所支持的日志文件里，除了二进制文件外，其他日志文件都是文本文件</strong></p>
<p>（1）二进制日志：该日志文件会以二进制的形式记录数据库的各种操作，但是不记录查询语句。（2）错误日志：该日志文件会记录MySQL服务器启动、关闭和运行时出错等信息。（3）慢查询日志：记录执行时间超过指定时间的各种操作，通过工具分析慢查询日志可以定位MySQL服务器性能瓶颈所在。（4）通用查询日志：该日志记录MySQL服务器的启动和关闭信息、客户端的连接信息、更新数据记录SQL语句和查询数据记录SQL语句。启动日志有优点也有缺点，启动日志后，虽然可以帮助数据库管理员对MySQL服务器进行维护，但是会降低MySQL软件的执行速度，因此是否启动上面类型的日志要根据具体情况来决定。<strong>1.错误日志文件****错误日志，顾名思义，应该是记录错误信息的日志，MySQL中的错误日志文件不仅记录错误信息，MySQL服务进程即mysqld启动或关闭的信息也会被记录。</strong>，只有服务进程运行过程中发生的关键错误才会被记录</p>
<p><strong>2.二进制日志文件****二进制日志</strong>（Binary Log）：记录数据库中的修改事件，包括所有的DDL语句和DML语句，但是不包括数据查询语句，语句以“事件”的形式保存，它描述了数据的更改过程。通过二进制日志文件，用户可以详细了解MySQL数据库中进行了哪些操作。<strong>二进制日志文件（Binary Log File）：</strong>保存数据库中修改事件的文件。（1）二进制日志有以下两个重要功能。<strong>①用于复制。</strong>将MySQL Master（主数据库）端的二进制日志发送至Slave（从数据库）端，Slave端即可根据二进制日志中的内容在本地重做，以达到主从同步的目的<strong>②用于恢复。</strong>二进制日志可用于数据恢复，当使用备份了数据库后，通过应用二进制日志文件，能够将数据库恢复到故障发生前的状态<strong>（2）二进制日志的操作包括启动二进制日志、查看二进制日志、删除二进制日志和停止二进制日志。</strong></p>
<p><strong>3.慢查询日志文件****慢查询日志为MySQL软件非常重要的日志之一，主要用来记录执行时间超过指定时间的查询语句。通过查看该类型日志文件，可以查找哪些查询语句的执行效率低，从而找出MySQL服务器的性能瓶颈并进行优化。</strong>慢查询日志</p>
<p><strong>4.通用查询日志文件</strong>MySQL的查询日志有两种，一种是前面提到的慢查询日志（Slow Query Log），还有一种是<strong>通用查询日志（Gerneral Query Log），通用查询日志不仅记录执行慢的查询，而且会将所有执行的查询语句都记录下来。****通用查询日志为MySQL软件非常重要的日志之一，其主要用来记录用户关于MySQL服务器的所有操作，包含MySQL服务器的启动和关闭信息、客户端的连接信息、更新数据记录SQL语句和查询数据记录SQL语句。</strong>由于该日志记录了客户端连接MySQL的所有请求，如果当前示例访问量较大，此日志会急剧增加，会抢占系统IO导致影响MySQL的性能，一般建议关闭此日志，需要时再打开。</p>
<h3 id="2-5-2-全局共享内存"><a href="#2-5-2-全局共享内存" class="headerlink" title="2.5.2 全局共享内存"></a>2.5.2 全局共享内存</h3><p><strong>全局共享内存主要是MySQL实例（mysqld进程）以及底层存储引擎用来暂存各种全局运算及可共享的暂存信息，</strong>如存储查询缓存的Query Cache，缓存连接线程的Thread Cache，缓存表文件句柄信息的Table Cache，缓存二进制日志的Binlog Buffer，缓存MyISAM存储引擎索引键的Key Buffer以及存储InnoDB数据和索引的InnoDB Buffer Pool，等等，类似于Oracle的SGA。下面针对MySQL主要的共享内存进行简单的分析。<strong>1.查询缓存（Query Cache）</strong>查询缓存是MySQL比较独特的一个缓存区域，用来缓存特定Query的结果集（Result Set）信息，且共享给所有客户端。MySQL接收到每一个SELECT类型的Query之后都会先在Query Cache中查找是否有相应的缓存，如果有，则直接将Cache的结果集返回给客户端，如果没有，再进行后续操作，得到对应的结果集之后将该结果集缓存到Query Cache中，再返回给客户端。<strong>2.连接线程缓存（Thread Cache）</strong>连接线程是MySQL为了提高创建连接线程的效率，将部分空闲的连接线程保持在一个缓存区以备新进连接请求的时候使用的，当通过thread_cache_size设置了连接线程缓存池可以缓存的连接线程的大小之后，可以通过(Connections - Threads_created)&#x2F;Connections*100%计算出连接线程缓存的命中率。需要注意的是，这里设置的是可以缓存的连接线程的数目，而不是内存空间的大小。<strong>3.表缓存（Table Cache）</strong>表缓存区主要用来缓存表文件的文件句柄信息，在MySQL 5.1.3之前的版本通过table_cache参数设置，但从MySQL 5.1.3开始改为通过table_open_cache来设置其大小。<strong>4.表定义信息缓存（Table definition Cache）</strong>表定义信息缓存是从MySQL 5.1.3版本才开始引入的一个新的缓存区，用来存放表定义信息（表的定义信息可以称为元数据或者数据字典）。<strong>5.二进制日志缓冲区（Binlog Buffer）</strong>二进制日志缓冲区主要用来缓存由于各种数据变更操做所产生的日志信息<strong>6.MyISAM索引缓存（Key Buffer）</strong>MyISAM索引缓存将MyISAM表的索引信息缓存在内存中，以提高其访问性能。</p>
<h1 id="3-MySQL数据库对象管理"><a href="#3-MySQL数据库对象管理" class="headerlink" title="3.MySQL数据库对象管理"></a>3.MySQL数据库对象管理</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><h3 id="3-1-1-数据库对象"><a href="#3-1-1-数据库对象" class="headerlink" title="3.1.1 数据库对象"></a>3.1.1 数据库对象</h3><p><strong>数据库对象是数据库的组成部分，有表、索引、视图、触发器、存储过程、用户（User）等</strong></p>
<ol>
<li><strong>1. 表（Table）</strong></li>
</ol>
<p>表是关系数据库最基础的数据库对象。数据库中的表与我们日常生活中使用的表格类似，它也是由行（Row）和列（Column）组成的，每列由同类的信息组成，每列又称为一个字段，每列的标题称为字段名。一行数据称为一个或一条记录，它表达有一定意义的信息组合。一个数据库表由一条或多条记录组成，没有记录的表称为空表。典型的关系数据库往往包含多个表，每个表中通常都有一个主键列，用于唯一确定的一条记录。很多表包含关键信息，用来将一个表中的行关联到另一个表中的行（外键约束）。<strong>2. 索引（Index）</strong>索引是针对表中数据的一种存储方式，是根据指定的数据库表列建立起来的顺序。建立索引是加快查询速度的一种有效手段，可监督表的数据，使其索引所指向的列中的数据不重复<strong>3. 视图（View）</strong>视图是关系数据库系统提供给用户从多种角度观察数据库中数据的重要机制。一个表上可以定义若干个视图，一个视图也可以定义在若干个表上。视图是表与外模式之间的映像，一个数据库的所有视图构成数据库应用系统三级结构中的外模式。<strong>4. 触发器（Trigger）</strong>触发器是DBMS提供给程序员和数据分析员用于保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是由手工启动，而是由事件来触发，例如，当对一个表进行操作（insert、delete、update）时触发器就会被激活。触发器是一个用户定义的SQL事务命令的集合，当操作事件发生时，这组命令就会自动执行。<strong>5. 存储过程（Stored Procedure）</strong>存储过程是指一组为了完成特定功能而存储在数据库服务器中的、由SQL语句和流程控制语句组成的程序体，它可以将常用或复杂的工作预先用SQL语句和流程控制语句写好，并用一个指定名称存储起来，以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用CALL存储过程名字，即可自动执行存储过程中的命令。存储过程中允许用户声明变量，同时，存储过程可以接收和输出参数、返回执行存储过程的状态值，也可以嵌套调用。一个存储过程是一个可编程的函数，它在数据库中创建并保存。当希望在不同的应用程序或平台上执行相同的函数或者封装特定的功能时，存储过程是非常有用的。数据库中的存储过程可以看作对编程中面向对象方法的模拟，它允许控制数据的访问方式。<strong>6. 用户（User）</strong>用户就是操作数据库的一个人或者客户端，一个数据库面对许多用户，甚至在数据库运行的过程中，还会有新的用户进来、老的用户退出等变化，因此就有了用户管理。</p>
<h3 id="3-1-2-数据字典"><a href="#3-1-2-数据字典" class="headerlink" title="3.1.2 数据字典"></a>3.1.2 数据字典</h3><p>根据<strong>数据库</strong>的定义【数据库（Database，简称DB）是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据和数据的定义的集合。】可以看出，数据库中包含了两类数据，一类是应用程序要使用的数据（或者称为用户的数据），另一类是数据的定义，数据的定义也是数据（或者系统要使用的数据），也放在了数据库中，这类数据可以称为数据字典（Dictionary）或者元数据（Metadata）。<strong>数据字典是描述数据的信息集合，是对系统中使用的所有数据元素的定义的集合，数据字典是一种用户可以访问的记录数据库和数据库对象的目录</strong></p>
<h2 id="3-2-管理库"><a href="#3-2-管理库" class="headerlink" title="3.2 管理库"></a>3.2 管理库</h2><h3 id="3-2-1-创建数据库"><a href="#3-2-1-创建数据库" class="headerlink" title="3.2.1 创建数据库"></a>3.2.1 创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;DATABASE <span class="operator">|</span> SCHEMA&#125; [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]database_name		<span class="operator">/</span><span class="operator">/</span>（IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>）即当数据库不存在时方创建</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database test;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-查看和选择数据库"><a href="#3-2-2-查看和选择数据库" class="headerlink" title="3.2.2 查看和选择数据库"></a>3.2.2 查看和选择数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> basedata;	#查看数据库</span><br><span class="line">use test;	#选择数据库</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><table>
<thead>
<tr>
<th><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345617641-d617d3e3-690c-4522-bd57-8a45c0c555d6.png#clientId=u736bb5e6-27d0-4&from=paste&id=uf9fb592c&originHeight=77&originWidth=314&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u473c8258-4752-45ab-9998-89ce5b09bd3&title=">图3-13 选择不存在的数据库</th>
<th><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345617599-7e75a78a-ca81-4eb7-bea7-8c98db7931dd.png#clientId=u736bb5e6-27d0-4&from=paste&id=u37d4ad51&originHeight=77&originWidth=175&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua60c8ccc-ca3f-40e0-84a0-65ce5edf61b&title=">图3-14 选择数据库</th>
</tr>
</thead>
</table>
<h3 id="3-2-3-修改数据库"><a href="#3-2-3-修改数据库" class="headerlink" title="3.2.3 修改数据库"></a>3.2.3 修改数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> databse test;</span><br><span class="line"><span class="keyword">default</span> charcter <span class="keyword">set</span> gb2312;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">collate</span> gb2312_chinese_ci;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行<span class="keyword">ALTER</span> DATABASE语句修改之前创建的database_test数据库的默认字符集和校对规则</span><br></pre></td></tr></table></figure>


<h3 id="3-2-4-删除数据库"><a href="#3-2-4-删除数据库" class="headerlink" title="3.2.4 删除数据库"></a>3.2.4 删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dorp database test;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-管理表"><a href="#3-3-管理表" class="headerlink" title="3.3 管理表"></a>3.3 管理表</h2><h3 id="3-3-1-MySQL表中支持的数据类型"><a href="#3-3-1-MySQL表中支持的数据类型" class="headerlink" title="3.3.1 MySQL表中支持的数据类型"></a>3.3.1 MySQL表中支持的数据类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小&#x2F;字节</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>0 ~ 255</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0 ~ 255</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0 ~ 255</td>
<td>不超过255个字符的二进制字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0 ~ 255</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0 ~ 65 535</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0 ~ 65 535</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0 ~ 16 777 215</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0 ~ 16 777 215</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LOGNGBLOB</td>
<td>0 ~ 4 294 967 295</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0 ~ 4 294 967 295</td>
<td>极大文本数据</td>
</tr>
</tbody></table>
<p>表3-2 MySQL数值类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>有符号-128无符号0</td>
<td>有符号127无符号255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>有符号-32 768无符号0</td>
<td>有符号32 767无符号65 535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>有符号-8 388 608无符号0</td>
<td>有符号8 388 607无符号16 777 215</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4</td>
<td>有符号-2 147 483 648无符号0</td>
<td>有符号-8 388 608无符号4 294 967 295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>有符号-9233372936854775808无符号0</td>
<td>有符号9233372936854775807无符号0</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4</td>
<td>±1.75494351E-38</td>
<td>±3.402823466E+38</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8</td>
<td>±2.2250738585072014E-308</td>
<td>±1.7976931348623157E+308</td>
</tr>
<tr>
<td>DECIMAL(m，d)</td>
<td>m+2</td>
<td>依赖于m和d的值</td>
<td>依赖于m和d的值</td>
</tr>
</tbody></table>
<p>表3-3 MySQL支持的日期和时间类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 ~ 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 ~ 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 ~ 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>8</td>
<td>1970-01-01 00:00:00 ~ 2037年某时</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h3 id="3-3-2-创建表"><a href="#3-3-2-创建表" class="headerlink" title="3.3.2 创建表"></a>3.3.2 创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">              id  <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">primary</span> key,</span><br><span class="line">              task <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">              sign TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">              <span class="type">time</span> <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">              )</span><br><span class="line">              <span class="operator">/</span><span class="operator">/</span>属性名 数据类型 约束条件</span><br></pre></td></tr></table></figure>


<h3 id="3-3-3-查看表结构"><a href="#3-3-3-查看表结构" class="headerlink" title="3.3.3 查看表结构"></a>3.3.3 查看表结构</h3><h3 id="3-3-4-DESCRIBE语句查看表定义"><a href="#3-3-4-DESCRIBE语句查看表定义" class="headerlink" title="3.3.4 DESCRIBE语句查看表定义"></a>3.3.4 DESCRIBE语句查看表定义</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">describe</span> data_tests;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>显示列名</td>
<td>显示列的数据类型</td>
<td>标识该列是否可以为空，显示NO表示不能为空，显示YES表示运行为空。</td>
<td>标识该列是主键列或者索引列，为空的话表示该列上没有创建任何索引。</td>
<td>用于显示该列的默认值，为空表示没有默认值。</td>
<td>用于显示一些额外的附加信息，比如说该列如果定义为自增列，则会显示为“AUTOINCREMENT对于TIMESTAMP列如果定义了on updata选项，则此处也会显示相应的关键字。</td>
</tr>
</tbody></table>
<h3 id="3-3-5-修改表"><a href="#3-3-5-修改表" class="headerlink" title="3.3.5 修改表"></a>3.3.5 修改表</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test RENAME test_test;</span><br></pre></td></tr></table></figure>

<h4 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test_test <span class="keyword">ADD</span> this <span class="type">varchar</span>(<span class="number">20</span>);	#在表最后添加</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test_test <span class="keyword">ADD</span> this_one <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">FIRST</span>;	#在表第一个位置检查</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test_test <span class="keyword">ADD</span> this_two <span class="type">varchar</span>(<span class="number">20</span>) AFTER this_one;	#指定字符后添加</span><br></pre></td></tr></table></figure>


<h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><p>对于表，可以在修改表时进行字段的增加操作，也可以在修改表时进行字段的删除操作。所谓删除字段是指删除已经在表中定义好的某个字段。在MySQL中删除字段同样可以通过SQL语句ALTER TABLE来实现，其语法如下：ALTER TABLE table_name DROP 属性名;上述语句中，table_name参数表示所要修改表的表名，“属性名”参数为所要删除的字段名。</p>
<h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><p>如果要修改字段，除了可以修改字段名外，还可以实现修改字段所能存储的数据类型。由于一个表中会拥有许多字段，因此还可以实现修改字段的顺序。<strong>1. 修改字段的数据类型</strong>在MySQL中修改字段的数据类型通过SQL语句ALTER TABLE来实现，其语法如下：ALTER TABLE table_name MODIFY 属性名 属性类型;上述语句中，table_name参数表示所要修改表的表名，“属性名”参数为所要修改字段的名称，“属性类型”参数为所要修改字段的数据类型。<strong>2. 修改字段的名字</strong>在MySQL中修改字段的名称通过SQL语句ALTER TABLE来实现，其语法如下：ALTER TABLE table_name CHANGE 旧属性名 新属性名 旧数据类型;上述语句中，table_name参数表示所要修改表的表名，“旧属性名”参数为所要修改字段的名称，“新属性名”参数表示所要修改成的字段名。<strong>3. 同时修改字段的名字和属性</strong>通过关键字MODIFY可以修改字段的数据类型，通过关键字CHANGE可以修改字段的名字。同时修改字段的名字和数据类型，其语法如下：ALTER TABLE table_name CHANGE 旧属性名 新属性名 新数据类型;上述语句中，“新属性名”参数表示所要修改成的字段名，“新数据类型”参数表示所要修改成的数据类型。<strong>4. 修改字段的顺序</strong>修改字段的顺序通过SQL语句ALTER TABLE来实现，其语法如下：ALTER TABLE table_name MODIFY 属性名1 新数据类型 FIRST|AFTER 属性名2;table_name参数表示所要修改表的名字，“属性名1”参数表示所要调整顺序的字段名，“FIRST”参数表示将字段调整到表的第一个位置，“AFTER 属性名2”参数表示将字段调整到属性名2字段位置之后。需要注意的是，属性名1和属性名2必须是表中已经存在的字段名。</p>
<h3 id="3-3-6-复制表"><a href="#3-3-6-复制表" class="headerlink" title="3.3.6 复制表"></a>3.3.6 复制表</h3><p>在MySQL中复制表通过CREATE TABLE来实现，其语法形式如下：CREATE [TEMPORY] TABLE [IF NOT EXISTS] table_bame[( ) LIKE old_table_name[ ] ]| [AS (select_statement) ];上述语句中，使用LIKE关键字创建一个与old_table_name表的结构相同的新表，列名、数据类型、空指定和索引也将被复制，但是表的内容不会被复制，因此，创建的新表是一个空表。使用AS关键字可以复制表的内容，但索引和完整性约束是不会被复制的，select_statement表示一个完整的SELECT语句。<strong>例</strong>将数据库company中名为t_dept的表复制到名为test的表中，使用CREATE TABLE test LIKE t_dept，其结果如图3-24所示。创建t_dept表的一个名为test1的复制，并且复制其内容，采用SQL语句CREATE TABLE test1 AS（SELECT * FROM t_dept），其结果如图3-25所示。</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345717033-8737d287-8da7-4928-9e9d-0ceaf575bb03.png#clientId=u736bb5e6-27d0-4&from=paste&id=u38b74b1d&originHeight=53&originWidth=323&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4b46b9c5-a575-42c7-871a-82df9d64dc1&title=">图3-24 复制表t_dept</th>
<th><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345717002-8c29f92b-f641-43a7-819d-b354a83e3b93.png#clientId=u736bb5e6-27d0-4&from=paste&id=u73b8b727&originHeight=79&originWidth=315&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23142341-0bd6-451f-9e59-6056c8f733e&title=">图3-25 复制并复制内容</th>
</tr>
</thead>
</table>
<h3 id="3-3-7-删除表"><a href="#3-3-7-删除表" class="headerlink" title="3.3.7 删除表"></a>3.3.7 删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> test_test;	#删除数据库</span><br><span class="line">rename <span class="keyword">table</span> test.test_test <span class="keyword">to</span> test_test.test	#从test数据库中将test_test表移动至test_test数据库并另命名为test</span><br></pre></td></tr></table></figure>

<h2 id="3-4-管理索引"><a href="#3-4-管理索引" class="headerlink" title="3.4 管理索引"></a>3.4 管理索引</h2><h3 id="3-4-1-索引的概念"><a href="#3-4-1-索引的概念" class="headerlink" title="3.4.1 索引的概念"></a>3.4.1 索引的概念</h3><p>索引由一系列存储在磁盘上的索引项组成，索引项第一列是索引键，第二列是行的地址，索引项按索引键排序。改变表中的数据（如增加、删除、修改记录）时，索引将自动更新。索引建立后，在查询使用该列时，系统可以自动使用索引进行查询。索引是一把双刃剑，由于要建立索引页面，索引也会减慢更新的速度。索引数目无限制，但索引越多，更新数据的速度就越慢。仅用于查询的表可多建索引，数据更新频繁的表则应少建索引。</p>
<h3 id="3-4-2-索引的利与弊"><a href="#3-4-2-索引的利与弊" class="headerlink" title="3.4.2 索引的利与弊"></a>3.4.2 索引的利与弊</h3><p><strong>1. 索引的利</strong>创建索引可以大大提高系统的查询性能，此为正面作用。具体来讲包括以下几方面。①通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。②可以大大加快数据的检索速度，这也是创建索引最主要的原因。③可以加速表和表之间的连接，在实现数据的参考完整性方面特别有意义。④在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。⑤通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。<strong>2. 索引的弊</strong>创建索引要消耗系统的一些资源，降低数据更新的性能，此为负面作用。具体如下。①创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。②索引需要占用物理空间，除数据表占用数据空间以外，每一个索引还要占用一定的物理空间。如果有大量的索引，则索引占用的空间可能会比数据表占用的空间还大。如果要建立聚簇索引，那么需要的空间会更大。③当对表中的数据进行插入、删除和修改时，对索引也要进行动态维护，这样就降低了数据的维护速度。表中的索引越多，更新表的时间就越长。</p>
<h3 id="3-4-2-索引的类型与创建原则"><a href="#3-4-2-索引的类型与创建原则" class="headerlink" title="3.4.2 索引的类型与创建原则"></a>3.4.2 索引的类型与创建原则</h3><p>索引是创建在数据库表对象上的，由表中的一个字段或多个字段生成的键组成，这些键存储在数据结构（B树或哈希表）中，通过MySQL可以快速有效地查找与键值相关联的字段。InnoDB和MyISAM存储引擎的表默认创建的都是B树类型索引。</p>
<h3 id="3-4-3-索引的类型"><a href="#3-4-3-索引的类型" class="headerlink" title="3.4.3 索引的类型"></a>3.4.3 索引的类型</h3><p>MySQL大部分索引都是以B树方式存储的。B树方式构建为包含多个节点的一棵树，顶部的节点构成了索引的开始点，叫作根，每个节点中含有索引列的几个值，节点中的每个值又都指向另一个节点或者指向表中的一行，一个节点中的值必须是有序排列的。指向一行的节点叫作叶子页。叶子页本身也是相互连接的，一个叶子页有一个指针指向下一组。这样，表中的每一行都会在索引中有一个对应值，查询时就可以根据索引值直接找到所在的行。索引中的节点是存储在文件中的，所以索引也要占用物理空间。MySQL将一个表的所有索引都保存在同一个索引文件中。如果更新表中的一个值或者向表中添加或者删除一行，MySQL会自动地更新索引，因此，索引树总是和表的内容保持一致。1. 聚簇索引与非聚簇索引根据索引的顺序与数据表的物理顺序是否相同，可以把索引分成两种类型，一种是数据表的物理顺序与索引顺序相同的聚簇索引，另一种是数据表的物理顺序与索引顺序不相同的非聚簇索引。<strong>（1）聚簇索引</strong>MySQL聚簇索引构成了一个树状结构，树的叶子节点存储了表中所有字段上的数据，而不是存储了索引项（键值加地址）。在聚簇索引中，数据值的顺序总是按照升序排列。<strong>（2）非聚簇索引</strong>非聚簇索引的结构也是树状结构，在非聚簇索引中，树的叶子节点仅仅保存索引项（包含键值及其地址），而没有包含数据行。2. 普通索引与主键索引MySQL按B树方式存储索引，根据索引值的唯一性、索引字段的类型等，其主要的索引类型有普通索引、唯一性索引、主键索引、全文索引。<strong>（1）普通索引</strong>这是最基本的索引类型，它没有唯一性之类的限制。创建普通索引的关键字是INDEX。<strong>（2）唯一性索引</strong>这种索引和普通索引基本相同，但是有一个区别：索引列的所有值都只能出现一次，即必须是唯一的。创建唯一性索引的关键字是UNIQUE。<strong>（3）主键索引</strong>主键索引是一种唯一性索引，必须指定为PRIMARY KEY。主键一般在创建表时指定，也可以通过修改表的方式加入主键，但是每个表只能有一个主键。在创建主键约束时，系统自动创建了一个唯一性的聚簇索引<strong>（4）全文索引</strong>MySQL支持全文检索和全文索引。在MySQL中，全文索引的索引类型为FULLTEXT。全文索引只能在VARCHAR或TEXT类型的列上创建，并且只能在MyISAM表中创建。</p>
<h3 id="3-4-4-索引的创建原则"><a href="#3-4-4-索引的创建原则" class="headerlink" title="3.4.4 索引的创建原则"></a>3.4.4 索引的创建原则</h3><p>（1）经常被搜索的字段，创建索引可以加快搜索的速度。（2）作为主键的字段，创建索引可强制该列的唯一性和组织表中数据的排列结构。（3）经常用在连接的字段上，这些字段主要是一些外键，创建索引可以加快连接的速度。（4）经常需要根据范围进行搜索的字段，因为索引已经排序，所以指定的范围是连续的。（5）经常需要排序的字段，因为索引已经排序，这样查询可以利用索引的排序，缩短排序查询时间。（6）经常在WHERE子句中使用的列，创建索引可以加快条件的判断速度。</p>
<p>不应该创建索引的字段有下列特点（1）在查询中很少被使用或者参考的字段不应该创建索引，这是因为既然这些字段很少使用，那么有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，且增加了空间需求。（2）对于那些只有很少数据值的字段不应该创建索引，这是因为这些列的取值很少，如人事表的性别字段，在查询的结果中，结果集的数据行占了表中数据行很大的比列，即需要在表中搜索的数据行的比例很大，增加索引并不能明显加快检索速度。（3）对于那些定义为TXEXT、IMAGE和BIT数据类型的字段不应该增加索引，这是因为这些字段的数据量要么相当大，要么取值很少。（4）当更新性能远远大于检索性能时不应该创建索引，这是因为更新性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低更新性能；当减少索引时，会提高更新性能，但是会降低检索性能。</p>
<h3 id="3-4-5-创建和查看索引"><a href="#3-4-5-创建和查看索引" class="headerlink" title="3.4.5 创建和查看索引"></a>3.4.5 创建和查看索引</h3><p>所谓普通索引，就是在创建索引时不附加任何限制条件（唯一、非空等限制）。该类型的索引可以创建在任何数据类型的字段上。<strong>1.创建表时创建普通索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_two (</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    task <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    INDEX test (task(<span class="number">20</span>) <span class="keyword">DESC</span>)	# [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]<span class="operator">=</span><span class="operator">=</span>升序<span class="operator">|</span>降序</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>2. 在已经存在的表上创建普通索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX test_test <span class="keyword">ON</span> test (this(<span class="number">20</span>)<span class="keyword">asc</span>);</span><br></pre></td></tr></table></figure>
<p><strong>3. 通过SQL语句ALTER TABLE创建普通索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test <span class="keyword">ADD</span> INDEX test_two_two (task);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-6-创建唯一索引"><a href="#3-4-6-创建唯一索引" class="headerlink" title="3.4.6 创建唯一索引"></a>3.4.6 创建唯一索引</h3><p>所谓唯一索引，就是在创建索引时限制索引的值必须是唯一的。在MySQL中，根据创建索引方式，可以分为自动索引和手动索引两种。所谓自动索引，是指在数据库表里设置完整性约束时，该表会被系统自动创建索引。所谓手动索引，是指手动在表上创建索引。当设置表中的某个字段设置主键或者唯一完整性约束时，系统会自动创建关联该字段的唯一索引。<strong>1. 创建表时创建唯一索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_two_two(</span><br><span class="line">	id  <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    test <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">unique</span> index id (id)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>UNIQUE KEY表示创建唯一索引。<strong>2. 在已经存在的表上创建唯一索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index test <span class="keyword">on</span> test_two_two (test); </span><br></pre></td></tr></table></figure>

<h3 id="3-4-7-创建全文索引"><a href="#3-4-7-创建全文索引" class="headerlink" title="3.4.7 创建全文索引"></a>3.4.7 创建全文索引</h3><p>全文索引主要关联在数据类型为CHAR、VARCHAR和TEXT的字段上，以便能够更加快速地查询数据量较大的字符串类型的字段。<strong>1. 创建表时创建全文索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_three(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    test <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    fulltext key test (test)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>其中FULLTEXT INDEX或FULLTEXT KEY表示创建全文索引。<strong>2. 通过SQL语句ALTER TABLE创建全文索引</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test_three <span class="keyword">add</span> fulltext index name(name);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-8-删除索引"><a href="#3-4-8-删除索引" class="headerlink" title="3.4.8 删除索引"></a>3.4.8 删除索引</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> index name <span class="keyword">on</span> test_three;	#name<span class="operator">=</span><span class="operator">=</span>索引名 test_three<span class="operator">=</span>表名</span><br></pre></td></tr></table></figure>

<h2 id="3-5-管理视图"><a href="#3-5-管理视图" class="headerlink" title="3.5 管理视图"></a>3.5 管理视图</h2><h3 id="3-5-1-视图的概念和作用"><a href="#3-5-1-视图的概念和作用" class="headerlink" title="3.5.1 视图的概念和作用"></a>3.5.1 视图的概念和作用</h3><p>视图作为数据库对象的一种形式，在实际应用中十分常用，视图在数据库体系结构中处于用户层。</p>
<h3 id="3-5-2视图的概念"><a href="#3-5-2视图的概念" class="headerlink" title="3.5.2视图的概念"></a>3.5.2视图的概念</h3><p>视图是一个虚表，即<strong>视图所对应的数据不进行实际存储，数据库中只存储视图的定义</strong>。对视图的数据进行操作时，系统根据视图的定义操作与视图相关联的基本表。视图中的数据来源于原来的基本表，所以当基本表中的数据发生变化时，从视图中查询出的数据也就随之改变。</p>
<h3 id="3-5-3-视图的作用"><a href="#3-5-3-视图的作用" class="headerlink" title="3.5.3 视图的作用"></a>3.5.3 视图的作用</h3><p><strong>（1）简化用户的数据操作</strong>视图机制使用户可以将注意力集中在所关心的数据上，如果这些数据不是基本表中的全部，则可以通过定义视图，使数据库看起来结构简单、清晰，并且简化用户的数据查询操作。<strong>（2）使用户能以多种角度看待同一数据</strong>视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。<strong>（3）提供了一定程度的逻辑独立性</strong>数据的逻辑独立性是指用户的应用程序不依赖于数据库的逻辑结构。当数据库重构造（数据库结构改变），如增加新的表或对原有的表增加新的字段时，用户的应用程序会尽量不受到影响（否则要重新开发程序，耗时、费力且成本增加）。<strong>（4）视图能够对机密数据提供安全保护</strong>有了视图机制，就可以在设计数据库应用系统时对不同的用户定义不同的视图，使机密数据不出现在不应看到这些数据的用户视图上，这样视图机制就自动提供了对机密数据的安全保护功能。</p>
<h3 id="3-5-4-创建视图"><a href="#3-5-4-创建视图" class="headerlink" title="3.5.4 创建视图"></a>3.5.4 创建视图</h3><p><strong>创建视图主要是指明视图的名字、其数据来源于关系数据库中的哪些表、视图中的新列名称。</strong></p>
<ol>
<li>创建视图语句</li>
</ol>
<p>定义或创建视图使用CREATE VIEW语句，其语法格式为</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">OR REPLACE==能够替换已有的同名视图——可选</span></span><br><span class="line"><span class="string">ALGORITHM==可选的ALGORITHM子句是对标准SQL的MySQL扩展——可选</span></span><br><span class="line"><span class="string">view_name==视图名——必填</span></span><br><span class="line"><span class="string">column_list==为列定义明确的名称——可选</span></span><br><span class="line"><span class="string">select_statement==用于创建视图的SELECT语句——必填</span></span><br><span class="line"><span class="string">——例：CREATE VIEW test AS SELECT * FROM test2;</span></span><br><span class="line"><span class="string">WITH CHECK OPTION==可选</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>单源表视图</li>
</ol>
<p>视图的数据可以来自一个基本表的部分行、列，这样的视图可以称为单源表视图。</p>
<ol start="3">
<li>多源表视图</li>
</ol>
<p>视图不仅可以建立在单个基本表上，也可以建立在多个基本表上。视图的数据可以来自多个表，这样定义的视图称为多源表视图。多源表视图一般只用于查询，不用于修改数据。</p>
<ol start="4">
<li>在已有的视图上定义新视图</li>
</ol>
<p><strong>视图不仅可以建立在一个或多个基本表上，也可以建立在一个或多个已定义好的视图上，或建立在基本表与视图上。</strong>5.  带表达式的视图由于视图中的数据并不实际存储，所以定义视图时，可以根据应用的需要设置一些派生属性列。这些派生属性列由于在基本表中并不实际存在，故也称它们为<strong>虚拟列</strong>。带虚拟列的视图也称为<strong>带表达式的视图</strong>。</p>
<ol start="6">
<li>修改视图定义<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]；</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-5-5-查看视图定义"><a href="#3-5-5-查看视图定义" class="headerlink" title="3.5.5 查看视图定义"></a>3.5.5 查看视图定义</h3><p><strong>1. 访问views表</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> database.views；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用DESCRIBE语句</strong><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> 视图名;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-5-6-使用视图"><a href="#3-5-6-使用视图" class="headerlink" title="3.5.6 使用视图"></a>3.5.6 使用视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> view_name;</span><br></pre></td></tr></table></figure>

<h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p><strong>更新视图是指通过视图对数据进行插入(INSERT)、删除(DELETE)和修改(UPDATE)操作。</strong></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> database.view_name (key,key2)</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       (<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>视图是不实际存储数据的虚表，其没有数据。在视图中进行插入、删除、修改操作，最终要转换为对基本表的更新，这实际上是在其原始表中进行的，视图更新并不会对性能有太大影响。</p>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> database.view_name;</span><br></pre></td></tr></table></figure>

<h1 id="4-数据库安全性与完整性控制"><a href="#4-数据库安全性与完整性控制" class="headerlink" title="4 数据库安全性与完整性控制"></a>4 数据库安全性与完整性控制</h1><h2 id="4-1-数据库风险与安全需求"><a href="#4-1-数据库风险与安全需求" class="headerlink" title="4.1 数据库风险与安全需求"></a>4.1 数据库风险与安全需求</h2><h3 id="4-1-1-数据库隐私"><a href="#4-1-1-数据库隐私" class="headerlink" title="4.1.1 数据库隐私"></a>4.1.1 数据库隐私</h3><p><strong>1.隐私泄露的渠道</strong></p>
<ul>
<li>数据收集——互联网上存储着的信息资料（公开的）</li>
<li>非法获取——个人或团队对互联网安全性较弱的数据进行窃取</li>
<li>信息服务——用户喜好推荐这类功能</li>
<li>搜索引擎——字面意思</li>
</ul>
<p><strong>2.隐私防范的规则</strong></p>
<ul>
<li>提供者同意</li>
</ul>
<p>对于数据库当中每一条个人信息记录，都应该征得提供者对于其个人信息入库的同意。</p>
<ul>
<li>收集限制</li>
</ul>
<p>在提供者同意的前提下，不过多收集信息提供者的多余信息，把信息内容控制在指定目的的最小范围之内。</p>
<ul>
<li>使用限制</li>
</ul>
<p>收集的信息只用于收集时双方约定的目的，不作其他用途。</p>
<ul>
<li>泄露限制</li>
</ul>
<p>同一信息提供者对于目的A的数据信息不能与该提供者对于目的的数据信息，进行交流。</p>
<ul>
<li>保留限制</li>
</ul>
<p>个人信息只在须完成指定目的时才可保留，否则无效销毁。</p>
<ul>
<li>准确性</li>
</ul>
<p>数据库中存储的个人信息必须是正确、完整、有迹可循、更新至最新状态的，不能是杂乱无章、缺损、虚假、过时的。</p>
<ul>
<li>开放</li>
</ul>
<p>信息拥有者应有权限访问自己所收集并存储到数据库当中的所有信息。</p>
<ul>
<li>遵守</li>
</ul>
<p>信息拥有者应该具有验证以上规侧的能力，以对数据库隐私安全进行把控。</p>
<h3 id="4-1-2-数据库安全性威胁"><a href="#4-1-2-数据库安全性威胁" class="headerlink" title="4.1.2 数据库安全性威胁"></a>4.1.2 数据库安全性威胁</h3><ol>
<li><strong>来自硬件的威胁</strong></li>
</ol>
<p><strong>硬件设备是否完好从根本上决定了数据库系统的安全与否</strong></p>
<ol start="2">
<li><strong>来自系统软件的威胁</strong></li>
</ol>
<p>**存储文件包括数据库的数据文件、备份文件、日志文件等，只要能够通过操作系统访问或得到数据库存储文件，就可以获得数据库中的信息。 **</p>
<ol start="3">
<li><strong>来自网络的威胁</strong></li>
</ol>
<ul>
<li>黑客非法侵入</li>
<li>SQL注入</li>
</ul>
<p>在$QL注入攻击中，入侵者通常将未经授权的数据库语句插入（或“注入”）有漏洞的$SQL数据信道中。</p>
<ul>
<li>数据库通信协议漏洞</li>
</ul>
<p>在所有数据库供应商的数据库通信协议中，也有可能存在安全漏洞，针对这些漏洞的欺骗性活动包括未经授权的数据访问、数据破坏以及拒绝服务。更糟糕的是，由于自身数据库审计机制不审计协议操作，所以在自身审计记录中不存在这些欺骗性活动的记录。</p>
<ul>
<li>身份验证不足</li>
</ul>
<p>弱口令等可以轻易获取进入系统权限的方法</p>
<ul>
<li>拒绝服务</li>
</ul>
<p><strong>4.来自用户的威胁</strong>用户的威胁可以是滥用过高权限或者滥用合法权限<strong>5.来自开发人员和数据库管理员的威胁</strong></p>
<ul>
<li><strong>开发人员故意使应用程序留有“后门”</strong></li>
<li><strong>审计记录不足</strong></li>
</ul>
<p>审计自动记录所有敏感的或异常的数据库事务，其应该是所有数据库部署基础的一部分，如果数据库管理人员不尽职，数据库审计策略不足，则将在很多级别上面临重大风险。</p>
<ul>
<li><strong>备份数据暴露</strong></li>
</ul>
<h3 id="4-1-3-数据库安全性需求"><a href="#4-1-3-数据库安全性需求" class="headerlink" title="4.1.3 数据库安全性需求"></a>4.1.3 数据库安全性需求</h3><p><strong>物理数据库的安全性：</strong>对于数据库管理系统以及数据本身所存储的硬件设备不受外力而损坏，不因为自然、人为灾害而遭受损失。<strong>逻辑数据库的安全性：</strong>在软件层面上保证数据库系统以及数据库本身不易受到侵害，可以理解为数据库中各种数据库对象的定义，包括表、视图、索引等不受侵害。<strong>元素安全性：</strong>数据库元素本身的安全性，保证存储到数据库当中的所有数据都是正确的、相容的、有意义的，如数据库中每个表中、每条记录、每个字段上的值都是符合语义的，都是可信的。<strong>可审计性：</strong>每次对于数据库中数据的增加和更新都有迹可循，记录数据库的完整日志，使得数据库修改过程可回溯。<strong>访问控制：</strong>不同的数据模块由不同权限的人控制，确保只有授权用户和程序可以访问该模块数据。<strong>身份认证：</strong>身份作为衡量权限的唯一标识，用于访问控制和审计，只有通过身份验证的用户才能接近数据库，才能对数据库中的数据进行操纵。<strong>可用性：</strong>对于有授权的合法用户，应保证其具有随时随地能够正常使用和访问数据库的权利，能够调取其授权范围内的数据。<strong>规则推理：</strong>不同权限或者不同领域的人之间通过共享信息、合谋拼凑信息等方式由合法的低安全等级数据推导出高安全等级数据的内部构造或者数据内容。<strong>多级保护：</strong>根据数据保密程度划分多个保护级别，同一个数据库表中不同值的保密程度也可不同。</p>
<h2 id="4-2-数据库安全性控制措施"><a href="#4-2-数据库安全性控制措施" class="headerlink" title="4.2 数据库安全性控制措施"></a>4.2 数据库安全性控制措施</h2><h3 id="4-2-1-数据库安全性控制措施概述"><a href="#4-2-1-数据库安全性控制措施概述" class="headerlink" title="4.2.1 数据库安全性控制措施概述"></a>4.2.1 数据库安全性控制措施概述</h3><p>从技术上讲，数据库隐私的防护主要分为两个方面，即物理设备防护和数据库管理系统防护，在防护过程中，通常物理防护和数据库管理系统防护甚至操作系统防护应该是相互配合、密切联系的。（1）物理设备防护主要在于对磁盘的管理。数据库由无数条记录构成，如果从磁盘中能直接读取可用信息条目（或者记录），那么就存在一定的隐私泄露风险。通过对磁盘信息的解密、转换才能得到可用信息条目的磁盘才足够安全。（2）数据库管理系统防护主要在逻辑上进行权限的划分，对用户的数据库访问进行控制，对用户数据进行加密解密，以及对敏感隐私数据访问进行审计，等等。</p>
<h3 id="4-2-2-用户认证与鉴别"><a href="#4-2-2-用户认证与鉴别" class="headerlink" title="4.2.2 用户认证与鉴别"></a>4.2.2 用户认证与鉴别</h3><p><strong>用户认证和鉴别的过程不仅在连接数据库的时候进行，而且在连接成功后进行数据库查询（或者数据库访问）时，还要进行用户的身份认证</strong></p>
<h3 id="4-2-3-数据库访问控制"><a href="#4-2-3-数据库访问控制" class="headerlink" title="4.2.3 数据库访问控制"></a>4.2.3 数据库访问控制</h3><p><strong>数据库访问控制是维护数据库安全最主要、最基本、最核心的方法。****1.自主访问控制</strong>在自主访问控制中，用户可按照自己的需求对系统相应参数进行修改，以决定满足哪些条件的用户可以访问相应数据，“自主”来源于可访问数据资源的用户能够自主地将他所拥有的权限授予其他在该系统登录的任意用户。用户对于不同的数据对象有不同的存取权限，不同用户对同一对象也有不同的存取权限，用户还可以将其拥有的权限转授给其他用户，其最基本的实现方式可以用一个三元组来表示：（S，O，M）<strong>其中S表示主体，即操作用户；O表示客体，即数据；M表示数据库基本的查询、修改、添加、删除等操作。</strong>主体、客体、操作三元组的自主访问控制存在些许不足，即数据范围不能被约束，也就是客体不受约束，为此还可以进一步对客体进行约束，形成四元组：（S，O，M，P）新增的P元素用来表示约束条件，只有当满足P条件时，S才对O进行M授权。对访问控制添加了约束条件后，可以对用户进行等级划分，将授权指定给某最大级用户组s，根据先前制定好的权限传播策略传递给其他用户。例如，某数据库指定某授权给教师，根据传播策略，英语老师和语文老师都属于老师，都应该得到该授权，这里存在老师、某科目老师两个层次的抽像，这样大大提升了授权的精确性。</p>
<p><strong>2.基于角色的访问控制****基于角色的访问控制模型，该模型中心思想为将角色作为访问控制对象，对角色赋予其安全特征，并且对用户主体赋予角色语义，一个用户可以拥有许多角色，每种角色对应一定的安全权限，一个用户所拥有的安全权限为其拥有所有角色相应权限的并集</strong></p>
<p><strong>3.强制访问控制</strong>强制访问控制与自主访问控制相比，更适合于安全级别更高的数据库系统，因为自主访问控制可以由授权用户将权限任意传递，造成了数据库访问控制权限十分自由，使数据库安全受到了威胁。强制访问控制通过不可逾越的访问限制来保障数据库不受各种直接或间接的攻击，保证数据库的安全。DBMS中对于客体和主体所分配的所有权限在系统安全策略不发出调整时不能被改变。强制访问控制是一种基于安全级标记的访问控制方法，对每个数据对象都标记为一定的密级，这种标记分为几个不同的级别，每个用户也被授予某个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取，其强制存取控制相对比较严格。强制访问控制机制虽然在一定程度上提高了数据库系统的安全性，但是由于框定了各种访问约束，导致系统的灵活性受限，影响了实际应用中方便的性能。</p>
<h3 id="4-2-4-视图"><a href="#4-2-4-视图" class="headerlink" title="4.2.4 视图"></a>4.2.4 视图</h3><p>视图是一个虚表，对视图的数据进行操作时，系统根据视图的定义操作与视图相关联的基本表。视图中的数据来源于原来的基本表中，所以当基本表中的数据发生变化时，从视图中查询出的数据也就随之改变。视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。</p>
<h3 id="4-2-5-数据库加密"><a href="#4-2-5-数据库加密" class="headerlink" title="4.2.5 数据库加密"></a>4.2.5 数据库加密</h3><p><strong>加密的基本思想是根据一定的算法将原始数据（明文，plain text）变换为不可直接识别的格式（密文，cipher text），从而使得不知道解密算法的人无法获知数据的内容。</strong></p>
<h3 id="4-2-6-数据库审计"><a href="#4-2-6-数据库审计" class="headerlink" title="4.2.6 数据库审计"></a>4.2.6 数据库审计</h3><p><strong>数据库审计功能将用户的操作自动记录到审计日志（Audit Log）中，数据库运维人员可以根据审计日志信息将用户对数据库的一系列操作进行重现，找出非法存取数据的人、时间和内容，使得数据库恢复有迹可循，并且能够追踪攻击者并对其定责</strong></p>
<p>审计的作用就是将用户操作记录到日志中，国际信息安全评估通用准则提出安全审计系统的主要功能包括以下几点。（1）审计数据产生：审计数据包括两部分，一部分记录可审计事件并且记录相关数据信息，这部分数据信息可以包括访问、删除敏感数据项的操作，权限的设定和更改乃至取消，改变用户主体或数据客体的安全级别，以及操作发生时间、类型、对象、造成的影响或改变等；另一部分记录用户信息，将可审计事件和用户形成联系，该模块能够将用户和其操作可审计事件进行对应。（2）审计自动响应：由审计系统判断出一个操作事件存在安全隐患，自动进行报警或阻止进一步操作甚至中断数据库服务并及时通知数据库管理员进一步进行排查。（3）审计分析：对系统行为和产生的审计数据进行分析，发现已经发生的或者潜在的安全违规问题。（4）审计浏览：数据库运维人员需要通过对审计记录的查看进行系统维护判断，审计系统应提供审计记录的浏览工具。审计记录的访问也需要设定权限，不同的权限设定方式匹配不同的用户级别。（5）审计事件选择：为不同的应用场合选择不同的审计事件，并且只对该情况下安全威胁较为严重的属性进行审计。可以直接在可审计事件标记是否接受审计，也可以通过对一些关键字进行筛选，审计筛选出的可审计事件。（6）审计事件存储：审计完成后应对审计过程和对象进行记录并维护，保证审计记录的有效性，防止未授权用户的修改，并且应有一定的容灾策略。除了存储审计记录，防止未授权篡改以及在硬件和软件上都保证存储的有效性之外，还应该预防审计记录的丢失。</p>
<h2 id="4-3-MySQL的安全性控制"><a href="#4-3-MySQL的安全性控制" class="headerlink" title="4.3 MySQL的安全性控制"></a>4.3 MySQL的安全性控制</h2><h3 id="4-3-1-MySQL的安全性控制概述"><a href="#4-3-1-MySQL的安全性控制概述" class="headerlink" title="4.3.1 MySQL的安全性控制概述"></a>4.3.1 MySQL的安全性控制概述</h3><p><strong>MySQL自身的安全机制主要有用户的身份验证管理、基于权限系统的访问控制</strong></p>
<h3 id="4-3-2-MySQL访问控制"><a href="#4-3-2-MySQL访问控制" class="headerlink" title="4.3.2 MySQL访问控制"></a>4.3.2 MySQL访问控制</h3><p>MySQL安全性目标：保证所有的访问和操作都是由正确的用户发起的、进行的是正确的访问和操作、访问或操作的是正确的数据内容。<strong>1.MySQL支持的权限</strong></p>
<ul>
<li>select权限</li>
</ul>
<p>用于控制用户对数据库表的查询操作。</p>
<ul>
<li>insert权限</li>
</ul>
<p>用于控制用户对数据库表元素的插入操作。</p>
<ul>
<li>update权限</li>
</ul>
<p>用于控制用户对数据库表指定数据进行更新。</p>
<ul>
<li>delete权限</li>
</ul>
<p>用于控制用户对数据库表元组的刪除操作。</p>
<ul>
<li>index权限</li>
</ul>
<p>用于控制用户对数据库表建立或删除索引。</p>
<ul>
<li>alter权限</li>
</ul>
<p>用于控制用户所修改的数据表或修改数据表中某列属性</p>
<ul>
<li>create权限</li>
</ul>
<p>用于控制用户建立数据库、数据库表和索引。</p>
<ul>
<li>drop权限</li>
</ul>
<p>用于控制用户册除数据库或表。</p>
<ul>
<li>granti权限</li>
</ul>
<p>用于向特定用户授子各种权限。</p>
<ul>
<li>reload权限</li>
</ul>
<p>用于控制用户对服务器的f1ush操作。</p>
<ul>
<li>shudown权限</li>
</ul>
<p>用于控制用户关闭数据库服务器。</p>
<ul>
<li>process权限</li>
</ul>
<p>用于控制用户查看和杀死数据库服务器上的线程。</p>
<ul>
<li>file权限</li>
</ul>
<p>用于控制用户是否能够存取系统服务器文件。其中select权限、insert权限、update权限、delete权限为数据层级操作权限，用于数据的查询、插入、修改和删除，剩余权限则主要用于数据库层级的管理，操作对象为表、数据库等其他逻辑层面。</p>
<p><strong>2.权限系统工作原理</strong>MySQL成功安装后会自动创建超级管理员root账户，用来管理MySQL所有资源，<strong>MySQL资源主要包括数据库本身、数据库表、临时表、索引、表空间、字段、存储过程、存储函数、视图、触发器、文件、事件、MySQL命令等。</strong>在实际使用过程中，使用一个超级用户控制数据库所有资源显然不合理，因此，需要创建多个不同的账户协同管理数据库资源。MySQL权限系统对用户可操作行为的<strong>认证分两个部分，首先，通过用户名密码与数据库记录相匹配，</strong>以及对IP进行联合确认来验证用户身份，也就是说，如果用户名和密码都匹配，但是IP不合法，那么认定该用户访问不合法。合法用户直接进入下一步，不合法用户直接被拒绝访问；<strong>其次，对通过验证的用户进行权限匹配，赋予其应有权限，随后用户可以在授权范围内对数据库进行操作</strong>。MySQL在确定身份中考虑用户的主机IP和用户名，这样做允许用相同的用户名从不同的主机连接同一个MySQL服务器，同名用户属于不同的身份。</p>
<p><strong>MySQL服务器安装时，自动建立两个数据库，首先是mysql数据库，该数据库是MySQL权限系统的核心，包含以下5个表：user、db、host、tables-priv和columns-priv</strong></p>
<p>MySQL的存取控制包含以下两个步骤：首先由服务器检查是否允许用户连接；其次若认证成功从而允许用户连接，服务器检查用户的每个请求，查询对其赋予的权限，查看其是否有足够的权限实施。</p>
<p><strong>3.权限表****MySQL服务器在存取控制的两个阶段使用的user、db、host、tables-priv、columns-priv、procs_priv表，这些权限表放在mysql数据库中</strong></p>
<h3 id="4-3-3-MySQL用户管理"><a href="#4-3-3-MySQL用户管理" class="headerlink" title="4.3.3 MySQL用户管理"></a>4.3.3 MySQL用户管理</h3><p><strong>1.使用CREATE USER创建新用户****使用CREATE USER语句来创建用户</strong></p>
<p><strong>2.通过直接操作user表创建新用户****使用INSERT语句直接操作mysql中user表创建新用户</strong>的语法如下：INSERT INTO mysql.user(Host,User,Password)VALUES(‘host_name’, ‘user_name’,PASSWORD(‘password’))；</p>
<p><strong>3.修改用户名和主机名****使用RENAME USER语句修改一个已经存在于数据库系统中的用户名，</strong>其具体语法格式如下：RENAME USER old_username@host_name TO new_username@host_name,[ old_username@host_name TO new_username@host_name]…；</p>
<p><strong>4.修改root用户密码****（1）使用mysqladmin命令操作在命令行终端中修改密码，</strong>其基本语法如下：</p>
<p><strong>（2）使用UPDATE语句</strong>修改mysql数据库的user表，改变root用户的密码。所有的用户信息包括用户名、主机名、密码、权限，都写在mysql数据库中的user表内，root用户也不例外。root用户登录数据库系统后，由于其拥有所有权限，可以通过使用UPDATE语句修改user表中root用户记录的password字段来修改root用户的密码，该操作语句语法格式如下：UPDATE mysql.user SET password&#x3D;PASSWORD(‘rootpassword’)WHERE user&#x3D;”root” and host&#x3D;”host_name”；其中mysql.user表示mysql数据库中的user表，PASSWORD()表示加密函数，括号内容为用户指定明文密码，用户名为root，主机名为host_name。修改完成后，由user表中root@host_name记录相应password已经修改成功，但是通过后续登录验证可能发现，用新密码登录被系统返回Access denied，虽然user表中已经修改完成，但是并没有刷新用户权限，因此需要使用flush privileges重新加载用户权限。<strong>（3）使用SET语句修改root账户密码。</strong>SET PASSWORD操作语句可以用来修改本账户的登录密码，也可以用来修改其他普通账户的登录密码，使用SET PASSWORD的语法格式如下：SET PASSWORD&#x3D;PASSWORD(‘rootpassword’)；其中PASSWORD()密码加密函数在这里是必须使用的，rootpassword表示要修改成的root账户新密码。输入上述指令之后，mysql.user表中root@localhost账户加密后的密码发生了改变，表明在mysql.user表中相应项修改成功。<strong>5.修改普通用户密码</strong>root用户可以<strong>使用SET语句及UPDATE语句对普通账户密码进行修改。</strong></p>
<p><strong>6.root密码丢失的处理</strong>普通用户密码丢失可以通过各方请求验证，随后由root用户进行修改，如果root密码丢失，该数据库其他用户无法通过修改root账户密码的方式找回。考虑到这种情况，MySQL提出一种机制，可以使用特殊方式登录MySQL服务器，然后在root用户内直接重设自己的密码，其具体分为以下几个步骤。（1）查看MySQL是否已经启动，如果已经启动，就停止。在Windows系统中，可以用mysqld启动MySQL，具体命令如下：mysqld –skip-grant-tables由于修改MySQL中root用户的密码需要慎重执行，所以这里要求使用该计算机的管理员操作权限。（2）打开一个新的终端命令行窗口，使用mysql -uroot指令，不需要密码可直接登录到MySQL系统root账户中。mysql –uroot（3）如果不想修改密码，只是想看原来的密码，可以在命令行执行下面的语句SELECT host,user,password FROM mysql.user；即可查看到用户和密码。（4）如果要修改密码，在命令行下依次执行下面的语句USE MYSQLUPDATE mysql.user SET password&#x3D;PASSWORD(‘new_password’)WHERE user&#x3D;”root”；FLUSH PRIVILEGES；EXIT；（5）重新启动MySQL，再次登录时即可采用新的密码登录root账户。验证新密码登录成功后记得关闭mysql_safe进程，使得MySQL功能提供完整。</p>
<p><strong>7.查看用户账户信息</strong>可以<strong>通过SHOW GRANTS对账户信息进行查看，</strong>语法如下：SHOW GRANTS [FOR “user_name@host_name”]；</p>
<p><strong>8.删除用户****（1）使用DROP USER语句删除用户</strong>的语法格式如下：DROP USER use_name@host_name [, user_name@host_name] …</p>
<p>（2）使用DELETE语句直接删除mysql数据库中user表的该账户条目，其语法如下：DELETE FROM mysql.user WHERE user&#x3D;use_name and host&#x3D;host_name；</p>
<p><strong>9.退出账户</strong>另外一种方式是登录进入mysql后，利用键盘中断的方式，或输入MySQL可识别的命令退出MySQL。键盘中断的方式是control+z，而<strong>MySQL可识别的命令有“\q”“exit”“quit”。</strong></p>
<p><strong>10.限制MySQL账户资源次数</strong>所谓限制MySQL账户资源次数，就是指在用户表的资源控制列对某用户行进行控制。一般默认mysql.user表中的资源控制列字段的值均为0，表示不受限制。其数据类型是unsigned int，大于0的数值表示限制次数，该列有4个字段。（1）max_questions表示限定每小时内该用户账户向MySQL服务器发送查询语句或者mysql命令的最大允许次数，其对应参数值为max_queries_per_hour。（2）max_updates表示限定每小时内该用户账户向MySQL服务器发送更新语句所允许的最大次数，其对应参数值为max_updates_per_hour。（3）max_connections表示限定每小时内该用户账户可被允许连接MySQL服务器的最大请求数，其对应参数值为max_connections_per_hour。（4）max_user_connections表示限定同时段内该用户账户连接到MySQL服务器的最大并发连接数，其对应参数值为max_user_connections。mysql&gt;grant all on <em>.</em> to ‘username1’@’localhost’ with max_queries_per_hour 10max_updates_per_hour 5 max_connections_per_hour 5 max_user_connections 4；</p>
<h3 id="4-3-4-MySQL权限管理"><a href="#4-3-4-MySQL权限管理" class="headerlink" title="4.3.4 MySQL权限管理"></a>4.3.4 MySQL权限管理</h3><p><strong>权限可以分为多个不同层级：全局层级、数据库层级、表层级、列层级和子程序层级，</strong>（1）全局层级。全局层级也称用户层级，该级别权限指定的是某服务器下全部的数据库，在该服务器上登记备案的所有用户拥有的全部权限都被记录到mysql数据库的user表内。（2）数据库层级。数据库层级次于全局层级，只覆盖一个数据库的权限范围。（3）表层级。表层级次于数据库层级，其覆盖范围为数据库中某表的所有列。（4）列层级。列层级用来赋予指定数据库中指定表的某一列，列层级权限的管理都存储在mysql数据库的columns_priv表中。（5）子程序层级。GRANT、ALTER ROUTINE、EXECUTE等都可用于数据库中存储的函数或子程序，存储于mysql数据库的procs_priv当中。</p>
<p><strong>2.权限授予语句****授予权限使用的是GRANT语句，</strong>该语句的语法结构如下：    GRANT priv_type [(column_list)] [, priv_type [(column_list)]] …       ON [object_type] {table_name | * | <em>.</em> | db_name.<em>}       TO user_name [IDENTIFIED BY [PASSWORD] ‘password’]         [, user_name [IDENTIFIED BY [PASSWORD] ‘password’]] …       [WITH with_option [with_option] …] 其中object_type的格式为TABLE| FUNCTION| PROCEDUREwith_option的格式为GRANT OPTION| MAX_QUERIES_PER_HOUR count| MAX_UPDATES_PER_HOUR count| MAX_CONNECTIONS_PER_HOUR count| MAX_USER_CONNECTIONS count在上述语句中，priv_type是权限的名称，如SELECT、UPDATE等，给不同的对象授予权限，priv_type的值也不相同，一个GRANT语句当中可以赋予多个权限类别，每个权限类别可以指定某一列进行授权，即指定column_list值；ON关键字后面给出的是要授予权限的数据库或表名，object_type可以包括表table、函数function、过程procedure，主要用在MySQL升级时。为保证授权不受影响，通常使用object_type语句确定权限作用对象类型；db_name表示数据库名，table_name表示表名，用来指定授权该用户的是db_name数据库的table_name表中数据，或者使用</em>.<em>表示授权数据库系统中所有数据库内容，或者使用</em>授权当前数据库所有表的某权限，或者使用*.table_name表示授权为所有数据库的table_name表，或者使用以逗号分隔的多个表名来表示授权覆盖范围为授权的列所在的表，使用user_name@host_name表示用户名和主机名指定的账户基本信息；TO子句用来设定用户以及密码；PASSWORD表示可以使用密码加密函数对明文密码进行加密；‘password’表示设置的明文密码；WITH关键字后可以跟多个值，可以是GRANT OPTION，用来表示该用户有将自己所拥有权限赋给其他用户的权限；MAX_QUERIES_PER_HOUR用来设置每个小时可以执行的查询次数，该次数由其后count参数指定；MAX_UPDATES_PER_HOUR用来设置每个小时可以执行的更新次数，该次数由其后count参数指定；MAX_CONNECTIONS_PER_HOUR用来设置每个小时可以建立的连接次数，该次数由其后count参数指定；MAX_USER_CONNECTIONS用来设置某用户可同时建立的连接数，该连接数由其后count参数指定。（1）授予表权限和列权限。授予表权限时，priv_type可以是以下值。</p>
<table>
<thead>
<tr>
<th>①SELECT</th>
<th>给予用户使用SELECT语句访问特定的表的权限。用户也可以在一个视图公式中包含表，但用户必须对视图公式中指定的每个表（或视图）都有SELECT权限。</th>
</tr>
</thead>
<tbody><tr>
<td>②INSERT</td>
<td>给予用户使用INSERT语句向一个特定表中添加行的权限。</td>
</tr>
<tr>
<td>③DELETE</td>
<td>给予用户使用DELETE语句向一个特定表中删除行的权限。</td>
</tr>
<tr>
<td>④UPDATE</td>
<td>给予用户使用UPDATE语句修改特定表中值的权限。</td>
</tr>
<tr>
<td>⑤REFERENCES</td>
<td>给予用户创建一个外键来参照特定的表的权限。</td>
</tr>
<tr>
<td>⑥CREATE</td>
<td>给予用户使用特定的名字创建一个表的权限。</td>
</tr>
<tr>
<td>⑦ALTER</td>
<td>给予用户使用ALTER TABLE语句修改表的权限。</td>
</tr>
<tr>
<td>⑧INDEX</td>
<td>给予用户在表上定义索引的权限。</td>
</tr>
<tr>
<td>⑨DROP</td>
<td>给予用户删除表的权限。</td>
</tr>
<tr>
<td>⑩ALL或ALL PRIVILEGES</td>
<td>表示所有权限名。</td>
</tr>
</tbody></table>
<p>在授予表权限时，ON关键字后面跟table_name，这里table_name是表名或视图名。授予username2@localhost用户在bookmanage数据库中book表的Book_name列对应的select权限，并且限定该用户此种select访问权限的每小时最多访问次数为20次，其语句如下：mysql&gt;GRANT SELECT(Book_name) ON bookmanage.book TO username2@localhost WITH MAX_QUERIES_PER_HOUR 20；仍在root账户使用flush privileges进行权限更新后，登录username2@localhost账户，然后输入select * from bookmanage.book，查询bookmanage数据库中的book表的所有信息，由于权限分配时只授予了该用户对于bookmanage数据库中book表的Book_name列的select权限，所有book表的第一列也就是Book_id列就无权实现select操作，从而导致返回SELECTION command denied结果。由于username2@localhost账户没有对mysql数据库的任何权限，所以继续使用root账户访问，查看mysql数据库user表中username2@localhost账户信息，能够发现select用户层级权限被设置成‘N’，db表内select相关权限同样为‘N’，说明该账户在用户层级和数据库层级不存在select权限。接下来继续在root账户查看mysql数据库中的tables_priv表，找到username2@localhost账户对应的表授权信息，能够看出host为localhost，user为username2，拥有对于bookmanage数据库的book表中某一列的select权限。再查询mysql数据库中columns_priv表中所有信息，查阅到host为localhost、user为username2的账户拥有对bookmanage数据库的book表内Book_name列的select权限。（2）授予数据库权限。表权限适用于一个特定的表，MySQL还支持针对整个数据库的权限。例如，在一个特定的数据库中创建表和视图的权限。授予数据库权限时，priv_type可以是以下值。</p>
<table>
<thead>
<tr>
<th>①SELECT</th>
<th>给予用户使用SELECT语句访问特定数据库中所有表和视图的权限。</th>
</tr>
</thead>
<tbody><tr>
<td>②INSERT</td>
<td>给予用户使用INSERT语句向特定数据库中所有表添加行的权限。</td>
</tr>
<tr>
<td>③DELETE</td>
<td>给予用户使用DELETE语句删除特定数据库中所有表的行的权限。</td>
</tr>
<tr>
<td>④UPDATE</td>
<td>给予用户使用UPDATE语句更新特定数据库中所有表的值的权限。</td>
</tr>
<tr>
<td>⑤REFERENCES</td>
<td>给予用户创建指向特定的数据库中的表外键的权限。</td>
</tr>
<tr>
<td>⑥CREATE</td>
<td>给予用户使用CREATE TABLE语句在特定数据库中创建新表的权限。</td>
</tr>
<tr>
<td>⑦ALTER</td>
<td>给予用户使用ALTER TABLE语句修改特定数据库中所有表的权限。</td>
</tr>
<tr>
<td>⑧INDEX</td>
<td>给予用户在特定数据库中的所有表上定义和删除索引的权限。</td>
</tr>
<tr>
<td>⑨DROP</td>
<td>给予用户删除特定数据库中所有表和视图的权限。</td>
</tr>
<tr>
<td>⑩CREATE TEMPORARY TABLES</td>
<td>给予用户在特定数据库中创建临时表的权限。</td>
</tr>
<tr>
<td>⑪CREATE VIEW</td>
<td>给予用户在特定数据库中创建新的视图的权限</td>
</tr>
<tr>
<td>⑫SHOW VIEW</td>
<td>给予用户查看特定数据库中已有视图的视图定义的权限。</td>
</tr>
<tr>
<td>⑬CREATE ROUTINE</td>
<td>给予用户为特定的数据库创建存储过程和存储函数的权限。</td>
</tr>
<tr>
<td>⑭ALTER ROUTINE</td>
<td>给予用户更新和删除数据库中已有存储过程和存储函数的权限。</td>
</tr>
<tr>
<td>⑮EXECUTE ROUTINE</td>
<td>给予用户调用特定数据库的存储过程和存储函数的权限。</td>
</tr>
<tr>
<td>⑯LOCK TABLES</td>
<td>给予用户锁定特定数据库的已有表的权限。</td>
</tr>
<tr>
<td>⑰ALL或ALL PRIVILEGES</td>
<td>表示以上所有权限名。</td>
</tr>
</tbody></table>
<p>登录root账户后，使用GRANT语句对username2@localhost账户授予对bookmanage数据库上的所有表的create权限，该权限作用范围为某数据库内所有表，是数据库层级的权限。mysql&gt;GRANT CREATE ON bookmanage.* TO username2@localhost WITH GRANT OPTION；下面分别探究各个层级上访问控制权限表的内容。登录root账户，查询mysql数据库user表，create操作权限所对应的Create_priv字段，该字段值为‘N’，表明用户层级上没有create权限。查询mysql数据库db表，create操作权限对应字段值为‘Y’表示该账户在数据库层级拥有create权限。查询mysql数据库的tables_priv表，host为localhost、user为username2的账户不存在create权限的任何表示，说明该用户不存在表级别的create权限。输入Select * from columns_priv \G，查看mysql数据库中columns_priv表的全部内容，可以看到，host为localhost、user为username2的账户中不存在create相关权限的内容，于是不属于列层级权限。（3）授予用户权限。对于需要授予数据库权限的所有语句，也可以定义在用户权限上。例如，在用户级别上授予某人CREATE权限，这个用户可以创建一个新的数据库，也可以在所有的数据库（而不是特定的数据库）中创建新表。MySQL授予用户权限时，priv_type还可以是以下值。</p>
<table>
<thead>
<tr>
<th>①CREATE USER</th>
<th>给予用户创建和删除新用户的权限。</th>
</tr>
</thead>
<tbody><tr>
<td>②SHOW DATABASES</td>
<td>给予用户使用SHOW DATABASES语句查看所有已有的数据库的定义的权限。</td>
</tr>
</tbody></table>
<p>登录root账户后，使用GRANT操作对username2@localhost账户赋予全局的，也就是用户层级的insert操作权限。mysql&gt;GRANT INSERT ON <em>.</em> TO username2@localhost；登录root账户查看mysql数据库的user表，查看username2@localhost账户的对应insert权限的相应字段为‘Y’,说明该授权作用范围为整个数据库，为用户层级。查看db表中所有username2@localhost账户的行中insert权限对应字段都为‘N’。查询mysql数据库的tables_priv表的username2@localhost账户的信息，没有有关insert授权的描述。同样，columns_priv表中也没有该账户insert权限的信息。<strong>3.权限回收</strong>权限回收是指撤销目标用户对某层级范围的数据库对象执行某种操作的权利，管理用户权限时，通过权限回收使得数据库安全的保障机制得以提升。<strong>使用REVOKE语句回收权限</strong>后，改变mysql数据库中的相应权限字段。撤销权限时首先撤销其权限的使用，然后再改变其在mysql数据库的user表中相应的字段值。权限的回收可以是将被分配的所有权限的回收，也可以是回收其权限范围内的部分数据库、部分表甚至部分列的权限。使用“REVOKE ALL PRIVILEGES，GRANT OPTION FROM ‘user_name’@‘host_name’[，‘user_name’@‘host_name’]…”语句回收某个账户或多个账户的所有权限，包括其将权限授予其他用户的权限。REVOKE语句的语法如下：REVOKE priv_type [(column_list)] [, priv_type [(column_list)]] …    ON {table_name | * | <em>.</em> | db_name.<em>}    FROM user_name@host_name [, user_name@host_name] … 或者REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] …第一种格式用来回收某些特定的权限，第二种格式用来回收所有该用户的权限。其中priv_type表示所要撤回权限的类型，column_list表示可以对某列的该权限进行撤回，每种权限的撤回都可以覆盖多列的范围，若不指定该参数，则作用范围是整个表。一次执行REVOKE语句可以撤销多个类型的权限，db表示撤销权限所覆盖的数据库范围，该处为‘</em>’时代表对所有数据库执行此操作。table_name表示对数据库中某表做限制，user_name表示用户名，host_name表示主机名，一次调用REVOKE语句可撤销多个用户账户中的权限。某用户能够使用REVOKE语句的前提是需要拥有对mysql数据库的create user权限或者对mysql中所有表的update权限。对username1@localhost账户撤销全部权限，操作语句如下：mysql&gt;REVOKE ALL PRIVILEGES,GRANT OPTION FROM ‘username1’@’localhost’；然后再次查看该账户的权限，得到的结果相当于只是存在了一个无访问权限的空壳账户。<strong>4.更改账户权限</strong>对账户权限的更改包括为账户增加权限和为账户撤销权限这两种。为某账户增加权限需要当前登录账户拥有待增加权限且当前登录账户需要有对其他账户赋予自己拥有权限的权利，也就是查看权限时的“WITH GRANT OPTION”。使用GRANT语句操作已有账户时就是对该账户赋予权限的过程，使用REVOKE语句操作已有账户的已有权限时就是收回该账户权限的过程。如下语句所示，当hostname1@localhost存在且其对应密码为123456时，对其在所有数据库中全部表的范围授予select、delete、create权限。若用户名—主机名对在mysql.user表中不存在，则创建这个账户，若密码与mysql.user表中不符，还可修改密码为 ‘123456’。mysql&gt;GRANT SELECT,DELETE,CREATE ON <em>.</em> TO hostname1@localhost IDENTIFIED BY ‘123456’；登录root账户后，执行如下操作：mysql&gt;REVOKE SELECT,CREATE ON <em>.</em> FROM hostname1@localhost；则收回hostname1@localhost用户在所有数据库中全部表的范围的select、create权限。<strong>5.权限转移或限制****GRANT语句后若添加WITH GRANT OPTION则表示TO子句指定的所有用户账户都拥有把自己所拥有的所有权限授予其他用户的权利，</strong>不受其他用户当前授权情况的影响。登录root用户，用下列操作创建一个新的用户账户username3@localhost，设定其密码为‘123456’，将整个数据库系统的所有数据库中所有表的select权限赋予该用户，并赋予该用户将自己所拥有权限赋予其他用户的权利。mysql&gt;GRANT SELECT ON <em>.</em> TO username3@localhost IDENTIFIED BY ‘123456’ WITH GRANT OPTION；但是需要注意一点，在登录uername3@localhost账户权限授予时，不能使用GRANT语句授予不存在的用户账户，因为当授予不存在的用户账户时，等价于创建新用户，然而username3@localhost账户没有create用户的权限，于是此次操作被服务器拒绝。在root账户创建username4@localhost账户后，登录username3@localhost账户对username4@localhost账户进行全局的select授权，系统返回授权成功的结果。mysql&gt;GRANT SELECT ON <em>.</em> TO username4@localhost；登录username4@localhost后查看本账户所拥有权限，发现username3@localhost已经成功将全局的select权限授予username4@localhost账户。<strong>6.权限生效时机</strong>用户更改权限时，不论是设置权限还是撤销权限，都是对权限的一种更新，这种更新会直接作用到数据库表中，而在数据库系统运行过程中，user表是提前加载到内存的，如果在某一时间，root用户正在修改正处于登录状态的某账户的权限列，并且使用的是对数据库user表直接修改的方式，那么在被修改账户的登录状态下权限维持修改之前状态不变。只有当外存中的数据表内该字段信息更新至内存后才能真正修改对该用户的权限，除非重新连接MySQL服务器或者打开该用户新连接，或者<strong>使用FLUSH PRIVILEGES语句才能将数据表中字段写入内存，</strong>举例如下。例（1）登录username1@localhost账户，使用SHOW GRANTS查看自己的授权，可以发现具有所有表上的所有权限，不退出username1@localhost账户。mysql&gt;SHOW GRANTS；（2）在root账户中使用REVOKE语句修改其权限，收回username1@localhost账户的select和create权限。mysql&gt;REVOKE SELECT,CREATE ON <em>.</em> FROM username1@localhost；（3）在username1@localhost账户下查看自己的权限，用户可以发现其还具有所有表上的所有权限，包括select。（4）通过root账户使用UPDATE语句修改mysql.user表中username1@localhost账户的相关信息。mysql&gt;UPDATE mysql.user SET Insert_priv&#x3D;’N’,Update_priv&#x3D;’N’,Delete_priv&#x3D;’N’WHERE user&#x3D;’username1’ and host&#x3D;’localhost’；（5）仍在保持登录状态的username1@localhost账户中查看自己的权限，发现并没有撤销insert、update、delete三个权限。（6）在root账户中执行FLUSH PRIVILEGES操作：mysql&gt;FLUSH PRIVILEGES；（7）仍在保持登录状态的username1@localhost账户中使用SHOW GRANTS语句查看自己所拥有的权限，发现已经不存在insert、update、delete权限了。</p>
<h3 id="4-3-5-MySQL审计"><a href="#4-3-5-MySQL审计" class="headerlink" title="4.3.5 MySQL审计"></a>4.3.5 MySQL审计</h3><p>为了安全和操作的可追溯性考虑，MySQL 5.5企业版推出了相关的审计功能，到5.6.20版本，其功能进一步完善，下面介绍MySQL审计的使用过程。（1）mysql 5.6中的审计是通过server_audit插件来实现的，首先应该在相关网站下载server_audit.so插件。（2）登录MySQL，执行如下命令获取MySQL的plugin目录，一般Windows环境下数据库的插件目录默认是&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin。mysql&gt; SHOW GLOBAL VARIABLES LIKE ‘plugin_dir’；（3）将server_audit.so插件上传到&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;目录下。（4）在命令行下安装server_audit.so（卸载该插件可以使用UNINSTALL PLUGIN server_audit）；mysql&gt;INSTALL PLUGIN server_audit SONAME ‘server_audit.so’；（5）查看变量开启设置情况，一般默认都是关闭的。mysql&gt;SHOW variables like ‘%audit%’；（6）编辑my.ini添加配置（应该在server_audit插件被安装好，并且已经运行之后添加这些配置，否则过早在配置文件添加这个选项，会导致MySQL发生启动错误）。server_audit_events&#x3D;’CONNECT,QUERY,TABLE,QUERY_DDL,QUERY_DML,QUERY_DCL’ 备注：指定哪些操作被记录到审计日志文件中server_audit_logging&#x3D;on 备注：启动审计server_audit_file_path &#x3D;&#x2F;data&#x2F;mysql&#x2F;auditlogs&#x2F; 备注：审计日志存放路径，该路径下会生成一个server_audit.log文件，就会记录相关操作记录server_audit_file_rotate_size&#x3D;200000000 备注：限制审计日志文件的大小server_audit_file_rotations&#x3D;200 备注：指定审计日志文件的数量server_audit_file_rotate_now&#x3D;ON防止server_audit插件被卸载，需要在配置文件中添加[mysqld]server_audit&#x3D;FORCE_PLUS_PERMANENT（7）重启服务，登录MySQL后发现，在MySQL环境下执行的任何命令都会被记录到&#x2F;data&#x2F;mysql&#x2F;auditlogs&#x2F;server_audit.log，如果审计日志文件达到指定的大小，会自动将文件进行切割。配置文件中可以对审计做约定，参数如下。</p>
<table>
<thead>
<tr>
<th>server_audit_output_type</th>
<th>指定审计日志输出类型，可为SYSLOG或FILE。</th>
</tr>
</thead>
<tbody><tr>
<td>server_audit_logging</td>
<td>启动或关闭审计。</td>
</tr>
<tr>
<td>server_audit_events</td>
<td>指定记录事件的类型，可以用逗号分隔多个值（connect、query、table），如果开启了查询缓存（Query Cache），查询直接从查询缓存返回数据，审计日志中将没有table记录。</td>
</tr>
<tr>
<td>server_audit_file_path</td>
<td>如server_audit_output_type为FILE，使用该变量设置存储审计日志的文件，可以指定目录，默认存放在数据目录的server_audit.log文件中。</td>
</tr>
<tr>
<td>server_audit_file_rotate_size</td>
<td>限制审计日志文件的大小。</td>
</tr>
<tr>
<td>server_audit_file_rotations</td>
<td>指定审计日志文件的数量，如果为0，审计日志将从不切换。</td>
</tr>
<tr>
<td>server_audit_file_rotate_now</td>
<td>强制审计日志文件切换。</td>
</tr>
<tr>
<td>server_audit_incl_users</td>
<td>指定哪些用户的活动将被记录，connect不受此变量影响，该变量比server_audit_excl_users优先级高。</td>
</tr>
<tr>
<td>server_audit_syslog_facility</td>
<td>默认为LOG_USER，指定facility。</td>
</tr>
<tr>
<td>server_audit_syslog_ident</td>
<td>设置ident，作为每个syslog记录的一部分。</td>
</tr>
<tr>
<td>server_audit_syslog_info</td>
<td>指定的info字符串将添加到syslog记录。</td>
</tr>
<tr>
<td>server_audit_syslog_priority</td>
<td>定义记录审计日志的syslogd priority。</td>
</tr>
<tr>
<td>server_audit_excl_users</td>
<td>该列表的用户行为将不被记录，connect不受该设置影响。</td>
</tr>
<tr>
<td>server_audit_mode</td>
<td>标识版本，可用于开发测试。</td>
</tr>
</tbody></table>
<p>审计日志名称为server_audit.log，默认存放在MySQL数据文件目录data路径下，下面给出一个审计日志文件内容的示意，从该示意内容可以看出审计日志文件中记录了用户对MySQL数据库的操纵行为，审计员通过对审计日志文件的理解和检查，可以得出审计报表，在这里不作过多阐述。20180310 15:58:10,node02,root,192.168.2.71,7,8,QUERY,,’SHOW DATABASLES’,106420180310 15:58:14,node02,root,192.168.2.71,7,9,QUERY,,’SHOW DATABASES’,0</p>
<h2 id="4-4-MySQL的完整性控制"><a href="#4-4-MySQL的完整性控制" class="headerlink" title="4.4 MySQL的完整性控制"></a>4.4 MySQL的完整性控制</h2><h3 id="4-4-1-实体完整性约束"><a href="#4-4-1-实体完整性约束" class="headerlink" title="4.4.1 实体完整性约束"></a>4.4.1 实体完整性约束</h3><p>实体完整性就是指数据表中的每条记录（或元组）都表示了现实世界中一个客观存在的实体，在现实世界中由于实体在实际情况当中是唯一存在的，实体完整性规则要求：表中的记录（或元组）既不能为空，也不能重复。<strong>MySQL实体完整性实现分为主键完整性和唯一索引约束两个方面。****1.主键完整性</strong>主键是指定数据库中某表的一列或多列的组合作为唯一确定该记录的标志性内容。主键列中所有记录的值都是唯一且存在的。<strong>在创建表时，使用PRIMARY KEY子句指定当前创建表的主键，</strong>PRIMARY KEY所约束的列中任何元组内该值均不为空。</p>
<p><strong>2.唯一索引约束（替代键约束）</strong>唯一索引指的是在某表内除主键以外的某一列，每一元组该列的取值都是唯一的。由于主键有最小化原则，所以逻辑上虽然有其他一列或多列可以唯一确定某一记录（或元组），那么如果仍存在某列要求该列所有记录（或元组）中的值唯一，我们称该列为替代键，是没有被选作主键的候选键，<strong>使用UNIQUE子句来定义唯一索引约束。</strong>例</p>
<h3 id="4-4-2-参照完整性约束"><a href="#4-4-2-参照完整性约束" class="headerlink" title="4.4.2 参照完整性约束"></a>4.4.2 参照完整性约束</h3><p>一张数据表中某列数据只能引用另一数据表中关键字的数据，保证表之间数据的一致性，防止没有意义或不存在的数据出现，称为参照完整性（Referential Integrity）。<strong>在SQL中的CREATE TABLE语句中添加外码FOREIGN KEY子句来声明参照完整性。</strong>例如，在stuandcour表中我们可以用foreign key(stuno) references stuinfo来表明在每个选课记录中指定的学生学号stuno必须在stuinfo数据表中存在。一旦违反了参照完整性约束，一般数据库系统都会采取拒绝执行导致完整性破坏的操作措施，如更新操作或删除操作等。<strong>1.创建外键****创建外键可以通过CREATE TABLE和ALTER TABLE语句来完成。</strong></p>
<h3 id="4-4-3-用户自定义完整性约束"><a href="#4-4-3-用户自定义完整性约束" class="headerlink" title="4.4.3 用户自定义完整性约束"></a>4.4.3 用户自定义完整性约束</h3><p>用户自定义完整性就是针对某一具体关系数据库的约束条件，它反映了在某一具体应用场景当中，数据信息所涉及的由数据库系统必须满足的语义要求<strong>用户自定义完整性可以有元组约束、关系间约束和域约束等形式。****1.元组约束</strong>元组约束指的是在某表中两列间存在某种关系，使得记录中其中某一列的值确定了，那么拥有这种关系的另外一个值也就确定了。例如，数据库中学生信息表包括学生出生年份字段和学生年龄字段，一旦知道了某学生的出生年份，就能计算出该学生的年龄，反之也成立，如果知道某学生的年龄，根据系统时间也可以计算出该学生的出生年份。这种元组之间存在关系且可以由某一值确定另一值时，可以使用元组约束防止数据不正确。例如下操作，创建student2表，使得学生生日为int型，age也为int型，在创建表的声明中插入CHECK子句，使得学生年龄age的值等于当前年份减去学生出生年份stubir的值：mysql&gt; CREATE TABLE student2     (stuno varchar(10),     Stubir int,     Age int check(age&#x3D;2018-stubir))； 需要注意的是，当前MySQL中对于CHECK子句的支持仅停留在表定义的阶段，只是在定义的阶段检查其输入不会产生错误，但是在插入数据时并不会对用户所插入的内容进行这方面的判断，例如，向上表中输入如下操作语句，发现虽然28不等于2018减去1999，但是该值依然插入成功了：mysql&gt; INSERT INTO student2 values(‘2016211001’,1999,28)；所以MySQL数据库中如果需要构造元组约束，需要使用触发器对该约束进行描述。    mysql&gt; delimiter&#x2F;&#x2F;     mysql&gt;CREATER TRIGGER age_birth3 before insert on student2 for each row         begin             declare msg varchar(200)；             declare sumval int；             set sumval&#x3D;new.age+new.stubir；             if sumval&#x3D;2018 then                 set msg&#x3D;”Age and stubirth is not math,cannot insert”；                     signal sqlstate ‘HY000’ SET message_text&#x3D;msg；             end if；         end&#x2F;&#x2F; 首先使用delimiter定界符构造可以输入触发器定义语句的环境，然后定义一个在student2数据表中的触发器，使得在该表中每插入一行数据前都要进入触发器中进行该项检验，在这里取得输入的学生年龄age项写为new.age，取得所输入的学生生日stubir项写为new.stubir，然后声明一个msg用来存储返回错误信息字符串，声明一个sumval的整型变量，使其作为学生年龄和学生出生年份的和，然后判断sumval值是否等于当前年份2018，如果等于当前年份则不作任何操作，如果不等于当前年份则要求将前面声明的msg变量赋值，这里选择将该错误记为年龄与学生生日不匹配错误，然后将这个signal发送给用户以提示用户该输入不合法，但是就算是此种方法也不能解决当前问题，因为即使检测到学生年龄加上出生年份不等于当前年份，那么也只能抛出信号，然后就无能为力了，因为MySQL不存在undo机制，于是INSERT操作并没有被数据库系统拒绝，而是在抛出错误信号后继续执行。图4-23为使用INSERT语句插入出生年份与当前年龄不匹配的数据时，MySQL数据库系统返回的结果。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572517064-341243d1-8427-4af2-acca-16b6a71a57c0.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u3e09088b&originHeight=66&originWidth=906&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9929b734-fe1f-41f9-a273-046e92a929f&title=">图4-23 不满足元组约束可以观察到，向student2表中添加数据时，如果出生年份与该学生年龄不相符则不允许插入，返回错误提示信息为在触发器定义的msg变量中的内容，说明触发器触发成功，并且能够成功阻止不合法数据输入数据库。我们知道系统返回的“ERROR 1644 (HY000): Age and stubirth is not match. Cannot insert.”信息是自己在构造触发器过程中制造的返回语句，进一步从数据库表student2中确定，查找学号stuno为“2010211001”记录的所有列的信息，得到该搜索结果为空集，从而可以确定，使用触发器来保证元组完整性的作用方法在MySQL中完全可行。<strong>2.关系间约束</strong>关系间约束表示的是不同表的两列或多列之间可能存在的直接要求关系，这种直接要求关系涉及两个不同的表，是两个不同关系之间的约束行为，我们可以通过一个例子来理解这种关系间约束的需求是如何产生的，并且讨论关系间约束的实现方法。例我们创建一个数据库，使得数据库中存在三个表：学生信息表、课程信息表、学生选课表，这三个表中存在参照关系如下。student7的学生信息表，表中存在两个字段：学号stuno列（varchar(3)）和标志（int）是否毕业的graduate字段，其中学号stuno列为主键。course1的课程信息表，包括课程的课程号courno（varchar(1)）以及该课程的学分credit（int），其中课程号courno为主键。stuandcour的学生选课表，该表中有三个字段：学生学号stuno（varchar(3)）、课程号courno（varchar(1)）和选课编号scno（varchar(1)）。其中，选课编号scno作为主键，学生学号stuno作为参照学生信息表中学号stuno的外键，课程号courno作为参照课程信息表中课程号courno的外键。现在有一种用户需求，要求多个关系直接满足一定的条件。如要求学生表graduate字段如果填入1，则该学生其所修学分必须达到10学分。该约束条件在除MySQL以外的一些数据库中，可以在数据库模式下利用断言（ASSERTION，限于篇幅本书不详细讨论）来完成，但MySQL数据库不支持创建断言，因此在MySQL中可以解决这个问题的方法就是使用触发器进行关系间约束。下面创建一个触发器来解决当其所修学分数不足10分时，UPDATE操作不能将graduate置为1的关系间约束：mysql&gt; delimiter&#x2F;&#x2F; mysql&gt;CREATER TRIGGER graduate_check1 after update on student7 for each row     begin         declare graduate int；         declare sumcredit int；         declare ssno char(10)；         declare msg varchar(200)；         set ssno&#x3D;old.stuno,graduate&#x3D;new.graduate；         select sum(credit) into sumcredit from stuandcour1 a,course1 b              where a.courno&#x3D;b.courno and a.stuno&#x3D;ssno group by a.stuno；         if (graduate&#x3D;1 and sumcredit&lt; 10) then&lt;             set msg&#x3D;”Credit is not enough for graduate,cannot update”；         上面语句使用delimiter分隔符提示进入创建触发器状态，然后创建了一个在有用户对数据表student7进行UPDATE操作之后的响应触发器，名为graduate_check1。该触发器取得修改前的学生表中学生学号为ssno，取得修改后的graduate值为graduate，然后计算该条记录对应的学号在stuandcour1表对应所选课程号，通过该课程号对应course1表中对应的学分credit值。将记录中学生所修所有课程的所有学分相加之和赋值给sumcredit变量，然后判断如果graduate值为1，也就是说该学生已毕业，但是sumcredit值小于10，说明该学生没有修够毕业所需分数，这种情况是数据库系统不允许的，所以给用户返回“Credit is not enough for graduate,cannot update”的信息，表示该UPDATE不合法。通过实验可以发现通过触发器解决了要求学生表graduate字段如果填入1，则该学生其所修学分必须达到10学分的问题，使得学分总数与毕业与否两个处于不同表之间的关系的约束控制得以实现。**3.域完整性**所谓域完整性，就是用来指定数据类型来说明某字段可以接受的值都有哪些，是什么样的。比如说性别、国籍等这种取值范围限定在一些字符串数组中的数据类型，或者是一些基于整型的数据，在取值范围上对输入数据有所要求，从而可以使得输入的国籍由于不存在于世界上任何一个国家的情况而被数据库系统拒绝，输入性别时不至于输入为“中”等此种情况的发生。在数据插入阶段，其在一定程度上维护了数据库的安全性。这里我们分两个方面来分析，第一个方面是关于可例举的数据的处理方法，第二个方面是对于整型数据这种连续型数据类型的范围框定的处理方法。（1）例举方法，对于可例举的数据，如对于性别的选择，使用CHECK子句，可以定义为如下形式：mysql&gt; CREATE TABLE student3     (stuno varchar(10),     Sex varchar(1) check(sex in(‘M’,’F’)),     Primary key (stuno))； 上面语句创建了一个新表student3，在该表中建立两列，学号stuno列和性别sex列，其中加入对sex变量的check检查，这里指定sex的取值为‘M’或者‘F’，其中M代表Male男性，F代表Female女性，指定stuno为主键。尝试向student3表中插入一个记录，stuno为‘2017211001’，sex为‘S’，插入记录的两列都符合创建两列时对数据类型的要求，但是sex字段不符合CHECK对值的要求，由于MySQL没有对CHECK语句进行实质上的响应，于是MySQL并没有拒绝这次INSERT操作。对于这种约束的实现，可以使用ENUM子句进行：mysql&gt; CREATE TABLE student4     (stuno varchar(10),     Sex enum (‘M’,’F’),     Primary key (stuno))； 在sex字段声明的数据类型处使用ENUM，其后括号内表示该字段的可取值范围。与CHECK不同，ENUM在MySQL数据库中既能够进行合法声明又具有域约束功能。对使用ENUM创建的域约束进行验证，在student4表中使用ENUM声明sex字段进行域约束，然后向student4表中插入一条新记录，使得该记录的学号stuno符合要求，sex的取值赋予‘M’和‘F’之外的某字符，可以看到，数据库系统返回的结果表示系统拒绝该次插入操作，表示输入的sex列数据不合法，然后输入一条拥有正确的性别取值和正确的学号类型的记录，可以验证插入成功。域约束还有另外一种实现思想，就是当某数据库中存在一个表，其某列所有数据值构成的集合可以作为另外一个表的某一列数值的取值范围。这样的枚举型数据可以在CHECK子句中加入如下SELECT语句来实现：mysql&gt; CREATE TABLE student6     (stuno varchar(10),     Sex char(1) check(sex in (select sex from student4) ),     Primary key (stuno))； 上面语句创建了一个新的数据表student6，使得数据表中性别sex的取值范围由student4表中sex列出现的所有值来确定。若student4表中加入了新的sex字段取值，那么student6表中sex字段的取值范围同样加入了新的取值。同样，在MySQL数据库中无法对该模式进行识别，只能停留在定义阶段，这种实现想法对于MySQL数据库的实现仍然能够通过触发器的方式实现，具体实现方法这里不再赘述，可以由读者自行实现。（2）第二种域约束是指数据类型为数值类，然后经过对数值的边界进行约束，从而对该列取值作约束。这种域约束类型不能通过ENUM子句完成，此外，由于MySQL不支持CHECK语句的使用，尽管声明处语法合乎要求，但是不会实际在用户插入数据时对其访问进行限制，只能继续选择触发器方式。mysql&gt; delimiter&#x2F;&#x2F; mysql&gt;CREATER TRIGGER stu_age before insert on student5 for each row     begin         declare msg varchar(200)；         if new.age&lt;&#x3D;6 then             set msg&#x3D;”Age is inappropriate,cannot insert”；                 signal sqlstate ‘HY000’ SET message_text&#x3D;msg；         end if；     end&#x2F;&#x2F; 使用delimiter分隔符来插入触发器创建语句，然后对表student5创建一个名为stu_age的触发器，该触发器的触发时机在于每当向student5数据表中使用INSERT语句插入信息时，作用为对插入信息的age字段值进行校验，当age大于6时合法，当age小于或等于6时对用户该操作返回一个提醒signal，使得插入用户可以清晰地定位当前操作错误源。对由触发器创建的第二类域约束进行验证，保证学号字段符合该字段定义的数据类型，年龄字段同样符合该字段的数据类型，并且使得该数值为触发器定义中所不允许的数值，比如向student5表中插入“‘2017211002’，2”记录，该记录的返回结果为“Age is inappropriate，cannot insert”，表明触发器已经启用并且成功判断输入值不符合对于该表的约束，然后继续查证数据库中student5表是否存在学号stuno字段为‘2017211002’的数据记录，从而得出上述INSERT语句并没有成功运行，非法数据并没有被插入数据库中。</p>
<h3 id="4-4-4-命名完整性"><a href="#4-4-4-命名完整性" class="headerlink" title="4.4.4 命名完整性"></a>4.4.4 命名完整性</h3><p>使得数据库中每个完整性约束都有一个名字，并且这个名字能够体现完整性约束种类以及作用表的名称。例</p>
<h3 id="4-4-5-删除完整性"><a href="#4-4-5-删除完整性" class="headerlink" title="4.4.5 删除完整性"></a>4.4.5 删除完整性</h3><p>在一个复杂的数据库中，每改动一个记录都受到重重的约束条件判断，如果直接删除某个表，难免会使得数据库系统发生错乱甚至崩溃，尤其在涉及一些参照约束、关系间约束等有关表与表之间相关性的其中的某个表时，所以在删除表之前，需要人工手动将与该表相关的所有约束都清理掉，根据实际要求对与要删除的数据表有约束关系的数据记录进行约束剔除或修改。这里需要用到ALTER TABLE语句对数据表中完整性约束作改变。</p>
<h1 id="第5章-数据库备份与恢复"><a href="#第5章-数据库备份与恢复" class="headerlink" title="第5章 数据库备份与恢复"></a>第5章 数据库备份与恢复</h1><h2 id="5-1-备份与恢复原理"><a href="#5-1-备份与恢复原理" class="headerlink" title="5.1 备份与恢复原理"></a>5.1 备份与恢复原理</h2><h3 id="5-1-1-故障种类"><a href="#5-1-1-故障种类" class="headerlink" title="5.1.1 故障种类"></a>5.1.1 故障种类</h3><p>数据库系统中可能发生各种故障，<strong>故障种类可以分为事务故障、系统故障、介质故障、计算机病毒等</strong>。<strong>1.事务故障</strong>撤销已做的数据修改，从而使得数据库恢复到正确的状态在大多数情况下，事务故障是非预期的，不能由事务程序处理，有以下两种错误都可能造成事务执行失败。</p>
<p>事务故障也就是说事务最终没有达到预期的目标（COMMIT或显式的ROLLBACK），所以数据库可能会处于不正确的状态。此类故障的解决办法是在不影响其他事务运行的情况下强行回滚（ROLLBACK）该事务，即撤销该事务已经做出的任何修改，回到事务执行之前的状态，我们称此方法为事务撤销（UNDO）。</p>
<p><strong>2.系统故障</strong>系统故障是指造成系统停止运转的事件，使得系统要重启的故障，如突然停电、CPU故障、操作系统故障、DBMS代码错误等。这类故障会导致内存中存储的数据丢失，并使得事务处理终止。换句话说，此类故障会影响正在运行的所有事务，但不破坏数据库。发生此类故障时，主存的内容尤其是数据库缓冲区中存储的数据都会丢失，所有正在运行的事务都会非正常终止。数据库系统为了提高效率，对数据库对象操作的结果不是立刻写入磁盘，而是保留在缓冲区中，从而可以被不同事务一次又一次地使用，如果它变得不常用，则可写入磁盘并清出缓冲区（参见2.2.2节，InnoDB存储引擎的内容）。缓冲区采用最少使用算法（LRU）决定最长时间内未被使用的缓冲区被写入磁盘的数据文件中。缓冲区是否写入磁盘数据文件与其中的数据是否提交无关，即未提交的数据也有可能被先写入磁盘。数据库写进程只服从于LRU，不服从于事务。为了防止因故障原因使留在缓冲区但已提交的数据反映不到磁盘上，或者写入磁盘的数据没有提交，可以利用日志来记录对数据库的更新操作，使用日志项记录更新操作的足够信息。发生系统故障时，主要数据库存在以下两种可能的不正确的状态。（1）未完成的事务的结果可能已经写入磁盘。此类故障的解决办法是清除这些事务对数据库进行的所有的更改操作，即事务撤销（UNDO）。（2）完成的事务结果可能有一部分甚至全部留在缓冲区，并没有写入磁盘。此类故障的解决办法是将这些事务已提交的结果重新写入数据库，即事务重做（REDO）。处理系统故障，就是要撤销所有未完成的事务，重做所有已完成的事务。</p>
<p><strong>3.介质故障</strong>介质故障是指在数据传送操作的过程中由于磁头损坏、瞬时强磁场干扰等造成的磁盘块上的内容丢失。</p>
<p><strong>4.计算机病毒</strong>计算机病毒是一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序。它可以像病毒一样繁殖和传播，这种程序会对计算机系统包括数据库造成危害。计算机病毒是计算机系统的主要威胁，也是数据库系统的主要威胁。以上几种故障都可能会破坏数据的完整性、一致性。DBMS所提供的备份与恢复机制可以将这些故障引起的错误状态恢复到某一已知的正确状态（可能是一致状态或完整状态）。<strong>数据库恢复用到是数据转储和登记日志文件。</strong>数据转储不仅在上述的故障恢复中具有重要的地位，在数据库的升级过程中，有时候也需要知道数据或数据库模式在过去的某个时间点是什么样的。例如，或许被卷入一场法律官司，或发现了应用的一个Bug，想知道这段代码之前干了什么（有时候仅仅依靠代码的版本控制还不够）。</p>
<h3 id="5-1-2-恢复机制的原理"><a href="#5-1-2-恢复机制的原理" class="headerlink" title="5.1.2 恢复机制的原理"></a>5.1.2 恢复机制的原理</h3><p><strong>我们将数据库的恢复原理概括为冗余</strong>。数据库中任何一部分数据的破坏或者不正确的数据都可以根据存储在系统中的冗余数据来建立。<strong>建立冗余数据最常用的技术是数据转储和登记日志文件。</strong></p>
<p>（1）数据转储。数据转储也称为数据备份。数据备份是数据库恢复中最基本的技术，其<strong>是由数据库管理员或者运维人员定期将整个数据库复制到磁带、磁盘或者其他存储介质保存起来的过程，这些备用的数据成为后备副本或后援副本</strong>。</p>
<p>（2）登记日志文件。前面章节中我们不止一次地提到日志文件，日志文件是用来记录事务对数据库的更新操作的文件，该文件在MySQL中也称为二进制日志文件，由MySQL自动维护。<strong>以事务为单位的日志文件中需要登记的内容包括各个事务的开始、各个事务的结束、各个事务的所有更新操作。这里的每个事务的开始标记、每个事务的结束标记和每个更新操作均为日志文件中的一个日志记录。每个日志记录的内容主要包括事务标识（用于表明是哪一个事务）、操作的类型（包括插入、删除或更新）、操作对象（记录内部标识）、操作前的值和操作后的值等。</strong>对于日志来说，MySQL有一个控制准则叫作“写日志优先准则”，即当数据库执行更新操作时，先把更新信息写进日志，然后更新数据库，这种机制保证了通过日志可以还原用户对数据库的更新操作，所以当数据库发生故障时，利用日志对执行完的更新操作进行重做（将更新后的值强行写入数据库中），可以恢复数据库。</p>
<p><strong>1．事务故障的恢复****事务故障的恢复主要是利用日志文件撤销此事务已对数据库进行的更改</strong>。事务故障的恢复是由DBMS自动完成的，系统的恢复步骤如下。（1）反向扫描日志文件，查找该事务的更新操作。（2）对该事务的更行操作执行逆操作，如果日志记录中是插入操作，则相当于做一个删除操作；如果日志记录中是删除操作，则相当于做一个插入操作；如果日志记录中是修改操作，则相当于用修改前的值代替修改后的值。（3）继续反向扫描日志文件，查找该事务的更新操作，并做同样处理，直到读到此事务的开始标记，事务故障恢复就完成了。</p>
<p><strong>2．系统故障的恢复</strong>系统故障造成数据库不一致状态的原因主要有两个，一个是未完成的事务对数据库的更新可能已经写入数据库中，另一个是已提交事务对数据库的更新可能还留在缓冲区，还没来得及写入数据库，因此，<strong>系统故障的恢复操作就是要撤销故障发生时未完成的事务，重做已经完成的事务。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572775955-6cdb5c2d-0e61-414f-af0f-b3a36b198c99.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u05be4568&originHeight=317&originWidth=680&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1db0f0b2-bd2c-4457-8b1f-4cc18543c33&title="><strong>3．介质故障的恢复</strong>发生介质故障后，磁盘上的物理数据和日志文件都被破坏，这是最为严重的一种故障，恢复的方法是重装数据库，然后重做已完成的事务。（1）装入最新的数据库的后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还需要同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法，才能将数据库恢复到一致性状态。（2）装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务。<strong>介质故障的恢复需要数据库管理员重装数据库副本和有关的各日志文件副本，然后执行系统提供的恢复命令，</strong>具体的恢复操作仍由DBMS完成。<strong>4．具有检查点的恢复</strong>利用日志文件进行数据库恢复时，恢复系统必须搜索日志，确定哪些事务需要重做，哪些事务需要撤销。一般来说，需要检查所有日志记录，这样做有两个问题，一是搜索整个日志文件将耗费大量的时间，二是很多需要重做处理的事务实际上已经将它们的更新操作结果写入了数据库中，然而恢复子系统又重新执行了这些操作，浪费了大量时间。为了解决这些问题，又发展了具有检查点的恢复技术，<strong>检查点的恢复技术在日志文件中添加了一类新的记录——检查点记录，数据库的恢复只需要找到最近的一个检查点记录，恢复该检查点以后的日志信息</strong>。检查点记录的内容包括建立检查点时刻所有正在执行的事务清单和这些事务最近一个日志记录的地址。DBMS动态维护日志文件，周期性地执行建立检查点、保存数据库状态的操作。具体包括将当前日志缓冲区中的所有的日志记录写入磁盘的日志文件上；在日志文件中写入一个检查点记录；将当前数据缓冲区的所有数据记录写入磁盘的数据库中；把检查点记录在日志文件中的地址写入一个重新开始的文件。DBMS可以定期或不定期地建立检查点，保存数据库状态；也可以按照预定的一个时间间隔建立检查点，如每隔一小时建立一个检查点；也可以按照某种规则建立检查点，如日志文件写满一半时建立一个检查点。使用检查点的方法可以改善恢复效率。当事务T在一个检查点之前提交，T对数据库所做的修改一定都写入数据库，写入时间是在这个检查点建立之前或在这个检查点建立之时，这样在进行恢复处理时，就没必要对事务T执行重做操作。DBMS使用检查点的方法进行恢复的步骤如下。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572775998-4951e3f7-a849-47e9-87a2-aee61111ac6b.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u787e88db&originHeight=430&originWidth=680&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u101100ed-c678-41bc-8a23-c9fc934a576&title="></p>
<h3 id="5-1-3-备份的类型"><a href="#5-1-3-备份的类型" class="headerlink" title="5.1.3 备份的类型"></a>5.1.3 备份的类型</h3><p>根据不同的划分标准，<strong>备份划分为在线备份与离线备份，物理备份与逻辑备份，完全备份、增量备份与差异备份，本地备份与异地备份等不同形式</strong>。<strong>1.在线备份与离线备份</strong>按照备份时服务器是否继续提供服务，备份分为在线备份和离线备份。（1）在线备份（Online Backup）：也称作热备份（Hot Backup）。在线备份不要求数据库服务器系统中无运行的事务，也就是数据库服务器不需要关闭，其在数据库服务器正在运行时直接备份，备份过程中不影响前端用户对数据库进行存取或修改，数据备份和前端提交的事务可以并发执行（2）离线备份（Offline Backup）：也称作冷备份（Cold Backup）。数据库进行备份时在系统中无运行事务，即备份操作开始的时刻，数据库处于一致性的状态，而备份期间则不允许对数据库进行任何存取和修改操作。</p>
<p><strong>2.物理备份与逻辑备份</strong>按照备份的操作方式，备份分为物理备份与逻辑备份。（1）物理备份：原始数据在操作系统呈现什么样的表现形式，备份出来也是什么样。这种方式属于纯I&#x2F;O型的备份方式，从备份形式上看，其就是将组成数据库的数据文件、配置文件等相关的文件复制到其他路径上保存。换句话说，物理备份是以磁盘文件为基本单位的，这种备份较适合大型、重要、出现故障时需要快速恢复的场景。（2）逻辑备份：逻辑备份是对数据库的逻辑结构（通过CREATE DATABASE、CREATE TABLE等语句创建的数据库表对象）以及其所存储的数据（转换为INSERT INTO）进行备份，这种备份方式非常灵活，但是对于大型系统来讲，使用逻辑备份进行恢复时性能较低。换句话说，逻辑备份是以表或者记录集合为基本单位的，备份出来的结果往往以文件形式保存。</p>
<p><strong>3.完全备份、增量备份与差异备份</strong>按照是否备份全部数据或是只备份部分数据可将备份分为完全备份、增量备份与差异备份。（1）完全备份（Full Backup）：每次对数据进行完整的备份。当发生数据丢失的灾难情况时，完全备份无须依赖其他信息，即可实现100%数据恢复，其恢复时间最短且操作最方便。</p>
<p>（2）增量备份（Incremental Backup）： 增量备份是指在一次全备份或上一次增量备份后，每次的备份只需要备份与前一次相比增加和修改的文件。这就意味着第一次增量备份的对象是进行完全备份后所产生的增加和修改的文件；第二次增量备份的对象是进行第一次增量备份后所产生的增加和修改的文件，以此类推。</p>
<p><strong>4.本地备份与远程备份</strong>（1）本地备份：MySQL服务运行的服务器上执行的备份。本地备份生成的备份集一般都是在本地保存的。（2）远程备份：非本地服务器上执行的备份。远程备份生成的备份集不一定在远程，有些备份方案只是备份操作命令在远端执行，但备份集仍然是创建于MySQL所运行的本地服务器上的。</p>
<h2 id="5-2-MySQL备份方案"><a href="#5-2-MySQL备份方案" class="headerlink" title="5.2 MySQL备份方案"></a>5.2 MySQL备份方案</h2><h3 id="5-2-1-备份策略的影响因素和备份内容"><a href="#5-2-1-备份策略的影响因素和备份内容" class="headerlink" title="5.2.1 备份策略的影响因素和备份内容"></a>5.2.1 备份策略的影响因素和备份内容</h3><p>在实际工作中，MySQL备份方式的选择受到很多因素的影响。MySQL允许通过各种不同的方式来备份数据库中的数据，但是这些方式又各自有优缺点，数据库管理员需要根据自己的生产环境来考虑最适用的备份方式。<strong>1.MySQL备份策略的影响因素****制定MySQL的备份策略受到很多因素的影响，主要包括数据库的可用性、MySQL存储引擎、数据库锁策略、MySQL拓扑等因素。</strong>（1）数据库的可用性。如果数据库在某个时间段没有用户对其进行访问，此时数据库并不要求可用，这个时间段就成为维护数据库的绝佳窗口。例如，系统运行的不是“24×7”的业务，这些业务就可能存在维护窗口，这样的时间段为我们做数据库备份提供了机会。（2）MySQL存储引擎。2.2.2节中对MySQL存储引擎进行了介绍，在MySQL数据库中，不同的数据表可以选择不同的存储引擎，不同的MySQL存储引擎有着不同的锁需求和一致性要求，因此表所使用的存储引擎对于最终备份方案的选择会产生很大的影响。</p>
<p><strong>2.备份内容</strong>具体备份的过程中，我们需要备份什么呢？备份的内容是由备份的需要决定的，其中最简单、最低要求的就是备份数据和表定义。在实际的生产环境中，<strong>MySQL在备份上需要考虑更多的内容，主要包括表定义和数据、非显著数据、代码、服务器配置、复制配置和操作系统文件</strong>。表的结构信息（或者表的定义信息）和数据可以称为显著数据。（1）非显著数据。不要忘记那些容易被忽略的数据，如二进制日志和InnoDB事务日志，正如5.1节所说，这些日志信息在数据库恢复时起着非常重要的作用。（2）代码。MySQL服务器可以存储表和索引，也可能还存储着许多代码，如触发器和存储过程。如果备份了MySQL数据库，那么大部分这类代码也备份了，但如果需要还原单个业务数据库（如只是备份了自己创建的数据库）就会比较麻烦，因为诸如存储过程，实际是存放在MySQL数据库（参见第3章数据字典）中的。（3）服务器配置。假定要从一个实际的灾难中恢复，比如说地震过后在一个新的数据中心构建服务器，备份中包含的服务器配置很关键，服务器配置一般在配置文件中。（4）复制配置。如果恢复一个涉及MySQL复制的服务器，应该备份所有与复制相关的文件，如二进制日志、中继日志、日志索引文件和.info文件，至少应该包含SHOW MASTER STATUS和SHOW SLAVE STATUS的输出。执行FLUSH LOGS也非常有好处，可以让MySQL从一个新的二进制日志开始，从日志文件的开头做基于故障时间点的恢复要比从中间进行更容易。（5）操作系统文件。由于MySQL的数据库和表是直接通过目录和表文件实现的，因此，可以通过直接复制文件的方法来备份数据库（第2章的数据库实例和第3章的数据库对象中都讲述了一个数据库所对应的磁盘文件）。这些建议在许多场景下会被当作“备份一切”，然而如果有大量的数据，这样做的开销会非常高，需要更加明智地考虑如何做备份，特别是可能需要在不同备份中备份不同的数据。例如，可以单独地备份数据、二进制日志和操作系统及系统配置。</p>
<h3 id="5-2-2-文件系统冷备份"><a href="#5-2-2-文件系统冷备份" class="headerlink" title="5.2.2 文件系统冷备份"></a>5.2.2 文件系统冷备份</h3><p>如果MySQL实例存在维护窗口，那么我们可以通过干净而适当的关机来停止MySQL实例，就有可能执行一次<strong>文件系统冷备份，这是对文件系统上的文件的物理复制，即直接使用操作系统提供的复制命令就可以完成备份</strong>。在Windows操作系统平台下，MySQL数据库缺省的安装目录为C:\Program Files\MySQL\MySQL Server 5.6，MySQL数据库存放目录默认为C:\Program Files\MySQL\MySQL Server 5.6\data，也可以是其他用户自定义的目录。前面3.3.1节中讲到，在MySQL中创建一个数据库，就会在操作系统下形成一个同名的目录，因此如果要对某一个数据库进行文件系统的冷备份，可以在操作系统下找到这个同名的目录，然后对该目录下的所有文件进行复制（参见3.2.4表对象文件格式）。为了确保能够成功地备份所有重要的MySQL数据，可以通过查询MySQL配置变量来获得各种文件的位置，应该仔细检查这些文件的位置，并将其包含在要备份的文件列表中，应该在服务器运行时获得这些变量的值。配置文件中不会定义所有的变量，MySQL将对未定义的变量使用预先设置的默认值。我们可以通过MySQL的命令SHOW VARIABLES查看变量对应的值，找到备份目录所在的具体位置。为了能够更快地查找到我们需要的变量，可以使用通配符来实现，不同的目录以及存放的内容如下。（1）datadir：MySQL数据目录。（2）innodb_data_home_dir：InnoDB Data数据目录。（3）innodb_data_file_path：单独的InnoDB数据文件，它可能包含特定的不同目录。（4）log-bin：二进制日志目录。（5）log-bin-index：二进制日志索引文件。（6）relay-log：中继日志记录。（7）relay-log-index：中继日志索引文件。通过SHOW VARIABLES LIKE ‘%dir%’命令可以查看MySQL的数据所在目录，操作结果如图5-1所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819171-6bf276cf-0af2-4bb0-9d54-68a0fb7fe631.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u3929182c&originHeight=351&originWidth=845&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udcc94fa6-3994-4292-b969-8f24b47d909&title=">图5-1 查看MySQL数据库所在目录除了上述的数据文件之外，备份MySQL的配置文件页也非常重要，因为这些设置对于成功运行MySQL来讲十分重要，尤其是innodb_data_file_path和innodb_log_file_size包含着底层文件，如果所配置的文件大小与这些文件的大小不一致，将导致MySQL实例不能启动。我们举一个简单的实例来说明文件系统冷备份的具体步骤，首先使用show tables查看MySQL数据库employees下的数据表，该数据库共有6张表，如图5-2所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819196-2d0a04d7-6e04-4fc9-8ff5-fdd0ba33d1fd.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u46e8e81e&originHeight=309&originWidth=674&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u427e85f2-4091-46f9-8138-db8489415e4&title="><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819189-4a1d842d-dd5b-41e7-a9c0-83943c2e2a54.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8d2deae7&originHeight=204&originWidth=223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uaa7bcf7d-90ed-46a5-a620-1d237c86d02&title=">图5-2 查看MySQL数据库employees下的数据表<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819157-df519c98-586b-446d-8c57-d272a93e775c.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue5070452&originHeight=193&originWidth=673&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u896f61cb-2d15-4ff2-9fa4-9573195cffe&title="><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819190-1ce5faff-be81-472e-a954-1c4e4c11b085.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u2a4920ee&originHeight=44&originWidth=431&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u80856453-c7c9-41bc-b4cf-51bcb9c5153&title=">图5-3 employees中salaries出错情形图5-3中出现了Table doesn’t exist（表不存在）这个错误，错误的原因是上述备份的数据库中数据表的所有存储引擎都是使用的InnoDB存储引擎。InnoDB存储引擎的表格与其他存储引擎的表格不同，InnoDB表对应的表结构文件存储在后缀为.frm的文件中，即存储在数据库的目录中，也就是说在上述的操作过程中我们成功地复制了表结构文件，但是InnoDB的数据文件则存储在根目录下的ibdata1文件中，所以在进行之前的文件复制中一定要在复制数据库目录文件的同时，将ibdata1的文件一并复制，并将其保存至数据库的根目录，替换原来的文件，此时再次执行查询命令，查询成功，至此employees数据库备份还原成功。对于只有MyISAM存储引擎的数据库，数据库向对应的目录下复制相应的数据文件，不需要复制ibdata1文件，即可备份成功。在大多数实际情况下，一个MySQL数据库中通常包含了不同存储引擎的表，对于物理文件冷备份，为了备份成功，须注意将ibdata1文件一起进行复制。文件系统冷备份策略过程简单，而且允许使用任何文件系统备份工具来进行备份，但是这种备份策略存在一些严重的缺点。在备份过程中，MySQL实例是不可用的，而且在恢复的过程中需要一个相似的配置系统，这个系统要具有与原系统相同的操作系统和目录结构。当重启MySQL时，MySQL实例的内存池要重新初始化，这样会耗费一些时间。</p>
<h3 id="5-2-3-逻辑备份"><a href="#5-2-3-逻辑备份" class="headerlink" title="5.2.3 逻辑备份"></a>5.2.3 逻辑备份</h3><p>逻辑备份并不是对MySQL文件的备份，而是对SQL语句的备份或者是以符号分割的方式将数据库表中数据存放在文件中，<strong>逻辑备份可以使用SELECT…INTO…OUTFILE语句，或者使用mysqldump工具和Workbench工具来完成</strong>。<strong>1.使用SELECT…INTO…OUTFILE备份</strong></p>
<p><strong>2.使用mysqldump备份</strong>mysqldump是MySQL数据库逻辑备份的常用工具，在日常的维护工作中经常会用到。</p>
<p><strong>3.使用MySQL Workbench备份</strong>上述的逻辑备份是通过使用mysqldump实现的，而MySQL Workbench是MySQL官方为 MySQL提供的一款可视化管理工具，可以在里面通过可视化的方式直接管理数据库中的内容，同样可以完成MySQL的逻辑备份。</p>
<h3 id="5-2-4-二进制日志"><a href="#5-2-4-二进制日志" class="headerlink" title="5.2.4 二进制日志"></a>5.2.4 二进制日志</h3><p>前面章节中不止一次地提及MySQL二进制日志的概念，二进制日志文件是备份和恢复过程中的重要组成部分。数据库备份除了需要进行某个时刻的备份之外，后续可能还需要执行一个时间点的恢复，以便将数据库恢复到最近的某个一致状态，或者是恢复到某个人为确定的时刻，这就是为人熟知的<strong>基于时间点的恢复，它是通过将MySQL二进制日志应用到某个数据库副本上来执行的</strong>。</p>
<h3 id="5-2-5-InnoDB事务日志"><a href="#5-2-5-InnoDB事务日志" class="headerlink" title="5.2.5 InnoDB事务日志"></a>5.2.5 InnoDB事务日志</h3><p>前面5.1.2节中讲过，事务日志包括重做日志Redo和回滚日志Undo。<strong>InnoDB的事务日志也包括重做日志Redo log和回滚日志Undo log，</strong>InnoDB重做日志记录的是已经全部完成的事务，就是执行了commit的事务，记录在文件ib_logfile0 ib_logfile1或者ib_logfile<em>里面；InnoDB回滚日志记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下其是记录在表空间中的（共享表空间或者独享表空间对应ibdata</em>文件，存储的是Check point日志序列号）。</p>
<h2 id="5-3-MySQL数据库的恢复"><a href="#5-3-MySQL数据库的恢复" class="headerlink" title="5.3 MySQL数据库的恢复"></a>5.3 MySQL数据库的恢复</h2><h3 id="5-3-1-基于复制文件的恢复"><a href="#5-3-1-基于复制文件的恢复" class="headerlink" title="5.3.1 基于复制文件的恢复"></a>5.3.1 基于复制文件的恢复</h3><p>5.2节讲述了MySQL允许通过各种不同的方式来备份数据库中的数据，根据备份方式的不同，数据的恢复也不同，数据的恢复取决于所用的备份方法。对一个文件系统进行复制恢复就是重新安装所有的MySQL的备份数据文件和备份配置文件。首先停止MySQL服务，然后将需要恢复的库的文件夹复制出来，注意还有ibdata1，覆盖到能够启动的MySQL的data文件夹的目录下，最后重新启动MySQL服务，这个时候就会发现数据库已经可以打开。需要特别提醒的是，如果两个MySQL的版本不一样，基于复制文件的恢复就可能无法实现。</p>
<h3 id="5-3-2-逻辑备份的恢复"><a href="#5-3-2-逻辑备份的恢复" class="headerlink" title="5.3.2 逻辑备份的恢复"></a>5.3.2 逻辑备份的恢复</h3><p>与逻辑备份相同，逻辑备份的恢复也对应着多种方式，MySQL允许将数据导出到外部文件，也可以从外部文件导入数据。</p>
<p><strong>1.使用LOAD DATA INFILE导入</strong></p>
<p><strong>2.使用mysqlimport导入</strong>使用mysqlimport可以导入文本文件，并且不需要登录MySQL客户端。<strong>mysqlimport命令提供了许多与LOAD DATA INFILE语句相同的功能，大多数选项直接对应LOAD DATA INFILE子句</strong>。使用mysqlimport命令需要指定所需的选项、导入的数据库名称以及导入的数据文件的路径和名称。mysqlimport命令的基本语法格式为</p>
<p><strong>3.SQL格式的恢复</strong>5.2.3节使用的mysqldump备份的默认方式是SQL导出的方式，通过这种方式导出的数据都是由一条条SQL语句构成的，所以恢复的过程就变得非常简单，直接执行这些SQL语句即可，因为这样的SQL语句不止一条，并不适合使用MySQL的命令行模式逐条进行执行，下面有两种简单的操作方式。（1）使用mysql命令行工具。借助命令行工具和重定义输入&#x2F;输出，将SQL脚本作为条件输入mysql命令，下面例子将导入我们之前备份的employees数据库的数据表deparmtents，在导入之前先删除employees数据库中的数据表departments。mysql –uroot –p123456 employees&lt; &#x2F;users&#x2F;admins&#x2F;file.sqlfile.sql文件是之前导出的内容，接下来我们使用SHOW TABLES命令可以查看employees下的数据表，成功地恢复了删掉的数据表。（2）我们还可以使用mysql命令行模式提供的source命令。source命令并不是标准的SQL语句，而是由mysql命令行工具提供的客户端命令，该命令可执行指定的SQL脚本。在使用source命令的过程中需要首先连接到数据库，与上述的例子一样，导入employees数据库中的departments的SQL格式文件，在使用source导入的过程中要提供文件的绝对路径，具体的命令如下：mysql&gt;source &#x2F;users&#x2F;admins&#x2F;file.sql</p>
<p><strong>4.使用MySQL Workbench进行恢复</strong></p>
<h3 id="5-3-3-基于时间点的恢复"><a href="#5-3-3-基于时间点的恢复" class="headerlink" title="5.3.3 基于时间点的恢复"></a>5.3.3 基于时间点的恢复</h3><p><strong>基于时间点恢复可以使用mysqlbinlog工具。</strong></p>
<h3 id="5-3-4-InnoDB崩溃恢复"><a href="#5-3-4-InnoDB崩溃恢复" class="headerlink" title="5.3.4 InnoDB崩溃恢复"></a>5.3.4 InnoDB崩溃恢复</h3><h3 id="5-3-5-使用复制来进行恢复"><a href="#5-3-5-使用复制来进行恢复" class="headerlink" title="5.3.5 使用复制来进行恢复"></a>5.3.5 使用复制来进行恢复</h3><p>第7章我们将专门讲述MySQL复制，复制和时间点恢复使用相同的机制，都是使用二进制日志，这意味着在恢复过程中，<strong>复制也是一种非常有用的工具，</strong>复制比mysqlbinlog更可靠，因为mysqlbinlog可能会有一些导致异常行为的奇怪的Bug和不常见的情况。（1）延迟复制以实现快速恢复。发生故障后，停止从属服务器，然后使用START SLAVE UNTIL语句重放事件，接下来执行SET GLOBAL SQL_SLAVE_ SKIP_COUNTER &#x3D; 1跳过错误的语句。执行START SLAVE并让从机运行，直到完成其中继日志，这样就可以完成时间点恢复的所有烦琐工作。即使没有延迟复制从服务器来加速恢复，从从属服务器也很有用，因为它将主服务器的二进制日志读取到另一台计算机上。如果主磁盘发生故障，从属服务器的中继日志可能是唯一可以获得主服务器二进制日志的最新副本的地方。（2）使用日志服务器进行恢复。把从属服务器设置为日志服务器。使用日志服务器可以执行更复杂的过滤，例如，通过日志服务器可以很轻松地恢复单个表。</p>
<h2 id="5-4-MySQL备份恢复工具"><a href="#5-4-MySQL备份恢复工具" class="headerlink" title="5.4 MySQL备份恢复工具"></a>5.4 MySQL备份恢复工具</h2><h3 id="用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。"><a href="#用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。" class="headerlink" title="用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。"></a>用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。</h3><p><strong>1.MySQL Enterprise Backup</strong>MySQL Enterprise Backup是MySQL“官方”的备份工具，它是一个多平台、高性能的工具，提供在线备份、增量和差异备份、选择性备份和恢复等功能，支持直接云存储备份、备份加密和压缩等丰富功能。</p>
<p><strong>2.XtraBackup</strong>XtraBackup与MySQL Enterprise Backup在很多方面都非常类似，它是由知名的数据库软件服务企业Percona提供的一款热备份工具，是开源并且免费的。XtraBackup备份时具有读写无阻塞、支持增量等特点。除了核心备份工具外，还有一个用Perl写的封装脚本，可以提供更多的高级功能，它支持类似流、增量、压縮和多线程（并行）备份操作。也有许多特别的功能，用以减小在高负载的系统上备份的影响。</p>
<p><strong>3.mylvmbackup</strong>mylvmbackup是一种快速创建MySQL服务器数据文件的完整物理备份的工具，是一个Perl脚本。为了执行备份，mylvmbackup在所有表上获得读锁定并将所有服务器缓存刷新到磁盘，为包含MySQL数据目录的卷制作LVM（Logical Volume Manager，逻辑卷管理）快照，然后再次解锁表。快照过程只需要很短的时间。完成后，服务器可以继续正常操作，而实际文件备份继续进行。</p>
<p><strong>4.mydumper</strong>mydumper是一个针对MySQL数据库备份的轻量级第三方的开源工具，备份方式为逻辑备份。它支持多线程，备份速度远高于原生态的mysqldump。mysqldump工具支持单线程工作，依次导出多个表，没有一个并行的机，这就使得它无法迅速备份数据。mydumper作为一个实用工具，能够良好地支持多线程工作，可以并行多线程从表中读入数据并同时写到不同的文件里，这使得它在处理速度方面快于传统的mysqldump。其特征之一是在处理过程中需要对列表加以锁定，因此如果需要在工作时段执行备份工作，那么可能会引起DML阻塞，但一般现在的MySQL都有主从，备份也大部分在从上进行，所以锁的问题可以不用考虑，这样mydumper能更好地完成备份任务。<strong>5.mysqlhotcopy</strong>mysqlhotcopy是一个Perl脚本，最初由Tim Bunce编写并提供，它将FLUSH TABLES、LOCK TABLES以及cp&#x2F;scp等命令封装调用，能够直接对数据库或某些指定的表对象创建备份，方便用户执行。但是因为调用操作系统命令（cp或scp）实现的原因，它只能进行本地备份，除此之外也只能支持在线备份。该备份工具与备份对象所用的存储引擎强相关，并不适用于所有的场景，只用于备份MyISAM和ARCHIVE存储引擎的对象。<strong>6.Zmanda Recovery Mananger</strong>Zmanda Recovery Manager for MySQL（ZRM）为数据库管理员提供了一套方便、灵活、强大的MySQL数据库备份和复原的解决方案。</p>
<h1 id="第6章-数据库性能监视与优化"><a href="#第6章-数据库性能监视与优化" class="headerlink" title="第6章 数据库性能监视与优化"></a>第6章 数据库性能监视与优化</h1><h2 id="6-1-数据库性能检测工具"><a href="#6-1-数据库性能检测工具" class="headerlink" title="6.1 数据库性能检测工具"></a>6.1 数据库性能检测工具</h2><h3 id="6-1-1-数据库性能检测工具概述"><a href="#6-1-1-数据库性能检测工具概述" class="headerlink" title="6.1.1 数据库性能检测工具概述"></a>6.1.1 数据库性能检测工具概述</h3><p>数据库部署于服务器上面，若服务器的性能下滑，势必影响数据库的性能，所以<strong>数据库性能监视不仅要对MySQL当前的状态，如InnoDB、线程状态、锁状态、慢查询等进行检测，而且还要适当延伸到对OS进行监视，如收集OS的内存利用情况、IO情况、网络使用情况等</strong>，因此MySQL监视是一个很复杂的任务，不同的监测工具有不同的侧重。</p>
<h3 id="6-1-2-非交互性监视工具"><a href="#6-1-2-非交互性监视工具" class="headerlink" title="6.1.2 非交互性监视工具"></a>6.1.2 非交互性监视工具</h3><p><strong>1.Nagios****Nagios是一款开源的操作系统、数据库系统和网络监视工具</strong>，能有效监视Windows、Linux和Unix操作系统的主机状态，在系统或服务状态异常时发出邮件或短信报警，第一时间通知运维人员，在状态恢复后发出正常的邮件或短信通知。</p>
<p><strong>2.Monyog****Monyog是MySQL监视工具</strong>，该工具可以积极主动地监视数据库环境，并会就如何优化性能、加强安全或为MySQL系统减少停机时间提供意见。Monyog提供了一个日志分析模块，可以方便地识别在服务器上运行缓慢的语句和应用程序，同时可以监视MySQL的错误日志，可以提取错误日志的内容，Monyog还可以通过邮件或SNMP向我们发送警报，及时告知我们mysql服务器的状态。</p>
<h3 id="6-1-3-交互性监视工具"><a href="#6-1-3-交互性监视工具" class="headerlink" title="6.1.3 交互性监视工具"></a>6.1.3 交互性监视工具</h3><p><strong>1.Innotop****Innotop是一个通过文本模式显示MySQL和InnoDB的监测工具</strong>，它能详细地监视当前MySQL和InnoDB运行的状态，让数据库管理员根据结果合理地优化MySQL。事务列表可以显示InooDB当前的全部事务，查询列表可以显示当前正在运行的查询，可以显示当前锁和锁等待的列表，可以显示服务器状态和变量的汇总信息，同时有多种模式可用来显示InnoDB内部信息（缓冲区、死锁、外键错误、I&#x2F;O活动、行操作等）。<strong>2.Mytop****Mytop是一个基于命令行的工具，用于监视MySQL服务器的线程和整体性能</strong>。如图6-1所示，第一行显示了主机名称、MySQL的运行时间(以days hour:minutes: seconds为格式)；第二行、第三行的Queries显示了执行的SQL查询语句总数，另外还有目前每秒处理的查询数和速度；第四行的Key Efficiency显示了缓存命中率；最下方的区域就是目前链接到数据库的各个线程。</p>
<h2 id="6-2-数据库性能监视剖析"><a href="#6-2-数据库性能监视剖析" class="headerlink" title="6.2 数据库性能监视剖析"></a>6.2 数据库性能监视剖析</h2><h3 id="6-2-1-数据库性能监视剖析"><a href="#6-2-1-数据库性能监视剖析" class="headerlink" title="6.2.1 数据库性能监视剖析"></a>6.2.1 数据库性能监视剖析</h3><p><strong>数据库性能监视的出发点就是在整个数据库应用系统实际运行在生产环境或者测试环境时，对数据库服务器的各项指标进行定量的检测和收集</strong>。这些数据将成为以后优化分析的基础，比如磁盘I&#x2F;O、网络延时或者是语句等，详尽的数据收集是数据库优化的第一步。数据库性能监视首先要明确监视指标，下面介绍一些常用的指标，在不同的具体应用中则需要从更多方面去衡量。<strong>1.吞吐量****吞吐量指的是单位时间内的事务处理数</strong>，这个指标一直是最经典的数据库应用测试指标，在一些标准的测试之中广泛地使用。吞吐量代表了数据库处理请求的能力，一个数据库应用系统的吞吐量与请求对CPU的消耗、外部接口、I&#x2F;O等紧密关联。单个请求对CPU的消耗越高，外部接口、I&#x2F;O反应速度越慢，数据库吞吐量越低，反之则越高。在一些测试中（如TPC-C），主要针对在线事务处理的吞吐量非常适用于多用户的交互式应用，常用的测试单位有每秒事务数量（TPS，Transaction Per Second）或者每分钟事务数量（TPM，Transaction Per Minute），以及每秒查询数量（QPS, Query Per Second）。<strong>2.并发性****并发性经常表示有多少用户在同一时间内同时操纵数据库应用系统</strong>，数据库的并发性和创建数据库的连接不完全是一回事。一个良好设计的应用同时可以打开成百上千的MySQL数据库服务器的连接，但是可能只有很少数的连接同时在执行真正的查询任务，所以同时有上万个用户在访问，并不代表有上万个并发请求发送到了MySQL数据库。我们应该关注的问题是同时工作的并发操作，当并发请求增多的时候，吞吐量是否下降，响应时间是否变长。每当应用处于访问峰值的时候，整体应用的效率就会降低，影响用户体验。<strong>3.响应时间和延迟时间****响应时间和延迟时间指的是一种度量方式，其是指一条查询或者更新语句从发出请求到接收完数据的时间</strong>，通常测试的单位为微秒、毫秒、秒或者分钟。根据不同的单位计算平均响应时间和最大响应时间，因为最大响应时间的不确定性和不可重复性，所以一般使用X%的查询响应时间作为指标。如果值为95%为10 ms，意味着95%的查询会在10 ms内返回。对于联机事务处理过程查询来说，在50 ms内返回是比较理想的结果，超过200 ms的查询则被视为慢查询。我们可以将一段时间内的检测数据使用统计图表的方式来呈现，通常为饼状图或者柱状图，可以看到时间的具体分布，再根据MySQL提供的慢日志查询来收集运行时间超过一定阈值的语句，当90%的语句都能够在50 ms以内完成，那么阈值就可以设为50 ms，当发现一条SQL语句执行超过了5 s，就可以根据这条记录复现查询，分析耗时原因，做出相应优化。</p>
<h3 id="6-2-2-MySQL主要指标监视方法"><a href="#6-2-2-MySQL主要指标监视方法" class="headerlink" title="6.2.2 MySQL主要指标监视方法"></a>6.2.2 MySQL主要指标监视方法</h3><p>前面3.1节中讨论过数据字典的概念，MySQL中有一个自带的数据库performance_schema，记录了数据库服务器的运行状态信息，该数据库可用于数据库性能的监视和优化。同时我们知道，可以通过访问服务器状态变量获得MySQL运行中的一些信息。以下从MySQL吞吐量、查询性能、连接检查、InnoDB缓冲区、查询缓存、临时表、访问表的数量等几个方面来讲述MySQL的主要指标监视方法，主要指标类型分为吞吐量、响应时间、并发性、利用率、错误率等。<strong>1.吞吐量****MySQL中关于吞吐量可以从Questions、Com_select、Com_insert、Com_update、Com_delete几个指标值获取</strong>。Questions是内部计数器（这是一个服务器状态变量），客户端每发送一个查询语句，其值就会加一。也可以监视读指令、写指令分别的执行情况，从而监视数据库的工作负载，从中寻找可能出现的问题。读指令由Com_select的值表示，而写指令（Writes）由插入、更新、删除这三种语句综合表示，这三种语句分别是Com_insert、Com_update、Com_delete，可以通过查询这三个值的和来反映当前的读写压力。若总的查询量突然增大或者突然减少，同时变化幅度非常大，超过正常预期，这就预示着某些严重的问题已经发生。同时随着磁盘IO的增大，读写命令数没有相应变化，可能和当前设备的读写速度或缓冲区设置不当有着密切的联系。表6-1介绍了吞吐量指标采集方法。</p>
<p><strong>2.查询性能</strong></p>
<p><strong>3.连接检查</strong>在MySQL中每个连接（Connection）对应一个线程，<strong>MySQL关于连接检查的相关指标有Threads_connected、Threads_running、Connection_errors_internal、Aborted_connects和Connection_errors_max_connections</strong>，见表6-3。通过监视当前连接的线程数Threads_connected，就可以知道当前连接数，通过其余剩余资源来确定还可容纳新的连接数。通过监视Threads_running变量可以知道当前任意时间正在活跃的线程数，而剩余线程就是处于连接闲置状态。当连接数达到max_connections限制，新的连接将被拒绝，Connection_errors_max_connection会随着被拒绝连接的数量递增，每拒绝一个将会增加一个，与此同时指示所有失败连接的指标Aborted_connects也会增加。Connection_errors_internal指标反映的是由于内部错误而失败的连接数量，该指标会在错误来自于服务器本身时而增加，内部错误反映了内存不足或者是服务器无法开启新的线程而导致。</p>
<p><strong>4.InnoDB缓冲区</strong>通常MySQL的默认存储引擎为InnoDB，InnoDB为了减少实际的I&#x2F;O次数并提高效率而使用了缓冲区的技术，缓冲区用于缓存数据和索引。若缓冲区设置不当，往往会导致数据库的效率降低，对缓冲区监视有助于对问题进行排查。例如，当I&#x2F;O一直处于高位，而数据库的性能却降低了，这代表缓冲区页面命中的概率减少，可以适当扩大缓冲区，以缓存更多数据来减少实际的I&#x2F;O次数。缓冲区大小默认为128 MiB，也可以根据服务器的内存大小来手动设置。缓冲区并不是越大越好，内存本身是有限制的，通常成本较高。InnoDB的内存开销可能提高超过缓冲池大小10%的内存占用，并且如果物理内存耗尽了，系统会求助于分页，这样会导致数据库性能严重受损。<strong>InnoDB缓冲区的指标有Innodb_buffer_pool_pages_total、Innodb_buffer_pool_read_requests、Innodb_buffer_pool_reads及缓冲池使用率</strong></p>
<p><strong>5.查询缓存****缓存命中率指的是当一模一样的查询语句重复执行时，能够直接从查询缓存中取得结果集的次数除以查询语句的数量</strong>。缓存命中率也是MySQL重要的指标之一，MySQL会自动将之前查询的语句以及查询返回的结果都缓存下来，并且在它们之间建立映射关系。当MySQL收到一条如SELECT类型的语句时，MySQL会对这条查询语句进行hash计算而得到一个hash值，然后通过该hash值到查询缓存中去匹配，如果没有得到匹配结果，则会将这个hash值存放在一个hash链表中，同时将此次查询的结果存放至缓存中。存放hash值的链表的每个节点都会存放相应查询返回结果在缓存中的地址，以及该次查询所涉及的一些表的相关信息。如果通过hash值匹配到相同的查询，则会直接将缓存中相应的查询结果返回给客户端；如果MySQL的任何一张表中的任何一条数据发生了变化，便会通知查询缓存，将和这张表相关的查询缓存全部变为失效，并释放占用的内存空间。查询缓存的工作原则是执行查询最快的方式就是不去执行，当客户端执行一条查询语句的时候，首先会去查询缓存中查找，并且同时交给解析器进行解析，如果在查询缓存中命中，则终止解析器的SQL语句解析工作，直接返回缓存的数据。</p>
<p><strong>6.临时表</strong>在MySQL中，临时表分为外部临时表和内部临时表。通过CREATE TEMPORARY TABLE创建的临时表被称为外部临时表，这种临时表只对当前用户可见，当前会话结束的时候，该临时表会自动关闭。这种临时表的命名与非临时表可以同名（同名后非临时表将对当前会话不可见，直到临时表被删除）。内部临时表是一种特殊轻量级的临时表，用来进行性能优化，这种临时表会被MySQL自动创建并用来存储某些操作的中间结果，这些操作可能包括在优化阶段或者执行阶段，这种内部表对用户来说是不可见的，但是通过EXPLAIN或者SHOW STATUS可以查看MYSQL是否使用了内部临时表用来帮助完成某个操作。内部临时表在SQL语句的优化过程中扮演着非常重要的角色，MySQL中的很多操作都要依赖内部临时表进行优化。</p>
<p><strong>7.访问表的数量</strong>MySQL在访问一张表的时候，将其放入缓存中，如果数据库中有许多的表，通常将其放入缓存中，可对性能的提升带来帮助。当打开的表的数量不断增多的时候，缓存会被逐渐填满，如果新打开的表不在缓存中，MySQL会将一些旧的表移出缓存。</p>
<h3 id="6-2-3-MySQL-PROCESSLIST"><a href="#6-2-3-MySQL-PROCESSLIST" class="headerlink" title="6.2.3 MySQL PROCESSLIST"></a>6.2.3 MySQL PROCESSLIST</h3><p>仅仅通过6.2.1节中介绍的指标进行判断，能够发现出现了何种问题，给出一个大概的参考，如果需要进一步地定位问题并快速处理，那就需要SHOW PROCESSLIST命令协助进行故障诊断。SHOW PROCESSLIST命令可以显示用户正在运行的线程，需要注意的是，除了root用户能看到所有正在运行的线程外，其他用户只能看到自己正在运行的线程，而看不到其他用户正在运行的线程，除非单独将这个用户赋予了PROCESS权限。PROCESSLIST命令运行结果如图6-14所示。</p>
<h3 id="6-2-4-慢查询日志解析"><a href="#6-2-4-慢查询日志解析" class="headerlink" title="6.2.4 慢查询日志解析"></a>6.2.4 慢查询日志解析</h3><p>正如3.2.2节中所说，<strong>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10 s以上的语句。在默认情况下，MySQL数据库并不启动慢查询日志，需要手动设置该参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少对性能带来一定的影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。慢查询主要体现在慢上，通常意义上来讲，只要返回时间大于1 s的查询都可以称为慢查询。慢查询会导致CPU、内存消耗过高，数据库服务器压力陡然增大，对于大部分情况来讲，基本都是由某些慢查询导致的。<strong>慢查询日志中不止包含了执行时间过长的语句（大于设置的long_query_time阈值），还包含了未使用索引或者未使用最优的索引</strong>，这两种日志默认都是没有打开的。未使用索引的日志内容一般来讲会有很多，导致日志文件非常大，通常不记录这种日志或者限制其每分钟输出的日志数量（设置遍历</p>
<h2 id="6-3-查询性能优化"><a href="#6-3-查询性能优化" class="headerlink" title="6.3 查询性能优化"></a>6.3 查询性能优化</h2><h3 id="6-3-1-查询执行过程与优化技术"><a href="#6-3-1-查询执行过程与优化技术" class="headerlink" title="6.3.1 查询执行过程与优化技术"></a>6.3.1 查询执行过程与优化技术</h3><p><strong>1.查询执行过程****服务器端的SQL处理过程大体包括：查询缓冲、语句解析、查询优化、语句执行、提取数据，</strong>如图6-15所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573112631-f9567555-8a7b-49fa-9691-82be0708e6a5.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8c6ecec0&originHeight=122&originWidth=546&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u883a92f2-559a-4dbd-ab72-a0386141271&title=">图6-15 SQL语句处理过程（1）查询缓冲。数据库服务器在接到客户端传送过来的SQL语句时，不会直接去数据库查询，而是会先在数据库的高速缓存中去查找，是否存在相同语句的执行计划，如果找到，则服务器进程就会直接执行这个SQL语句，省去后续的工作，这样可以提高SQL语句的查询效率。（2）语句解析。当在高速缓存中找不到对应的SQL语句时，则服务器会开始对这条语句进行解析，语句解析通过解析器完成，主要包括语法和语义检查、获得对象锁、访问权限核对等过程。（3）查询优化。如果语法与语义都没有问题，权限也匹配的话，服务器还是不会直接对数据库文件进行查询。服务器会根据一定的规则，对这条语句进行优化，这个工作主要由优化器完成。<strong>关于查询优化器</strong>（4）语句执行。SQL语句执行也分两种情况，一种情况是若被查询的数据块已经读取到数据缓冲区的话，则服务器会直接把这个数据传递给客户端，而不是从数据库文件中去查询数据；另一种情况是若数据不在缓冲区中，则服务器将从数据库文件中查询相关数据，并把这些数据放入数据缓冲区中。（5）提取数据。当语句执行完成之后，查询到的数据还是在服务器中，还没有被传送到客户端，所以在服务器端有一个专门负责数据提取的一段代码，其作用就是把查询到的数据结果返回给用户端进程，从而完成整个查询动作。我们从整个查询处理过程中了解到，绝大部分SQL语句都是按照这个过程处理的，数据库管理员或者数据库运维人员了解这些语句的处理过程，对于我们进行查询优化是非常有帮助的。有时候掌握这些处理原则可以减少排错和优化的时间。<strong>2.查询优化技术</strong>前面我们大概理解了一条查询语句执行的过程之后会发现，主要的查询优化的工作都是对SQL语句进行的，也就是进行SQL层面的优化。<strong>查询语句优化主要有以下几种方法：查询重用、查询重写、并行查询</strong>，等等。（1）查询重用。对于服务器来说，所有的查询处理、语句分析、查询优化、生成查询计划都是一个非常昂贵的开销。</p>
<p>（2）查询重写。我们知道对于同一个查询任务，存在多种查询语句的写法，不同的语句其查询效率不一样。在针对同一个任务时，重写原有的SQL语句，从而使其提高执行效率，这就是查询重写的思想。</p>
<h3 id="6-3-2-逻辑查询优化"><a href="#6-3-2-逻辑查询优化" class="headerlink" title="6.3.2 逻辑查询优化"></a>6.3.2 逻辑查询优化</h3><p><strong>1.子查询优化</strong>当一个查询是另一个查询的子部分时，称之为子查询，子查询是查询语句中相对耗时的操作。从子查询出现的位置来看，可以出现在WHERE子句、JOIN&#x2F;ON子句、FROM子句、GROUPBY子句、HAVING子句和ORDERBY子句中，子句出现的位置的不同，对优化的影响程度不同。（1）MySQL支持的优化。<strong>MySQL子查询优化（MySQL优化器优化）只局限于对简单SELECT查询中的子查询进行优化，</strong>简单SELECT语句中的子查询会被MySQL优化器自动上拉到父层，这样可以提高效率。<strong>2.视图重写</strong>视图是指计算机数据库中的视图，是一个虚拟表，其内容由查询定义。视图并不在数据库中以存储的数据值集形式存在，行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。<strong>视图重写也就是在查询语句中出现视图对象(先将视图转化为子查询，再进行优化)，查询优化后，视图对象消失，消失的视图对象的查询语句融合到初始查询中。</strong></p>
<p><strong>3.等价谓词重写****等价谓词重写，主要就是使其能更好地利用索引，有些谓词是可以利用索引的，所以将表达式写成更高效的形式能够有效提高查询的执行效率，这就是等价谓词重写。</strong></p>
<p><strong>4.条件化简</strong>在SQL语句中，WHERE、HAVING、ON的条件由许多表达式组成，而这些表达式在特定时候存在关系。利用等式和不等式的性质可以将其化简。具体条件化简的方式包括以下几种常见的形式。</p>
<h3 id="6-3-3-物理查询优化"><a href="#6-3-3-物理查询优化" class="headerlink" title="6.3.3 物理查询优化"></a>6.3.3 物理查询优化</h3><p>6.3.2节讲述的逻辑查询优化解决的是如何找出SQL语句等价的变换形式，使得SQL执行更为高效，而物理查询优化解决的问题是从可选的单表扫描方式中挑选什么样的单表扫描方式是最优的；在两个表做连接时，如何连接最优；多表连接时，连接顺序有多种组合，哪种连接顺序是最优的。多表连接，连接顺序有多种组合，是否要对每种组合都探索？如果不全部探索，怎么找到最优的一种组合？这当中就需要对查询的代价进行估算，根据估算值进行比较选择，此外，能在索引上完成的查询，尽量避免扫描表。<strong>1.查询代价估算</strong>查询代价估算的重点，也就是物理查询优化的核心是代价估算模型。查询代价估算是基于CPU代价和IO代价进行的，<strong>代价模型的公式如下所示</strong>：总代价&#x3D; I&#x2F;O代价(数据读取) +CPU代价(数据计算处理)COST &#x3D; pages×a_page_cpu_time+W×T式中，pages：计划运行时访问的页面数；a_page_cpu_time：每个页面读取的时间花费。pages×a_page_cpu_time反映了I&#x2F;O花费。T：访问的元组数，反映了CPU花费（存储层是以页面为单位，数据以页面的形式被读入内存，每个页面上可能有多条元组，访问元组需要解析元组结构，才能把元组上的字段读出，这消耗的是CPU）。如果是索引扫描，则还会包括索引读取的花费。W：权重因子，表明I&#x2F;O到CPU的相关性，又称选择率。选择率用于表示在关系R中，满足条件“A  col”的元组数与R的所有元组数N的比值。选择率W在代价估算模型中占有重要地位，其精准程度直接影响最优化的计划的选取。选择率计算可以采用抽样方法，从数据库中抽取部分样本元组，针对这些样本进行查询，然后收集统计数据，只有足够的样本被测试之后才能达到预期的精度。</p>
<p><strong>2.索引</strong>3.4节比较详细地讲述了索引的概念、索引的类型和创建原则，过多地使用索引将会造成滥用，因此索引也会有它的缺点：虽然索引大大提高了查询速度，但会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE操作。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，而建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果在一个大表上创建了多种组合索引，索引文件会膨胀得很快。索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p>
<h2 id="6-4-优化数据库对象"><a href="#6-4-优化数据库对象" class="headerlink" title="6.4 优化数据库对象"></a>6.4 优化数据库对象</h2><h3 id="6-4-1-优化表的数据类型"><a href="#6-4-1-优化表的数据类型" class="headerlink" title="6.4.1 优化表的数据类型"></a>6.4.1 优化表的数据类型</h3><p>表需要根据应用来判断使用何种数据类型。虽然应用设计的时候需要考虑字段的长度留有一定的冗余，但是不推荐让很多字段都留有大量的冗余，这样既浪费存储也浪费内存。<strong>我们可以使用PROCEDURE ANALYSE()对当前已有应用的表类型进行判断，该函数可以对数据表中的列的数据类型提出优化建议，可以根据应用的实际情况酌情考虑是否实施优化</strong>。PROCEDURE ANALYSE()的语法如下：</p>
<p><strong>1.数据类型选择的总体原则</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573186402-3967a422-db29-42a5-a4c5-1207a0dbd7c6.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9e4cb0db&originHeight=598&originWidth=699&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u78b79890-8778-4fd1-848a-8c376b503f6&title="><strong>2.数据类型的使用建议</strong>3.4.1节中讲述了数据库表支持的数据类型，我们在为列选择数据类型的时候，不仅要考虑存储类型大小，还要考虑MySQL如何对它们进行计算和比较。例如，MySQL在内部把ENUM和SET类型保存为整数，但是在比较的时候把它们转换为字符串。我们要在相关表中使用同样的类型，类型之间要精确匹配，包括诸如UNSIGNED这样的属性。混合不同的数据类型会导致性能问题，即使没有性能问题，隐式的类型转换也能导致难以察觉的错误。选择最小的数据类型要考虑将来留出的增长空间。例如，中国的省份，我们知道不会有成千上万个，因此不必用INT，用TINYINT就足够了，它比INT小3个字节。整数通常是最佳的数据类型，因为它速度快，并且能使用AUTO_INCREMENT。要尽可能避免将字符串作为列的数据类型，因为它们占用了很多空间，并且通常比整数类型要慢。MyISAM默认情况下为字符串使用了压缩索引，这使得查找更为缓慢。</p>
<h3 id="6-4-2-拆分表"><a href="#6-4-2-拆分表" class="headerlink" title="6.4.2 拆分表"></a>6.4.2 拆分表</h3><p><strong>拆分表是按照一定的方式将一张表拆分成多张表或者使用MySQL分区，</strong>这样做可以有效提高表的查询和更新效率，也有助于将耦合的数据解耦合。拆分的方法可以分成两种情况：水平拆分或者垂直拆分。</p>
<h3 id="6-4-3-逆规范化"><a href="#6-4-3-逆规范化" class="headerlink" title="6.4.3 逆规范化"></a>6.4.3 逆规范化</h3><p>数据库设计时要满足何种规范化的要求，同时需要遵守数据库三范式，但是并不是任何时候我们都需要遵守规范和范式，因为规范化越高，产生的关系就越多，关系过多的直接结果就是导致表之间的连接操作越频繁，而表之间的连接操作是性能较低的操作，直接影响査询的速度，所以对于査询较多的应用，就需要根据实际情况运用逆规范化对数据进行设计，通过逆规范化来提高査询的性能。<strong>逆规范化（Denormalization）是一种通过添加冗余数据的数据库优化技术，</strong>可以帮助我们减少关系数据库中耗时的JOIN运算。在一般的规范化的数据库中，我们将数据存在不同的表中是为了减少冗余数据，所以我们会尝试使每条数据在数据库中只有一份。比如说，在一个规范化的数据库中，我们有Courses表和Teachers表，每个Courses表的一项都会保存teacherID，但是没有teacherName，当我们想要返回Course和teacherName时，我们需要联合两个表。当老师需要改名时，我们只需要修改Teachers表，这是这样做的好处，但是当表很大的时候，联合两表就会很耗时。逆规范化使我们容忍部分冗余数据和更新表所需多余的一些工作，以此换来快速高效的检索和较少的JOIN操作。很多公司都会同时使用规范化和逆规范化数据库。</p>
<h3 id="6-4-4-缓存表和汇总表"><a href="#6-4-4-缓存表和汇总表" class="headerlink" title="6.4.4 缓存表和汇总表"></a>6.4.4 缓存表和汇总表</h3><p>在数据库设计的时候我们需要在统计效率和数据冗余之间作出取舍，在同一张表中保存衍生的冗余数据可以极大地提升性能，有时候也需要创建一张完全独立的汇总表或缓存表。建立汇总表的原因就在于：无论通过粗略的统计计算还是严格的计数，都比计算原始表的所有行有效的多。建立缓存表的原因则是优化检索和查询语句，这些查询语句经常需要特殊的表和索引，跟普通的OLTP操作表有一些区别。</p>
<h3 id="6-4-5-ALTER-TABLE加速"><a href="#6-4-5-ALTER-TABLE加速" class="headerlink" title="6.4.5 ALTER TABLE加速"></a>6.4.5 ALTER TABLE加速</h3><p>ALTER TABLE操作的性能对MYSQL来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样的操作非常耗费时间，尤其是在数据量非常大且内存不足的情况下，如果还有很多索引那么时间将会更长，一个ALTER TABLE将会耗费数小时甚至数天才可以完成。一般而言，大部分ALTER TABLE操作将导致MySQL服务中断。对常见的场景，能使用的技巧只有以下两种。（1）先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换。（2）影子复制。影子复制的技术是用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。<strong>1.修改.frm文件</strong>MySQL中列的相关信息被存放在.frm文件中，当使用ALTER TABLE语句修改列的默认值时，MySQL将新建一张相同结构的空表，然后执行插入操作。其实我们可以跳过创建新表的步骤，直接修改这个文件，但是MySQL没有采用这个方式。下面这些操作是有可能不需要重建表的。（1）移除(不是增加)一列的AUTO_INCREMENT属性。（2）增加、移除或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字串值。<strong>2.InnoDB快速载入数据</strong>在MyISAM中有一个常用的技巧是禁用索引（只能禁用非唯一索引）、载入数据，然后重新启用索引。在现代版本的InnoDB版本中，有一个类似的技巧，这依赖于InnoDB的快速在线索引创建功能。这个技巧是先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引。此外，也可以使用ALTER TABLE的骇客访求加速这个操作，但需要多做一些工作并承担一定的风险，这对从备份中载入数据是很有用的。例如，当已经知道所有数据都是有效的且没有必要做唯一性检查时就可以操作。下面是操作步骤。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573220679-45a1e8b6-22c2-4c35-b1aa-a1529a49013b.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1bcdaa68&originHeight=546&originWidth=575&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6ca0625-4743-4d35-beff-c8071975156&title="></p>
<h2 id="6-5-应用优化"><a href="#6-5-应用优化" class="headerlink" title="6.5 应用优化"></a>6.5 应用优化</h2><h3 id="6-5-1-使用连接池"><a href="#6-5-1-使用连接池" class="headerlink" title="6.5.1 使用连接池"></a>6.5.1 使用连接池</h3><p>当App或者Web应用投入实际的生产中后，这个应用的整体性能受其各个组件的制约，比如网络、硬件、操作系统和应用程序，当然数据库性能也是其中的一部分。根据木桶效应的原理，当数据库性能降低，直至成为整个应用的短板时，应用整体的性能就会随之降低。如果用户在每一次的单击背后都在等待着数据库返回结果，而数据库却迟迟不能完成这个简单的查询，这时就需要对整个数据库进行优化了。<strong>1.连接池的概念和优点</strong>对于访问数据库来说，数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响整个应用程序的伸缩性和健壮性，影响应用程序的性能指标，因此，有必要建立连接池以提高访问的性能，数据库连接池正是针对这个问题提出来的。<strong>连接池是一个存放连接的池子，需要直接访问数据库的请求，从这个池子里面获取连接来使用，数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个，</strong>因为池子中的连接都已经预先创建好，可以直接分配给应用使用，所以大大减少了创建连接所耗费的资源。连接返回后，本次访问将连接交还给连接池，以供新的访问使用。数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有一定的连接数。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入等待队列。使用<strong>连接池的优势</strong>有以下几点。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236147-74e62cef-be60-488d-bab8-f6f31c3b9e73.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u19ae6dc1&originHeight=331&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua8ca6364-46de-4580-82fd-f9d80632b13&title="><strong>2.连接池的设置</strong>数据库连接池的最小连接数和最大连接数的设置要考虑以下几个因素。（1）最小连接数是连接池一直保持的数据库连接，如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。（2）最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过次数，后面的数据库连接请求将被加入到等待队列中，这会影响以后的数据库操作。（3）如果最小连接数与最大连接数相差很大，那么最先连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用后不会马上被释放，其将被放入连接池中等待重复使用或是在空间超时后被释放。MySQL默认的最大连接数为151，MySQL服务器允许的最大连接数为16 384。可以使用SHOW VARIABLES命令查看最大连接数，如图6-16所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236100-d6f2b118-75cd-483a-8dd4-e12d6d8a2426.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u5fa71f6e&originHeight=119&originWidth=353&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47ed1e63-2755-4ae5-be8f-3b6fec7e2b6&title=">图6-16 查看最大连接数可以使用两种方法修改最大连接数，第一种方法是直接修改MySQL的配置文件my.ini或者my.cnf，将其中的max_connections修改为合适的值，重启MySQL生效；第二种方法是通过SET命令修改，如图6-17所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236195-d0961f06-730c-45d5-a4ac-905ceb03c10f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u34058ee3&originHeight=39&originWidth=313&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e380e7d-03f9-4a9b-abc0-d70d8d33d6f&title=">图6-17 修改连接数最大连接数的修改可以根据实际情况动态决定，一般可以使用SHOW GLOBAL STATUS命令查询使用的连接数：mysql&gt; show global status like ‘Max_used_connections’;如果使用的连接数占上限的85%左右是相对理想的情况，如果比例在10%以下那就是设置过高，需要动态调整。</p>
<h3 id="6-5-2-减少对MySQL的访问"><a href="#6-5-2-减少对MySQL的访问" class="headerlink" title="6.5.2 减少对MySQL的访问"></a>6.5.2 减少对MySQL的访问</h3><p><strong>1.避免重复检索</strong>应用中需要厘清对数据库的访问逻辑，需要对相同表的访问，尽量集中SQL语句访问，一次SQL一次提取结果，减少对数据库的重复访问。虽然MySQL会对重复的查询有缓存的机制，但是对于频繁修改的表，缓存也会失效。重复查询会降低数据获取效率，同时增加MySQL的压力，减少对MySQL访问的次数可以节省宝贵的资源。编写SQL语句的时候就要通过一个SQL语句中查询出需要的数据，需要对整个数据库模式有着非常清楚的认知和良好的设计，这是对使用者而言的基本要求。<strong>2.使用查询缓存</strong>查询缓存存储SELECT查询的文本，以及发送给客户端的相应结果。如果随后收到一个相同的查询，服务器从查询缓存中重新得到查询结果，而不再需要解析和执行查询，其适用范围为不发生数据更新的表。当表更改（包括表结构和表数据）后，查询缓存值的相关条目被清空。在大部分的MySQL版本中，Query Cache功能默认都是打开的，我们可以通过调整 MySQL Server的参数选项打开该功能。Query Cache的主要参数query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type在6.2.1节中已经做了详细讲述。除了以上4个参数还有query_cache_wlock_invalidate，该参数控制当有写锁定发生在表上的时刻是否先失效该表相关的Query Cache，如果设置为1(TRUE)，则在写锁定的同时将失效该表相关的所有Query Cache，如果设置为0(FALSE)，则在锁定时刻仍然允许读取该表相关的 Query Cache。Query Cache是以客户端请求提交的查询为对象来处理的，只要客户端请求的是一个查询，无论这个查询是一个简单的单表查询还是多表Join，或者是带有子查询的复杂SQL，都被当作成一个查询，不会被分拆成多个查询来进行Cache，所以存在子查询的复杂查询也只会产生一个Cache对象，子查询不会产生单独的Cache内容。UNION[ALL]类型的语句也同样如此，Query Cache中缓存的内容仅仅只包含该查询所需要的结果数据，其是结果集。当然，并不仅仅只是结果数据，还包含与该结果相关的其他信息，比如产生该Cache的客户端连接的字符集、数据的字符集，以及客户端连接的Default Database等。Query Cache的查找是在MySQL接收到客户端请求后在对查询进行权限验证之后，SQL解析之前。也就是说，当MySQL接收到客户端的SQL后，仅仅只需要对其进行相应的权限验证后就会通过Query Cache来查找结果，甚至都不需要经过优化器进行执行计划的分析优化，更不需要发生任何存储引擎的交互，减少了大量的磁盘IO和CPU 运算，所以效率非常高。由于Query Cache在内存中是以HASH 结构来进行映射，HASH算法的基础就是组成SQL语句的字符，所以必须要整个SQL语句在字符级别完全一致，才能在Query Cache 中命中，即使多一个空格也不行。为了保证Query Cache中的内容与实际数据绝对一致，当表中的数据有任何变化，包括新增、修改、删除等，都会使所有引用该表的SQL的Query Cache失效。当开启了Query Cache之后，尤其是当我们的query_cache_type参数设置为1以后，MySQL会对每个SELECT语句都进行Query Cache查找，查找操作虽然比较简单，但仍然要消耗一些CPU运算资源，而由于Query Cache的失效机制的特性，可能由于表上的数据变化比较频繁，大量的Query Cache频繁地被失效，所以Query Cache的命中率就可能比较低下，所以在有些场景下，Query Cache不仅不能提高效率，反而可能造成负面影响。<strong>3.使用cache层</strong>在应用中，可以在应用端增加cache层来达到减轻数据库负担的目的。cache层有很多种，也有很多种实现的方式，只要能达到降低数据库的负担又能满足应用就可以，这就需要根据应用的实际情况进行特殊处理。</p>
<h3 id="6-5-3-负载均衡"><a href="#6-5-3-负载均衡" class="headerlink" title="6.5.3 负载均衡"></a>6.5.3 负载均衡</h3><p>负载均衡是在一个服务器集群中尽可能地平均负载量，通常的做法是在服务器前端设置一个负载均衡器（专门的硬件设备），MySQL的负载均衡通常都离不开数据分片（把数据分割成小块，存储到不同的DB节点中）、复制等操作。负载均衡的主要贡献除了均发数据库请求之外，还可提供管理读&#x2F;写策略。其在分发请求时会确定哪些节点可写、可读，随即将请求发送到指定节点上执行操作。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573250887-c05e193b-0105-4b1c-92c4-f24cc82ef23e.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=uc517ff05&originHeight=354&originWidth=552&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u721aecdf-9b53-4756-b0ca-00d9f15d56e&title="><strong>（1）MySQL读写分离</strong>。MySQL复制（第7章专门讲述数据库复制）时，产生了多个数据副本（从库），为减少服务器压力，从库用于处理读操作，主库可同时处理读写是MySQL集群实现读写分离的常用策略。由于从库的复制是异步的，无法实时同步，读写分离的主要难点也在于从库上的脏数据。通常如果使用从库进行读取，一般对数据的实时性要求不能太高。对此，MySQL提供了几种常见的读写分离方式，如基于查询、基于脏数据、基于会话的读写分离等。MySQL设置的读写分离减少了主库的请求量，将大量读的操作发送给从数据库，实现负载均衡。利用MySQL的主从复制可以有效地分流更新操作和查询操作，多台从服务器一方面用来确保可用性，另一方面可以创建不同的索引，满足不同查询的需要。对于主从之间不需要复制全部表的情况，可以通过在主服务器上搭建一个虚拟的从服务器，将需要复制到从服务器的表设置成blackhole引擎，然后定义replicate-do-table参数只复制这些表，这样就过滤出需要复制的binlog，减少了传输binlog的带宽。因为搭建的虚拟从服务器只起到过滤binlog的作用，并没有实际纪录任何数据，所以对主数据库服务器的性能影响也非常有限。通过复制分流查询存在的问题是主数据库上更新频繁或者网络出现问题的时候，主从之间的数据可能存在差异，造成查询结果的异议，应用在设计的时候需要有所考虑。<strong>（2）修改DNS</strong>。通过n个服务器IP指定到一个域名，根据请求的不同标识特征，将请求发送给不同的IP服务器进行处理，但是修改DNS存在许多问题，首先DNS一般都有缓存，通常在失效之前如果某台服务器无法提供服务，如MySQL的某个数据库宕机或者通信链路存在问题，服务请求方是无法探测到这些问题的，还依旧按照缓存的DNS中的IP来访问，这样就会出现问题。<strong>（3）使用中间件</strong>。例如，引入MySQL官方提供的MySQL负载中间件，MySQL_proxy也需要在服务器安装，修改配置文件（MySQL服务器的IP），其实质与NGINX是类似的，其也是一个负载均衡代理服务器。此外，还可以使用<strong>分布式数据库架构</strong>来实现负载均衡。分布式数据库架构适合大数据量、负载高的情况，它具有良好的扩展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载平均，提高访问的执行效率。具体实现的时候，可以使用MySQL的CLUSTER功能或者通过用户自己编写的程序来实现全局事务。需要注意的是，当前分布式事务只支持InnoDB存储引擎，因此如果通过自己编写程序来实现分布式架构数据库，那么就必须采用InnoDB存储引擎。</p>
<h1 id="第7章-数据库复制"><a href="#第7章-数据库复制" class="headerlink" title="第7章 数据库复制"></a>第7章 数据库复制</h1><h2 id="7-1-数据库复制原理"><a href="#7-1-数据库复制原理" class="headerlink" title="7.1 数据库复制原理"></a>7.1 数据库复制原理</h2><h3 id="7-1-1-数据库复制原理概述"><a href="#7-1-1-数据库复制原理概述" class="headerlink" title="7.1.1 数据库复制原理概述"></a>7.1.1 数据库复制原理概述</h3><p>前面我们介绍的都是基于单台MySQL数据库的情形，但在实际的生产环境中，无论是在安全性、高可用性及高并发等各个方面，由单台MySQL作为独立的数据库服务器可能不能完全满足实际需求，因此，可以考虑通过主从复制（Master-Slave）的方式同步数据，再通过读写分离（MySQL-Proxy）提升数据库的并发负载能力。在MySQL复制（Replication）的过程中一个服务器充当主数据库服务器（Master），而另一个或多个其他服务器充当从数据库服务器（Slave），从数据库也称备库。<strong>复制解决的基本问题是让一个主数据库服务器的数据与其他从数据库服务器的数据保持同步。****MySQL复制的基本原理是将主数据库服务器的DDL和DML操作通过二进制日志传到从数据库服务器上，然后在从数据库服务器上将这些日志文件重新执行，从而使从数据库服务器和主数据库服务器的数据保持同步。</strong>简单来说，复制有三个步骤：<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573280552-8b1760e3-cb83-4498-891b-da9c930ffb93.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1f8d4fe3&originHeight=202&originWidth=677&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7201c300-6e23-4f69-a57d-eb235ad2ab9&title="></p>
<h3 id="7-1-2-复制的架构和用途"><a href="#7-1-2-复制的架构和用途" class="headerlink" title="7.1.2 复制的架构和用途"></a>7.1.2 复制的架构和用途</h3><p><strong>1.复制的架构****MySQL复制的基本原理就是基于二进制日志，</strong>不过复制作为一项专门技术，当然不仅仅是这么简单，主数据库服务器更新重新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环，这些日志可以记录发送到从数据库服务器的更新。当一个从数据库服务器连接主数据库服务器时，它通知主数据库服务器、从数据库服务器在日志中读取的最后一次成功更新的位置，从数据库服务器接受从那时起发生的任何更新，然后封锁并等待主数据库服务器通知新的更新。<strong>为了实现主数据库二进制文件在从数据库的复用，在从数据库服务器中引入了中继日志文件、I&#x2F;O线程和SQL线程，如图7-1所示，更详细地描述了复制的架构。</strong>（1）在从数据库服务器上执行sart slave命令开启主从复制开关，开始进行主从复制（7.2节会详细讲述复制的设置），然后在主数据库记录二进制日志，每次准备提交事务完成数据更新前，主数据库将数据更新的事件会被记录到二进制日志中。MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。在记录二进制日志后，主数据库会告诉存储引擎可以提交事务了。（2）从数据库服务器会启动一个工作线程，称为I&#x2F;O线程，I&#x2F;O线程跟主数据库建立一个普通的客户端连接，然后在主数据库上启动一个特殊的二进制转储（Binlog Dump）线程，这个二进制转储线程会读取主数据库上二进制日志中的事件，它不会对事件进行轮询。此时，从数据库服务器的I&#x2F;O线程会通过在主数据库服务器上已经授权的复制用户权限请求连接主数据库服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容。<img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653573289858-f4a4dd86-0cd8-4c8a-b584-4d13c164c80c.png#clientId=ud43d93cd-6fda-4&from=paste&id=ue8cf501f&originHeight=598&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u51ba1d81-e789-4ab5-94ac-87dbac298c9&title=">图7-1 复制的架构（3）主数据库服务器接收到来自从数据库服务器的I&#x2F;O线程的请求后，二进制转储线程会根据从数据库服务器的I&#x2F;O线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回从数据库服务器端的I&#x2F;O线程。返回的信息中除了binlog日志内容外，还有在主数据库服务器端记录的新的binlog文件名称，以及在新的binlog中的下一个指定更新位置。（4）当从数据库服务器的I&#x2F;O线程获取到主数据库服务器上二进制转储线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到从数据库服务器端自身的中继日志（Relay Log）文件（MySQL-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取主数据库服务器端新binlog日志时能告诉主数据库服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容。如果从数据库服务器的I&#x2F;O线程追赶上了主数据库，它将进入睡眠状态，直到主数据库服务器发送信号量通知其有新的事件产生时才会被唤醒。（5）从数据库服务器端的SQL线程从中继日志中读取事件并在从数据库上执行，从而实现从库数据的更新，SQL线程会实时检测本地中继日志中I&#x2F;O线程新增的日志内容，然后及时把中继日志文件中的内容解析成SQL语句，并在自身从数据库服务器上按解析SQL语句的位置顺序执行应用这样的SQL语句，且在relay-log.info中记录当前应用中继日志的文件名和位置点。当SQL线程追赶上I&#x2F;O线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低，SQL线程执行的事件也可以通过配置选项来决定是否写入其自己的二进制日志中，它对于我们稍后提到的场景非常有用。图7-1显示了在从数据库有两个运行的线程，和其他普通连接一样，由从数据库发起的连接，在主数据库上同样拥有一个线程。这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行，也就是说I&#x2F;O线程能够独立于SQL线程之外工作。当然，仔细分析，这种架构也可能限制复制的过程，其中最重要的一点是在主数据库上并发运行的查询，在从数据库只能串行化执行，因为只有一个SQL线程来重放中继日志中的事件，这也可能造成工作负载的性能瓶颈。一个简单复制环境只需要两台运行MySQL的主机即可，甚至可以在一台物理服务器主机上启动两个MySQL实例，一个作为master，而另一个作为slave来完成复制环境的搭配，但在实际应用环境中，可以根据实际的业务需求利用MySQL复制的功能自己搭建出其他多种更利于扩展的复制架构，如最常用的主从架构。<strong>主从架构指的是使用一台MySQL服务器作为master，使用一台或多台MySQL服务器作为slave，将master的数据复制到slave上</strong>。在实际应用场合，主从架构模式是MySQL复制最常用的。一般在这种架构下，系统的写操作都是在master中进行的，而读操作则分散到各个slave中进行，因此这种架构特别适合现在互联网高读写的问题。此外，从数据库本身也可以被配置成另外一台服务器的主数据库，主数据库和从数据库之间可以有多种不同的组合方式。<strong>MySQL簇</strong>Mysql cluster（又称MySQL簇）就是由多台MySQL数据库服务器组成的服务器群，而多台服务器之间的数据同步就依赖于Mysql replicaion（复制）。Mysql replicaion（复制）本身是一个比较简单的结构，即一台从服务器（Slave）从一台主服务器（Master）读取二进制日志，然后再解析并应用到自身。<strong>2.复制过滤****复制过滤就是对用于复制的数据进行过滤，允许仅复制服务器上的一部分数据，而不是全部数据。</strong>有两种复制过滤方式：在主数据库上过滤记录到二进制日志中的事件，以及在从数据库上过滤记录到中继日志的事件，图7-2显示了这两种类型。<img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653573289819-2ae3892c-b938-466e-9b02-7f731906cf93.png#clientId=ud43d93cd-6fda-4&from=paste&id=u74778b01&originHeight=596&originWidth=1176&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u376d1d41-3b26-4afb-8803-7fc16f25a55&title=">图7-2 两种过滤方式在主数据库上使用选项binlog_do_db和binlog_ignore_db来控制过滤，在从数据库上，可以通过设置replicate_<em>选项，在从中继日志中读取事件时进行过滤。可以复制或忽略一个或多个数据库，把一个数据库重写到另外一个数据库，或使用类似LIKE的模式复制或忽略数据库表。</em><em>do</em> db和*_ignore_db有一些作用，但非常有限，必须要很小心地去使用这些参数，否则很容易造成主备不同步或复制出错。<strong>3.复制的用途</strong>通过对复制架构的理解，可以知道通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力，或者用来作为主备机的设计，保证在主机停止响应之后在很短的时间内就可以将应用切换到备机上继续运行。数据库集群系统具有多个数据库节点，在单个节点出现故障的情况下，其他正常节点可以继续提供服务；如果主服务器上出现了问题可以切换到从服务器上；通过复制可以在从服务器上执行查询操作，降低了主服务器的访问压力，实现数据分布和负载均衡；可以在从服务器上进行备份，以避免备份期间影响主服务器的服务。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573289819-5c4e0ff9-c0fc-44d5-a193-c0425a909062.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0d201b78&originHeight=351&originWidth=506&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u858a2e37-15a4-44b2-b777-53e4d6f374a&title=">（1）数据分布。MySQL复制通常不会对带宽造成很大的压力，可以随意地停止或开始复制，在不同的地理位置来分布数据备份，形成不同的数据中心。即使在不稳定的网络环境下，远程复制也可以工作。数据分布可以让一个业务模块读取一个数据库，再针对不同的业务场景进行数据库的索引创建和根据业务选择MySQL存储引擎，不同的从数据库可以根据不同需求设置不同索引和存储引擎。（2）负载均衡。读写分离也算是负载均衡的一种，通过MySQL复制可以将读操作分布到多个服务器上，实现对读密集型应用的优化，一般都是有多台数据库服务器的，所以可以将读操作指定到某一从数据库服务器上（需要代码控制，通过简单的代码修改就能实现基本的负载平衡），同时也可以把一些大量计算的查询指定到另一台从数据库服务器上，这样就不会影响主数据库服务器的写入及其他查询。在一个主数据库多个备数据库的架构中，写操作会被执行多次，这时候整个系统的性能取决于写入最慢的那部分。对于小规模的应用，可以简单地对机器名做硬编码或使用DNS轮询（将一个机器名指向多个IP地址），当然也可以使用更复杂的方法，如通过网络负载均衡这一类的标准负载均衡解决方案，能够很好地将负载分配到不同的MySQL服务器上。当使用一主库多备库的架构时，可能会造成一些浪费，因为本质上它会复制大量不必要的重复数据。例如，对于一台主库和10台备库，会有11份数据复制，并且这11台服务器的缓存中存储了大部分相同的数据，这和在主服务器上有11路RAID1类似，这不是一种经济的硬件使用方式，但这种复制架构却很常见。（3）备份。对于备份来说，复制是一项很有意义的技术补充，但复制既不是备份也不能取代备份。一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好地解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全可靠。（4）高可用性和故障切换。复制能够帮助应用程序避免MySQL单点失败，因为数据都是相同的，所以当主数据库服务器挂掉后，可以指定一台从数据库服务器充当主服务器继续保证服务运行，这表明数据具有一致性（如果当插入主数据库时挂掉，可能不一致，因为同步也需要时间）。一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间。复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这些开销也是必要的。此外，每个备库也会对主库增加一些负载（如网络I&#x2F;O开销），尤其当备库请求从主库读取旧的二进制文件时，可能会造成更高的I&#x2F;O开销，而锁竞争也可能阻碍事务的提交，还有如果是从一个高吞吐量（如5 000或更高的TPS）的主库上复制到多个备库，唤醒多个复制线程发送事件的开销将会增加。（5）MySQL升级测试。这种做法比较普遍，使用一个更高版本的MySQL作为备库，保证在升级全部实例前查询能够在备库按照预期执行。</p>
<h3 id="7-1-3-复制的格式"><a href="#7-1-3-复制的格式" class="headerlink" title="7.1.3 复制的格式"></a>7.1.3 复制的格式</h3><p>在MySQL复制中，有一个被称为复制格式（Replication Formats）的概念，复制格式有些时候也称为复制模式。<strong>复制模式分为三种：</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573299657-75a2e4e3-b242-40f3-89c3-9399431cb422.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue0f2693c&originHeight=236&originWidth=485&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u74d7e563-e745-4eda-9fcd-954bd724d2f&title=">（1）基于语句的复制（Statement-Based Replication，SBR）模式。MySQL中基于语句的复制（也称为逻辑复制）模式早在MySQL 3.23版本中就存在，就是靠复制SQL语句到目标端执行的方式，也就是说，二进制日志文件中保存的就是执行的SQL语句，在MySQL 5.1.4及之前的版本，只有这一种日志记录方式。（2）基于行的复制（Row-Based Replication，RBR）模式。从MySQL 5.1.4版本开始，MySQL又引入了全新的基于行粒度的日志记录格式，这种技术就是关注表中发生变化的记录，而非以前的照抄二进制日志模式。在这种格式下，当将事件写入二进制日志文件时，记录的是变更的记录行的信息。（3）混合记录（Mixed-Based Replication，MBR）模式。到后来的MySQL 5.1.8版本，MySQL又近了一步，在将事件记入二进制日志时，MySQL服务器能够根据需要动态修改日志的格式，就是所谓的混合模式。大家注意混合记录是一种模式，而不是一种格式。在这种模式下，还是会默认选择基于语句的格式进行记录，只有在需要的场景下才会自动切换成基于行的格式进行记录，具体选择何种格式，要看当前执行的语句，以及操作对象所使用的存储引擎而定。就像前面说的，MySQL的复制原理主要就是依赖于二进制日志。与复制模式一致，<strong>二进制日志在记录事件时也支持三种格式，</strong>由binlog_format参数控制。（1）基于语句记录（Statement-Based Logging，SBL），对应的参数值为statement。（2）基于行格式记录（Row-Based Logging，RBL），对应的参数值为row。（3）混合模式记录（Mixed-Based Logging，MBL），对应的参数值为mixed。在MySQL 5.6版本中，尽管默认的日志记录格式是基于语句，但是一般我们都会手动将其改为混合模式（当然，不是所有人都能随意更改的，只有拥有SUPER权限的用户才可以修改系统变量）。日志格式是由binnlog_format系统参数控制的，在MySQL服务运行期间可以动态地对binlog_format系统变量进行修改，而且既可以在会话级进行设置，也可以指定为全局有效。<strong>例</strong>在配置文件中设置：binlog_format&#x3D;”statement” #binlog_format&#x3D;”row” #binlog_format&#x3D;”mixed” 在运行时动态修改binlog的格式：Mysql&gt; set session binlog_format&#x3D;”statement”不同的日志记录格式都有其适用的场合，各有利弊，明确SBR或RBR的特点及其优势很有必要，下面简单描述它们各自的特点，以帮助读者找到最佳应用场景。<strong>1.基于语句的复制模式</strong>在基于语句的复制（SBR）模式下，主数据库会记录那些造成数据更改的SQL语句，当从数据库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。这种方式既有好处，也有缺点。</p>
<table>
<thead>
<tr>
<th>SBR的优点</th>
<th>①最明显的优点是实现相当简单。从理论上讲，简单地记录和执行这些语句，能够让主从数据库保持同步，目前这个技术较为成熟，自3.23版本开始提供对这种记录格式的支持。②二进制日志里的事件更加紧凑，生成日志少，特别是对于大量更新及删除的操作，所以相对而言，基于语句的模式不会使用太多带宽，一条更新好几兆数据的语句在二进制日志里可能只占几十个字节。③mysqlbinlog工具（第1章和第3章介绍过，本章多处也会提到）是使用基于语句的日志的最佳工具，由于能够记录下数据库做过的所有变更操作，日志可用于数据库审计（参见4.3.4节）。</th>
</tr>
</thead>
<tbody><tr>
<td>SBR的缺点</td>
<td>①存在数据安全隐患。主数据库中产生的修改操作（含INSERT、DELETE、UPDATE、REPLACE）并不是都能通过基于语句方式完整地复制到从数据库中，对于不确定的行为在基于语句复制时，很难确保从数据库会执行并获得正确的数据，比如同一条SQL在主数据库和从数据库上执行的时间可能会不同，主数据库和从数据库分别执行FOUND_ROWS()、SYSDATE()、UUID()、NOW()这类函数，可能返回不同的结果。如果使用了这些函数，那么语句执行时会抛出下列警告信息（客户端通过SHOW WARNINGS查看）：06489 18:08:54 [Warning] Statement is not safe to log in statement format.②存在一些无法被正确复制的SQL，例如，存储过程和触发器在使用基于语句的复制模式时可能存在问题。③更新必须是串行的，这需要更多的锁。执行INSERT…SELECT语句时需要持有更多行锁（相比RBR而言），UPDATE要扫表（无可用索引的情况下）时需要持有更多行锁（相比RBR而言）。④对于复杂的语句，从数据库执行SQL语句时必须先被评估，也就是语法、词法分析等，而对于基于row格式复制，则从数据库只需要修改具体的记录即可（不必执行跟主数据库端相同的SQL语句，这既是优点也是缺点）。⑤为了避免冲突，数据库对象定义必须拥有唯一键。⑥不是所有的存储引擎都支持这种复制模式，尽管这些存储引擎是包括在MySQL 5.5及之前版本中发行的。</td>
</tr>
</tbody></table>
<p><strong>2.基于行的复制模式</strong>基于行的复制（RBR）模式会将实际数据记录在二进制日志中，最大的好处是可以正确地复制每一行。</p>
<table>
<thead>
<tr>
<th>RBR的优点</th>
<th>①所有修改都能被安全地复制到从数据库中。对于像GRANT&#x2F;REVOKE这类操作，以及存储过程、触发器、视图等数据库对象的维护操作，会被使用SBR模式复制到从数据库端。对于CREATE TABLE…SELECT这类DDL+DML的操作，CREATE创建对象部分使用SBR模式复制。②主数据库端执行修改操作时，仅需极少的锁持有，因此可获得更高的并发性能。③从数据库端执行INSERT&#x2F;UPDATE&#x2F;DELETE时也仅需持有少量锁, 使用基于行的复制模式能够更高效地复制数据。由于无须重放更新主库数据的SQL，重放一些SQL的代价可能会很高。例如，下面有一个SQL将数据从一个大表中汇总到小表：mysql&gt; INSERT INTO summary_table(col1, co12, sum_co13)     一&gt;SELECT col1, co12, sum(co13)     一&gt;FROM enormous_table     一&gt;GROUP  BY col1, co12; 想象一下，如果表enormous_table的列col1和col2有三种组合，这个查询可能在源表上扫描多次，但最终只在目标表上产生三行数据。但使用基于行的复制方式，在从数据库库上开销会小很多。在这种情况下，基于行的复制模式更高效。</th>
</tr>
</thead>
<tbody><tr>
<td>RBR的缺点</td>
<td>①RBR可能会生成更多的日志，比如执行DML语句，基于语句格式记录日志的话，仅记录所执行的SQL语句，相比之下，基于行格式记录日志的话，会将所有变化了的行记录到二进制日志文件中，如果语句触发的记录变得特别多，即使执行的操作随后被回滚，其生成的二进制日志也会非常多。这同样也意味着创建备份及恢复需要更多的时间，以及二进制日志会被更长时间加锁以写数据，也可能还会带来额外的并发性能上的问题。例如，下面这条语句使用基于语句的复制方式代价会小很多：mysql&gt; UPDATE enormous_table SET col1&#x3D;0;由于这条语句做了全表更新，使用基于行的复制开销会很大，因为每行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大，并且会给主数据库上记录日志和复制增加额外的负载，更慢的日志记录则会降低并发度。②如果有BLOB值，则需要花费比基于语句格式日志更长的时间，因为BLOB列的值是被记录的，而不是语句生成的。③不能通过分析日志来获取曾经执行过的语句（不能做语句级的审计），只能通过mysqlbinlog命令看到哪些数据被修改了。④对于非事务存储引擎，比如MyISAM表对象，从数据库端INSERT操作时，使用RBR模式要比使用SBR模式持有更强的锁定，也就是说，使用RGB模式在从数据库端没有并行插入的概念。</td>
</tr>
</tbody></table>
<p><strong>3.哪种模式更优</strong>我们已经讨论了这两种复制模式的优点和缺点，那么在实际应用中哪种模式更优呢？由于没有哪种模式对所有情况都是完美的，所以MySQL能够在这两种复制模式间动态切换，默认情况下使用的是基于语句的复制模式，但如果发现语句无法被正确地复制，其就会切换到基于行的复制模式，此外，其还可以根据需要设置会话级别的变量binlog_format，控制二进制日志格式。以上描述尽管内容枯燥了一些，但信息量很大，下面用最简单的例子描述SBR和RBR应用在不同场景时的表现。<strong>例</strong>假设有多条复杂的SQL语句，在主数据库端执行了一个多小时，最终才成功修改了一条记录。采用基于语句的复制模式，二进制日志中记录的事件就是这条SQL语句，那么这个记录被复制到从数据库节点后，也需要至少一个多小时才能艰难地执行。若采用基于行的复制模式会怎么样呢？不管主数据库节点执行了多长时间，最终变更的记录只有一条，那么二进制中记录的事件就是这一条记录的更新，日志被同步到从数据库节点后，相信秒速就被执行完了。<strong>例</strong>假设有条简单的SQL语句，在主数据库节点执行时向库中插入了一千多万条记录。若采用基于行复制模式，由这一千万条记录生成的二进制日志数量相当庞大，从数据库要全部接收完，而后还得花费相当长的时间慢慢同步。若是采用基于语句的复制模式，则二进制日志文件中记录的事件就是该条SQL语句，相对节省时间，从数据库节点也可以很快接收完，尽管在应用这条语句时，执行的时间依然不短（因其数据量大，这一步无法提速），但是总体时间还是基于语句的复制模式更快。<strong>在多数场景下，使用混合复制模式能够提供不错的数据完整性保护和性能。</strong>对于混合复制模式，默认情况下它依然是基于语句记录事件。应对例一的场景时，其表现跟基于语句的复制模式没有区别，那么混合复制模式的应用场景究竟是什么呢？简单理解的话，它只是当遇到SBR模式记录事件，存在数据安全隐患时，自动将日志记录格式变更为基于行格式记录，也就是RBR模式。所以没有万能的参数，没有最佳设置，每种模式都有它适合的场景，参数没有相对的好坏，只有能不能把它用好，因此深入了解不同模式的原理和特点就显得非常有必要。SBR&#x2F;RBR该怎么选，哪种模式最好，这取决于要怎么用。此外，MySQL复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备份库，但反过来，将老版本作为新版本服务器的备份库通常是不可行的，因为它可能无法解析新版本所采用的新的特性或语法，而所使用的二进制文件的格式也可能不相同。例如，不能从MySQL 5.1复制到MySQL 4.0。在进行大的版本升级前，如从4.1升级到5.0，或从5.1升级到5.5，最好先对复制的设置进行测试，但对于小版本号升级，如从5.1.51升级到5.1.58，则通常是兼容的。</p>
<h3 id="7-1-4-复制相关的文件类型"><a href="#7-1-4-复制相关的文件类型" class="headerlink" title="7.1.4 复制相关的文件类型"></a>7.1.4 复制相关的文件类型</h3><p>3.2.3节中介绍过中继日志文件和复制状态文件，MySQL数据库中有二进制日志文件，用于记录所执行的变更事件，复制特性正是基于这类文件实现“复制”操作。从数据库（Slaves）端有两个线程，其中I&#x2F;O线程用于接收和保存二进制日志，SQL线程用于应用这些日志，这样听起来分工明确、合理且有效，不过我们应该有这样的疑问：I&#x2F;O线程将接收的二进制日志保存在了哪里呢？本地的二进制日志文件看起来是无法直接保存的，因为从数据库端也是MySQL服务器，也有可能产生自己的操作事件，这类事件默认是肯定要写到二进制日志文件中，若将收到的来自主数据库端的事件也写入本地二进制日志文件中，尽管技术上一定可以实现，但是会给SQL线程解析日志时造成很大难度。MySQL数据库在处理这个问题时的思路是：既然来自于主数据库的二进制文件在从数据库没有现成的地方保存（不能保存在从数据库的二进制文件中），那就专门给它设置一个地方保存，于是就有了中继日志（Relay Log）。<strong>Oracle的Standby</strong>对于熟悉Oracle的读者，这听起来像Standby Redolog Files，类似于Oracle Dataguard特性中的逻辑Standby，而非物理Standby的原因。<strong>1.中继日志文件</strong>从文件类型上来看，中继日志文件和二进制日志文件极为相似，两者唯一的区别是逻辑上的，即<strong>二进制日志文件用于保存节点自身产生的事件，而中继日志文件则是保存接收来自其他节点的事件（也是二进制格式的）。</strong>中继日志文件拥有与二进制日志文件相同的结构，当然也可以通过mysqlbinlog命令解析。在默认情况下，中继日志文件按照[host_name]-relay-bin.[nnnnn]的命名规则保存在mysql的data目录下，其中[host_name]表示主机名，[nnnn]表示递增序列，从000001开始计数。跟二进制日志文件一样，中继日志文件也有一个日志的索引文件，中继日志索引文件默认名为[host_name]-relay-bin.index，同样保存在msql的data目录下。中继日志文件和日志文件索引的保存路径可以通过–relay-log和–relay-log-index参数进行自定义。需要注意的是，如果从数据库节点使用默认中继文件的命名规则（就是说没有修改过–relay-<em>参数的参数值），那么一旦修改了从数据库节点所在服务器的主机名，复制环境也会受到影响，复制进程会抛出“Failed to open the relay log” “Could not find target log during relay log initialization”等错误信息（参见BUG#2122），因此对于主机名可能发生修改的服务器，建议在创建从数据库节点之初，就先使用–relay-log和–relay-log-index参数自定义中继日志文件的文件名。修改配置文件my.ini，可以在[mysqld]块中增加如下两行内容：relay-log &#x3D; ..&#x2F;binlog&#x2F;relay-binrelay-log-index &#x3D; ..&#x2F;binlog&#x2F;relay-bin.index如果是在部署好的复制环境中遇到了从数据库节点主机名修改的情况，那么临时的解决方案可以通过修改中继日志、相关日志文件名的方式解决，比如将文件名中主机名部分修改为新的主机名即可。注意只需要修改中继日志索引文件名称即可，中继日志文件不要修改，不然会导致与索引文件中的记录不符，导致另外的错误。从数据库节点会在满足下列条件时触发创建新的中继日志文件，并更新相关的索引文件。（1）启动Slaves节点I&#x2F;O线程时。（2）执行日志刷新命令，比如FLUSH LOGS或mysqladmin flush-logs等。（3）中继日志文件达到指定最大值，有下列两种情况：如果max_relay_log_size参数值大于0，则日志文件超过该值后即会重建；如果max_relay_log_size参数值0，则通过max_binlog_size确定单个Relay日志文件的最大值。中继日志文件的管理可以完全交由从数据库节点的SQL线程来维护，它会自动删除无用的中继日志文件，至于如何删除及何时删除，并没有明确的机制，SQL线程会自己搞定。<strong>2.状态文件</strong>除了中继日志文件之外，<strong>复制环境中的从数据库节点还会创建两个复制环境的状态文件，即master.info和relay-log.info，</strong>这两个文件默认都保存在mysql的data目录下，用户也可以通过–master-info-file和–relay-log-info-file参数修改文件的名称和保存路径。这两个状态文件中保存的信息类似于SHOW SLAVE STATUS中显示的信息，当然没有SHOW SLAVE STATUS语句中显示得全面，而且更为重要的是，SHOW SLAVE STATUS语句只是显示信息，而master.info和relay-log.info在启动时都有重要作用，从数据库需要读取这里两个文件中的信息，以确定从什么位置继续处理日志。（1）master.info：顾名思义，当然是保存复制环境中连接主数据库节点的配置信息，比如说从数据库节点连接主数据库使用的用户名&#x2F;密码&#x2F;IP端口等均在其中，格式为纯文本（每行一个值）。随着版本的增长，这个文件中保存的内容也越来越丰富。在MySQL 5.6版本之前，这些信息日志总是保存在master.info文件中，默认在MySQL的data路径下，而进入MySQL 5.6版本后，数据库管理员也可以选择将这些信息保存在mysql.slave_master_info表对象中。（2）relay-log.info：保存处理进度及中继日志文件的位置, 不要删除这个文件，否则在从数据库重启后将无法获知从哪个位置开始复制，可能会导致重放已经执行过的语句。与前面的日志信息相似，在MySQL 5.6版本之前，其也都是保存在文本格式中，位于data路径下的relay-log.info文件中，不过从MySQL 5.6版本开始，我们也可以将这个信息保存在mysql.slave_relay_log_info表对象中。注意为了保证宕机后表对象数据的安全性和一致性，前面提到的两个表对象最好使用支持事务的存储引擎，尤其是对master.info文件需要特别保护，因为其中保存的有复制环境的配置及连接主库的用户名和密码等重要信息。之前默认的都是MyISAM存储引擎，不过从MySQL 5.6.6版本开始，这两个表对象就会是InnoDB存储引擎。不管是作为文本格式文件还是表对象，主数据库信息和中继日志信息都不要手动去编辑或修改，否则极有可能导致出现不可预料的错误。需要注意的是，relay-log.info中的内容与SHOW SLAVE STATUS语句显示的内容有可能不一致，通常是因为relay-log.info未被及时更新。master.info和relay-log.info两个文件的更新也是有分工的，I&#x2F;O线程负责更新master.info文件，SQL线程负责更新relay-log.info文件。通过MySQL服务处于启动状态时，可以通过SHOW SLAVE STATUS语句查看相关状态，只有当MySQL服务处于关闭状态时，才会通过这两个文件查看其状态。<strong>3.其他文件</strong>*</em>除了二进制日志文件和中继日志文件，其实还有其他的文件会被用到，比如mysql-bin.index和mysql-relay-bin-index。**在默认情况下不同版本的MySQL可能将这些文件放到不同的目录里，其大多取决于具体的配置选项，可能在data目录或者包含服务器.pid文件的目录下。mysql-bin.index：当在服务器上开启二进制日志时，同时会生成一个和二进制日志同名的但以后缀为.index的文件，该文件用于记录磁盘上的二进制日志文件。这里的“index”并不是指表的索引，而是说这个文件的每一行都包含了二进制文件的文件名。这个文件并不是多余的，MySQL依赖于这个文件，除非在这个文件里有记录，否则MySQL识别不了二进制日志文件。mysql-relay-bin-index：这个文件是中继日志的索引文件，和mysql-bin.index的作用类似。</p>
<h2 id="7-2-配置复制"><a href="#7-2-配置复制" class="headerlink" title="7.2 配置复制"></a>7.2 配置复制</h2><h3 id="7-2-1-配置复制"><a href="#7-2-1-配置复制" class="headerlink" title="7.2.1 配置复制"></a>7.2.1 配置复制</h3><p>为MySQL服务器配置复制非常简单。最基本的场景是新安装的主数据库和从数据库，<strong>总的来说分为以下几个步骤。</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573329991-c15840b1-811a-4f26-9a7d-df3ca7ce6f62.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u7d201c52&originHeight=208&originWidth=480&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f7a2087-9616-40e4-a6da-69ba73a2712&title=">这里假定大部分配置采用默认值即可，在主数据库和从数据库都是全新安装并且拥有同样的数据。现实中由于场景不同，其基本的步骤可能有所差异。接下来将展示如何配置复制：系统使用Windows操作系统，假设有服务器Server1 （IP地址10.210.69.228）和服务器Server2（IP地址10.210.69.237），我们将解释如何为一个已经运行的服务器配置从数据库，并探讨推荐的复制配置。</p>
<h3 id="7-2-2-创建复制账号"><a href="#7-2-2-创建复制账号" class="headerlink" title="7.2.2 创建复制账号"></a>7.2.2 创建复制账号</h3><p>MySQL会赋予一些特殊的权限给复制线程。在从数据库运行的I&#x2F;O线程会建立一个到主数据库的TCP&#x2F;IP连接，这意味着必须在主数据库创建一个用户（创建用户的方法参见4.3.2节），并赋予其合适的权限。从数据库I&#x2F;O线程以该用户名连接到主数据库并读取其二进制日志。Windows通过如下语句创建用户账号，操作界面如图7-3所示。mysql&gt;grant replication slave on <em>.</em> to ‘slave_user‘@’10.210.69.237’ identified by ‘12345’ ;<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338647-2b678428-50b7-4de5-9b2b-a62a75900d5f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ufb1e60d7&originHeight=50&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u444856ef-3eac-4f3c-b306-9526e7889ea&title=">图7-3 创建用户账号在主数据库创建该账号slave_user，在从数据库用root账号。注意我们把这个账户限制在本地网络，因为这是一个特权账号（尽管该账号无法执行select或修改数据，但仍然能从二进制日志中获得一些数据）。这里有一点需要说明，复制账户事实上只需要有主数据库上的REPLICATION SLAVE权限，并不一定需要每一端服务器都有REPLICATION CLIENT权限，那为什么要给主数据库、从数据库都赋予这两种权限呢？有两个原因：一是用来监视和管理复制的账号需要REPLICATION CLIENT权限，并且针对这两种目的使用同一个账号更加容易（而不是为某个目的单独创建一个账号）；二是如果在主数据库上建立了账号，然后从主数据库将数据克隆到从数据库上时，从数据库也就设置好了（变成主数据库所需要的配置），这样后续有需要可以方便地交换主、从数据库的角色。可以用flush privileges语句来刷新权限操作界面，如图7-4所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338941-5c430d9d-8596-42c7-935d-4eee649722bc.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ua9b9d750&originHeight=58&originWidth=442&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3ae27434-4992-4258-a512-7ef9c144a00&title=">图7-4 刷新权限然后查看是否配置成功，使用select user,host from mysql.user语句查询状态，操作界面如图7-5所示，图中可以看到10.210.69.237（也就是从数据库）有了访问slave_user的权限。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338609-6ae513e7-b27d-4aee-85aa-3139871e0d59.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u88e4d2e4&originHeight=242&originWidth=474&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u662ef947-40b8-41bb-b172-95d672c195c&title=">图7-5 查询配置结果</p>
<h3 id="7-2-3-配置主数据库和从数据库"><a href="#7-2-3-配置主数据库和从数据库" class="headerlink" title="7.2.3 配置主数据库和从数据库"></a>7.2.3 配置主数据库和从数据库</h3><p>下一步需要在主库上开启一些设置，假设主库是服务器serverl，需要打开二进制日志并指定一个独一无二的服务器ID（server ID）。<strong>1.主数据库的配置</strong>在主数据库的my.ini文件中增加或修改如下内容，修改后的配置文件使用写字板打开，如图7-6所示。server-id&#x3D;1log_bin&#x3D;master-binlog_bin-index&#x3D;master-bin.index<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573347962-328ac465-ce00-49fb-9ab2-bb4cfeb9fc08.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u06c41a59&originHeight=640&originWidth=886&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0bde01f9-99b1-48ec-9693-4926a633b37&title=">图7-6 my.ini添加二进制日志路径结果必须明确地指定唯一的服务器ID，默认服务器ID通常为1（这和版本相关，一些MySQL版本根本不允许使用这个值）。使用默认值可能会导致和其他服务器的ID冲突，因此这里我们选择10作为服务器ID。通用的做法是使用服务器IP地址的末8位，或者选择一些有意义的约定，但要保证它是不变且唯一的（例如，服务器都在一个子网里）。如果之前没有在MySQL的配置文件中指定log-bin选项，就需要重新启动MySQL。为了确认二进制日志文件是否已经在主库上创建，可使用SHOW MASTER STATUS命令检查输出是否与如下的一致。MySQL会为文件名增加一些数字，所以这里看到的文件名和定义的会有点不一样，操作界面如图7-7所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348009-999a77bb-f080-455c-9c88-45d51c930486.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9cc7730c&originHeight=57&originWidth=395&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6b4963cd-1c3e-465e-b247-fefb07577d3&title=">图7-7 查看主服务器状态注意图7-7中显示为Empty，是因为二进制日志路径并没有设置正确或者并未重启数据库，可以使用show variables like ‘%log_bin’查看二进制日志状态，操作界面如图7-8所示，可以看到log_bin是OFF，此时需要重启计算机，或者重启数据库并刷新权限，再次查询界面，如图7-9所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348005-17d551a8-cd40-4502-aedc-bb3146cfbfc4.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue170527f&originHeight=252&originWidth=487&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2b0b6e9f-fe64-41ef-b273-ea5a6359ffb&title=">图7-8 查看二进制日志状态<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573347934-72f4ccd8-24d5-466b-8718-2998f7597375.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u4be0221b&originHeight=161&originWidth=430&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9a2212f8-17b7-46b4-afb6-6045b6d5497&title=">图7-9 查看刷新后的二进制日志状态之后使用show binary logs命令查询二进制日志具体信息，操作界面如图7-10所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573349559-52c84b88-dc3d-42cf-b85f-d7c2327f0c34.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=udcd59cd6&originHeight=335&originWidth=460&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f951161-a752-4d5f-9988-35c65ab0fc6&title=">图7-10 查看二进制日志具体信息此时在mysql文件夹下产生二进制日志文件，如图7-11所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348641-dede61c9-4036-4fb6-bff2-ef4fcb895a22.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0d5c2c08&originHeight=278&originWidth=799&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6ef58218-dac4-4010-832f-d6f59f4475a&title=">图7-11 二进制日志文件的位置配置好二进制日志文件后使用show master status命令查看主服务器状态，操作界面如图7-12所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348878-f5685775-a427-49c0-a6d2-215333cc4e8f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u5f287508&originHeight=151&originWidth=934&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u27266cae-1657-4d7f-baec-6df06b6a774&title=">图7-12 查看主服务器状态<strong>2.从数据库的配置</strong>从数据库上也需要在my.ini中增加类似的配置，并且同样需要重启服务器，如图7-13所示是配置完my.ini的效果。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348833-a6769b18-be9c-4342-b85a-4f6d2188990d.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9e060a1c&originHeight=508&originWidth=769&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u641694f4-eefc-4b55-a334-6cb8ba146fb&title=">图7-13 从数据库my.ini配置其中一些选项我们只是显式地列出了默认值，事实上只有server_id是必需的。默认情况下，它是根据机器名来命名的，但如果机器名发生变化可能会出现问题。为了简便，可以将主数据库和从数据库上的log-bin设置为相同的值，当然也可以设置成别的值。配置选项relay_log为指定中继日志的位置和命名。<strong>3.一主多从的配置****log_slave_updates选项可以让从数据库变成其他服务器的主数据库，</strong>也就是有一个主数据库，两个从数据库，从数据库1又是从数据库2的主数据库。在设置该选项后，MySQL会将其执行过的事件记录到它自己的二进制日志中，这样它的从数据库就可以从其日志中检索并执行事件。在这种场景下，主数据库将数据更新事件写入二进制日志，从数据库1提取并执行这个事件。这时候一个事件的生命周期应该已经结束了，但由于设置了log_slave_updates，从数据库1会将这个事件写到它自己的二进制日志中，这样从数据库2就可以将事件提取到它的中继日志中并执行。这意味着作为源服务器的主数据库可以将其数据变化传递给没有与其直接相连的从数据库上。默认情况下这个选项是被打开的，这样在连接到从数据库时就不需要重启服务器。</p>
<h3 id="7-2-4-启动复制"><a href="#7-2-4-启动复制" class="headerlink" title="7.2.4 启动复制"></a>7.2.4 启动复制</h3><p>配置完成后，下一步是告诉<strong>从数据库如何连接到主数据库并重放其二进制日志，</strong>这一步不通过修改my.ini来配置，而是<strong>使用CHANGE MASTER TO语句，</strong>该语句完全替代了my.ini中相应的设置，并且允许指向别的主数据库时无须重启从数据库。下面是启动复制的基本语句。change master to master_host&#x3D;’10.210.69.228’,master_user&#x3D;’slave_user’,master_password&#x3D;’12345’,port&#x3D;3307,master_logfile&#x3D;master_bin.000010,master_log_pos&#x3D;2148当执行完这条语句后，使用start slave语句启动从数据库，可以通过SHOW SLAVE STATUS\G语句来检查复制是否正确执行，如图7-14所示。Slave_IO_Running和Slave_SQL_Running这两行为YES时表示配置成功，从输出可以看出I&#x2F;O线程和SQL线程都已经开始运行，Seconds_Behind_Master的值也不再为NULL。I&#x2F;O线程正在等待从主数据库传递过来的事件，这意味着I&#x2F;O线程已经读取了主数据库所有的事件。日志位置发生了变化，表明已经从主数据库获取和执行了一些事件。如果在主数据库上做一些数据更新，就会看到从数据库的文件或者日志位置都可能会增加，备库中的数据同样会随之更新。我们还可以使用SHOW PROCESSLIST语句从线程列表中看到复制线程（6.2.2节中使用线程查看用于数据库性能查看），在主数据库上可以看到由从数据库I&#x2F;O线程向主数据库发起的连接，如图7-15所示。同样，在从数据库也可以看到相应的线程。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356668-32b265aa-b1a6-4b74-87e1-c6e66c8ec590.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1223e575&originHeight=1261&originWidth=909&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucbc8f1ee-82d3-4025-a10f-6bd824a57dd&title=">图7-14 查看SLAVE STATUS<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356630-ef35905d-32bc-48b4-a6b6-62ace57d41da.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u27a44d28&originHeight=421&originWidth=779&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub4fced5e-c3d4-4aa0-9ce9-a7802376548&title=">图7-15 查看PROCESSLIST然后进行主从验证，在主数据库创建数据库和一张表，查看从数据库中是否与主数据库同步，也有了刚创建的数据库和表。在主数据库创建一个名为test的数据库，在该数据库下创建一个名为person的表，如图7-16所示。在从数据库中查看是否存在相应的库和表，查询结果如图7-17所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356664-35c05a20-5c39-4005-aa2d-63a1a4b13fd3.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u69d4a760&originHeight=300&originWidth=413&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47ad0541-0d3b-4f28-940d-653f9034a36&title=">图7-16 主数据库创建库和表<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356681-6a698e0d-e551-4123-81e1-dd9fca18e32f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8ed701e2&originHeight=445&originWidth=262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb2af69a-42f2-4ac9-a025-9babeef3692&title=">图7-17 在从数据库中查看对应的库和表</p>
<h3 id="7-2-5-从另一个服务器开始复制"><a href="#7-2-5-从另一个服务器开始复制" class="headerlink" title="7.2.5 从另一个服务器开始复制"></a>7.2.5 从另一个服务器开始复制</h3><p>前面的设置都是假定主数据库、从数据库均为刚刚安装好且都是默认的数据，也就是说两台服务器上数据相同，并且知道当前主数据库的二进制日志，这不是典型的案例。大多数情况下是有一个已经运行了一段时间的主数据库，然后用一台新安装的从数据库与之同步，此时这台从数据库还没有数据。有几种方法来初始化从数据库或者从其他服务器复制数据到从数据库（在从数据库的主机上安装MySQL，注意从数据库的版本不能低于主数据库），包括从主数据库复制数据、从另外一台从数据库复制数据，以及使用最近的一次备份来启动从数据库，都需要获得以下三个条件来让主数据库和从数据库保持同步。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573365937-273a3ad9-d2f0-4869-b755-55e5797f473a.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0e148467&originHeight=515&originWidth=603&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua20137a6-aa87-4b1a-8c95-85b0c485cec&title="><strong>1.使用主数据库备份</strong>（1）使用冷备份。最基本的方法是关闭主数据库，把数据复制到从数据库。重启主数据库后，会使用一个新的二进制日志文件，在从数据库通过执行CHANGE MASTER TO指向这个文件的起始处。这个方法明显的缺点是在复制数据时需要关闭主数据库。（2）使用热备份。如果仅使用了MyISAM表，可以在主数据库运行时使用mysqlhotcopy或rsync来复制数据到从数据库。（3）使用mysqldump。如果只包含InnoDB表，那么可以使用mysqldump来转储主数据库数据并将其加载到从数据库，然后设置相应的二进制日志坐标。Mysql&gt;mysqldump –single-transaction –all-databases –master-data&#x3D;1–host&#x3D;server1|mysql –host&#x3D;server2选项–single-transaction使得转储的数据为事务开始前的数据，如果使用的是非事务型表，可以使用–lock-all-tables选项来获得所有表的一致性转储。（4）使用快照或者备份。只要知道对应的二进制日志坐标，就可以使用主数据库的快照或者备份来初始化从数据库（如果使用备份，需要确保从备份的时间点开始的主数据库二进制日志都要存在），只需要把备份或快照恢复到从数据库，然后使用CHANGE MASTER TO指定二进制日志的坐标，也可以使用LVM快照、SAN快照及EBS快照。<strong>2.使用另外的从数据库</strong>我们可以使用任何一种复制技术来从任意一台从数据库上将数据复制到另外一台服务器，但是如果使用的是mysqldump的–master-data选项就会不起作用。此外，不能使用SHOW MASTER STATUS来获得主数据库的二进制日志坐标，而是要在获取快照时使用SHOW SLAVE STATUS来获取从数据库在主数据库上的执行位置。使用另外的从数据库进行数据复制最大的缺点是，如果这台从数据库的数据已经和主数据库不同步，复制得到的就是脏数据。<strong>3.使用Percona Xtrabackup</strong>Percona Xtrabackup是一款开源的热备份工具，它能够在备份时不阻塞服务器的操作，因此可以在不影响主数据库的情况下设置从数据库，其可以通过克隆主数据库或另一个已存在的从数据库的方式来建立从数据库。如果是从主数据库获得备份，可以从xtrabackup_binlog_pos_innodb文件中获得复制开始的位置；如果是从另外的从数据库获得备份，可以从xtrabackup_slave_info文件中获得复制开始的位置。不建议使用LOAD DATA FROM MASTER命令或LOAD TABLE FROM MASTER命令进行数据复制。不管最后选择哪种技术，都要能熟练运用，要记录详细的文档或编写脚本，因为可能不止一次需要做这样的事情，甚至当错误发生时也要能够处理。</p>
<h3 id="7-2-6-推荐的复制配置"><a href="#7-2-6-推荐的复制配置" class="headerlink" title="7.2.6 推荐的复制配置"></a>7.2.6 推荐的复制配置</h3><p>有许多参数可以用于控制复制，其中一些会对数据安全和性能产生影响。接下来推荐的一种“安全”的配置，可以最小化问题发生的概率。在主数据库上二进制日志最重要的选项是sync_binlog。Sync_binlog&#x3D;1如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证在服务器崩溃时不会丢失事件。如果禁止该选项，则服务器会少做一些工作，但二进制日志文件可能在服务器崩溃时损坏或丢失信息。在一个不需要作为主数据库的从数据库上，该选项带来了不必要的开销，它只适用于二进制日志，而非中继日志。如果使用InnoDB，我们推荐设置如下选项：Innodb_flush_longs_at_trx_commit #Flush every log writeInnodb_support_xa&#x3D;1 #MySQL5.0 and newer onlyInnodb_safe_binlog #MySQL4.1 only roughly equivalent to innodb_support_xa推荐明确指定二进制日志的名字，以保证二进制日志名字在所有服务器上是一致的，避免因为服务器名的变化导致的日志文件名的变化。如果不指定二进制日志名字，当在服务器间转移文件、复制新的从数据库、转储备份或者其他场景下，可能会导致很多问题。为了避免这些问题，需要给log_bin选项指定一个参数，可以随意地给一个绝对路径，但必须明确地指定基本的命名。Log_bin&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql_bin在备库上，同样推荐开启如下配置选项，为中继日志指定绝对路径。Relay_log&#x3D;&#x2F;path&#x2F;to&#x2F;logs&#x2F;relay_binSkip_slave_startRead_only通过设置relay_log可以避免中继日志文件基于机器名来命名，指定绝对路径可以避免多个MySQL版本中存在的Bug，这些Bug可能会导致中继日志在一个意料外的位置创建。skip_slave_start选项能够阻止从数据库在崩溃后自动启动复制，如果从数据库在崩溃后自动启动并且处于不一致的状态，就可能会导致更多的损坏，最后将不得不把所有数据丢弃，并重新开始配置从库。read_only选项可以阻止大部分用户更改非临时表，除了复制SQL线程和其他拥有超级权限的用户之外，这也是要尽量避免给正常账号授予超级权限的原因之一。即使开启了所有推荐的选项，从数据库仍然可能在崩溃后被中断，默认情况下甚至不会刷新到磁盘，直到MySQL 5.5版本才有选项来控制这种行为。如果正在使用MySQL 5.5版本并且不介意额外的fsync()导致的性能开销，最好设置以下选项：Sync_master_info&#x3D;1Sync_relay_log&#x3D;1Sync_relay_log_info&#x3D;1如果从数据库与主数据库的延迟很大，从数据库的I&#x2F;O线程可能会写很多中继日志文件，SQL线程在重放完一个中继日志中的事件后会尽快将其删除（通过relay_log_purge选项来控制）。但如果延迟非常严重，I&#x2F;O线程可能会把整个磁盘撑满。解决办法是配置relay_log_space_limit变量，如果所有中继日志的大小之和超过这个值，I&#x2F;O线程会停止，等待SQL线程释放磁盘空间。但有一个隐藏的问题，如果从数据库没有从主数据库上获取所有的中继日志，这些日志可能在主库崩溃时丢失。除非磁盘空间真的非常紧张，否则最好让中继日志使用其需要的磁盘空间，这也是为什么没有将relay_log_space_limit列入推荐的配置选项的原因。</p>
<h2 id="7-3-复制管理和维护"><a href="#7-3-复制管理和维护" class="headerlink" title="7.3 复制管理和维护"></a>7.3 复制管理和维护</h2><h3 id="7-3-1-监视复制"><a href="#7-3-1-监视复制" class="headerlink" title="7.3.1 监视复制"></a>7.3.1 监视复制</h3><p>配置复制一般来说不会是需要经常做的工作，除非有很多服务器。但是一旦配置了复制， 不管有多少服务器，监视和管理复制就成为数据库运维一项日常工作。<strong>复制的管理和维护大体有监视复制、测量从数据库延迟、判断主数据库、从数据库是否一致、主数据库重新同步从数据库、改变主数据库等。</strong>复制相关的命令见表7-1。表7-1 复制相关的命令</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Slave start</td>
<td>启动复制线程</td>
</tr>
<tr>
<td>Slave stop</td>
<td>停止复制线程</td>
</tr>
<tr>
<td>Reset slave</td>
<td>重置复制线程</td>
</tr>
<tr>
<td>Show slave status</td>
<td>显示复制线程状态</td>
</tr>
<tr>
<td>Show slave status\g</td>
<td>显示复制线程状态（分行显示）</td>
</tr>
<tr>
<td>Show master status\G</td>
<td>显示主数据库的状态（分行显示）</td>
</tr>
<tr>
<td>Show master logs</td>
<td>显示主数据库日志</td>
</tr>
<tr>
<td>Change master to</td>
<td>动态改变到主数据库的配置</td>
</tr>
<tr>
<td>Show processlistv</td>
<td>显示有哪些线程正在运行</td>
</tr>
</tbody></table>
<p>尽管复制发生在主数据库和从数据库上，但大多数工作是在从数据库上完成的，这也正是最常出问题的地方。是否所有的从数据库都在工作？最慢的从数据库延迟是多大？MySQL本身提供了大量可以回答上述问题的信息，但要实现自动化监视过程及使复制更健壮，还是需要运维人员做更多的工作。在主数据库上，可以使用SHOW MASTER STATUS命令查看当前主数据库的二进制日志位置和配置（参见7.2.1节介绍的“配置主数据库和备库”部分），还可以使用show master logs命令查看主数据库当前有哪些二进制日志是在磁盘上的，如图7-18所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573392690-9559cff5-1f47-43c0-b135-0a1714b249b7.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9c4eb90c&originHeight=338&originWidth=385&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2eec520e-fc17-4f14-bd3a-90692538511&title=">图7-18 主数据库在磁盘上的二进制文件还可以通过SHOW BINLOG EVENTS命令来查看复制事件，如图7-19所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573392652-f5cca40e-9f68-44f9-b9d3-972ea50ab3c2.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u81034386&originHeight=198&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u49f528be-ede6-42d2-bf7d-e793e03f35f&title=">图7-19 查看复制事件</p>
<h3 id="7-3-2-测量从数据库延迟"><a href="#7-3-2-测量从数据库延迟" class="headerlink" title="7.3.2 测量从数据库延迟"></a>7.3.2 测量从数据库延迟</h3><p>一个比较普遍的问题是如何监视从数据库落后主数据库的延迟有多大。虽然<strong>SHOW SLAVE STATUS输出的Seconds_ behind_ master列理论上显示了从数据库的延时，</strong>但由于各种各样的原因，其并不总是准确的，主要问题如下。（1）从数据库Seconds_ behind_ master的值是通过将服务器当前的时间戳与二进制日志中事件的时间戳相对比得到的，所以只有在执行事件时才能报告延迟。（2）如果从数据库复制线程没有运行，就会报延迟为NULL。（3）一些错误（例如，主从的max_attowed_packet不匹配，或者网络不稳定）可能中断复制或者停止复制线程，但Seconds_behind_master将显示为0而不是显示错误。（4）即使从数据库线程正在运行，从数据库有时候可能无法计算延时，如果发生这种情况，从数据库会报0或者NULL。（5）一个大事务可能会导致延迟波动，例如，有一个事务更新数据长达一个小时，最后提交，这条更新将比它实际发生时间要晚一个小时才被记录到二进制日志中。当从数据库执行这条语句时，会临时地报告从数据库延迟为一个小时，然后又很快变成0。（6）如果分发主数据库落后了，并且其本身也有已经迫赶上它的从数据库，从数据库的延迟将显示为0，而事实上和源主数据库之间是有延迟的。解决这些问题的办法是忽略Seconds_ behind_ master的值，并使用一些可以直接观察和衡量的方式来监视从数据库延迟，最好的解决办法是使用heartbeat record，这是一个在主数据库上会每秒更新一次的时间戳。为了计算延时，可以直接用从数据库当前的时间戳减去心跳记录的值，这个方法能够解决前面提到的所有问题，这样做另外一个好处是还可以通过时间戳知道从数据库当前的复制状况，包含在Percona Toolkit（1.4.2中介绍过该工具）里的pt-heartbeat脚本是“复制心跳”最流行的一种实现。心跳还有其他好处，记录在二进制日志中的心跳记录拥有许多用途，如在一些很难解决的场景下可以用于灾难恢复。</p>
<h3 id="7-3-3-判断主数据库、从数据库是否一致"><a href="#7-3-3-判断主数据库、从数据库是否一致" class="headerlink" title="7.3.3 判断主数据库、从数据库是否一致"></a>7.3.3 判断主数据库、从数据库是否一致</h3><p>在理想情况下，从数据库和主数据库的数据应该是完全一样的，但事实上从数据库可能发生错误并导致数据不一致，即使没有明显的错误，从数据库同样可能因为MySQL自身的特性导致数据不一致，如MySQL的Bug、网络中断、服务器崩溃等非正常关闭或者其他一些错误。按照经验来看，主从一致应该是一种规范，而不是例外，也就是说，<strong>检查主从一致性应该是运维的一个日常工作，</strong>特别是当使用从数据库来做备份时尤为重要，因为不可能从一个已经损坏的从数据库里获得备份数据。MySQL并没有内建的方法来比较一台服务器与别的服务器的数据是否相同，它提供了一些组件来为表和数据生成校验值，如CHECKSUM TABLE，但当复制正在进行时，这种方法是不可行的。Percona Toolkit里的pt-table-checksum能够解决上述几个问题（适应于linux系统，通过操作理解，不难在Windows中手工进行），其主要特性是用于确认从数据库与主数据库的数据是否一致。其工作方式是<strong>通过在主数据库上执行INSERT. SELECT查询，这些查询对数据进行校验并将结果插入到一个表中，这些语句通过复制传递到从数据库，并在从数据库执行一遍，然后可以比较主从上的结果是否一样</strong>。由于该方法是通过复制工作的，它能够给出一致的结果而无须同时把主从上的表都锁上。通常情况下可以在主数据库上运行该工具，参数如下：pt-table-checksum –replicate&#x3D;test.checksum 该命令将检查所有的表，并将结果插入test.checksum表中。当查询在从数据库执行完后，就可以简单地比较主从之间的不同了，pt-table_checksum能够发现服务器所有的从数据库，在每台从数据库上运行查询，并自动地输出结果。pt-table-checksum是唯一能够有效地比较主从一致性的工具。</p>
<h3 id="7-3-4-主数据库重新同步从数据库"><a href="#7-3-4-主数据库重新同步从数据库" class="headerlink" title="7.3.4 主数据库重新同步从数据库"></a>7.3.4 主数据库重新同步从数据库</h3><p>最简单的办法是使用mysyldump转储受影响的数据并重新导入。在整个过程中，如果数据没有发生变化，这种方法会很好。可以在主数据库上简单地锁住表然后进行转储，再等待从数据库赶上主数据库，然后将数据导入从数据库中（需要等待从数据库赶上主数据库，这样就不至于为其他表引入新的不一致，如那些可能通过和失去同步的表做join后进行数据更新的表）。虽然这种方法在许多场景下是可行的，但在一个繁忙的服务器上有可能行不通。其另外一个缺点是在从数据库上通过非复制的方式改变数据。通过复制改变从库数据（通过在主数据库上执行更新）通常是一种安全的技术，因为它避免了竞争条件和其他意料之外的事情。如果表很大或者网络带宽受限，转储和重载数据的代价依然很高。在一个有一百万行的表上对只有一千行不同的数据做转储和重载表是非常浪费资源的。pt-table-sync是Percona Toolkit中的另外一个工具，可以解决该问题，该工具能够高效地查找并解决表之间的不同，它同样通过复制工作，在主数据库上执行查询，在从数据库上重新同步，这样就没有竞争条件。它是结合pt-table-checksum生成的checksum表来工作的，所以只能操作那些已知不同步的表的数据块。但该工具不是在所有场景下都有效，为了正确地同步主数据库和从数据库，该工具要求复制是正常的，否则就无法工作。pt-table-sync设计得很高效，但当数据量非常大时效率还是会很低。比较主数据库和从数据库上1 TB的数据不可避免地会带来额外的工作，尽管如此，在很多场景中，该工具依然能节约大量的时间。</p>
<h3 id="7-3-5-改变主数据库"><a href="#7-3-5-改变主数据库" class="headerlink" title="7.3.5 改变主数据库"></a>7.3.5 改变主数据库</h3><p>数据库运维中或许是为了更迭升级服务器，或许是希望重新分配容量，或许是主数据库出现问题时需要把一台从数据库转换成主数据库。不管出于什么原因，现实中有可能存在改变主数据库的情形，其大体分为计划内的改变或者计划外的改变（如主数据库突然出现了问题）。对于计划内的改变会比较容易（至少比紧急情况下要容易），只需要在从数据库简单地使用CHANGE MASTER TO命令，并指定需要改变的项即可。<strong>1.计划内的改变</strong>把从数据库改变为主数据库在理论上是很简单的，大体有以下步骤：停止向老的主数据库写入；让备库追赶上主数据库；将一台从数据库配置为新的主数据库；将从数据库和写操作指向新的主数据库，然后开启主数据库的写入。更深入一点，下面是大多数配置需要的步骤。（1）停止当前主数据库上的所有写操作，如果可以，最好能将所有的客户端程序关闭（除了复制连接）。为客户端程序建立一个“do not run”这样的类似标记，如果正在使用虚拟IP地址，也可以简单地关闭虚拟IP，然后断开所有的客户端连接，以关闭其打开的事务。（2）通过FLUSH TABLES WITH READ LOCK在主数据库上停止所有活跃的写入，这一步是可选的，也可以在主数据库上设置read_only选项。从这一刻开始，应该禁止向即将被替换的主数据库做任何写入，因为一旦它不是主数据库，写入就意味着数据丢失。注意，即使设置read_only也不会阻止当前已存在的事务继续提交。为了更好地保证这一点，可以“kill”所有打开的事务，这将会真正地结束所有写入。（3）选择一个从数据库作为新的主数据库，并确保它已经完全跟上主数据库（例如，让它执行完所有从主数据库中获得的中继日志）。（4）确保新的主数据库和旧的主数据库的数据是一致的。（5）在新的主数据库上执行STOP SLAVE。（6）在新的主数据库上执行CHANGE MASTER TO MASTER_HOST&#x3D;”，然后再执行RESET SLAVE，使其断开与老的主数据库的连接，并丢弃master.info里记录的信息（如果连接信息记录在my.ini里，会无法正确工作，这也是前面建议不要把复制连接信息写到配置文件里的原因之一）。（7）执行SHOW MASTER STATUS，记录新的主数据库的二进制日志坐标。（8）确保其他从数据库已经追赶上。（9）关闭旧的主数据库。（10）在MySQL 5.1及以上版本中，如果需要，激活新的主数据库上的事件。（11）将客户端连接到新的主数据库。（12）在每台从数据库上执行CHANGE MASTER TO语句，使用之前通过SHOW MASTER STATUS获得的二进制日志坐标，来指向新的主数据库。<strong>从数据库提升为主数据库</strong>当将从数据库提升为主数据库时，要确保从数据库上任何特有的数据库、表和权限已经被移除。此外，可能还需要修改从数据库特有的配置选项，如innodb_flush_log_at_trx_commit选项。同样的，如果是把主数据库降级为从数据库，也要保证进行需要的配置。如果主从的配置相同，就不需要做任何改变。<strong>2.计划外的改变</strong>当主数据库崩溃时，需要提升一台从数据库来代替它，这个过程可能比较烦琐。如果只有一台从数据库，可以直接使用这台从数据库。但如果有超过一台的从数据库，就需要做一些额外的工作。此外，还有潜在的丢失复制事件的问题，可能出现主数据库上已发生的修改还没有更新到它的任何一台从数据库上的情况，甚至还可能有一条语句在主数据库上执行了回滚，但在从数据库上没有回滚，这样从数据库可能超过主数据库的逻辑复制位置。如果能在某一点恢复主数据库的数据，也许就可以取得丢失的语句并手动执行它们。在以下步骤中，需要确保在计算中使用Master_Log_File和Read_Master_Log_Pos的值。以下是对主从拓扑结构中的从数据库进行提升的过程。（1）确定哪台从数据库的数据最新。检查每台从数据库上SHOW SLAVE STATUS命令的输出，选择其中Master_Log_File&#x2F;read_Master Log_Pos的值为最新的那个。（2）所有从数据库执行完所有从崩溃前的旧的主数据库那里获得的中继日志。如果在未完成前修改从数据库的主数据库，它会抛弃剩下的日志事件，从而无法获知该从数据库在什么地方停止。（3）执行前面计划内的改变中的第（5）～（7）步。（4）比较每台从数据库和新的主数据库上的Master_Log_File&#x2F;Read_ Master_Log_Pos的值。（5）执行前面计划内的改变中的第（10）～（12）步。正如7.1节开始我们推荐的，假设已经在所有的从数据库上开启了log_bin和log_stave_updates，可以帮助我们快速将所有的从数据库恢复到一个一致的时间点。</p>

    </div>

    <div>
        
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">------ 本文结束------</div>
    
</div>

        
     </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/Xmind/Xmind%E7%A0%B4%E8%A7%A3/" rel="prev" title="Xmind破解">
      <i class="fa fa-chevron-left"></i> Xmind破解
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlserver%E5%A4%87%E4%BB%BD/" rel="next" title="sqlserver备份">
      sqlserver备份 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 数据库的基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-%E5%87%A0%E4%B8%AA%E6%9C%AF%E8%AF%AD"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 几个术语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 数据库系统的层次结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%BF%90%E8%A1%8C%E4%B8%8E%E7%BB%B4%E6%8A%A4"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.2 数据库系统运行与维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E8%BF%90%E7%BB%B4%E7%AE%A1%E6%8E%A7"><span class="nav-number">1.1.4.</span> <span class="nav-text">1.2.1 数据库系统运维管控</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86%E4%B8%8E%E9%85%8D%E7%BD%AE"><span class="nav-number">2.</span> <span class="nav-text">2. 数据库服务器的管理与配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 MySQL数据库服务器安装</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-Windows%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 Windows下MySQL的安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-ubuntu%E4%B8%8BMySQL%E7%9A%84%E5%AE%89%E8%A3%85"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 ubuntu下MySQL的安装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-%E5%90%AF%E5%8A%A8%E3%80%81%E8%BF%9E%E6%8E%A5%E3%80%81%E6%96%AD%E5%BC%80%E5%92%8C%E5%81%9C%E6%AD%A2MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 启动、连接、断开和停止MySQL服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 MySQL数据库服务器的体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 MySQL数据库服务器的逻辑架构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.2.2 MySQL存储引擎</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-MySQL%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 MySQL服务器配置工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-MySQL%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3. MySQL配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-2-MySQL%E7%9A%84%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.4.2 MySQL的日志文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-%E5%85%A8%E5%B1%80%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.5.2 全局共享内存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86"><span class="nav-number">3.</span> <span class="nav-text">3.MySQL数据库对象管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1"><span class="nav-number">3.1.</span> <span class="nav-text">3.1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 数据库对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-%E6%95%B0%E6%8D%AE%E5%AD%97%E5%85%B8"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 数据字典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E7%AE%A1%E7%90%86%E5%BA%93"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 管理库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 创建数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E6%9F%A5%E7%9C%8B%E5%92%8C%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 查看和选择数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link"><span class="nav-number">3.2.3.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.3 修改数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.2.4 删除数据库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E7%AE%A1%E7%90%86%E8%A1%A8"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 管理表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-MySQL%E8%A1%A8%E4%B8%AD%E6%94%AF%E6%8C%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 MySQL表中支持的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E5%88%9B%E5%BB%BA%E8%A1%A8"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 创建表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E6%9F%A5%E7%9C%8B%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 查看表结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-DESCRIBE%E8%AF%AD%E5%8F%A5%E6%9F%A5%E7%9C%8B%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 DESCRIBE语句查看表定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-%E4%BF%AE%E6%94%B9%E8%A1%A8"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.3.5 修改表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%90%8D"><span class="nav-number">3.3.5.1.</span> <span class="nav-text">修改表名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E5%AD%97%E6%AE%B5"><span class="nav-number">3.3.5.2.</span> <span class="nav-text">增加字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E5%AD%97%E6%AE%B5"><span class="nav-number">3.3.5.3.</span> <span class="nav-text">删除字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%AD%97%E6%AE%B5"><span class="nav-number">3.3.5.4.</span> <span class="nav-text">修改字段</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-6-%E5%A4%8D%E5%88%B6%E8%A1%A8"><span class="nav-number">3.3.6.</span> <span class="nav-text">3.3.6 复制表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-7-%E5%88%A0%E9%99%A4%E8%A1%A8"><span class="nav-number">3.3.7.</span> <span class="nav-text">3.3.7 删除表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E7%AE%A1%E7%90%86%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 管理索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 索引的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%A9%E4%B8%8E%E5%BC%8A"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 索引的利与弊</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99"><span class="nav-number">3.4.3.</span> <span class="nav-text">3.4.2 索引的类型与创建原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E7%B4%A2%E5%BC%95%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.4.4.</span> <span class="nav-text">3.4.3 索引的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99"><span class="nav-number">3.4.5.</span> <span class="nav-text">3.4.4 索引的创建原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-%E5%88%9B%E5%BB%BA%E5%92%8C%E6%9F%A5%E7%9C%8B%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.6.</span> <span class="nav-text">3.4.5 创建和查看索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-6-%E5%88%9B%E5%BB%BA%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.7.</span> <span class="nav-text">3.4.6 创建唯一索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-7-%E5%88%9B%E5%BB%BA%E5%85%A8%E6%96%87%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.8.</span> <span class="nav-text">3.4.7 创建全文索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-8-%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.9.</span> <span class="nav-text">3.4.8 删除索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E7%AE%A1%E7%90%86%E8%A7%86%E5%9B%BE"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 管理视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1 视图的概念和作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2%E8%A7%86%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2视图的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-%E8%A7%86%E5%9B%BE%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.3 视图的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-4-%E5%88%9B%E5%BB%BA%E8%A7%86%E5%9B%BE"><span class="nav-number">3.5.4.</span> <span class="nav-text">3.5.4 创建视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-5-%E6%9F%A5%E7%9C%8B%E8%A7%86%E5%9B%BE%E5%AE%9A%E4%B9%89"><span class="nav-number">3.5.5.</span> <span class="nav-text">3.5.5 查看视图定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-6-%E4%BD%BF%E7%94%A8%E8%A7%86%E5%9B%BE"><span class="nav-number">3.5.6.</span> <span class="nav-text">3.5.6 使用视图</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9B%B4%E6%96%B0%E8%A7%86%E5%9B%BE"><span class="nav-number">3.5.6.1.</span> <span class="nav-text">更新视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%A0%E9%99%A4%E8%A7%86%E5%9B%BE"><span class="nav-number">3.5.6.2.</span> <span class="nav-text">删除视图</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8E%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">4 数据库安全性与完整性控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%A3%8E%E9%99%A9%E4%B8%8E%E5%AE%89%E5%85%A8%E9%9C%80%E6%B1%82"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 数据库风险与安全需求</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%90%E7%A7%81"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 数据库隐私</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E5%A8%81%E8%83%81"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 数据库安全性威胁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E9%9C%80%E6%B1%82"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3 数据库安全性需求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6%E6%8E%AA%E6%96%BD"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 数据库安全性控制措施</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6%E6%8E%AA%E6%96%BD%E6%A6%82%E8%BF%B0"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 数据库安全性控制措施概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E4%B8%8E%E9%89%B4%E5%88%AB"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 用户认证与鉴别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3 数据库访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-%E8%A7%86%E5%9B%BE"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4 视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-5-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E5%AF%86"><span class="nav-number">4.2.5.</span> <span class="nav-text">4.2.5 数据库加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-6-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%A1%E8%AE%A1"><span class="nav-number">4.2.6.</span> <span class="nav-text">4.2.6 数据库审计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-MySQL%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 MySQL的安全性控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-MySQL%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%8E%A7%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 MySQL的安全性控制概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-MySQL%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 MySQL访问控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-MySQL%E7%94%A8%E6%88%B7%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 MySQL用户管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-MySQL%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4 MySQL权限管理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-5-MySQL%E5%AE%A1%E8%AE%A1"><span class="nav-number">4.3.5.</span> <span class="nav-text">4.3.5 MySQL审计</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-MySQL%E7%9A%84%E5%AE%8C%E6%95%B4%E6%80%A7%E6%8E%A7%E5%88%B6"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 MySQL的完整性控制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-%E5%AE%9E%E4%BD%93%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1 实体完整性约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2 参照完整性约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-3-%E7%94%A8%E6%88%B7%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8C%E6%95%B4%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="nav-number">4.4.3.</span> <span class="nav-text">4.4.3 用户自定义完整性约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-4-%E5%91%BD%E5%90%8D%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">4.4.4.</span> <span class="nav-text">4.4.4 命名完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-5-%E5%88%A0%E9%99%A4%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="nav-number">4.4.5.</span> <span class="nav-text">4.4.5 删除完整性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="nav-number">5.</span> <span class="nav-text">第5章 数据库备份与恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 备份与恢复原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E6%95%85%E9%9A%9C%E7%A7%8D%E7%B1%BB"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 故障种类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E6%81%A2%E5%A4%8D%E6%9C%BA%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 恢复机制的原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-%E5%A4%87%E4%BB%BD%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">5.1.3.</span> <span class="nav-text">5.1.3 备份的类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-MySQL%E5%A4%87%E4%BB%BD%E6%96%B9%E6%A1%88"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 MySQL备份方案</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E5%A4%87%E4%BB%BD%E7%AD%96%E7%95%A5%E7%9A%84%E5%BD%B1%E5%93%8D%E5%9B%A0%E7%B4%A0%E5%92%8C%E5%A4%87%E4%BB%BD%E5%86%85%E5%AE%B9"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 备份策略的影响因素和备份内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%86%B7%E5%A4%87%E4%BB%BD"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 文件系统冷备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3 逻辑备份</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97"><span class="nav-number">5.2.4.</span> <span class="nav-text">5.2.4 二进制日志</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-InnoDB%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97"><span class="nav-number">5.2.5.</span> <span class="nav-text">5.2.5 InnoDB事务日志</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 MySQL数据库的恢复</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-%E5%9F%BA%E4%BA%8E%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 基于复制文件的恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-%E9%80%BB%E8%BE%91%E5%A4%87%E4%BB%BD%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 逻辑备份的恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-%E5%9F%BA%E4%BA%8E%E6%97%B6%E9%97%B4%E7%82%B9%E7%9A%84%E6%81%A2%E5%A4%8D"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 基于时间点的恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-4-InnoDB%E5%B4%A9%E6%BA%83%E6%81%A2%E5%A4%8D"><span class="nav-number">5.3.4.</span> <span class="nav-text">5.3.4 InnoDB崩溃恢复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-5-%E4%BD%BF%E7%94%A8%E5%A4%8D%E5%88%B6%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%81%A2%E5%A4%8D"><span class="nav-number">5.3.5.</span> <span class="nav-text">5.3.5 使用复制来进行恢复</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-MySQL%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E5%B7%A5%E5%85%B7"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 MySQL备份恢复工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E4%BA%8E%E5%A4%87%E4%BB%BD%E6%81%A2%E5%A4%8D%E7%9A%84%E5%B7%A5%E5%85%B7%E6%9C%89%E5%BE%88%E5%A4%9A%E3%80%82%E5%AF%B9%E4%BA%8E%E5%A4%A7%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%8C%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8mysqldump%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%AE%83%E5%AF%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9C%89%E5%BD%B1%E5%93%8D%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%BF%98%E5%8E%9F%E6%97%B6%E9%97%B4%E4%B9%9F%E4%B8%8D%E5%8F%AF%E9%A2%84%E7%9F%A5%E3%80%82"><span class="nav-number">5.4.1.</span> <span class="nav-text">用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9B%91%E8%A7%86%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-number">6.</span> <span class="nav-text">第6章 数据库性能监视与优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 数据库性能检测工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7%E6%A6%82%E8%BF%B0"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 数据库性能检测工具概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-%E9%9D%9E%E4%BA%A4%E4%BA%92%E6%80%A7%E7%9B%91%E8%A7%86%E5%B7%A5%E5%85%B7"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 非交互性监视工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-%E4%BA%A4%E4%BA%92%E6%80%A7%E7%9B%91%E8%A7%86%E5%B7%A5%E5%85%B7"><span class="nav-number">6.1.3.</span> <span class="nav-text">6.1.3 交互性监视工具</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9B%91%E8%A7%86%E5%89%96%E6%9E%90"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 数据库性能监视剖析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9B%91%E8%A7%86%E5%89%96%E6%9E%90"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 数据库性能监视剖析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-MySQL%E4%B8%BB%E8%A6%81%E6%8C%87%E6%A0%87%E7%9B%91%E8%A7%86%E6%96%B9%E6%B3%95"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 MySQL主要指标监视方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-MySQL-PROCESSLIST"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.2.3 MySQL PROCESSLIST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-4-%E6%85%A2%E6%9F%A5%E8%AF%A2%E6%97%A5%E5%BF%97%E8%A7%A3%E6%9E%90"><span class="nav-number">6.2.4.</span> <span class="nav-text">6.2.4 慢查询日志解析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 查询性能优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%8E%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1 查询执行过程与优化技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-%E9%80%BB%E8%BE%91%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2 逻辑查询优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-%E7%89%A9%E7%90%86%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.3.</span> <span class="nav-text">6.3.3 物理查询优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E4%BC%98%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E8%B1%A1"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 优化数据库对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-%E4%BC%98%E5%8C%96%E8%A1%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">6.4.1.</span> <span class="nav-text">6.4.1 优化表的数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-%E6%8B%86%E5%88%86%E8%A1%A8"><span class="nav-number">6.4.2.</span> <span class="nav-text">6.4.2 拆分表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-%E9%80%86%E8%A7%84%E8%8C%83%E5%8C%96"><span class="nav-number">6.4.3.</span> <span class="nav-text">6.4.3 逆规范化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4-%E7%BC%93%E5%AD%98%E8%A1%A8%E5%92%8C%E6%B1%87%E6%80%BB%E8%A1%A8"><span class="nav-number">6.4.4.</span> <span class="nav-text">6.4.4 缓存表和汇总表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-5-ALTER-TABLE%E5%8A%A0%E9%80%9F"><span class="nav-number">6.4.5.</span> <span class="nav-text">6.4.5 ALTER TABLE加速</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E5%BA%94%E7%94%A8%E4%BC%98%E5%8C%96"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 应用优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">6.5.1.</span> <span class="nav-text">6.5.1 使用连接池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-%E5%87%8F%E5%B0%91%E5%AF%B9MySQL%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="nav-number">6.5.2.</span> <span class="nav-text">6.5.2 减少对MySQL的访问</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="nav-number">6.5.3.</span> <span class="nav-text">6.5.3 负载均衡</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AC%AC7%E7%AB%A0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E5%88%B6"><span class="nav-number">7.</span> <span class="nav-text">第7章 数据库复制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 数据库复制原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%8D%E5%88%B6%E5%8E%9F%E7%90%86%E6%A6%82%E8%BF%B0"><span class="nav-number">7.1.1.</span> <span class="nav-text">7.1.1 数据库复制原理概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-%E5%A4%8D%E5%88%B6%E7%9A%84%E6%9E%B6%E6%9E%84%E5%92%8C%E7%94%A8%E9%80%94"><span class="nav-number">7.1.2.</span> <span class="nav-text">7.1.2 复制的架构和用途</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-3-%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="nav-number">7.1.3.</span> <span class="nav-text">7.1.3 复制的格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-4-%E5%A4%8D%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9A%84%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.1.4.</span> <span class="nav-text">7.1.4 复制相关的文件类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-%E9%85%8D%E7%BD%AE%E5%A4%8D%E5%88%B6"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 配置复制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-%E9%85%8D%E7%BD%AE%E5%A4%8D%E5%88%B6"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1 配置复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-%E5%88%9B%E5%BB%BA%E5%A4%8D%E5%88%B6%E8%B4%A6%E5%8F%B7"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.2.2 创建复制账号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-%E9%85%8D%E7%BD%AE%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">7.2.3.</span> <span class="nav-text">7.2.3 配置主数据库和从数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-4-%E5%90%AF%E5%8A%A8%E5%A4%8D%E5%88%B6"><span class="nav-number">7.2.4.</span> <span class="nav-text">7.2.4 启动复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-5-%E4%BB%8E%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%A7%8B%E5%A4%8D%E5%88%B6"><span class="nav-number">7.2.5.</span> <span class="nav-text">7.2.5 从另一个服务器开始复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-6-%E6%8E%A8%E8%8D%90%E7%9A%84%E5%A4%8D%E5%88%B6%E9%85%8D%E7%BD%AE"><span class="nav-number">7.2.6.</span> <span class="nav-text">7.2.6 推荐的复制配置</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-3-%E5%A4%8D%E5%88%B6%E7%AE%A1%E7%90%86%E5%92%8C%E7%BB%B4%E6%8A%A4"><span class="nav-number">7.3.</span> <span class="nav-text">7.3 复制管理和维护</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-1-%E7%9B%91%E8%A7%86%E5%A4%8D%E5%88%B6"><span class="nav-number">7.3.1.</span> <span class="nav-text">7.3.1 监视复制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-2-%E6%B5%8B%E9%87%8F%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%B6%E8%BF%9F"><span class="nav-number">7.3.2.</span> <span class="nav-text">7.3.2 测量从数据库延迟</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-3-%E5%88%A4%E6%96%AD%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E3%80%81%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%90%A6%E4%B8%80%E8%87%B4"><span class="nav-number">7.3.3.</span> <span class="nav-text">7.3.3 判断主数据库、从数据库是否一致</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-4-%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%87%8D%E6%96%B0%E5%90%8C%E6%AD%A5%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">7.3.4.</span> <span class="nav-text">7.3.4 主数据库重新同步从数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-5-%E6%94%B9%E5%8F%98%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="nav-number">7.3.5.</span> <span class="nav-text">7.3.5 改变主数据库</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liaozonglong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liaozonglong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liaozonglong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liaozonglong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">368k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
