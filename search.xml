<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>零散</title>
    <url>/2022/09/13/%E6%88%B7%E5%A4%96/%E9%9B%B6%E6%95%A3/</url>
    <content><![CDATA[<p>不留痕迹：山林并不是为登山者而存在的，它不欠人类任何东西，对人类也无所欲求。登山者在登山前必须对将要造访的山林进行详细了解，并牢记当地最容易被破坏的景观和植被，并且在扎营、行进和攀登时，一定牢记：不留痕迹</p>
<p>翰·缪尔相同的感受：“去攀登吧！倾听山的呼唤。自然的平和会侵入你的身心，如同阳光洒满树林。微风让你心旷神怡，暴风赐予你无穷的力量，忧愁如同秋叶悄然落下。静静地走向四方，品味和拥抱无限的自由。”</p>
<p>确保自己拥有即将开始的任何一项探险所必备的各类装备。我建议你随身，带盒式宝囊，用来盛放几儿种精心挑选的工具和物品，它们对于野外生存非常关键一称必须与之形影不离。刀是你最重要的求生工具，必须仔细挑选、精心维护。个人心理状态同样非常重要。必须保证自己拥有良好的身心状态，能够对各种压力和险情应付自如。必须透御理解求生需要，尤其是食盐和淡水一一必须知道如何获取。</p>
<p>1.幸存之道生存是维持生命的艺术。1.1 作好准备打开背包许多人最初总是装得太多，最终受罪的还是自己</p>
<p>装备检查清单</p>
<ul>
<li><input disabled="" type="checkbox"> 我将离开多久？这段时间我语要多少食物？要带水吗？</li>
</ul>
<p>☐我带的衣服适合相应气侯吗？一双靴子够用吗？考虑到路途状况和行走路程，我该带双备用靴吗？☐我需为相应地形携带什么特殊类型装备呢？口带何种医药品最合适？</p>
<p>1.1.1 保健及体检临行前完成一次彻底的检查，并知晓当地的是否存在病毒流行曲，对于服用对应药片。临行前拜访一次牙科医生</p>
<p>1.2 计划的研究了解当地人生活习惯和特点是否对外来人员存在敌意山多高，坡度，植被，树，日出日落，风向，温度，日夜温差</p>
<p>1.3 研究后计划切记：一定要有人了解你正计划做什么以及什么时侯开始做。筹备前期就应与他们保持联系，这样联系中嘶本身就意味着按片了带铃。轮知和飞机的日程安#是严格控制的，如来延误且原因不明，搜寻组就会行动起来、检查行动路线，以便进行有效营救。要养成告知人们你去事里及日程如何安排的好习惯。</p>
<ol start="2">
<li>装备</li>
</ol>
<p>触发前两周就应试穿新鞋直至合脚</p>
<ol start="3">
<li>救生宝盒</li>
</ol>
<p>盘。一旦出了意外，你会很高兴它们总在身边。对于居家生活，总是随身携带刀具和这些小工具也许会使称感到很烦。但对于出门娘行者来说，它们都算得上相当小巧了，很便于随身携带。出现意外时没有它门也许你仍能就地取材，但带上它们会给称带来极大的便利。有时对于能否成功地存活下来，它们是至关磁要的。</p>
<p>擦亮称的烟盒，使之光亮如镜，然后封好口。为了防水还应用狭长胶带封紧（见1！页图a),这样也便于携带和转移位置。千万不要忘记最重要的是带着它。定期检查烟盒里的各类小东西，一旦发觉哪个不能用了〔比如火柴和药片)，应及时更换。所有药品都应标明用法、用量和有效期。盒内余下的空隙用棉绒塞满，这样做有两个好处：应急时用来点火同时又可防止各类小东西相互碰缠发出声响。火种对于生存来说至关重要，盒中有四类小东西是为生火准备的：火柴、蜡烛、打火石和放大镜。</p>
<p>6 正视灾难</p>
<p>7 基本需要7.1 水人离开食物可以存活三周，但没有水三天也活不了。保留你珍贵的存水，尽最大努力去寻找水源。流动的水源最理想</p>
<p>水分损失正常人平均每天耗水2-3升如何维持体液平衡？为了使水分消耗降至最柢程度，可以采取以下措施：口多林总，少活动。口不要抽烟。口呆在阴凉场所。如果找不到，可搭一凉擂。口不要躺在热腾烤的地面上。口不要进食或尽可能少进食。如果身体得不到水分，体液会从要害器官转移以便消化食物，这会加速脱水。脂肪很滩消化，需要大量水分。口不要饮语，那样会使器官消耗大量水分。口不要谈话一不要用嘴呼吸，可以用鼻呼吸。</p>
<p>7.1.1 寻找水源俗话说，人往高处走，水往低处流。寻找水源首选之地是山谷底部地区。如果谷底见不着明显的溪流或积水池，要注意绿色植物的分布带，试者向下挖，很可能植被之下就有水源。在干湘河床或沟渠下面很可能会发现泉限，尤其是沙石地带。在高山地区寻水应沿着岩石裂缝去找。在海岸边，应在收高水线以上挖坑，尤其是在沙丘地带。很可能会有一层厚约5厘米的沉滤淡水，浮在密度较大的海水层上。这层水可能会稍有盐味，但可以饮用。在悬崖人海处应注意生长茂盛的植物，包括羊齿类和苔藓类植物。在岩石的断层间你很可能会发现湿地或泉眼。</p>
<p>7.1.2 雨露的收集除了工业化国家中出现的会增加土壤污染的酸雨外，各个地方雨水几乎都能饮用，你所做的仅不过是收集而已。尽可能选取大面积的集水区、利用各种可能的容器收集。在地面上挖个洞，四周用粘土围往很大一块地方，可以有效地收集雨水，但要防止洞里的水海走。如果没有防渗的薄片材料，金属材料或者帆布材料都可很好防渗。如果对水的安全性有所怀疑，可以在饮用前烧开。在日夜祖差相当大的地区，会有很多落水。当它凝结在金属体上时，可以指抹下来或者直接舐吸。你可用衣服浸透水，然后再拧出来。一种方式是将于净衣服系在腿土，在湿的植被中穿行，然后可以将水拧出来或者吮吸。切记：可以控制少流汗，但不要限定饮水。如果必须限重就小口啜饮。在长时问缺水后，一旦发现了水薄，千万不可豪饮，开始也应吸饮。大量素饮猛灌会导致脱术者区吐，造成大量宝责体液的丧失。</p>
]]></content>
      <categories>
        <category>户外</category>
      </categories>
  </entry>
  <entry>
    <title>哲学导论</title>
    <url>/2023/05/04/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="初略阅读"><a href="#初略阅读" class="headerlink" title="初略阅读"></a>初略阅读</h1><p>人文社会科学</p>
<p>作者想在不简化哲学的前提下介绍哲学本身</p>
<p>章节末尾附上哲学家和哲学概念的关键词以及哲学概念的关键词以及哲学家的主要思想的概括</p>
<p>书后索引帮助读者定位书中重要概念</p>
<p>整书为四大部分</p>
<ol>
<li>形而上学和认识论</li>
<li>道德哲学和政治哲学</li>
<li>宗教哲学</li>
<li>其它声音<br>第一章，谈哲学自身和哲学的作用还有一些基础性的认识</li>
</ol>
<p>第一部分：形而上学和认识论<br>谈具备代表性的哲学的思想<br>谈近代哲学</p>
<p>第二部分：到的哲学和政治哲学<br>针对管理者如何管理的吧</p>
<p>第三部分：宗教哲学<br>被信仰的特殊存在</p>
<p>后面是一些女权和其他国家，诸如儒释道，佛等</p>
]]></content>
      <categories>
        <category>哲学</category>
        <category>哲学导论</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>书籍笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>摄影</title>
    <url>/2022/09/22/%E6%91%84%E5%BD%B1/%E6%91%84%E5%BD%B1/</url>
    <content><![CDATA[<h1 id="拍些什么"><a href="#拍些什么" class="headerlink" title="拍些什么"></a>拍些什么</h1><p>大家来学手机摄影主要是为了培养兴趣，提升生活幸福度，绝大多数人并不是想成为摄影师。我们拍摄的场景也都是平常生活中的场景，素材也都来自于生活中。经常有学员问我：“老师，我不知道该拍些什么，怎么办？”我一般会回答：“任何一个你习以为常的场景都不要放过。”比如在我们生活、工作的环境中，大家可能很少会停下脚步去仔细观察，因为觉得这个太普通了，太平常了，这有什么可拍的呢？但往往好的照片，就来自这些看似平凡、不起眼的地方。</p>
<p>不放过有光影的地方</p>
<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="HDR"><a href="#HDR" class="headerlink" title="HDR"></a>HDR</h2><p>使用这个功能，按下快门会自动拍摄三张照片，一张过曝，一张欠曝，一张正常。然后把三张照片自动合成一张照片。这样合成后的照片中，光线不足的地方会自动增加曝光，曝光过度的地方会自动降低曝光，照片的效果会更清晰、准确，避免了画面中因为光线对比强而出现的阴影太暗或者高光部分太亮的情祝况。</p>
<p>那我们如何选择合适的环境呢？多数是逆光的环境，或者画面中明暗对比很强烈的环境。开启HDR后，可以让天更蓝，草更绿，画面明暗对比更自然。否则，逆光的环境中经常会拍出曝光不合理的照片。但是，如果你想借助逆光拍摄剪影的话，就不要用这种功能了，因为它会把剪影部分的亮度提高。</p>
<h2 id="景深"><a href="#景深" class="headerlink" title="景深"></a>景深</h2><p>很多人拍照片，希望能把背景拍模糊，而人物清晰，因为这样的效果会显得人物更突出。其实在相机里，这是通过光圈大小来实现的景深效果。通俗来讲，就是拍照的时候，镜头里场景清晰的范围。</p>
<p>如果你用的是单摄像头的手机，想把背景拍得模糊一些，可以让主体离背景远一点，或者你离主体近一点，保证相机和主体的距离小于主体和背景的距离。只有距离近的时候，才能拍出背景模糊的效果。</p>
<p>手机中的人像大光圈其实是一种模拟算法，识别人体轮廓</p>
<h2 id="打开辅助线：保证照片横平竖直"><a href="#打开辅助线：保证照片横平竖直" class="headerlink" title="打开辅助线：保证照片横平竖直"></a>打开辅助线：保证照片横平竖直</h2><p>照片一定要横平竖直吗？当然不是，但是对于摄影入门者来说，要做的是打好基础，把最基本的原则掌握好，再去发挥自己的创意</p>
<h2 id="曝光"><a href="#曝光" class="headerlink" title="曝光"></a>曝光</h2><p>摄影就是光影的艺术，但有时候，在光线不理想的环境中，拍出来的照片也不好看</p>
<h2 id="对焦"><a href="#对焦" class="headerlink" title="对焦"></a>对焦</h2><p>是因为在摄影中，唯一不能舍弃的就是对焦，因为对焦是保证画面清晰度的重要因素。如果主体不清晰，画面模糊，只要不是刻意为之，那这个照片就是失败的。照片光线不好，构图不合理，这些通过后期都可以实现修改，但是清晰度是没办法后期改变的。所以，按快门前，最好先手动对焦。</p>
<h1 id="构图"><a href="#构图" class="headerlink" title="构图"></a>构图</h1><h2 id="留白构图"><a href="#留白构图" class="headerlink" title="留白构图"></a>留白构图</h2><p>我很喜欢留白这个词，因为留白意味着，你会有空间制造惊喜，创造更多可能。很多刚开始摄影的人会犯一个错误，就是希望一张照片尽量包含更多的元素。</p>
<p>我们知道，摄影是减法，因为即使你的镜头角度再广，也没办法把你看到的所有内容拍进去。所以要抓重点。留白的方式能让照片更好地突出主体，然后通过大面积的留白给观者更多的想象空间。</p>
<h2 id="框架式构图"><a href="#框架式构图" class="headerlink" title="框架式构图"></a>框架式构图</h2><p>有的时候，我们拍出来的照片会略显单调，感觉画面中的场景不够丰富层次感也不强。那么，我们可以尝试利用框架式构图，它是利用物体的天然框架形状形成前景，然后把主体放到框架中，这样能够使主体更加突出，吸引观者的视线，聚焦在框架内的主体上。常用的框架有门、窗、镜子，等等，还有一些天然形成的框架，比如洞穴、树叶之间的缝隙，等等。</p>
<h2 id="对称构图"><a href="#对称构图" class="headerlink" title="对称构图"></a>对称构图</h2><p>对称构图也是一种中规中矩的构图方式。对称包括三种方式：上下对称、左右对称、对角对称。我们看几张图就一目了然了。对称构图的优势是显得画面均衡、稳定，不会出现左右倾斜的情祝，给人一种严肃的宁静感。在拍摄大型建筑物、水面倒影，或者想表达画面稳定性的时候，经常会采用这种方式。</p>
<h2 id="三角形构图"><a href="#三角形构图" class="headerlink" title="三角形构图"></a>三角形构图</h2><p>三角形构图又叫金字塔构图，是指图中的主体具备三角形轮廓，或者相关的主要元素可以形成一个三角形。我们上学的时候都学过，最稳定的图形是三角形。所以在照片中应用三角形，会显得照片的结构稳定，画面稳定，不会有头重脚轻或者左右摇摆的情况。三角形可以很好地填充画面，因为人地视觉会主动地寻找具有相关性的元素，形成一个平面。所以能够形成三角形，是最简单的构图。</p>
<h2 id="中心构图"><a href="#中心构图" class="headerlink" title="中心构图"></a>中心构图</h2><p>从字面上，非常容易理解，就是把主体放在画面的中间。无论横构图还是竖构图，都可以使用。</p>
<p>中心构图的好处就是画面结构简单，容易被人接受。将主体放到中间非常容易被识别，而且能起到聚焦的作用。画面左右均衡，不会出现头重脚轻，或者左右摇摆的情祝。</p>
<p>在拍摄的时候，把主体放在画面的正中间，能够特别有效地突出主体。特别是在拍摄人物、静物或者单独个体的场景的时候，会经常使用中心构图。</p>
<h2 id="九宫格构图"><a href="#九宫格构图" class="headerlink" title="九宫格构图"></a>九宫格构图</h2><p>这是最常用、最保险的构图法。意思是把一张照片横向、纵向分为九等份，可以理解为在照片上写一个等比例的“井”字。横线和竖线在画面中形成了四个交叉点。在拍照的时候，结合实际情况，把画面的主体放到四个交叉点中的某一个上，而不是放到九个格子中的某一个里。</p>
<p>我们上学的时候学过的黄金分割定律被称为最完美的比例，那么九官格就可以理解为简化的黄金分割线。画面中的四个交叉点，就位于这个最佳的比例附近。所以，九宫格也是被用得最多的构图方式。</p>
<p>至于把主体放到哪个交叉点上，要根据主体和周围环境的关系决定，构图的目的是交代完整的环境。我们通过四张照片，分别理解一下主体在不同焦点上的视觉效果。</p>
<h2 id="构图的必要性"><a href="#构图的必要性" class="headerlink" title="构图的必要性"></a>构图的必要性</h2><p>你是否遇到过这种情况：照片拍完之后发现，歪歪扭扭，左右不对称，头重脚轻。这样的照片都缺少稳定性，画面的美感会下降。那为什么会出现这种情况？主要原因在于，我们对于画面的构思不够清晰，或者拍照的时候太匆忙，拿起手机就拍，并没有思考清楚画面的布局。构图的目的就是把画面中的元素很好地利用起来，保证人、景、物出现在合适的位置，构成一个协调完整的画面。</p>
<h1 id="光影"><a href="#光影" class="headerlink" title="光影"></a>光影</h1><h2 id="顶光"><a href="#顶光" class="headerlink" title="顶光"></a>顶光</h2><p>拍摄建筑、风光也是同样的道理。顶光环境下，物体基本上是看不到影子的，也看不到明显的明暗对比。要突出主体的立体感，明暗对比是很重要的因素。建筑像人那样可以做不同的动作，所以拍摄风光、建筑时，还是尽量避开这个种光线。如果出去旅游，尽量“起早，贪黑”，利用低角度的光线拍摄，而不要选择烈日当头的时间出去拍照。</p>
<p>比如顶光拍人像的时侯，可以做一些抬<br>头、遮挡阳光或者其他的动作。</p>
<h2 id="黄金一小时"><a href="#黄金一小时" class="headerlink" title="黄金一小时"></a>黄金一小时</h2><p>在摄影中有一个原则叫【黄金一小时】，就是日出后一小时和日落前一小时。这两个时间段的光线偏暖色调，而且不是非常的刺眼，角度也很低，所以很适合拍照。无论是拍人，拍风，光，拍建筑，都会显得非常的立体，明暗对比清晰。</p>
<h2 id="侧光"><a href="#侧光" class="headerlink" title="侧光"></a>侧光</h2><p>我们前面讲过很多次“立体感”，因为照片是一个二维平面，所以我们需要用一些方法技巧，使画面呈现出立体感，突破二维平面空间。那么，侧光就是拍摄时用得最多的一种光线，特点是能够在主体上形成明显的明暗对比。跟顺光相比，它的立体感就会很强。如果你学过素描，应该很容易理解。看足球的两个素描。</p>
<h2 id="逆光"><a href="#逆光" class="headerlink" title="逆光"></a>逆光</h2><p>手机不同于相机，它对于强烈光比的场景，有时候会处理得不尽人意，特别是逆光场景。现在大家的生活都离不开旅行，比如我们去草原，去海边，去爬山，都会喜欢拍日出日落。这种环境都是逆光场景，如果拍不好，就会曝光不足或者曝光过度。</p>
<p>这种环境下，拍摄剪影是一个明智的选择。</p>
<p>这种逆光场景，人物离镜头很远的情况下，一定要做出一些可区分的肢体动作。比如这对情侣，女孩侧身，一条腿弯曲，伸出手牵住男孩的手。虽然男孩的姿势比较单一，但是两个人的动作放在一起，就能好地体现人物的轮廓和姿态。</p>
<h2 id="顺光"><a href="#顺光" class="headerlink" title="顺光"></a>顺光</h2><p>顺光拍摄是最常见的一种光线效果。对于新手来说，很多人会选择顺光拍摄，因为拍出来的主体会很清楚。顺光的优点就是光照面比较大，光线充足，显得非常的清晰，色泽鲜艳，能很好地表现主体，抓住读者的眼球。特别是手机拍摄的时候，光的亮度是保证画面清晰度的一个重要因素,所以用手机拍照片，采用顺光的角度拍，能保证清晰的画质。</p>
<p>不过顺光的缺点也很明显：它能把物体正面全部照亮，但是没有了明暗对比，就会缺少细节，缺乏立体感，感觉很平淡。所以，顺光也叫平面光。这张照片就是用顺光拍摄的场景，整个建筑显得比较平淡。</p>
<h2 id="利用光"><a href="#利用光" class="headerlink" title="利用光"></a>利用光</h2><p>常见的光线一般会有4个方向：顺光、逆光、侧光、顶光。</p>
<p>【顺光】是指光线在你的背后照射过来，拍摄主体的正面被照亮，影子在拍摄主体后边。<br>【逆光】则刚好相反，光源在你的对面，拍摄主体的背面被照亮，正面是黑的，影子在拍摄主体前边。<br>【侧光】是指光线从你和拍摄主体侧面照射过来，或左或右，拍摄主体在光源的一侧是亮的，影子在另一侧。<br>【顶光】是指光源在你和拍摄主体的上方，光线从头顶照射下来，影子在脚下。</p>
<p>其实，判断光源最简单的方法就是通过影子的位置来进行，因为不同的角度，给照片带来的效果是完全不同的。</p>
<h2 id="光影概念"><a href="#光影概念" class="headerlink" title="光影概念"></a>光影概念</h2><p>我们能看到身边的一切，正是因为有光。摄影被称为光影的艺术。在摄影中，没有光，就没有了物体的形状、体积、结构、质感、颜色，就不会有摄影这种艺术形式，因为我们什么都看不见。作为一个摄影师，前期拍摄就是捕捉光，而后期处理则是调整光在照片上的强度和分布。所以，想要拍出好照片，就一定要了解光影的特点。</p>
]]></content>
      <categories>
        <category>摄影</category>
      </categories>
  </entry>
  <entry>
    <title>服装</title>
    <url>/2022/09/13/%E6%88%B7%E5%A4%96/%E6%9C%8D%E8%A3%85%E4%B8%8E%E8%A3%85%E5%A4%87/%E6%9C%8D%E8%A3%85/</url>
    <content><![CDATA[<p>在攀登时，维持身体相对舒适的关键在于保持身体干爽，特别是在被雨淋湿之后</p>
<p>身上的衣物在长期潮湿的情况下会失去保暖作用，即使是在气温回暖的时候也是如此。风侵袭人体，会导致体温迅速下降，这就是常说的“风寒效应”，也是“失温”</p>
<p>防晒和透气性是选择衣物时需要考虑的关键因素</p>
<p>衣物的选择要根据个人的体型或者新陈代谢的速率而定。最好的方法就是从过去的经验出发，选择那些最舒适的衣物</p>
<h2 id="分层系统穿衣法"><a href="#分层系统穿衣法" class="headerlink" title="分层系统穿衣法"></a>分层系统穿衣法</h2><p>分层系统穿衣法能够优化服装的效能和通用性，更能适应山区气温的波动，便于登山者根据所需进行调整。</p>
<p>分层穿衣原则的“分层”是指贴身内层、保暖层和外层**贴身内层		<strong>内层衣物应选择排汗性较强的内衣，以保持身体的干爽。排汗对于保来说非常重要，因为湿衣服贴在皮肤上会加剧体温的流失。</strong>保暖层		<strong>保暖层应该包住人体周围的温暖空气，这层空气越厚，人就会感觉越温暖。穿件宽松的薄衣服虽然不如穿一件羊绒大衣保暖，但可以一层一层地包住暖空，方使调节。</strong>外层		**外层衣物-一定要能够防风、防雨和防晒。</p>
<h2 id="登山服的质地"><a href="#登山服的质地" class="headerlink" title="登山服的质地"></a>登山服的质地</h2><table>
<thead>
<tr>
<th>品种</th>
<th>材料</th>
<th>优点</th>
<th>缺点</th>
<th>特征</th>
</tr>
</thead>
<tbody><tr>
<td>天然纤维</td>
<td>棉</td>
<td>在酷热时，穿起来透气又凉爽，还有不错的防晒</td>
<td>他能吸收比本身重数倍的水，而且不容易干，这常常会造成登山者失温</td>
<td></td>
</tr>
<tr>
<td>天然纤维</td>
<td>毛料</td>
<td>不易受潮，比棉更好的保暖，遇热不容易融化</td>
<td>重、挠皮肤</td>
<td>摔倒对地摩擦力大，有利于制动</td>
</tr>
<tr>
<td>合成纤维</td>
<td>聚丙烯和聚酯纤维</td>
<td>透气性强</td>
<td>容易发臭，吸水差</td>
<td>极适合做贴身衣物</td>
</tr>
<tr>
<td>合成纤维</td>
<td>尼龙</td>
<td></td>
<td>超强的吸水性（除非特殊处理）否二不容易干</td>
<td>通常是最外层保护衣物的首选材料，不同尼龙特征各异，有些抗风好，有些柔软</td>
</tr>
<tr>
<td>防水面料</td>
<td>防水不透气的涂料（例如：聚氨基甲酸乙酯）</td>
<td>便宜，轻</td>
<td>不耐磨，会封闭汗水</td>
<td>身体无法保持干爽</td>
</tr>
<tr>
<td>防水面料</td>
<td>防水透气涂料（聚氨基甲酸乙酯）</td>
<td>透气</td>
<td>贵</td>
<td>涂料在每平方厘米之内布满了数十亿个细孔</td>
</tr>
<tr>
<td>防水面料</td>
<td>防水透气薄膜（Gore-Tex）</td>
<td>保养得当很耐用</td>
<td>比涂料要贵</td>
<td></td>
</tr>
<tr>
<td>保暖填充料</td>
<td>鹅绒</td>
<td>最保暖、最轻便、易压缩</td>
<td>价格贵、一旦打湿就会丧失保暖功能，很难恢复完全干燥</td>
<td></td>
</tr>
<tr>
<td>保暖填充料</td>
<td>人造纤维</td>
<td>不会因潮湿丧失保暖功能，价格便宜，容易清洗</td>
<td>重、占地方</td>
<td></td>
</tr>
</tbody></table>
<h2 id="登山衣物的保养"><a href="#登山衣物的保养" class="headerlink" title="登山衣物的保养"></a>登山衣物的保养</h2><h3 id="冲锋衣的清理"><a href="#冲锋衣的清理" class="headerlink" title="冲锋衣的清理"></a>冲锋衣的清理</h3><p>手洗：</p>
<ol>
<li>35°左右的水手洗</li>
<li>使用中性洗衣液。（如无法判断，可用洗洁精或洗发水代替 。用海绵或棉布直接蘸适量洗涤剂擦拭服装表层，直至起泡，起泡可以加快污渍溶解，然后轻轻揉搓，如果真的很难洗掉脏污的地方，先泡几分钟，再揉搓几下。  </li>
<li>用大量清水漂洗掉泡沫 ，一定要彻底漂洗掉</li>
<li>通风处自然阴干</li>
<li>衣服干燥前不可晒太阳</li>
<li>不可拧干</li>
<li>衣服全部干燥后就可以放到太阳下晒一晒，可以起到灭菌的效果。</li>
</ol>
<p>机洗：最好用滚筒，立缸①先用透明皂在脏污的地方涂上，轻轻涂抹开。②把衣服折起来，最脏的部分尽量折在外面，接着把衣服装进洗衣袋。③将衣服放进洗衣机内，加皂粉（皂粉的碱性较低，平时非常适合洗内衣或贴身穿着的衣服），用手轻轻搅动，让水起泡，浸泡20分钟，然后正常洗涤（搅、甩均可）。④最后把衣服放到通风处自然晾干，当衣服完全干燥后可以放到太阳下晒一晒，灭菌消毒，避免暴晒。</p>
<h3 id="防水透气衣物的保养"><a href="#防水透气衣物的保养" class="headerlink" title="防水透气衣物的保养"></a>防水透气衣物的保养</h3><ul>
<li>不可洗衣机清洗</li>
<li>汗水和污垢都可能阻塞细孔或者弄脏薄膜降低其通气性</li>
<li>某些洗洁剂会分解薄膜或者涂料层，清洗前需要询问厂家和遵守厂家建议</li>
<li>当雨衣表面的雨水无法形成圆珠状时，用熨斗烫一烫或放在烘干机中适当烘烤就会恢复如初。此外，还可以重新喷涂防水剂，但最好遵照厂家的建议操作。</li>
</ul>
<h2 id="登山的全套服装"><a href="#登山的全套服装" class="headerlink" title="登山的全套服装"></a>登山的全套服装</h2><h3 id="贴身内层"><a href="#贴身内层" class="headerlink" title="贴身内层"></a>贴身内层</h3><p><strong>长内衣：</strong>合适的长内衣能够起到良好的保暖作用。聚丙烯和聚酯纤维是多数人的选择。深色内衣吸热强，阳光下易干。浅色长内衣适合夏天穿<strong>T恤：</strong>酷暑中并不需要靠衣物排汗，因此棉T恤或无袖上衣比较好。凉爽的山区不适合棉T恤，容易失温<strong>短裤：</strong>耐磨和透气。一件宽松的尼龙短裤，加上一件尼龙网眼内裤即可做到。可拆解成短裤的尼龙长裤也是不错的产品。在气候宜人时，轻质聚酯纤维长内衣加上一条尼龙短裤是登山者最爱的组合。可拆解成短裤</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>服装与装备</category>
        <category>服装</category>
      </categories>
  </entry>
  <entry>
    <title>登山物品准备</title>
    <url>/2022/09/15/%E6%88%B7%E5%A4%96/%E6%9C%8D%E8%A3%85%E4%B8%8E%E8%A3%85%E5%A4%87/%E7%99%BB%E5%B1%B1%E7%89%A9%E5%93%81%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<p>##10项必备物品</p>
<table>
<thead>
<tr>
<th>10个要点</th>
<th>10项必备物品</th>
</tr>
</thead>
<tbody><tr>
<td>1.导航</td>
<td>1.地图   2.指南针</td>
</tr>
<tr>
<td>2.防晒</td>
<td>3.太阳眼镜和防晒油</td>
</tr>
<tr>
<td>3.保暖（备用衣物）</td>
<td>4.备用衣物</td>
</tr>
<tr>
<td>4.照明</td>
<td>5.头灯&#x2F;手电筒</td>
</tr>
<tr>
<td>5.急救</td>
<td>6.急救箱</td>
</tr>
<tr>
<td>6.火</td>
<td>7.火种  8.火柴</td>
</tr>
<tr>
<td>7.维修</td>
<td>9.刀子</td>
</tr>
<tr>
<td>8.营养（备用粮食）</td>
<td>10.备用粮食</td>
</tr>
<tr>
<td>9.水（备用水）</td>
<td>10.备用粮食</td>
</tr>
<tr>
<td>10.紧急避难</td>
<td>10.备用粮食</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>服装与装备</category>
      </categories>
  </entry>
  <entry>
    <title>登山知识-背包</title>
    <url>/2022/09/15/%E6%88%B7%E5%A4%96/%E6%9C%8D%E8%A3%85%E4%B8%8E%E8%A3%85%E5%A4%87/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86-%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>一个好的背包应具有良好的贴身性，且重力集中在臀部</p>
<h2 id="内架型背包和外架型背包"><a href="#内架型背包和外架型背包" class="headerlink" title="内架型背包和外架型背包"></a>内架型背包和外架型背包</h2><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>内架型背包</td>
<td>有利于身体保持平衡有利于灌木穿行和托吊（因为外形简单而狭长）可以利用压缩带将背包体积动态调整</td>
<td>酷热天，让人感觉不适</td>
<td>包内有坚固的框架</td>
</tr>
<tr>
<td>外架型背包</td>
<td>负重大不易出汗</td>
<td>容易晃动容易被灌木丛卡住</td>
<td>外架型背包的装载物悬挂在一个梯状框架上，以拉紧的尼龙背带将架子撑离身体。</td>
</tr>
</tbody></table>
<h2 id="测试背包"><a href="#测试背包" class="headerlink" title="测试背包"></a>测试背包</h2><ul>
<li><p>可以将自己的装备带到店里试用，没有负重，就无法感知</p>
</li>
<li><p>测试背包之前，调节带全部放松，按照店员建议调整带子</p>
</li>
<li><p>检查背包是否符合背部线条</p>
</li>
<li><p>测试头是否有足够活动空间（抬头是否会碰到背包，带上岩盔是否会碰到）</p>
</li>
<li><p>背包接触背的地方是否有足够的衬垫</p>
</li>
<li><p>重点检查肩带和臀带衬垫的厚度和质量</p>
</li>
<li><p>衬垫必须包住整个髋骨</p>
</li>
<li><p>如果要把重量转移到臀部位置，臀带必须直接系在髋骨上方，不可系在髋骨两边或者腰上</p>
</li>
<li><p>背负系统如何设计？坚固耐用如何？有容易断裂的薄弱点？</p>
</li>
<li><p>缝合处是否牢靠</p>
</li>
<li><p>开口是否使用拉练？如果拉链损坏，对包是否有影响？</p>
</li>
<li><p>是否方便存取装备？</p>
</li>
<li><p>是否有特殊装备放置处？（雪铲、登山杖等）</p>
</li>
<li><p>登山时是否可能晃动？</p>
</li>
<li><p>容量易于拓展吗？</p>
</li>
<li><p>外形是否足够简单，便于灌木丛行走？</p>
</li>
</ul>
<h2 id="打包要领"><a href="#打包要领" class="headerlink" title="打包要领"></a>打包要领</h2><ul>
<li>重物靠近背部，最好是背部中间</li>
<li>常用物品应随身携带</li>
<li>具备功能性，但不一定用上可以放顶包易取位置</li>
<li>长时间背负背包之后，调整物品的放置位置有助于减轻疲劳或疼痛</li>
</ul>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>服装与装备</category>
        <category>背包</category>
      </categories>
  </entry>
  <entry>
    <title>登山守则</title>
    <url>/2022/09/13/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E5%AE%88%E5%88%99/%E7%99%BB%E5%B1%B1%E5%AE%88%E5%88%99/</url>
    <content><![CDATA[<ul>
<li>将登山行程表交给营地留守人员</li>
<li>带足上山的衣物、食物和装备</li>
<li>一个登山队至少应有三人，除非事先做了足够的准备。在攀登冰河时，建议至少组建两个绳队。</li>
<li>在没有任何遮蔽物的冰河上行进时，请用绳索确保，并固定所有的确保点。</li>
<li>集体行动，听从领队或者服从多数人的决定。</li>
<li>不要攀登超出你的知识水平和能力范围的路线。</li>
<li>选择走哪条路或者考虑是否返回时，别因冲动作决定。</li>
<li>遵照公认较好的登山指南介绍的登山守则。</li>
<li>任何时候都要以友好的态度对待山林，严格遵守“不留痕迹”原则。</li>
</ul>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山守则</category>
      </categories>
  </entry>
  <entry>
    <title>体能调试</title>
    <url>/2022/09/23/%E6%88%B7%E5%A4%96/%E4%BD%93%E8%83%BD%E8%AE%AD%E7%BB%83/%E4%BD%93%E8%83%BD%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h2 id="设定训练目标"><a href="#设定训练目标" class="headerlink" title="设定训练目标"></a>设定训练目标</h2><p>SMART原则具体、可测量、以行动为导向、切实、有时间限定</p>
<h2 id="明确训练项目"><a href="#明确训练项目" class="headerlink" title="明确训练项目"></a>明确训练项目</h2><p>以你的行程目标作为导向进行训练</p>
<h2 id="心血管训练"><a href="#心血管训练" class="headerlink" title="心血管训练"></a>心血管训练</h2><p>心血管耐力是在较长时间内重复进行某种运动的能力</p>
<p>有氧运动：短2-8min、中8-30min、长30以上min。持续时间长，强度低跑步、交叉训练、爬楼梯、旋转楼梯训练、徒步、雪地健行、越野滑雪、踏板踩、公路长跑</p>
<p>骑行、划桨、游泳可以代替交叉训练或作为恢复训练的补充项目</p>
<p>无氧运动：接近人体心跳上限的65-95%的有氧的极限状态——上气不接下气可以帮助你提高双腿的交换频率，获得更快的行进速度</p>
<p>##心血管耐力训练：定期评估你的心肺能力，选择一条就近、终年武无雪的登山路线。每两星期或一星期进行一次登山实地训练</p>
<p>一个简单的增加负重的方法就是在背包里放几个装满水的袋子，此举可以有效训练关节的耐磨能力，在到达山顶后，把这些水掉就可以了。然而，当你到达山顶后，要确保把你带上山的东西带下山。如果你在轻负重的时候感到上气不接下气，你应该在周的训练课程中专注于心血管耐力训练：如果你的双腿在刚增加背包负重时就明显感到吃力，你就应该把力量训练列为重点。</p>
<h2 id="力量训练"><a href="#力量训练" class="headerlink" title="力量训练"></a>力量训练</h2><p>四季皆可把训练重点放在当你攀爬高山时，如何调动全身的力量这方面。例如静态突进、单举、爬台阶等都可以锻炼你的腿部肌肉，让它更协调、有力。</p>
<h3 id="单举练习"><a href="#单举练习" class="headerlink" title="单举练习"></a>单举练习</h3><p>单举练习单举练习可以增强脚踝、臀部以及脚步的稳定，高腿部、臀部以及后背的力量。单腿站立，保持平衡，双各握一个哑铃（图4-1a)一或者单手握一个也可以，臀部给予腰部理想的力量支持，然后弯腰将哑铃放在地上，将一条腿抬起来，可以依靠前手撑地来保持平衡（图4-1b),呼气，回到站立姿势，重复6至15次。</p>
<h3 id="阶梯训练"><a href="#阶梯训练" class="headerlink" title="阶梯训练"></a>阶梯训练</h3><p>想要有效地训练肌肉力量，阶梯训练是必不可少的。先做准备练习：先站在一个台阶上，手中握一个五磅重的哑铃，把一只脚向前伸15至30厘米（双脚交替进行），用脚趾支撑身体的重量（图4-2a)。准备工作做好之后，慢慢地走下台阶（图4-2b)。再慢慢转身，踮起脚尖，用腿部肌肉支撑身走上台阶。膝盖要和脚中趾在一条直线上，不要让膝盖偏向身体的中轴线。每一个动作都保持两到三秒再做下一个动作。双腿复这个动作6至15次。这些练习最开始可以在家里进行，然后适当增加负重，有助于提高你的平衡感。当你行进在陡峭的山坡，你的小腿会承受大部分来自身体的重力。</p>
<p>试想一下你在野外需要什么样的肌肉力量和你的哪部分力量比较薄弱</p>
<p>例如：如果你知道你要去的地方是需要穿雪地靴的雪山，就可以有针对性地通过高拾腿的方式增强臀部屈肌的力量</p>
<h2 id="灵活度训练"><a href="#灵活度训练" class="headerlink" title="灵活度训练"></a>灵活度训练</h2><p>灵活度训练可以提高一个特定关键的灵活度。该训练能够在紧张的运动之后舒缓压力</p>
<p>一个非常有效的训练身体灵活度和攀爬能力的方法就是青蛙姿势（图4-3）。脚分开宽过肩膀，深蹲，保持脚后跟着地，身体轻微向前倾。手肘撑在膝盖内侧，保持臀部和大腿肌肉紧绷，坚持30全60秒。</p>
<h2 id="技能发展"><a href="#技能发展" class="headerlink" title="技能发展"></a>技能发展</h2><p>所谓技能，是指身体协调的技巧及其掌握的熟练度。</p>
<h2 id="交叉训练"><a href="#交叉训练" class="headerlink" title="交叉训练"></a>交叉训练</h2><p>攀登者进行协调练习的最后一部分就是交叉训练。所谓交叉训练，是指与攀登活动没有直接关系的额外的体力训练</p>
<p>攀登者的交叉训练包括水平拉伸或划船训练，它们可以提高攀登者在垂直攀登中的平衡性。在不少登山训练项目中，我们都能到自行车运动。这是为什么？因为这种运动虽然不像登山运动一样在攀登者的脊柱上产生负荷，但它是一种不错的非打击式心血管训练项目，比跑步给攀登者部带来的伤害小得多一而且还能让运动员在户外进行有氧运动。</p>
<h2 id="训练原则"><a href="#训练原则" class="headerlink" title="训练原则"></a>训练原则</h2><p>FITT原则：频率（多久一次训练）：每周应参加3-5次有氧训练，每次锻炼至少20分钟强度（训练难度）：最恰当的强度是登山者最大心率的65-95%。准备训练应采取低强度方式，逐渐增加时间（训练持续多久）：最开始可以展开15-20min的有氧运动，然后逐渐进入无氧运动。正常训练应持续20-60min种类（采取何种方式）：同样是根据目标来训练。攀冰&#x3D;上肢。重装&#x3D;背包攀登训练、下肢</p>
<h2 id="训练指南"><a href="#训练指南" class="headerlink" title="训练指南"></a>训练指南</h2><p>训练时应遵循以下指导原则目标明确有针对性：选择训练项目前应了解其作用，选择那些能够让更多肌肉得到训练的项目。自由重力训练比使用机器训练更有效循环渐进：每次提高的范围在5-15%之内。例如：本次训练20分钟，下次训练22-23分钟。主要运用大型肌肉的高冲击力运动。如跑步。一次增加最多10的运动量劳逸结合：高强度训练需要更多的休息时间。在低强度训练中，攀登者可以持续几日而不用休息，但如果考虑背包负重或地形因素，则应安排一天时间用来恢复。低强度恢复交叉训练包括：散步、游泳、跳舞、平地自行车运动、喻伽或在院子里工作。</p>
<h2 id="构建年度训练单元"><a href="#构建年度训练单元" class="headerlink" title="构建年度训练单元"></a>构建年度训练单元</h2><p>旺季：攀登者能够数次攀登同一地点的时间段。通常是夏天（冰攀即冬天）旺季之后：旺季后的2-4周淡季：上个旺季到下个旺季之间的时间。长达几个月</p>
<p>以下次登山倒推，制定一个合理的时间表</p>
<p>每个时间单元都有不同的训练目标。“旺季之前”的时间持续半年之久，可将其分为三个阶段。</p>
<p>旺季之前：早期：打好基础。在此阶段，无论是心血管训练还是力量训练的频率、强度或持久度，都应控制在比较低的范围内</p>
<p>中期：提高心血管耐力、增强力量：要在强度较低的情况下，逐渐提高心血管训练的频率和延长训练时间</p>
<p>后期：提高心理承受能力和毅力应增加一到两周的无氧训练、增加负重训练以及周末长途徒步训练，在接近旺季时，还要增加耐力训练。</p>
<p>旺季：维持前期水准。所以训练目标应从峰值逐渐降低</p>
<p>淡季：展开特殊运动训练，注重平衡发展；优先锻炼弱势肌肉</p>
<h2 id="解析年度训练计划"><a href="#解析年度训练计划" class="headerlink" title="解析年度训练计划"></a>解析年度训练计划</h2><p>对不同区域的旺季代表不同的时间段</p>
<h2 id="训练后的恢复"><a href="#训练后的恢复" class="headerlink" title="训练后的恢复"></a>训练后的恢复</h2><p>让肌肉恢复糖原储备。安排休息日，可以进行交叉训练：散步、有用、跳舞、自行车。关注你的</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>体能训练</category>
        <category>体能调试</category>
      </categories>
  </entry>
  <entry>
    <title>哲学学习计划书</title>
    <url>/2023/05/04/%E5%93%B2%E5%AD%A6/%E5%93%B2%E5%AD%A6%E5%AF%BC%E8%AE%BA/%E5%93%B2%E5%AD%A6/</url>
    <content><![CDATA[<h1 id="哲学学习计划书"><a href="#哲学学习计划书" class="headerlink" title="哲学学习计划书"></a>哲学学习计划书</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>通过学习哲学，建立一种对认知的学习模式，帮助自己创造生活模式，并掌握一些方法论技能。</p>
<h2 id="学习内容"><a href="#学习内容" class="headerlink" title="学习内容"></a>学习内容</h2><h3 id="1-系统的哲学概论"><a href="#1-系统的哲学概论" class="headerlink" title="1. 系统的哲学概论"></a>1. 系统的哲学概论</h3><p>建议阅读《哲学导论》等经典著作，以系统地了解哲学的各个分支和理论体系。</p>
<h3 id="2-逻辑和语言哲学"><a href="#2-逻辑和语言哲学" class="headerlink" title="2. 逻辑和语言哲学"></a>2. 逻辑和语言哲学</h3><p>建议阅读《逻辑学教程》等著作，掌握推理和论证等基本方法。</p>
<h3 id="3-认知科学和意识哲学"><a href="#3-认知科学和意识哲学" class="headerlink" title="3. 认知科学和意识哲学"></a>3. 认知科学和意识哲学</h3><p>建议阅读《意识的自然与超自然》等著作，深入了解人类认知和思维的本质。</p>
<h3 id="4-方法论和人生哲学"><a href="#4-方法论和人生哲学" class="headerlink" title="4. 方法论和人生哲学"></a>4. 方法论和人生哲学</h3><p>建议阅读《如何阅读一本书》等著作，学习如何组织知识、规划时间、提高效率以及建立良好的人生哲学等。</p>
<h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><p>每天保持2个小时的学习时间，分为两个阶段：</p>
<ul>
<li><p>每天早上第一件事情是，花费30分钟时间进行思考和规划当天的事情，明确当天最重要的几个任务，并设定一个简单的计划和时间表。</p>
</li>
<li><p>每天晚上花费1个半小时进行哲学学习，可结合每日最重要的任务逐步完善学习计划，保证高效的学习时间。</p>
</li>
</ul>
<h2 id="学习建议"><a href="#学习建议" class="headerlink" title="学习建议"></a>学习建议</h2><ul>
<li><p>对于每一章节的内容，可以通过搜索引擎或者各种在线课程来加深理解。</p>
</li>
<li><p>与其他人进行讨论和交流，可以获得更多的观点和启发。</p>
</li>
</ul>
<p>如果您需要更多的学习资源或者教材推荐，可以在随时联系我。</p>
]]></content>
      <categories>
        <category>哲学</category>
      </categories>
      <tags>
        <tag>哲学</tag>
        <tag>哲学学习计划书</tag>
      </tags>
  </entry>
  <entry>
    <title>考证-系统集成项目管理工程师</title>
    <url>/2023/05/04/%E8%80%83%E8%AF%81/%E8%BD%AF%E8%80%83%E4%B8%AD%E9%A1%B9/%E8%80%83%E8%AF%81-%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    <content><![CDATA[<h1 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h1><p>选择题</p>
<ul>
<li>第1-5天：系统集成项目管理的基础知识（如组织管理、项目质量管理等），并做好笔记；</li>
<li>第6-10天：学习项目管理过程中的各种工具和技术（如PERT图、风险管理等），并做好相应练习；</li>
<li>第11-15天：深入学习项目管理的各个知识领域（如项目范围管理、项目成本管理等），并做好总结；</li>
<li>第16-20天：学习项目管理过程中的沟通和人际关系管理，以及如何应对项目冲突问题；</li>
<li>第21-25天：对整本教科书进行全面回顾及练习，强化记忆；</li>
<li>第26-28天：模拟考试题及其解析，做好巩固和提升；</li>
<li>第29-30天：再次回顾重点内容、总结经验、留下最后时刻的冲刺。</li>
</ul>
<p>案例分析</p>
<h1 id="学习笔记"><a href="#学习笔记" class="headerlink" title="学习笔记"></a>学习笔记</h1><h2 id="《系统集成项目管理工程师》必备100题——废弃，以键盘敲一遍根本无助于记忆"><a href="#《系统集成项目管理工程师》必备100题——废弃，以键盘敲一遍根本无助于记忆" class="headerlink" title="《系统集成项目管理工程师》必备100题——废弃，以键盘敲一遍根本无助于记忆"></a>《系统集成项目管理工程师》必备100题——废弃，以键盘敲一遍根本无助于记忆</h2><ol>
<li><p>项目的特点有哪些</p>
</li>
<li><p>临时性：有开始和结束的时间</p>
</li>
<li><p>独特性：每个项目都是不一样的</p>
</li>
<li><p>渐进明细：项目的成果目标是逐步完成的</p>
</li>
<li><p>项目的组织方式有哪些？分别有什么特点？</p>
</li>
<li><p>职能型组织——明确个人任务<br> 责任分明，利于沟通，因为明确要找哪个人。缺点：个人职能利益高于项目，部门协调难</p>
</li>
<li><p>项目型组织<br> 结构和目标单一、责权分明。但管理成本高，资源配置效率低，员工无事业上的连续保障，资源配置效率低</p>
<p> 资源配置效率低:</p>
<ol>
<li>人员利用率低：由于各个项目分工明确，员工可能只在完成项目时才会被调配到需要的项目中，而在每个项目之间有空档期。这会导致一些员工的利用率低，浪费了公司的人力资源。</li>
<li>资源浪费：由于每个项目都需要单独配置资源，例如设备、技术支持、办公空间等等，这些资源可能不能被充分利用。当一个项目结束后，这些资源可能就空闲下来，浪费了公司的资源。</li>
<li>调度困难：由于每个项目都是相对独立的，需要根据不同的项目需求来调度人员和资源。这需要花费更多的时间和精力来进行规划和安排，可能导致调度方面的效率较低。</li>
</ol>
</li>
<li><p>项目管理过程组有哪些？</p>
<ol>
<li>启动过程组：以项目或现有项目的阶段为启动项授权开始</li>
<li>规划过程组：明确1的泛微，优化目标，执行行动方案</li>
<li>执行过程组：开始2工作</li>
<li>监控过程组：对3持续跟踪，识别需要的变更并启动</li>
<li>收费过程组</li>
</ol>
</li>
<li><p>怎么样才能成为一位优秀的项目经理？</p>
<pre><code>    1.	 理解项目经理的角色（废话）
    1.	 领导和管理团队
    1.	 根据项目执行计划、监控执行情况以及是否变更
    1.	 理解“一把手工程”：通常是指由领导或高层管理人员直接负责的重大工程项目，也称为领导工程
    1.	 注重客户和用户参与
</code></pre>
</li>
<li><p>PMO的主要职责有哪些？——以项目集合为核心进行共享、管理、协调、监控</p>
<ol>
<li>共享和协调项目资源</li>
<li>明确和制定项目管理方法，最佳实践和标准</li>
<li>负责制定项目方针、流程、模板和其它共享资料</li>
<li>为所有项目进行集中的配置管理</li>
<li>项目工具的管理中心</li>
<li>对所有PMO项目的基线进行集中监控</li>
<li>协调整体项目的质量标准</li>
</ol>
</li>
<li><p>项目经理（PM）和PMO的区别</p>
<ol>
<li>PM在约束条件下完成项目成果性目标，PMO是具特殊授权的组织机构，其目标包含组织级的观点</li>
<li>PM关注于特定的项目目标，PMO关注经营目标</li>
<li>PM控制赋予项目的资源以实现项目目标，PMO优化各项目的资源使用</li>
<li>PM管理中间产品的范围、进度、费用和质量，PMO管理整体的风险、机会和所有的项目依赖关系</li>
</ol>
</li>
<li><p>项目建议书的内容——为什么要做</p>
<ol>
<li>项目简介</li>
<li>项目建设单位概括———概括性讲解</li>
<li>项目建设的必要性————核心</li>
<li>业务分析</li>
<li>总体建设方案</li>
<li>本期项目建设方案——执行方案的分析与设计</li>
<li>环保、消防、职业安全——公共问题</li>
<li>项目实施进度——进度管理</li>
<li>投资估算和资金筹集——资金</li>
<li>效益与风险分析——风险和收益</li>
</ol>
</li>
<li><p>项目可行性研究内容包括哪些？——怎么做的问题</p>
<ol>
<li>投资必要性</li>
<li>技术可行性</li>
<li>财务可行性</li>
<li>经济可行性</li>
<li>社会可行性</li>
<li>风险因素及对策</li>
</ol>
</li>
<li><p>初步可行性研究可能出现的结果包括哪些？</p>
<ol>
<li>肯定，项目小的可以直接开始</li>
<li>肯定，转入可行性研究</li>
<li>继2，开始专题研究</li>
<li>否定</li>
</ol>
</li>
<li><p>项目可行性研究阶段包括哪些</p>
<ol>
<li>机会可行性研究</li>
<li>初步可行性研究</li>
<li>详细可行性研究</li>
<li>项目可行性研究报告的编写，提交和获得批准</li>
<li>项目评估——确认前面的研究的数据无误等</li>
</ol>
</li>
<li><p>系统集成供应商在进行项目内部立项时一般包括哪些内容</p>
<ol>
<li>项目资源估算</li>
<li>项目资源分配</li>
<li>准备项目任务书</li>
<li>任命项目经理</li>
</ol>
</li>
<li><p>项目整体管理包括哪几个过程</p>
<ol>
<li>制定项目章程</li>
<li>制定项目管理计划</li>
<li>指导与管理项目工作。按管理计划办事，实时已批准变更</li>
<li>监控项目工作。跟踪、审查和报告项目进展，以实现绩效目标</li>
<li>实施整体变更控制。走变更流程及管理相关的变更，并对变更处理结果进行沟通</li>
<li>结束项目或阶段</li>
</ol>
</li>
<li><p>项目经济作为项目的整合者，需要做的工作有哪些</p>
<ol>
<li>通过与项目干系人主动、全面的沟通，来了解他们对项目的需求</li>
<li>在相互竞争的众多干系人之间寻找平衡点</li>
<li>通过认真，细致的协调工作，来达到各种需求间的平衡、实现整合</li>
</ol>
</li>
<li><p>项目章程的内容包括哪些——以项目为主的核心管理</p>
<ol>
<li>概括性的项目描述和项目产品描述</li>
<li>项目目的或批准项目的理由</li>
<li>项目的总体要求</li>
<li>可测量的项目目标和相关的成功标准</li>
<li>项目的主要风险</li>
<li>总体里程碑进度计划</li>
<li>总体预算</li>
<li>项目审批要求</li>
<li>委派的项目经理及其职责和职权</li>
<li>发起人或其它批准项目章程的人员的姓名和职权</li>
</ol>
</li>
<li><p>制定项目章程的输入、输出和工具技术</p>
<ol>
<li>输入：项目工作说明书、商业论证（价值和风险分析）、协议（合同）、事业环境因素（社会影响）、组织过程资产（如规程、政策、程序和数据都属于组织过程资产）</li>
<li>项目章程</li>
<li>工具和技术：专家判断、引导技术</li>
</ol>
</li>
<li><p>项目章程的作用</p>
<ol>
<li>确定项目于经理，规定项目经理的权力</li>
<li>正式确定项目的存在，给项目一个合法的地位</li>
<li>规定项目的总体目标，包括范围、时间、成本和质量等</li>
<li>通过叙述启动项目的理由，把项目与执行组织的日常经营运作及战略计划等都联系起来</li>
</ol>
</li>
<li><p>简述项目管理计划制定的步骤</p>
<ol>
<li>各具体只是领域制定各自的分项计划</li>
<li>整体管理知识领域收集各分项计划，整合成项目管理计划</li>
<li>用于项目管理计划指导项目的执行和监控工作，并在执行过程中监控</li>
<li>对提出的必要的变更请求，根实施整体变更控制过程审批</li>
<li>根据经批准的变更请i去，更新项目管理计划</li>
</ol>
</li>
<li><p>制定项目管理计划的输入、输出和工具技术是</p>
<ol>
<li>输入：项目章程、其它规划过程的成果、事业环境因素、组织过程资产</li>
<li>输出：项目管理计划</li>
<li>工具与技术：专家判断、引导技术</li>
</ol>
</li>
<li><p>项目管理计划的内容包括哪些</p>
<ol>
<li>管理子内容：范围、进度、成本、质量、人力资源、干系人、沟通、风险、采购管理计划</li>
<li>其它管理计划：质量改进计划；配置、变更、需求管理计划</li>
<li>重要基准：范围基准、进度基准、成本基准</li>
<li>为项目选用生命周期和过程：项目所选用的生命周期及各阶段将次啊用的过程、生命周期模型</li>
</ol>
</li>
<li><p>项目管理计划的主要用途有哪些</p>
<ol>
<li>指导项目执行、监控和收尾</li>
<li>为项目绩效考核和项目控制提供基准</li>
<li>记录制定项目计划所依据的假设条件</li>
<li>记录制定项目计划过程中的有关方案选择</li>
<li>促进项目干系人之间的沟通</li>
<li>规定管理层审查的项目时间、内容和方式</li>
</ol>
</li>
<li><p>整体变更控制流程</p>
<ol>
<li>提出变更请求</li>
<li>评估变更影响</li>
<li>将评估结果通知项目干系人</li>
<li>CCB审核</li>
<li>执行变更</li>
<li>记录变更实施情况</li>
<li>分发新文档</li>
</ol>
</li>
<li><p>变更的常见原因有哪些？</p>
<ol>
<li>产品范围（成果）定义的过失或者疏忽</li>
<li>项目范围（工作）定义的过失或者疏忽</li>
<li>客户提出新需求</li>
<li>应对风险的紧急计划或回避计划</li>
<li>项目执行过程与基准要求不一致带来的被动调整</li>
<li>项目团队人员调整</li>
<li>技术革新的要求</li>
<li>外部事件</li>
</ol>
</li>
<li><p>变更请求包括哪些</p>
<ol>
<li>纠正措施。针对实际已经出现的偏差</li>
<li>预防措施，预防措施是针对将来可能出现的偏差</li>
<li>缺陷补救。为了修正不一致的产品或产品组件而进行的有目的的活动。缺陷补救措施只针对项目质量问题</li>
<li>更新。对正式受控的项目文件或计划等进行变更，以发反应修改或增加的意见或内容</li>
</ol>
</li>
<li><p>合同收尾与行政收费的区别是</p>
<ol>
<li>主要是指收集项目，分析经验教训，收集、整理、分发和归档各种项目文件，以便正式确认项目产品合格性等，同时伴随组织过程资产的更新和人力及非人力资源的释放。每个项目阶段完成时，都要及时整理项目信息和经验教训，以防止项目信息丢失</li>
<li>合同收尾针对外包形式的项目，通常在行政收费之前进行，一个合同只需要一个合同收费，是由项目经理向卖方签发的合同结束的书面确认</li>
<li>合同收费和行政收费相比的关键差别在于，前者还包括产品核实</li>
</ol>
</li>
<li><p>项目范围管理的主要过程</p>
<ol>
<li>编制范围管理计划。如何定义、确认和控制项目范围过程进行描述</li>
<li>收集需求。明确并记录项目干系人的相关需求</li>
<li>定义范围。详细描述产品和项目范围，编制项目范围说明书</li>
<li>创建WBS。把整个项目工作分解为较小的、易于管理的组成部分</li>
<li>确认范围。正式验收已完成的可交付成果</li>
<li>范围控制。监督项目和产品的范围状态、管理范围基准变更</li>
</ol>
</li>
<li><p>什么是产品范围？什么是项目范围</p>
<ol>
<li>产品范围：为表示产品和服务的特征和功能。如何确定信息系统的范围在软件工程中成为需求分析</li>
<li>项目范围：为了完成具有所规定特征和功能的产品和服务必须完成的全部工作</li>
</ol>
</li>
<li><p>范围管理计划和需求管理计划的内容是</p>
<ol>
<li>范围管理计划是项目或项目管理计划的组成部分，描述了如何定义、制定、监督、控制和确认项目范围</li>
<li>需求管理计划是项目管理计划的组成部分，描述了如何分析、记录和管理需求，以及阶段与阶段建的关系对管理需求的影响。项目经理为项目选择最有效的阶段间关系，并将它记录在需求管理计划中</li>
</ol>
</li>
<li><p>范围说明书包括哪些内容</p>
<ol>
<li>范围说明书是对项目范围、主要可交付成果、假设条件和制约因素的描述</li>
<li>项目范围说明书记录了整个范围，包括项目和产品范围。项目范围说明书详细描述项目可交付成果，以及创建这些可交付成果而必须开展的工作<ol>
<li>项目目标</li>
<li>产品范围描述</li>
<li>项目需求</li>
<li>项目边界</li>
<li>可交付成果</li>
<li>制约因素</li>
<li>假设条件</li>
</ol>
</li>
</ol>
</li>
<li><p>工作分解结构（WBS）可采用哪些形式分解</p>
<ol>
<li>把项目生命周期的各阶段</li>
<li>把主要可交付成果作为分解第一层</li>
<li>按子项目第一层分解。子项目（如外包工作）可能由项目团队之外的组织实施。然后，作为外包工作的一部分，卖方需编制相应的合同工作分解结构</li>
</ol>
</li>
<li><p>WBS的分解原则</p>
<ol>
<li>层次上保持项目完整性，避免遗漏</li>
<li>一个工作单元只能从属于某个上层单元，避免交叉</li>
<li>相同层次的工作单元应有相同性质</li>
<li>工作单位应能分开不同的责任者和不同的工作内容</li>
<li>便于项目管理计划和项目控制的需要</li>
<li>最底层工作应该具有可比性及可管理，可定量检查</li>
<li>要包括外包出去的工作</li>
</ol>
</li>
<li><p>将项目工作分解成工作包，需要开展的活动</p>
<ol>
<li>识别和分析可交付成果及相关工作</li>
<li>确定WBS的结构和编排方法</li>
<li>自上而下逐层细化分解</li>
<li>为WBS组件制定和分配标识编码</li>
<li>核实可交付成果分解的程度是否恰当</li>
</ol>
</li>
<li><p>范围控制的输入、输出、工具和技术是</p>
<ol>
<li>输入：项目范围管理计划、需求文件、需求跟踪矩阵、工作绩效数据、组织过程资产</li>
<li>输出：工作绩效信息、变更请求、项目文件更新、组织过程资产更新</li>
<li>工具与技术：偏差分析</li>
</ol>
</li>
<li><p>范围确认的输入、输出、工具与技术是？</p>
<ol>
<li>输入：项目管理文件、需求文件、需求跟踪矩阵、核实的可交付成果、工作绩效数据</li>
<li>输出：验收的可交付成果、变更请求、工作绩效信息、项目文件更新</li>
<li>工具与技术：检查、群体决策技术</li>
</ol>
</li>
<li><p>什么是控制账户</p>
<ol>
<li>控制账户它是一种在WBS中执行组织对项目的管理控制点（层），在该点（层），范围、预算、实际成本和进度将被整合起来，绩效测量（挣值）也将在该店（层）进行。每一个控制账户都很可能包含一个或多个工作包。每个控制账户都与组织分解结构OBS中的单一组织单元相关联</li>
</ol>
</li>
<li><p>常见的工作分解结构（WBS）的表示形式有哪些</p>
<ol>
<li>树型结构图的WBS层次清晰，非常直观，结构性强，但不易于修改；对于大的、复杂的项目也很难表示出项目全景。由于其直观性，一般在一些中小型的应用项目中用得比较多</li>
<li>表格形式能够反映出所有的工作要素，但是直观性较差。在一些大的、复杂的项目中运用的比较多</li>
</ol>
</li>
<li><p>核实的可交付成果和验收的可交付成果的区别</p>
<ol>
<li>核实的可交付成果是指已经完成，并经质量过程检查为正确的可交付成果，是范围确认的输入。</li>
<li>验收的可交付成果是由客户或发起人以书面的形式正式签字批准的可交付成果，是范围确认的输出</li>
</ol>
</li>
<li><p>范围变更过程中经常遇到的问题</p>
<ol>
<li>项目范围蔓延</li>
<li>得不到投资人的批准</li>
<li>项目小组未尽责任</li>
</ol>
</li>
<li><p>项目进度管理有哪些过程</p>
<ol>
<li>规划进度管理</li>
<li>定义活动</li>
<li>排列活动顺序</li>
<li>估算活动资源</li>
<li>制定进度计划</li>
<li>控制进度</li>
</ol>
</li>
<li><p>控制进度的工具与技术是</p>
<ol>
<li>绩效审查、项目管理软件、资源优化技术、建模技术、提前量和滞后量、进度压缩、进度计划编制工具</li>
</ol>
</li>
<li><p>活动之间的四种依赖关系</p>
<ol>
<li>强制性依赖关系：是法律或合同要求的或工作的内在性质决定的依赖关系</li>
<li>选择性依赖关系：它通常是基于具体应用领域的最佳实践或者是基于项目的某些特殊性质而设定，即便还有其他顺序可选用，但项目团队仍缺乏按照此种特殊的顺序安排活动。如果打算进行快速跟进，则应当审查相应的选择性依赖关系，并考虑是否需要调整或去除</li>
</ol>
</li>
<li><p>资源平滑和资源平衡的区别</p>
<ol>
<li>资源平衡往往改变关键路径，通常是延长</li>
<li>资源平滑不改变关键路径，完工日期不会延迟</li>
<li>资源平衡可以实现所有资源的优化，资源平衡可能无法实现所有的资源的优化</li>
</ol>
</li>
<li><p>什么是接驳缓冲？什么是项目缓冲？</p>
<ol>
<li>项目缓冲：放置在关键链末尾的缓冲称为项目缓冲，用来保证项目不因关键链的延误而延误</li>
<li>接驳缓冲：则放置在非关键链接合点，用来保护关键链不受非关键链延误的影响</li>
</ol>
</li>
<li><p>缩短活动工期可采取哪些措施</p>
<ol>
<li><p>赶工，投入更多的资源或增加工作时间，以缩短关键活动的工期</p>
</li>
<li><p>快速跟进，并行施工，以缩短关键路径的长度</p>
</li>
<li><p>使用高素质的资源或经验更丰富的人员</p>
</li>
<li><p>减小活动范围或降低活动要求</p>
</li>
<li><p>改进方法或技术，以提高生产效率</p>
</li>
<li><p>加强质量管理、及时发现问题、减少返工、从而缩短工期</p>
<p>补充：</p>
</li>
<li><p>快速跟进可能造成返工和风险增加</p>
</li>
<li><p>减小活动范围或降低活动要求可能导致干系人不满</p>
</li>
<li><p>改进方法或技术风险增加风险</p>
</li>
</ol>
</li>
<li><p>进度压缩的最常用两种技术是</p>
<ol>
<li>赶工：一般在关键线路上增加资源，缩短关键路径以缩短进度，要权衡进度和费用，争取以最小的成本来最大限度地进行压缩进度</li>
<li>快速跟进：将原顺序完成的工作并行完成，以缩短进度，其后果往往造成返工，增加风险。但并非所有串行的活动都可改为并行，应考虑依赖关系（可选择的依赖关系而不是强制性的依赖关系）</li>
</ol>
</li>
<li><p>三点估算法</p>
<ol>
<li>三点估算法&#x3D;（悲观+乐观+4*最可能）&#x2F;6</li>
<li>估算时长&#x3D;（悲观+乐观+4*最可能）&#x2F;6</li>
<li>标准差&#x3D;（悲观时间-乐观时间）&#x2F;6</li>
<li>正负X个标准差的完工改了</li>
<li>1个标准差&#x3D;68.26</li>
<li>2个标准差&#x3D;95.43</li>
<li>3个标准差&#x3D;99.73</li>
<li>6个标准差&#x3D;99.99</li>
</ol>
</li>
<li><p>针对成本超支，可采用哪些措施</p>
<ol>
<li>yoga工作效率高的人员替换工作效率低的人员</li>
<li>改进方法，提高工作效率</li>
<li>加强成本控制</li>
</ol>
</li>
<li><p>如何求得总时差和自由时差</p>
<ol>
<li>总时差&#x3D;TF&#x3D;LF-EF&#x3D;LS-ES</li>
<li>自由时差 FF&#x3D;min{紧后的活动ES}-EF</li>
</ol>
</li>
<li><p>简述项目成本管理的过程</p>
<ol>
<li>制定成本管理计划：制定了项目成本结构、估算、预算和控制的标准</li>
<li>成本估算：编制完成项目活动所需的大致成本</li>
<li>成本预算：合计各个活动或工作包的估算成本，以建立成本基准</li>
<li>成本控制：影响造成成本偏差的因素，控制项目预算的变更</li>
</ol>
</li>
<li><p>挣值分析的计算公式</p>
<ol>
<li>挣值分析的三个基本指标：PV（BCWS）；EV（BCWP）；AC（ACWP）</li>
<li>成本偏差CV&#x3D;EV&#x2F;AC；进度偏差SV&#x3D;EV-PV</li>
<li>成本绩效指数CPI&#x3D;EV&#x2F;AC；进度绩效指数SPI&#x3D;EV&#x2F;PV</li>
<li>ETC&#x3D;BAC-EV或（BAC-EV）&#x2F;CPI</li>
<li>EAC&#x3D;AC+ETC或BAC&#x2F;CPI</li>
<li>VAC&#x3D;BAC-EAC</li>
<li>TCPI&#x3D;(BAC-EV)&#x2F;(BAC-AC)</li>
</ol>
</li>
<li><p>截至某时点，项目的SPI&lt;1，就能判断项目的总工期一定会延误吗？</p>
<ol>
<li>不一定，因为SPI测量是项目的总工作量，它不能区分关键路径和非关键路径工作包，所以还需要对关键路径上的绩效进行单独分析，以确定项目是否将比计划完成日期提早或延迟完工</li>
</ol>
</li>
<li><p>什么是应急储备和管理储备</p>
<ol>
<li>应急储备是包含在成本基准内的一部分预算，用来应对已经接受的已识别风险，以及已制定应急或减轻措施的已识别风险。应急储备通常是预算的一部分</li>
<li>管理储备用来应对项目范围中不可预见的工作、“未知——未知”风险。管理储备不包括在成本基准中，但属于项目总预算和资金需求的一部分，使用前需要得到高层审批</li>
</ol>
</li>
<li><p>简述成本估算和成本预算之间的区别与联系</p>
<ol>
<li>区别：估算成本是估算完成每项活动所需的近似成本，成本预算是将单个活动或工作包的估算成本汇总，更精确估算项目总成本，并分摊到项目各活动和各阶段上</li>
<li>联系：成本估算输出的是成本预算的基础，成本预算是将已批准的项目总估算成本进行分摊</li>
</ol>
</li>
<li><p>简述成本控制的主要工作内容</p>
<ol>
<li>对造成成本基准变更的因素施加影响</li>
<li>确保所有变更请求都得到及时处理</li>
<li>当变更实际发生时，管理这些变更</li>
<li>确保成本支出不超过批注你的资金限额，即不超出时段、按WBS组件、按活动分配的限额，也不超出项目总限额</li>
<li>监督成本绩效，找出并分析与成本基准间的偏差</li>
<li>对照资金支出，监督工作绩效</li>
<li>防止在成本或资源使用报告中出现未经批注的变更</li>
<li>向有关干系人报告所有经批准的变更及相关成本</li>
<li>设法把预期的成本超支控制在可接受的范围内</li>
</ol>
</li>
<li><p>简述项目质量管理包括哪些过程</p>
<ol>
<li>规划质量管理：识别及其可交付的质量要求和标准，并书面描述项目将如何证明符合质量要求</li>
<li>实施质量保证：审计质量要求和质量控制测量结果，确保采用合理的质量标准和操作性定义的过程</li>
<li>控制质量：监督并记录执行质量活动执行结果，以便评估绩效，并推荐必要的变更的过程</li>
</ol>
</li>
<li><p>质量成本具体可分为哪些成本</p>
<ol>
<li>质量成本可分为一致性成本和非一致性成本<ol>
<li>一致性成本：在项目期间用于防止失败的费用。可分为：<ol>
<li>预防成本（生产合格产品），常见有质量培训、流程文档化、计划编制设备、选择正确的做事时间、评价成本（评定质量），常见有测试、破坏性测试导致的损失、检查</li>
</ol>
</li>
<li>非一致性成本：项目期间和项目完成后用于处理失败的费用。可分为：<ol>
<li>内部失败成本（项目内部发现的），返工、废品、额外库存</li>
<li>外部失败成本（客户发现的），责任认定、产品召回、保修、投诉处理、现场服务、信誉损失、业务流失</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>指出QA的主要工作内容</p>
<ol>
<li>QA的工作一般包括：制定质量管理计划、按照计划实施质量管理活动（如质量检查、产品检查、参加评审和抽检等活动）、发现问题要记录和沟通直至问题解决、无法解决的问题要上报给高层领导、做好质量记录、为项目组人员提供质量方面的培训</li>
</ol>
</li>
<li><p>质量控制的老七工具和新七工具分别是？</p>
<ol>
<li>老七工具：流程图、因果图、直方图、散点图、帕累托图、控制图、核查图</li>
<li>新七工具：亲和图、过程决策程序图、关联图、树形图、优先矩阵图、活动网络图、矩阵图</li>
</ol>
</li>
<li><p>七种质量工具的作用</p>
<ol>
<li>因果图：用来发现问题的根本原因</li>
<li>流程图：用来显示输入转化为输出过程中所需要的步骤顺序和可能分支</li>
<li>核查图：用来收集数据的查对清单</li>
<li>帕累托图：用来识别造成大多数问题的少数重要原因</li>
<li>控制图：用来确定一个过程是否稳定或者是否具有可预测的绩效</li>
<li>散点图：用来解释坐标中因变量Y相对于自变量X的变化</li>
</ol>
</li>
<li><p>实施质量保证和质量控制二者的去呗</p>
<ol>
<li>二者都是项目管理的重要过程和手段，他们的区别联系如下<ol>
<li>质量计划是质量控制与质量保证的共同依据</li>
<li>达到质量要求是质量控制和质量保证的共同目标</li>
<li>一顶时间内质量控制的结果也是质量保证的质量审计对象。质量保证又可以指导下一阶段的质量工作，包括质量控制和质量改进</li>
<li>质量保证是按质量管理计划正确地做</li>
<li>质量控制检查是否做得正确并纠错</li>
<li>质量保证属于执行过程组，质量控制属于监督与控制过程组</li>
</ol>
</li>
</ol>
</li>
<li><p>规划质量管理过程的输入、输出、工具和技术是</p>
<ol>
<li>输入：项目管理计划、干系人登记册、风险登记册、需求文件、事业环境因素、可交付成果、项目文件、组织过程资产</li>
</ol>
</li>
</ol>
<h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><p> <a href="................%5C%E8%B5%84%E6%96%99%5C%E8%80%83%E8%AF%81%5C%E8%BD%AF%E8%80%83%E4%B8%AD%E9%A1%B9%5C%E9%9B%86%E6%88%90%E7%9F%A5%E8%AF%86%E7%82%B9100%E6%9D%A1-%E5%B8%8C%E8%B5%9B%E7%BD%91.pdf">集成知识点100条-希赛网.pdf</a> </p>
<p> <a href="................%5C%E8%B5%84%E6%96%99%5C%E8%80%83%E8%AF%81%5C%E8%BD%AF%E8%80%83%E4%B8%AD%E9%A1%B9%5C%E8%AE%A1%E7%AE%97%E9%A2%98%E5%85%AC%E5%BC%8F.pdf">计算题公式.pdf</a>  </p>
<p>[十大管理输入、输出、工具和技术汇总 口诀（简单）.pdf](................\资料\考证\软考中项\十大管理输入、输出、工具和技术汇总 口诀（简单）.pdf) </p>
<p> <a href="................%5C%E8%B5%84%E6%96%99%5C%E8%80%83%E8%AF%81%5C%E8%BD%AF%E8%80%83%E4%B8%AD%E9%A1%B9%5C%E5%A4%87%E8%80%83%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6(1).pdf">备考知识集锦(1).pdf</a> </p>
<p> <a href="................%5C%E8%B5%84%E6%96%99%5C%E8%80%83%E8%AF%81%5C%E8%BD%AF%E8%80%83%E4%B8%AD%E9%A1%B9%5C%E5%A4%87%E8%80%83%E7%9F%A5%E8%AF%86%E9%9B%86%E9%94%A6.pdf">备考知识集锦.pdf</a> </p>
<p> <a href="................%5C%E8%B5%84%E6%96%99%5C%E8%80%83%E8%AF%81%5C%E8%BD%AF%E8%80%83%E4%B8%AD%E9%A1%B9%5C%E5%BF%85%E8%83%8C100%E9%A2%98.pdf">必背100题.pdf</a> </p>
<h1 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h1>]]></content>
      <categories>
        <category>考证</category>
        <category>系统集成项目管理工程师</category>
      </categories>
      <tags>
        <tag>考证</tag>
        <tag>系统集成项目管理工程师</tag>
      </tags>
  </entry>
  <entry>
    <title>Metasploit 渗透测试指南</title>
    <url>/2022/02/21/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%B8%97%E9%80%8F/Metasploit%20%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="1-渗透测试的基础"><a href="#1-渗透测试的基础" class="headerlink" title="1. 渗透测试的基础"></a>1. 渗透测试的基础</h2><h3 id="1-1PTES标准中的渗透测试阶段"><a href="#1-1PTES标准中的渗透测试阶段" class="headerlink" title="1.1PTES标准中的渗透测试阶段"></a>1.1PTES标准中的渗透测试阶段</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>前期交互阶段</td>
<td>与客户谈好渗透涉及目标，制定现实可行的渗透计划</td>
</tr>
<tr>
<td></td>
<td>情报搜集阶段</td>
<td>对目标系统进行信息收集并且隐藏自己</td>
</tr>
<tr>
<td></td>
<td>威胁建模阶段</td>
<td>通过已知的情报来标识可能存在的威胁</td>
</tr>
<tr>
<td></td>
<td>漏洞分析阶段</td>
<td>考虑如何取得目标系统的访问权，通过前几个阶段的猜测，找到重点分析的端口及可能的漏洞</td>
</tr>
<tr>
<td></td>
<td>渗透攻击阶段</td>
<td>渗透攻击不是大量盲目碰运气的阶段，而是有把握的出手。如果被拦截就要重新思考</td>
</tr>
<tr>
<td></td>
<td>后渗透攻击阶段</td>
<td>你已经拿到了部门权限了，但是你要开始渗透这整个系统。找到你要的</td>
</tr>
<tr>
<td></td>
<td>报告阶段</td>
<td>对上面成功进行总结，并给客户提供建议</td>
</tr>
</tbody></table>
<h3 id="1-2-渗透测试类型"><a href="#1-2-渗透测试类型" class="headerlink" title="1.2 渗透测试类型"></a>1.2 渗透测试类型</h3><p>白盒测试：在拥有所有内部知识的情况下的渗透测试黑盒测试：模拟入侵者的行为</p>
<h3 id="1-3-漏洞扫描器"><a href="#1-3-漏洞扫描器" class="headerlink" title="1.3 漏洞扫描器"></a>1.3 漏洞扫描器</h3><p>这个可以扫描指定系统或应用中可能的安全漏洞的自动化工具。不要过于依赖</p>
<h2 id="2-metasploit基础"><a href="#2-metasploit基础" class="headerlink" title="2 metasploit基础"></a>2 metasploit基础</h2><p>不要关注那些最新的渗透模块，而是关注metasploit是如何进行攻击的</p>
<ul>
<li>一些术语<ul>
<li>渗透攻击：即攻击机利用一个系统或服务的漏洞进行的攻击</li>
<li>攻击载荷：我们期望目标系统在被渗透攻击之后去执行的代码</li>
<li>shellcode：作为攻击载荷时运行的一组机器指令</li>
<li>模块：metasploit框架中所使用的一段软件代码组件</li>
<li>监听器：metasploit用来等待连入网络连接的组件</li>
</ul>
</li>
</ul>
<h3 id="2-1-metasploit用户接口"><a href="#2-1-metasploit用户接口" class="headerlink" title="2.1 metasploit用户接口"></a>2.1 metasploit用户接口</h3><h3 id="2-2-1-MSF终端接口"><a href="#2-2-1-MSF终端接口" class="headerlink" title="2.2.1 MSF终端接口"></a>2.2.1 MSF终端接口</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfconsole	#终端输入</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-MSF图形接口（Armitage）"><a href="#2-2-2-MSF图形接口（Armitage）" class="headerlink" title="2.2.2 MSF图形接口（Armitage）"></a>2.2.2 MSF图形接口（Armitage）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">armitage</span><br></pre></td></tr></table></figure>

<h2 id="2-3-metasploit功能程序"><a href="#2-3-metasploit功能程序" class="headerlink" title="2.3 metasploit功能程序"></a>2.3 metasploit功能程序</h2><h3 id="2-3-1-metasploit攻击载荷生成器"><a href="#2-3-1-metasploit攻击载荷生成器" class="headerlink" title="2.3.1 metasploit攻击载荷生成器"></a>2.3.1 metasploit攻击载荷生成器</h3><p>msf攻击载荷生成器允许你能够生成shellcode、可执行代码和其他更多的东西，也可以让他们在框架软件之外的渗透代码中使用例如：攻击web，以JavaScript语言方式输出是最好的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">msfvenom -h	#查看这个功能程序需要哪些配置选项</span><br><span class="line">msfvenom windows/shell_reverse_tcp o #查看必选和可选的选下那个列表</span><br></pre></td></tr></table></figure>
<p>###2.3.2 MSF编码器Metasploit的开发者们提供了MSF编码器，可以帮助你通过对原始攻击载荷进行编码的方式，来避免坏字符，以及避杀毒软件和IDS的检测。输入msfencode-h可以查看MSF编码器的配置选项列表。</p>
<p> 从2015年6月8日之后，msfpayload已经被移除了。以后只要使用msfvenom就行了，它集成了msfpayload和msfencode的功能。  </p>
<p>###2.3.3 Nasm Shellnasm shell..rb功能程序在你尝试了解汇编代码含义时是个非常有用的手头工具，特别是当你进行渗透代码开发时，你需要对给定的汇编命令找出它的opcode操作码，那你就可以使用这个功能程序来帮助你。</p>
<p>##3. 情报搜集</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>渗透</category>
      </categories>
  </entry>
  <entry>
    <title>保护自然-不留痕迹</title>
    <url>/2022/10/09/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E4%BF%9D%E6%8A%A4%E8%87%AA%E7%84%B6/%E4%BF%9D%E6%8A%A4%E8%87%AA%E7%84%B6-%E4%B8%8D%E7%95%99%E7%97%95%E8%BF%B9/</url>
    <content><![CDATA[<h2 id="制定务实的目标"><a href="#制定务实的目标" class="headerlink" title="制定务实的目标"></a>制定务实的目标</h2><p>每支队伍都有的极限，为了人员安全，就只好不顾对环境的破坏</p>
<h2 id="控制队伍人数"><a href="#控制队伍人数" class="headerlink" title="控制队伍人数"></a>控制队伍人数</h2><p>在确保安全的前提下，队伍的上限人数是多少</p>
<h2 id="考虑多种状态"><a href="#考虑多种状态" class="headerlink" title="考虑多种状态"></a>考虑多种状态</h2><p>获取当地相当信息，以帮助决定团队登山的地点、时间以及使用何种不留哼唧的技巧</p>
<ul>
<li>环境比较敏感与脆弱的区域，包括动物、植物与地质</li>
<li>土壤的状态与含水量</li>
</ul>
<p>你携带的包装越少越好</p>
<h2 id="行进或扎营"><a href="#行进或扎营" class="headerlink" title="行进或扎营"></a>行进或扎营</h2><h3 id="使用山径原则"><a href="#使用山径原则" class="headerlink" title="使用山径原则"></a>使用山径原则</h3><p>遵守以下使用山径原则：</p>
<ul>
<li>尽量走现成的山径</li>
<li>不要随意踩踏山径外的区域，即使是遇到泥泞或其他难行路况</li>
<li>保护路旁的植被。山径通常只允许一个人行走，不能并排行进，不要随意拓宽山径。</li>
<li>勿随便选择路径。随意选择路径不会节省时间，反而会耗费许多体力。随意开路会让泥土裸露</li>
<li>尽量在雪地上行走。在春秋季节，经过土壤水分饱和的雪土交界带是十分危险的，要格外小心。</li>
<li>带一个口袋，随时拉拾其他登山者丢弃的垃圾。</li>
<li>在行进中遇到沙暴时，不要乱跑。</li>
<li>选择在自然恢复能力较强的地方休总。如果因为环境容易遭到破坏或植被过于茂密而无法离开山径，请在山径上比较宽阔的地方休息。</li>
<li>当上山下山的两支登山者相遇时，通常是下山的队伍站在路旁，让上山的队伍先行。</li>
<li>沿着溪边行走要格外小心，避免造成水土流失</li>
</ul>
<p>山径外行走原则：</p>
<ul>
<li>保持缓慢的速度，随时留意周围的环境，选择对环境破坏最小的路线。</li>
<li>在山径外行走，尤其是在容易受损的草地上行进时，请分开，让每个人走在不同的路径上，除非那里已被其他登山者走出了明显的路径</li>
<li>请勿践踏草本植物。在山径外行走时，请寻找裸露的地表、岩石或有莎草科植物覆盖的坚硬地面行走。</li>
<li>在春季、晚秋通过土壤水分达到饱和的雪土交界带，要格外留心。</li>
<li>不要沿路堆石堆，更不要在树上刻字。</li>
<li>去程时做标记请在回程时拆除。</li>
</ul>
<h3 id="使用营地原则"><a href="#使用营地原则" class="headerlink" title="使用营地原则"></a>使用营地原则</h3><p>坚守“60米原则”：营地要距离水源、道路及其他登山者至少60米尽量使用现成的营地</p>
<h3 id="选择营地指南"><a href="#选择营地指南" class="headerlink" title="选择营地指南"></a>选择营地指南</h3><p>开发成熟的现有营地&gt;雪地&gt;岩面&gt;沙地、泥地或碎石底&gt;森林中的酸性腐植层&gt;有植物覆盖的草地&gt;林线上有植被覆盖的草地&gt;湖泊或者溪流沿岸</p>
<h3 id="原始环境搭建帐篷"><a href="#原始环境搭建帐篷" class="headerlink" title="原始环境搭建帐篷"></a>原始环境搭建帐篷</h3><ul>
<li>一个原始环境最多停留一到两天，然后必须换到其他地方</li>
<li>帐篷不要搭在一起</li>
<li>分散如厕地点和行走路线，以免在同一条路线上过度踩踏植被。</li>
<li>在有坡度的地方扎营，不然帐篷底下可能会积水，这就必须要挖排水沟。</li>
<li>不要把不平的地面铲平。</li>
</ul>
<p>离营时，应尽力将营地恢复成原有的状态。在原始环境中遵循不留痕迹原则需要下一番工夫才行，例如用天然物质掩盖使用过的地方、抹去痕迹，并把被压成垫状的草弄松等。</p>
<h2 id="使用炉具"><a href="#使用炉具" class="headerlink" title="使用炉具"></a>使用炉具</h2><p>炉具不会消耗自然资源，也不会让山里烟雾迷茫。此外，炉具的使用不受天气限制，比生营火更容易、更快、更方便。营火对自然的破坏其实挺大的</p>
<h2 id="妥善处理排泄物"><a href="#妥善处理排泄物" class="headerlink" title="妥善处理排泄物"></a>妥善处理排泄物</h2><p>登山若经常在恶劣的环境中行进，例如高山、沙漠和极地。在这些地方，人类排泄物的分解速度都很慢，甚至根本不会分解</p>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>保持60米原则，并且远离水源、山径、营地和人群聚集区。在裸地和岩石上小便，不要对准植物。如果在攀岩或冰面，请在尿液能顺着攀岩路径下流的地点小解。</p>
<p>可以使用河沙、球果、阔叶、雪代替卫生纸。如果一定要用卫生纸，请使用天然色泽及无味的。不要焚烧卫生纸，将它们放在胶袋里带下山去。</p>
<h3 id="猫坑掩埋法"><a href="#猫坑掩埋法" class="headerlink" title="猫坑掩埋法"></a>猫坑掩埋法</h3><p>适合低海拔且有较厚腐植层的地方</p>
<p>如果一个地方你能轻易找到，别人也一样。走得远一点</p>
<p>先用铲子和冰斧将草皮或地表整理出一个直径为10至15厘米的圆，再将表层草皮移开放在一边。猫坑的深度不要超过20厘米，大体上和腐植层相当，因为腐植层中的东西分解速度最快。方便完后，用松软的土壤把排泄物盖上，用棍子或铲子稍加混合，接着把草皮盖上，最后封好猫坑，整理附近的植被，恢复原貌。</p>
<h3 id="将排泄物背下山"><a href="#将排泄物背下山" class="headerlink" title="将排泄物背下山"></a>将排泄物背下山</h3><p>在热门的冰河路线，高山贫瘠的矿物土壤地带、沙漠、岩壁、冰攀路线、极区冻原等地方，以及冬季登山时，将排泄物装好背出去已成为登山者的首选做法。</p>
<h4 id="使用双层袋"><a href="#使用双层袋" class="headerlink" title="使用双层袋"></a>使用双层袋</h4><p>跟人们处理宠物狗的排泄物一样可以在内层塑料袋使用氨水海绵、石灰或猫砂来抑制气味</p>
<h4 id="裂隙掩埋法"><a href="#裂隙掩埋法" class="headerlink" title="裂隙掩埋法"></a>裂隙掩埋法</h4><h4 id="遵循“60米原则”"><a href="#遵循“60米原则”" class="headerlink" title="遵循“60米原则”"></a>遵循“60米原则”</h4><p>在清洗时，请遵循“60米原则”。洗碗时，可用热水代替洗洁精废水一定要远离水源，并位于营地下方处。废水也可以以弧形猛泼出去，让废水形成水雾</p>
<p>跳入湖泊或溪流前，先把身体清洗干净，不然这些油脂与化学物质会对水生植物造成伤害</p>
<h2 id="山林守护者"><a href="#山林守护者" class="headerlink" title="山林守护者"></a>山林守护者</h2><h3 id="保护荒野原貌"><a href="#保护荒野原貌" class="headerlink" title="保护荒野原貌"></a>保护荒野原貌</h3><p>露营之后请尽量恢复原貌</p>
<p>少用锯子、斧头、钉子</p>
<p>不要破坏植物，采摘植物</p>
<h3 id="善待野生动物"><a href="#善待野生动物" class="headerlink" title="善待野生动物"></a>善待野生动物</h3><p>不要投喂动物不要打扰攀登路线上筑巢</p>
<h3 id="为同伴着想"><a href="#为同伴着想" class="headerlink" title="为同伴着想"></a>为同伴着想</h3><p>减少自己的声音听音乐用耳机</p>
<h4 id="将影响降至最低"><a href="#将影响降至最低" class="headerlink" title="将影响降至最低"></a>将影响降至最低</h4><p>自己背炉具绳子使用自然色的松动的石头试着塞紧</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>保护自然</category>
      </categories>
  </entry>
  <entry>
    <title>观察路线</title>
    <url>/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E5%AF%BB%E8%B7%AF/%E8%A7%82%E5%AF%9F%E8%B7%AF%E7%BA%BF/</url>
    <content><![CDATA[<p>先用你的眼睛攀登。远距离眺望可以看到到山脊、悬崖、雪原、冰川的大致走势以及坡度。近距离观察，可以看见断层线、悬崖带和出现的裂隙。从以下方面寻找路线索：较两边山坡平缓的棱线；可以向上或横越坡面的岩隙、岩石凸出点或烟囱状局部地形，雪原或冰河易于通行的区位。找出攀登路段，然后将其连接起来。随着经验的积累，你将拥有一双可以轻易地找到与自己的攀登能力相适应的攀登路线的眼睛。</p>
<p>如果路线是从山脚开始，尝试从不同的角度去观察。当你从正面观察时，即使是平缓的斜坡看起来也十分陡峭。有时，从正面来断崖壁面上没办法清晰分辨的连串岩块凸点，从侧面就能看得一清二楚。</p>
<h2 id="注意危险地形"><a href="#注意危险地形" class="headerlink" title="注意危险地形"></a>注意危险地形</h2><p>休息时间应安排在穿过危险地形之前或之后。当你进人危险地带后，尽量不要被其他速度较的队员拖慢你的速度。如果可能，尽量不要在下大雨时通过危险路段。</p>
<p>对危险地形要随时保持警惕，并继续寻找安全前进的路线，如果目前线路存在隐患，就要今早寻找替代路线</p>
<h2 id="规划回程路线"><a href="#规划回程路线" class="headerlink" title="规划回程路线"></a>规划回程路线</h2><p>适合上攀并不意味着容易下行。行进途中要经常回头看看，携带好GPS和高度计，对一些标志景物做好笔记。随时考虑安全问题</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>寻路</category>
      </categories>
  </entry>
  <entry>
    <title>搜集路线信息</title>
    <url>/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E5%AF%BB%E8%B7%AF/%E6%90%9C%E9%9B%86%E8%B7%AF%E7%BA%BF%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>登山前搜集的信息越多，越有利于在登山过程中作出正确的判断。多花时间研究准备攀登地区的地质和气候。每条山脉都有自己的特性</p>
<p>登山指南提供了详细的信息，线路。预计时间，海拔高度，路线长度</p>
<p>不同的地图都可以提供有用的细节（航拍、登山者自绘、地形图）</p>
<p>一些有用的额路线信息通畅是通过与当地人交谈获取的</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>寻路</category>
      </categories>
  </entry>
  <entry>
    <title>活动计划</title>
    <url>/2022/09/15/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E5%89%8D%E5%87%86%E5%A4%87/%E6%B4%BB%E5%8A%A8%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>##活动计划资料收集→整理分析（线路选择：难度强度；风景指数：气象资料；交通状况：活动完成时间：费用预算)→确定活动目标→制定活动计划书</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>行前准备</category>
      </categories>
  </entry>
  <entry>
    <title>步行</title>
    <url>/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0/%E6%AD%A5%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="步行"><a href="#步行" class="headerlink" title="步行"></a>步行</h2><p>踏上山径之前，先舒展双跟、臀部、背部和肩膀；多喝水；在容易起水泡的部位贴好斜纹布条；花点时间调整背包与登山鞋，免太紧导致肌肉酸痛而在行进途中停下来调整。</p>
<p>出发前就要做好途中休息的准备。将-一整天会反复用到的东再，.例如爱食、水、外套、帽子、手套、绑腿、太阳眼镜与买灯等放在背包外面便于取放的口袋里。这不仅方便你本人取放，也方便队友取放，并且不用卸下背包或是停下来。把冰斧和登山挂在背包上并绑好，在遇到崎岖地形可直接取下使用。就算尚未进入雪地，冰斧也相当有用。</p>
<h2 id="设定速度"><a href="#设定速度" class="headerlink" title="设定速度"></a>设定速度</h2><p>从一天始就要设定好攀登速度，适当的速度可以让一天的攀登都保持愉快</p>
<p>如果你不能在接下来的几个小时里维持相同的速度，又或者你无法在交谈时维持正常的呼吸，那就说明你的速度太快了</p>
<p>另一个常见的错误就是速度太慢。这不仅会延长行进的时间，也会压缩处理行程中需要技术性攀登路线的时间。如果你是因为疲倦而放慢脚步，请记得身体还有很大的潜能。肌肉开始酸痛的时候，人其实还能继续走16公里</p>
<p>在登山途中，一定程度的不适是无法避免的。走得太快或太慢都会让你更加疲倦。</p>
<p>刚出发时，慢慢地走，可以当做热身。在开始流汗时，休息一会儿并脱掉一些衣服。之后就可以加快步伐，忍受身体的疼痛，让身体进入“重新振作”阶段。此时，你的心跳加快，血液循环加速，肌肉放松。当脑内啡开始起作用之后，身体的压力会减小，你会觉得自己不仅强壮有力，而且心情也很放松。</p>
<p>依据具体的山径情况调整速度。上坡时步调缓慢而有条不紊，在台阶变缓的时候要加快行进步伐。综合考虑背包的重量、地、气和其他因素后，确定一个适宜的行进速度。</p>
<p>疲惫会让一天行程的最后阶段的速度不可避免地慢下来。肾上腺素虽然可以暂时微发身体能量，但“重新振作”状态在一天之内只会出现一次。</p>
<h2 id="休息步法"><a href="#休息步法" class="headerlink" title="休息步法"></a>休息步法</h2><p>休息步法的精髓在于每踏出一步后都会伴随一次短暂的停顿，但并非完全停下</p>
<p>使用休总步法时要有耐心。这种单调重复的步骤很可能让队伍士气低落，尤其是当你只是单纯地在雪地跟随着另一位队友向上行进，而不用寻找攀登路线或踢步阶的时候。在脑子里哼一首轻快的歌曲吧，特别是在离登顶还很远的时候，相信这个步法能带领你成功登顶。</p>
<p>休息步法：a.把全身重量集中在右腿，呼气，放松左腿：b.吸气并迈出右腿走下一一步，将身体重量集中在左腿上：C呼气，放松右腿。</p>
<h2 id="途中休息"><a href="#途中休息" class="headerlink" title="途中休息"></a>途中休息</h2><p>在队伍行进半小时后，要停下来让队员调整鞋带和背包带，增减衣服。在行进之初，身体很精神，每隔一小时或一个半小时可以短暂休总一次。采用站立或半躺的姿势休息，靠着树或坡以减轻背包给肩膀带来的负重。保持顺畅的呼吸，吃点零食或喝点水。要注意预防脱水，最好每次休息时都要补充水分。</p>
<p>在队伍行进一段时间后，就可能需要更长的休息时间了，此时可以每隔两小时就充分休息一次。找一个环境较好的地方，例如水边、容易卸卜背包的斜坡、风景优美的地方等。舒展舒展筋骨，可以适当添加衣物，但在出发时要脱掉，不要才走几步就停下来脱衣服。</p>
<h2 id="下坡要领"><a href="#下坡要领" class="headerlink" title="下坡要领"></a>下坡要领</h2><p>长时间下坡会给登山者的身体带来疼痛。这是因为在下坡时，身休和背包的重量都压在了双腿、膝盖与脚上，脚趾不但会受到挤压，走路时的震动甚至会通过脊椎传遍整个身体。通过以下几个技巧，可以避免很多伤害，例如起水泡、膝盖软骨受伤、脚趾痛、趾甲出血变黑、头痛、背痛等。</p>
<ul>
<li>出发前修剪脚趾甲。</li>
<li>绑紧鞋带，防止脚在鞋子里滑来滑去，</li>
<li>避免脚趾受到挤压。</li>
<li>落步时膝盖略弯，可以诚缓震动。</li>
<li>如果脚开始有痛感，下脚时要轻。</li>
<li>使用雪杖或登山杖，减轻膝盖的负担，还能稳定身体</li>
<li>下坡的速度要慢一些 ，不要一时兴起就冲下去</li>
<li>必要时使用冰斧保持平衡或制动。冰斧的使用范围不限于雪地，在陡峭的草坡上、森林里或灌木丛中都可以用来辅助攀登。</li>
</ul>
<h2 id="横渡的注意事项"><a href="#横渡的注意事项" class="headerlink" title="横渡的注意事项"></a>横渡的注意事项</h2><p>上攀或下坡都远不如横渡困难。沿着斜坡一侧行走容易扭伤脚踝、髋部，并且不易保持身体平衡如果可能，不要横渡，改为下降到无灌木的山谷或爬上圆缓的山脊。无可避免，寻找岩点、兽迹、灌木丛上方易同行地面，使用之字形走法</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>行走</category>
      </categories>
  </entry>
  <entry>
    <title>通过困难地形</title>
    <url>/2022/10/08/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0/%E9%80%9A%E8%BF%87%E5%9B%B0%E9%9A%BE%E5%9C%B0%E5%BD%A2/</url>
    <content><![CDATA[<h2 id="灌木丛"><a href="#灌木丛" class="headerlink" title="灌木丛"></a>灌木丛</h2><p>在偏远地区，灌木丛简直是登山者的噩梦，密生的灌木丛会遮住危险的悬崖、巨石和沟壑。灌木本身也会缠住绳子或冰斧。以下是登山者常用的避开灌木丛的方法：</p>
<p>尽量跟着山径走：走8km山经可能快过穿越1km灌木丛在积雪覆盖灌木丛时穿过避开雪崩路线寻找大树，大树旁的灌木丛会比较稀疏走在碎石或残雪上寻找兽径走山脊的主棱或支棱沿着溪流行走直接在河道上行走走地势较高的路线走悬崖的底部</p>
<h2 id="碎石坡"><a href="#碎石坡" class="headerlink" title="碎石坡"></a>碎石坡</h2><p>碎石区的石块比较大，通常，一只脚踩上没有问题，石砾区的石块比较小，有些就像粗砂一样，大一点的直径有几厘米，只要一踩上去就会陷下去。石块较大的碎石坡是经年累月形成的，泥土已经将碎石的间隙填满，摩擦较大，不容易滑动，形成了一条天然的易走的山径。但形成时间不长的碎石坡或火山上的碎石坡因为没有长出植物，石块很容易松动。如果走在这样的石坡上，最好是踩在那些长出苔藓的石块上，因为这样的石块比较稳固，没有经常移动，否则就长不出苔藓。</p>
<p>保持警惕，脚下石头松落随时准备跳开。走一步要规划四五步。可以使用登山杖探路</p>
<p>队伍不要拉太长，避免落石增加动能，造成更严重的伤害</p>
<p>砾石区下坡可以采取大步滑踩下降，类似于滑雪的技巧</p>
<h2 id="积雪路径"><a href="#积雪路径" class="headerlink" title="积雪路径"></a>积雪路径</h2><p>如果积雪覆盖了整条路径，就要注意寻找积雪未覆盖的地面物体，这些物体的位置往往是雪层较薄的地方。</p>
<p>溪水的冲刷会不断融化雪桥的底层，直到雪桥丧失支撑登山者的功能。为了避免掉入水中，在过雪桥时先观察雪面是否有凹陷、颜色是否有变化，并仔细听是否有流水的声音。如果雪原底部有水流出表示下面有洞，从水量的大小可以看出洞的大小。可以用冰斧刺探较薄的雪层，以确定下面是否有空洞。</p>
<p>##过溪过溪会消耗大量的时问和精力，而且危险程度也最高。</p>
<p>###寻找过溪点尽可能从可以达到的高处来判断过溪点。尽可能从最宽处过溪（窄处路径短，但水流急）</p>
<p>判断溪水的来源，如果是融雪，那么可以等待第二天清晨过溪</p>
<h3 id="过溪"><a href="#过溪" class="headerlink" title="过溪"></a>过溪</h3><p>解开背包腰带和胸口，如果摔倒可以快速卸掉背包，便于游泳</p>
<p>利用倒木过溪：最好的方式，如果不平等等状态，采取登山杖等工具。必要可以骑在倒木上用手撑着慢慢移动</p>
<p>利用石头过溪：过溪前，必须在脑中预定线路</p>
<p>涉水过溪：注意装备防水。难度大：可以穿着登山鞋过溪（把袜子和鞋垫放进背包）水深：建议脱掉长裤或其他衣物，减少水中行走的阻力水深但水不急：保持和水流大致相同的速度，朝着下游方向斜横过溪（阻力最小的方法）</p>
<p>最好的过溪姿势：面朝上游、身体略微倾斜、登山杖朝上游方向插入水中作为第三个支撑点</p>
<p>只要水超过膝盖，溪水就有一定得危险</p>
<p><strong>结队过溪</strong>：木头：两个或两个以上的登山者可以利用木头来互相保证安全，任何人失去平衡都可以靠木头来恢复绳索（常用）：</p>
<h3 id="落水"><a href="#落水" class="headerlink" title="落水"></a>落水</h3><p>安全姿势：双脚朝向下游，保持仰泳姿势。如果遇到拦截物，迅速恢复头先脚后，借助“拦截物”尝试上岸</p>
<p>倒木摔倒：朝下游一方跌下，避免冲到倒木下</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>行走</category>
      </categories>
  </entry>
  <entry>
    <title>队伍管理</title>
    <url>/2022/09/15/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0%E4%BA%8B%E9%A1%B9/%E9%98%9F%E4%BC%8D%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>##队形分工领队（户外团队活动都有一名正领队，两名以上副领队）：前副队开路，后副队收队，正领队中间穿插调整队伍距离。前队：负责探路，而且需要等待后队后队：通常是队伍行走能力最强的，不能让任何队员落后在后面体力最弱：需要走到中间靠前的位置。队伍速度要配合体力最弱的人</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>行进事项</category>
      </categories>
  </entry>
  <entry>
    <title>食物</title>
    <url>/2022/09/22/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E9%9C%B2%E8%90%A5%E4%B8%8E%E9%A3%9F%E7%89%A9/%E9%A3%9F%E7%89%A9/</url>
    <content><![CDATA[<p>休息充分、饮水充足、饮食营养均衡，虚脱、中暑、感冒等症状就少有发生</p>
<p>登山需要充足的食物来保证摄取足够的碳水化合物、蛋白质和脂肪。易保存、易携带、丰富</p>
<table>
<thead>
<tr>
<th>食物营养</th>
<th>每日摄取的热量百分比</th>
</tr>
</thead>
<tbody><tr>
<td>碳水化合物</td>
<td>50-70</td>
</tr>
<tr>
<td>脂肪</td>
<td>20-30</td>
</tr>
<tr>
<td>蛋白质</td>
<td>20-30</td>
</tr>
</tbody></table>
<h2 id="营养成分"><a href="#营养成分" class="headerlink" title="营养成分"></a>营养成分</h2><p>碳水化合物：最容易转换成热量淀粉类碳水化合物：全麦、米、马铃薯、谷类、面包、燕麦等糖类碳水化合物：蜂蜜、糖、热巧克力、运动饮料、水果、果干、果酱</p>
<p>蛋白质：蛋白质不能直接在人体内储存，多余蛋白质不是转化成热量消耗，就是变成脂肪储存花生酱、坚果、牛肉干、肉罐头、豆子、豆腐、奶粉、蛋、奶酪</p>
<p>脂肪：人体重要的热量来源，热量是等量碳水化合物和蛋白质的两倍。脂肪不易消化，可以让人长时间不会有饥饿感。可以在较长时间维持身体的温暖蔬菜、谷类、谷类都含有少量脂肪，如果再加上鱼类、红肉或家禽肉，可以轻易获取足够的脂肪</p>
<p>脂肪不易消化，白天应吃富含碳水化合物的食物，晚间宜吃富含脂肪和蛋白质的食物以储存热量。如果预计夜间寒冷，睡前一些高热量的小点心是一个小诀窍</p>
<p>在登山前一到两个小时，登山者就应该摄取足够一天消耗的碳水化合物和水，这样才能给肌肉提供足够的能量。登山者所需的水化合物可以从食物中摄取，也可以从运动饮料中摄取。有些高能量运动饮料，可以同时补允水分、碳水化合物和电解质。建登山者先试饮，因为有些登山者对某个牌子的饮料会有不适反应。这类“高能量”饮料稀释后饮用，效果会更好。</p>
<h2 id="一般登山的食物规划"><a href="#一般登山的食物规划" class="headerlink" title="一般登山的食物规划"></a>一般登山的食物规划</h2><p>通常，每人每天需要一千克食物短途行程：自制三明治、新鲜蔬果。注重即食长行程：冷冻脱水食物更容易烹调、体积小、重量轻、但价格贵（登山者可以用食物脱水机自己开发菜品，可以进一步使用真空封包）</p>
<h2 id="食品的打包"><a href="#食品的打包" class="headerlink" title="食品的打包"></a>食品的打包</h2><p>可以用塑料袋、封口袋、或密封盒对食物进行包装，准备一个称，称出食物的重量。然后可以贴标签，如“早餐”“晚餐”“电信”</p>
<h2 id="菜单建议"><a href="#菜单建议" class="headerlink" title="菜单建议"></a>菜单建议</h2><p>不同的食物清单可以在短程登山或健行中使用，检验后再运用到长途登山活动中</p>
<h3 id="早餐"><a href="#早餐" class="headerlink" title="早餐"></a>早餐</h3><p>营养丰富什锦果麦、葡萄干或其他干果、奶粉只要加入热水即是一顿早餐燕麦粥、烤土司、面包饼干、肉感、坚果、水果糖、能量棒、脱水食物除碳水化合物外，试着在早餐中加入一些高蛋白食物</p>
<p>热饮：速溶可可粉、麦芽牛奶、咖啡、茶、蛋酒粉</p>
<h3 id="午餐和点心"><a href="#午餐和点心" class="headerlink" title="午餐和点心"></a>午餐和点心</h3><p>登山时，早餐后隔一会就应该进食，要少食多餐</p>
<p>午晚的食量应占一天食量的一半以上</p>
<p>什锦糖中混合坚果、巧克力、葡萄干和其他水果干，十分耐嚼，少吃零食，大口大口地吃可以当正餐</p>
<p>什锦麦片也是不错的点心</p>
<p>饮用水中添加一些水果香料。如柠檬、酸梅，可以增强喝水的欲望，与午餐搭配，有助于下咽</p>
<p>基本的午餐食品蛋白质类：鱼罐头、肉罐头、牛肉干、熟香肠、肉酱、芝麻酱、奶酪、坚果等高脂肪食品，适合午餐食用，不宜作为点心</p>
<p>淀粉类：全麦面包、培果、什锦麦片和其他谷类、饼干、糙米糕、洋芋片或椒咸脆片</p>
<p>甜品：小饼干、糖果、巧克力、松饼、糕饼、果酱、蜂蜜等</p>
<p>水果：新鲜水果、水果软糖、果干</p>
<p>蔬菜：新鲜胡萝卜、甜椒切片、脱水蔬菜</p>
<h3 id="晚餐："><a href="#晚餐：" class="headerlink" title="晚餐："></a>晚餐：</h3><p>菜单中应有含水量高德食物，例如热汤、热苹果酒、可可粉、茶、果汁、热调味洋菜等</p>
<p>通心面、米饭、青豆、马铃薯或谷物，都是富含碳水化合物的食物。如果再加上罐头肉或脱水鸡肉、牛肉、鱼肉、香肠，拎冻脱水蔬菜或水果、奶油或乳玛琳、快餐汤或什锦酱就更完美了</p>
<p>可以在晚餐中加入冷冻脱水蔬菜，可以多吃事先煮熟的冷冻脱水豆子或黄豆制品</p>
<p>调料：盐、胡椒、香料、蒜、辣椒、咖喱粉、培根片、脱水洋葱、奶酪、辣椒酱或酱油</p>
<p>餐后甜点：饼干、糖果、苹果酱、快餐布丁、脱水冰淇淋、热茶。</p>
<h3 id="杯式快餐"><a href="#杯式快餐" class="headerlink" title="杯式快餐"></a>杯式快餐</h3><p>方便、快速，只用把水烧开就行</p>
<h2 id="不要将食物放在帐篷内"><a href="#不要将食物放在帐篷内" class="headerlink" title="不要将食物放在帐篷内"></a>不要将食物放在帐篷内</h2><p>吊树法：离地3至4米高，离树干约1.2米远。利用石头和绳子将食物升起悬空。另一头找固定物绑树或压住</p>
<p>熊绳：找两个约三米的书，在两者之间拉一个离地约4米高德绳子</p>
<p>除了食物，牙刷、牙膏、乳液也是有气味的物品。用餐结束后，要使用不留味道的清洁剂彻底清洗锅底。身上、衣物、装备上的食物味道必须清除</p>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>露营与食物</category>
        <category>食物</category>
      </categories>
  </entry>
  <entry>
    <title>饮水</title>
    <url>/2022/09/21/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E9%9C%B2%E8%90%A5%E4%B8%8E%E9%A3%9F%E7%89%A9/%E9%A5%AE%E6%B0%B4/</url>
    <content><![CDATA[<h2 id="饮水"><a href="#饮水" class="headerlink" title="饮水"></a>饮水</h2><p>和平时相比，登山时所摄取的水量应该更充足，在登山前24小时大量喝水能迅速增强体能。即使自己不觉得渴，也可以试着多喝一些。在高海拔干燥、冷的环境中，皮肤和肺部都会释放出人量水汽。等到口渴了才喝水是错误的法，因为口渴代表身体已经处于脱水状态了。最好的方法是通过尿液来判：呈淡黄色或无色，表示身体水分充足；若呈深黄色，则表示身体已经开始缺。在高海拔地区脱水会让人有恶心感，让人根本不想再喝水。</p>
<p>随着大量流汗而丧失的电解质，可以用衡的饮食来补充。夏季登山或者长程山要格外注意补充电解质，运动饮料是不错的选择，但并非每个人都能快、效吸收其中的电解质。在喝运动饮料前先用水稀释或饮用后再喝一部分水，会有助于人体吸收电解质。</p>
<p>一天往返的形成，登山者带1.5至3升水就够喝了。若是三天的行程，没人至少6升水，还得加上营地引用或做菜消耗的5升水</p>
<h2 id="饮水的来源"><a href="#饮水的来源" class="headerlink" title="饮水的来源"></a>饮水的来源</h2><p>融雪</p>
<h2 id="水中的病原"><a href="#水中的病原" class="headerlink" title="水中的病原"></a>水中的病原</h2><p>水可能被动物或人类的排泄物污染了</p>
<p>野外水源中有三种须引起登山者重视的病原，病毒、细菌和寄生虫病毒：病毒一般只存在于热带地区的水源中，例如甲型肝炎（传染性肝炎）。这种肝炎就是因饮用被病毒污染的水源而感染的疾病。在北美，荒野区的水源通常没有病毒，但还是要小心为上。过滤器能够过滤掉水中的杂质，但无法过滤病毒，可以用添加化学药剂和把水烧开的方法杀此病毒。</p>
<p>细菌：荒野的水源中含有多种细菌，沙门式打菌（潜伏期为12至36小时）、曲杆菌（潜伏期为3至5天)和大肠杆菌（潜伏期为1至3天）都可以经水传。荒野地区，不洁的水可能会传染霍乱、痢疾、伤寒等病症。除了使用化学药和把水烧开两种方法杀死细菌外，由于细菌的体形比病毒大，还可以直接用滤器过滤。</p>
<p>寄生虫：常见的寄生虫有原虫、阿米巴虫、绦虫、扁虫等。攀登高山的登山者要格外注意梨形鞭毛虫和隐孢子虫，这两种奇生虫遍布世各地。梨形鞭毛虫病和隐孢子虫病的潜伏期为2至20天，症状包括严重恶心、腹泻、胃抽筋、发烧、头痛、胀气，打隔的气味如腐兴的鸡蛋等。有些奇生虫的细胞壁很坚韧，化学药剂根本对付不了它们，可以使用过滤器过滤和把水烧开来获取干净水。</p>
<h2 id="净水方法"><a href="#净水方法" class="headerlink" title="净水方法"></a>净水方法</h2><p>水中若有许多沉淀物，先用衣物、手帕和咖啡滤纸过来后再用过滤器或加化学药剂</p>
<p>化学药剂消毒法是一种便捷的方法，但效果并不是特别理想，而且残留的药剂对身体有一定的损害。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功效</th>
<th>优点</th>
<th>缺陷</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>烧开水</td>
<td>对所有病原都非常有效</td>
<td>最有效方法</td>
<td>麻烦，速度慢，要带燃料</td>
<td>烧开水再多烧一分钟，有效净水</td>
</tr>
<tr>
<td>加碘剂</td>
<td>能够有效杀死细菌与病毒；可杀死梨形鞭毛虫，但耗时；对环孢子虫无效。</td>
<td>轻，便于携带。配合滤水器可以对付所有病原。价格低廉</td>
<td>速度慢，除非与维生素C配合使用，否则处理后的水有异味，对碘过敏者不适合这个方法</td>
<td>通常的做法是将碘放入水瓶中，但水瓶不可直接浸人水中取水，因为瓶口会被污染。在加入碘后，盖上瓶盖，上下摇动或把瓶子倒过来。用碘处理过的水喝起来会有异味，等到碘完全发挥作用后加人果汁粉，冲淡碘的味道。</td>
</tr>
<tr>
<td>氯气</td>
<td>对付细菌和病毒效果较好；可杀死梨形鞭毛虫，但耗时；对环孢子虫和隐孢子虫无效。</td>
<td>轻，便于携带。配合滤水器可以对付所有病原。价格低廉</td>
<td>耗时，处理后有异味</td>
<td>可以等氯气完全挥发后再加入氧化氢来消除异味</td>
</tr>
<tr>
<td>二氧化氯</td>
<td>对所有病原体有效；轻</td>
<td>处理后的水没什么异味</td>
<td>耗时</td>
<td>使用前5分钟先将二氧化氯跟磷酸混合，二者进行化学反应后产生的养才能发挥消毒作用，将氯气加入水中之后等待5至30分钟</td>
</tr>
<tr>
<td>过滤法</td>
<td>对大型寄生虫效果较好</td>
<td>速度快，没异味</td>
<td>价格昂贵，体积大，容易堵塞</td>
<td>为了获得最佳的过滤效果，滤水器的绝对孔隙尺寸应小于0.4微米。过滤后的水中的碘剂就可以杀死病毒</td>
</tr>
<tr>
<td>紫外线净化法</td>
<td></td>
<td>可以杀死大部分细菌、病毒</td>
<td>必须依靠电池</td>
<td>不同紫外线净水器都有各自主要针对的原生生物种类</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>户外</category>
        <category>登山知识与技巧</category>
        <category>露营与食物</category>
        <category>饮水</category>
      </categories>
  </entry>
  <entry>
    <title>PPTPD</title>
    <url>/2022/01/26/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/Linux/Pptpd/</url>
    <content><![CDATA[<p><strong>安装PPTP</strong>sudo apt-get updatesudo apt-get install pptpd<strong>配置PPTP</strong>sudo vim &#x2F;etc&#x2F;pptpd.conf——取消掉 Recommended  行的注释，并根据需要修改内网网关以及地址池sudo vim &#x2F;etc&#x2F;ppp&#x2F;chap-secrets</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">client server secret IPaddresses ---标题</span><br><span class="line">name pptpd password * </span><br><span class="line">用户名 连接方式 密码 指定IP(*即无指定)</span><br></pre></td></tr></table></figure>
<p><strong>设置DNS解析</strong>sudo vim &#x2F;etc&#x2F;ppp&#x2F;pptpd-options取消掉ms-dns行的注释，dns修改成8.8.8.8 8.8.4.4<strong>开启转发功能（必须，否则无法连接外网）</strong>sudo vim &#x2F;etc&#x2F;sysctl.conf————取消掉【net.ipv4.ip_forward&#x3D;1】的注释<strong>更新配置</strong>sudo sysctl -p<strong>开启gre协议并打开服务器47,1723号端口</strong>sudo iptables -A INPUT -p gre -j ACCEPTsudo iptables -A INPUT -p tcp –dport 1723 -j ACCEPTsudo iptables -A INPUT -p tcp –dport 47 -j ACCEPT<strong>开启NAT转发</strong>sudo iptables -t nat -A POSTROUTING -s 192.168.88.0&#x2F;24 -o eno1 -j MASQUERADEsudo iptables -t nat -A POSTROUTING -s 192.168.0.0&#x2F;24 -o  eth0 -j MASQUERADEeno1 &#x3D;当前服务器的网卡192.168.88.1&#x2F;24 &#x3D; 虚拟vpn的主机的ip设置mtu值sudo iptables -A FORWARD -s 192.168.0.0&#x2F;24 -p tcp -m tcp –tcp-flags SYN,RST     SYN -j TCPMSS –set-mss 1200  sudo iptables-save		永久生效<strong>重启服务生效</strong>service pptpd restart</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Pptpd</tag>
        <tag>服务</tag>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>Apache2</title>
    <url>/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/WEB%E6%9C%8D%E5%8A%A1/Apache2/</url>
    <content><![CDATA[<p>sudo apt install apache2 -y	#安装vim &#x2F;etc&#x2F;apache2&#x2F;sites-available&#x2F;000-default.conf	#修改默认路径</p>
<blockquote>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ServerAdmin webmaster@localhost</span><br><span class="line">DocumentRoot /var/www/html    // 一般我们默认为这个作为网站的根目录</span><br></pre></td></tr></table></figure>

<p>sudo apache2ctl -k restart 		#重启Apache</p>
<p>参考文章：<a href="https://blog.csdn.net/weixin_39212776/article/details/81192847">Ubuntu 18.04下使用Apache搭建一个web服务器</a></p>
]]></content>
      <tags>
        <tag>服务</tag>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>WEB服务</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/WEB%E6%9C%8D%E5%8A%A1/HTML/</url>
    <content><![CDATA[<p>action&#x3D;”cgi-bin&#x2F;post.py” method&#x3D;”post”	#设置传递目标与模式import cgi, cgitb 		# 添加GI处理模块form &#x3D; cgi.FieldStorage() 		# 创建FieldStorage的实例化str_data_1  &#x3D;  form.getvalue(‘data_1’)	#获取html页面传递过来的数据值<a href="https://blog.csdn.net/Ikaros_521/article/details/102917453"></a>参考资料：<a href="https://ikaros.blog.csdn.net/article/details/102917453?spm=1001.2101.3001.6650.6&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.no_search_link&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-6.no_search_link">HTML发送表单给python处理</a></p>
]]></content>
      <tags>
        <tag>服务</tag>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>WEB服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Nignx</title>
    <url>/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/WEB%E6%9C%8D%E5%8A%A1/Nignx/</url>
    <content><![CDATA[<p>apt-get install nginx	#安装Nginxapt install spawn-fcgi	#通用FastCGI进程管理器apt-get install fcgiwrap	# Fcgiqwrap是另外一个CGI封装库，跟Simple CGI类似。spawn-fcgi -a 127.0.0.1 - p 8888 -f &#x2F;usr&#x2F;sbin&#x2F;fcgiwrap		#绑定服务IP和端口指定fcgiwrap目录netstat -tlnp | grep fcgiwrap	#查看端口状态service nginx restart	#重启Nginx&#x2F;etc&#x2F;init.d&#x2F;nginx stop	#关闭Nginx&#x2F;etc&#x2F;init.d&#x2F;nginx start  	#打开Nginx</p>
<p>参考资料：<a href="https://blog.csdn.net/qq_23832313/article/details/83578836">ubuntu安装nginx</a><a href="https://www.cnblogs.com/yadongliang/p/9212795.html">nginx重启几种方法</a></p>
]]></content>
      <tags>
        <tag>服务</tag>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>WEB服务</tag>
      </tags>
  </entry>
  <entry>
    <title>网页基础</title>
    <url>/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/WEB%E6%9C%8D%E5%8A%A1/%E7%BD%91%E9%A1%B5%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="1-网页的组成"><a href="#1-网页的组成" class="headerlink" title="1 网页的组成"></a>1 网页的组成</h1><p>网页可以分为三大部分一HTML、CSS和JavaScript。如果把网页比作一个人的话，HTML相当于骨架，JavaScript相当于肌肉，CSS相当于皮肤，三者结合起来才能形成一个完善的网页。</p>
<p>1.1 HTMLHTML是用来描述网页的一种语言，其全称叫作Hyper Text Markup Language,即超文本标记语言。网页包括文字、按钮、图片和视频等各种复杂的元素，其基础架构就是TML。不同类型的文字通过不同类型的标签来表示，如图片用img标签表示，视频用ideo签表示，段落用p标签表示，它们之间的布局又常通过布局标签dV嵌套组合而成，各种签通过不同的排列和嵌套才形成了网页的框架。在Chrome浏览器中打开百度，右击并选择“检查”项（或按Fl2键），打开开发者模式，这时在Elements选项卡中即可看到网页的源代码，如图2-9所示。</p>
<p>1.2 CSSHTML定义了网页的结构，但是只有HTML页面的布局并不美观，可能只是简单的节点元素的排列，为了让网页看起来更好看一些，这里借助了CSS。CSS,全称叫作Cascading Style Sheets,即层叠样式表。“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等格式。</p>
<p>1.3 JavascriptJavaScript,简称JS,是一种脚本语言。HTML和CSS配合使用，提供给用户的只是一种静态信息，缺乏交互性。我们在网页里可能看到一些交互和动画效果，如下载进度条、提示框、轮播图等，这通常就是JavaScript的功劳。它的出现使得用户与信息之间不是一种浏览与显示的关系，而是实现了一种实时、动态、交互的页面功能。JavaScript通常也是以单独的文件形式加载的，后缀为js,在HTML中通过script标签即可引入，例如：<script src="jquery-2.1.0.js"></script></p>
<h1 id="2-网页的结构"><a href="#2-网页的结构" class="headerlink" title="2 网页的结构"></a>2 网页的结构</h1><p>略</p>
<h1 id="3-节点树及节点间的关系"><a href="#3-节点树及节点间的关系" class="headerlink" title="3 节点树及节点间的关系"></a>3 节点树及节点间的关系</h1><p>在HTML中，所有标签定义的内容都是节点，它们构成了一个HTML DOM树。DOM是W3C(万维网联盟)的标准，其英文全称Document ObjectModl,即文档对象模型。它定义了访问HTML和XML文档的标准：W3C文档对象模型(DOM)是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。</p>
<p>W3CDOM标准被分为3个不同的部分：口核心DOM:针对任何结构化文档的标准模型。▣XML DOM:针对XML文档的标准模型。口HTML DOM:针对HTML文档的标准模型。</p>
<p>根据W3C的HTML DOM标准，HTML文档中的所有内容都是节点。口整个文档是一个文档节点。口每个HTML元素是元素节点。口HTML元素内的文本是文本节点。口每个HTML属性是属性节点。口注释是注释节点。</p>
<p>HTML DOM将HTML文档视作树结构，这种结构被称为节点树<img src="https://s2.loli.net/2022/07/09/o2Y84FQPwDlX9GN.png#id=ZV2v7&originHeight=309&originWidth=582&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>通过HTML DOM,树中的所有节点均可通过JavaScript访问，所有HTML节点元素均可被修改，也可以被创建或删除。</p>
<p>节点树中的节点彼此拥有层级关系。我们常用父、子和兄弟等术语描述这些关系。父节点拥有子节点，同级的子节点被称为兄弟节点。在节点树中，顶端节点称为根(roott)。除了根节点之外，每个节点都有父节点，同时可拥有任意数量的子节点或兄弟节点。<img src="https://s2.loli.net/2022/07/09/AXnjo3iDCSz1ka9.png#id=kzM9w&originHeight=297&originWidth=521&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="4-选择器"><a href="#4-选择器" class="headerlink" title="4 选择器"></a>4 选择器</h1><p>依据不同规则，可以对各个元素进行选择自行百度CSS选择器的其他语法规则</p>
<p>还有一种比较常用的选择器是XPath</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务</category>
        <category>WEB服务</category>
      </categories>
  </entry>
  <entry>
    <title>frp服务器与客户端的配置</title>
    <url>/2022/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/frp/frp%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h1><p><a href="https://github.com/fatedier/frp/releases">frp</a></p>
<h1 id="2-服务端配置"><a href="#2-服务端配置" class="headerlink" title="2. 服务端配置"></a>2. 服务端配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">frps.ini服务端配置</span></span><br><span class="line">[common]</span><br><span class="line">bind_addr = 0.0.0.0</span><br><span class="line">bind_port = 7000</span><br><span class="line">privilege_token = 12345678</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup /path/to/your/fprs -c-c /path/to/your/frps.ini </span><br></pre></td></tr></table></figure>

<h1 id="3-客户端配置"><a href="#3-客户端配置" class="headerlink" title="3. 客户端配置"></a>3. 客户端配置</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">frpc.ini客户端配置</span></span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_addr = 服务端IP</span><br><span class="line">server_port = 7000</span><br><span class="line">privilege_token = 12345678</span><br><span class="line"></span><br><span class="line">[tcp]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 80	#被穿透端口</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">remote_port = 8080	#穿透服务端口</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nohup /path/to/your/fprc -c-c /path/to/your/frpc.ini </span><br></pre></td></tr></table></figure>

<h1 id="4-开机自启动"><a href="#4-开机自启动" class="headerlink" title="4. 开机自启动"></a>4. 开机自启动</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /lib/systemd/system/frps.service </span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=fraps service</span><br><span class="line">After=network.target syslog.target</span><br><span class="line">Wants=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">启动服务的命令（此处写你的frps的实际安装目录）</span></span><br><span class="line">ExecStart=/your/path/frps -c /your/path/frps.ini</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">客户端即将【/your/path/frps】更换成【/your/path/frpc】</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start frps	#启动</span><br><span class="line">sudo systemctl enable frps	#自启动</span><br><span class="line">sudo systemctl restart frps	#重启应用</span><br><span class="line">sudo systemctl stop frps	#停止应用</span><br></pre></td></tr></table></figure>

<p>- </p>
<p>[</p>
<p>](<a href="https://blog.csdn.net/x7418520/article/details/81077652">https://blog.csdn.net/x7418520/article/details/81077652</a>)</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务器</category>
        <category>frp</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2022/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/</url>
    <content><![CDATA[<hr>
<h2 id="基础语句"><a href="#基础语句" class="headerlink" title="基础语句"></a>基础语句</h2><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><hr>
<p><strong>创建\删除\查看\修改</strong>use mysql; 	#进入mysql数据库</p>
<p>CREATE USER ‘username‘@’host’ IDENTIFIED BY ‘password’;  	#创建用户</p>
<p>drop user root;	#删除用户</p>
<p>select host, user, authentication_string from mysql.user;	#查看用户登陆主机\用户名\密码(不同版本mysql语句有出入)</p>
<p>SET PASSWORD FOR ‘username‘@’host’ &#x3D; PASSWORD(‘newpassword’); 	#设置与更改用户密码</p>
<p>flush privileges;	#刷新系统权限表  </p>
<hr>
<h3 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">用户授权</span><br><span class="line"><span class="keyword">GRANT</span> privileges <span class="keyword">ON</span> databasename.tablename <span class="keyword">TO</span> <span class="string">&#x27;username&#x27;</span>@<span class="string">&#x27;host&#x27;</span> 		#授权语句规则</span><br><span class="line">格式：<span class="keyword">grant</span> 权限 <span class="keyword">on</span> 数据库.<span class="operator">*</span> <span class="keyword">to</span> 用户名@登录主机 identified <span class="keyword">by</span> &quot;密码&quot;;　</span><br><span class="line">说明:</span><br><span class="line">privileges：用户的操作权限，如<span class="keyword">SELECT</span>，<span class="keyword">INSERT</span>，<span class="keyword">UPDATE</span>等，如果要授予所的权限则使用<span class="keyword">ALL</span></span><br><span class="line">databasename：数据库名</span><br><span class="line">tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用<span class="operator">*</span>表示，如<span class="operator">*</span>.<span class="operator">*</span>  </span><br><span class="line">例子：</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> privileges <span class="keyword">on</span> tornado.<span class="operator">*</span> <span class="keyword">to</span> <span class="string">&#x27;haidon&#x27;</span>@<span class="string">&#x27;%&#x27;</span> identified <span class="keyword">by</span> <span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<p>revoke all on tornado.* from “haidon”@”%”;		#收回用户权限</p>
<hr>
<h3 id="数据库管理"><a href="#数据库管理" class="headerlink" title="数据库管理"></a>数据库管理</h3><p><strong>创建\删除\查看\修改</strong>create database 数据库名;		#创建数据库create database article character set utf8;		#创建并设置utf8格式</p>
<p>drop database &lt;数据库名&gt;;  		#删除数据库</p>
<p>show databses;	#查看所有数据库</p>
<hr>
<h3 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h3><p>select * from tb_info;	#查看指定的表的现有数据</p>
<p>desc 表名;	#查看指定表结构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">写入数据</span><br><span class="line">INSERT INTO table_name ( field1, field2,...fieldN )</span><br><span class="line">                        VALUES</span><br><span class="line">                        ( value1, value2,...valueN );</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>服务</tag>
        <tag>计算机</tag>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlserver备份</title>
    <url>/2022/06/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/sqlserver%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p>删除旧测试数据库–&gt;数据库选项右键选择还原–&gt;源设备选择备份文件完成添加后还原<img src="https://s2.loli.net/2022/06/24/FbcDLTpzHi8lYME.webp#id=btxJg&originHeight=459&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://s2.loli.net/2022/06/24/LfIUuc1xoswqAgj.webp#id=Dr5uk&originHeight=408&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>散乱</title>
    <url>/2022/01/08/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%A3%E4%B9%B1/</url>
    <content><![CDATA[<ol>
<li>DDL（数据定义语言）</li>
</ol>
<p>DDL用来创建和修改数据库结构例如：<strong>CREATE DATABASE；CREATE TABLE</strong></p>
<hr>
<ol start="2">
<li>数据的逻辑独立性是指数据与程序的逻辑独立性。</li>
</ol>
<hr>
<ol start="3">
<li>innodb ，是MySQL的数据库引擎之一，现为MySQL的默认存储引擎 -支持事务处理、支持外键、支持崩溃修复能力和并发控制的存储引擎</li>
</ol>
<hr>
<ol start="4">
<li>MySQL中设置停止二进制文件的操作</li>
</ol>
<p>setsql_log_bin&#x3D;0;#设为0后，在Master数据库上执行的语句都不记录binlog(二进制日志文件)</p>
<hr>
<ol start="5">
<li><p>数据库对象与数据库三级模式对应关系正确的是</p>
<blockquote>
<p>表属于模式、索引属于内模式、视图属于外模式</p>
</blockquote>
<ol>
<li><strong>模式（Schema）</strong></li>
</ol>
</li>
</ol>
<p>定义：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。理解：① 一个数据库只有一个模式；② 是数据库数据在逻辑级上的视图；③ 数据库模式以某一种数据模型为基础；④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。</p>
<ol start="2">
<li><strong>外模式（External Schema）</strong></li>
</ol>
<p>定义：也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。理解：① 一个数据库可以有多个外模式；② 外模式就是用户视图；③ 外模式是保证数据安全性的一个有力措施。</p>
<ol start="3">
<li><strong>内模式（Internal Schema）</strong></li>
</ol>
<p>定义：也称存储模式（Storage Schema），它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照B树结构存储还是按hash方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。理解：① 一个数据库只有一个内模式；② 一个表可能由多个文件组成，如：数据文件、索引文件。它是数据库管理系统(DBMS)对数据库中数据进行有效组织和管理的方法其目的有：② 为了减少数据冗余，实现数据共享；② 为了提高存取效率，改善性能。</p>
<hr>
<ol start="6">
<li>DELETE FROM student<blockquote>
<p>删除student内的数据，不删除表结构</p>
</blockquote>
</li>
</ol>
<p>删除表DROP TABLE table_name（包括结构）</p>
<hr>
<ol start="7">
<li>关系数据库中，主键<blockquote>
<p>为标识表中唯一的实体</p>
</blockquote>
</li>
</ol>
<p>关系型数据库中的一条记录中有若干个属性，若其中某一个属性组(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键 比如  :学生表(学号，姓名，性别，班级) 其中每个学生的学号是唯一的，学号就是一个主键 成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以 学号和课程号的属性组是一个主键   成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的外键   同理 成绩表中的课程号是课程表的外键   定义主键和外键主要是为了维护关系数据库的完整性，总结一下：1.主键是能确定一条记录的唯一标识，比如，一条记录包括身份正号，姓名，年龄。</p>
<p>身份证号是唯一能确定你这个人的，其他都可能有重复，所以，身份证号是主键。 2.外键用于与另一张表的关联。是能确定另一张表记录的字段，用于保持数据的一致性。</p>
<p>比如，A表中的一个字段，是B表的主键，那他就可以是A表的外键。</p>
<hr>
<ol start="8">
<li>数据库中缓冲区写入磁盘使用的算法是LRU</li>
</ol>
<p> LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的<a href="https://baike.baidu.com/item/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95/7626091">页面置换算法</a>，选择最近最久未使用的页面予以淘汰。  </p>
<hr>
<ol start="9">
<li>系统故障的恢复操作正确的是<blockquote>
<p>正向扫描日志文件，对故障发生前已经提交的事务记入重做队列，故障发生时未完成的事务计入撤销队列</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="10">
<li>InnoDB引擎使用哪一种算法管理缓冲池<blockquote>
<p>LRU（最近最少使用）</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="11">
<li>在MySQL数据库中，InnoDB数据缓冲池用于数据读写描述正确的是<blockquote>
<p>采用LRU算法策略</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="12">
<li>查询优化策略中，正确的策略是<blockquote>
<p>尽可能的早做选择和投影（基本思路）</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="13">
<li>以下不符合数据类型选择总体原则的是<blockquote>
<p>尽量避免把列设置为NOT NULL</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="14">
<li>下列有关中继日志文件介绍错误的是<blockquote>
<p>中继日志文件拥有与二进制日志文件不同的结构</p>
</blockquote>
</li>
</ol>
<p>中继日志： 从服务器I&#x2F;O线程将主服务器的二进制日志读取过来记录到从服务器本地文件，然后从服务器SQL线程会读取relay-log日志的内容并应用到从服务器，从而使从服务器和主服务器的数据保持一致  </p>
<hr>
<ol start="15">
<li>数据库中数据的物理独立性是指<blockquote>
<p>用户的应用程序与存储在磁盘上数据库中的数据是相互独立的</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="16">
<li>MySQL可视化管理工具MySQL GUI Tools中方便数据库迁移的图形化应用程序是MySQL Migration Toolkit</li>
</ol>
<p>MySQL Migration Toolkit(数据迁移工具)</p>
<hr>
<ol start="17">
<li>显示复制线程状态（分行显示）的命令是（Show slave status\g    ）。</li>
<li>MySQL replication复制中主机和从机是通过什么进行数据同步的（ Binlog ）</li>
</ol>
<p>Binlog （二进制日志文件）</p>
<hr>
<ol start="19">
<li>索引设计属于数据库设计的（物理设计 ）阶段</li>
</ol>
<p>数据库物理设计指的是设计数据库的物理结构，根据数据库的逻辑结构来选定RDBMS（如Oracle、Sybase等），并设计和实施数据库的存储结构、存取方式等。  </p>
<hr>
<ol start="20">
<li>对好的加密算法描述不正确的是<blockquote>
<p>对授权用户来说，加密模式应依赖于算法的保密</p>
</blockquote>
</li>
</ol>
<hr>
<ol start="21">
<li>用于控制用户对数据库表建立或删除索引的权限为index权限</li>
</ol>
<p>INDEX权限，顾名思义就是在某个表上具有维护索引的权限。</p>
<hr>
<ol start="22">
<li>MySQL中，可以用于备份数据库的命令是mysqldump</li>
</ol>
<p>mysqldump备份数据库</p>
<hr>
<ol start="23">
<li>关于数据类型的使用建议，以下不正确的是TIMESTAMP类型的存储空间少于DATE类型</li>
</ol>
<p>TIMESTAMP（时间戳）DATE（日期）</p>
<hr>
<ol start="24">
<li>下列哪个选项可以让从数据库变成其他服务器的主数据库（log_slave_updates）</li>
</ol>
<p> master A ——&gt; slave B ——&gt; slave C   log_slave_updates是将从服务器从主服务器收到的更新记入到从服务器自己的二进制日志文件中。   对于mysql级联复制，上游的从服务器不仅仅要开启log_bin还要开启log_slave_updates，否则将导致下游的从服务器无法更新复制。  </p>
<hr>
<ol start="25">
<li>数据独立性是核心</li>
</ol>
<hr>
<ol start="26">
<li>关于MySQL数据库的MyISAM存储引擎描述正确的是（B）<blockquote>
<p>不缓存数据文件，只缓存索引文件</p>
</blockquote>
</li>
</ol>
<p><strong>MyISAM</strong>是<a href="https://baike.baidu.com/item/MySQL">MySQL</a>的默认<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E">数据库引擎</a>（5.5版之前），由早期的ISAM所改良。虽然性能极佳，但却有一个缺点：不支持<a href="https://baike.baidu.com/item/%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86">事务处理</a>（transaction）。不过，在这几年的发展下，<a href="https://baike.baidu.com/item/MySQL">MySQL</a>也导入了<a href="https://baike.baidu.com/item/InnoDB">InnoDB</a>（另一种数据库引擎），以强化<a href="https://baike.baidu.com/item/%E5%8F%82%E7%85%A7%E5%AE%8C%E6%95%B4%E6%80%A7">参照完整性</a>与并发违规处理机制，后来就逐渐取代MyISAM。  </p>
<hr>
<ol start="27">
<li>以下选项中不属于MySQL数据库文件的扩展名的是idb</li>
</ol>
<p>idb： 图像数据库是指用来存储各种图像或图形信息及有关文字说明资料的—种数据库。主要应用于建筑、设计、广告、产品目录、图片或照片等资料类型的计算机存储与检索。  </p>
<hr>
<ol start="28">
<li>聚簇索引与非聚簇索引</li>
</ol>
<ul>
<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>
<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>
</ul>
<hr>
<ol start="29">
<li>MySQL字符集以及校验规则</li>
<li>字符集(Character set)</li>
</ol>
<p>是多个字符(英文字符，汉字字符，或者其他国家语言字符)的集合，字符集种类较多，每个字符集包含的字符个数不同。</p>
<ol start="2">
<li>校对规则collation校对</li>
</ol>
<p>是在字符集内用于字符比较和排序的一套规则，比如有的规则区分大小写，有的则无视。</p>
<hr>
<ol start="30">
<li>数据完整性</li>
</ol>
<p> 数据完整性是为了保证插入到数据库中的数据是正确的,防止用户可能的错误输入。数据完整性分为实<strong>体完整性、域完整性、参照完整性</strong></p>
<hr>
<ol start="31">
<li>B-树</li>
</ol>
<p> 在B-树中查找给定<a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97/7105697">关键字</a>的方法是，首先把根结点取来，在根结点所包含的关键字K1,…,Kn查找给定的关键字（可用顺序查找或二分查找法），若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在Ki与Ki+1之间，Pi为指向子树根节点的指针，此时取<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304">指针</a>Pi所指的结点继续查找，直至找到，或指针Pi为空时查找失败。  </p>
<hr>
<ol start="32">
<li>物理备份和逻辑备份</li>
</ol>
<p><strong>物理备份：</strong> 物理备份是磁盘块为基本单位将数据从主机复制到备机。<strong>逻辑备份：</strong> 逻辑备份是以文件为基本单位将数据从主机复制到备机。</p>
<hr>
<ol start="33">
<li>1</li>
<li>1</li>
<li>1</li>
<li>1</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>散乱</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器</title>
    <url>/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/windowsserver%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E9%80%9A%E9%81%93/windowsserver%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E9%80%9A%E9%81%93/</url>
    <content><![CDATA[<h2 id="虚拟专用通道"><a href="#虚拟专用通道" class="headerlink" title="虚拟专用通道"></a>虚拟专用通道</h2><ol>
<li>添加“网络策略和访问服务”“远程访问”</li>
</ol>
<p><img src="https://i.loli.net/2021/11/03/mkFx83GW6HIEJu9.png#id=IwWQk&originHeight=365&originWidth=591&originalType=binary&ratio=1&status=done&style=none#id=ZAkmp&originHeight=365&originWidth=591&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">2. 勾选“网络策略服务器”该服务默认勾选<img src="https://i.loli.net/2021/11/03/xj5O4rJD1PAnBiq.png#id=aQhXB&originHeight=412&originWidth=631&originalType=binary&ratio=1&status=done&style=none#id=dpaNv&originHeight=412&originWidth=631&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">3. 勾选“DirectAccess和VPN(RAS）”和“路由”<img src="https://i.loli.net/2021/11/03/9caBuUzIql3Or5Z.png#id=Yxa2N&originHeight=424&originWidth=694&originalType=binary&ratio=1&status=done&style=none#id=PZLSg&originHeight=424&originWidth=694&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">4. 打开向导<img src="https://i.loli.net/2021/11/03/cjON7I4Cb8S5uFk.png#id=P6d78&originHeight=354&originWidth=685&originalType=binary&ratio=1&status=done&style=none#id=xyeZw&originHeight=354&originWidth=685&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">5. 仅部署VPN<img src="https://i.loli.net/2021/11/03/IsndtXNoeEbTh4j.png#id=xtIEe&originHeight=426&originWidth=630&originalType=binary&ratio=1&status=done&style=none#id=ue9pA&originHeight=426&originWidth=630&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">6. 选择“配置并启动路由和远程访问”<img src="https://i.loli.net/2021/11/03/bClaYZ9WOXVjR2v.png#id=E51Bn&originHeight=426&originWidth=654&originalType=binary&ratio=1&status=done&style=none#id=pfqvH&originHeight=426&originWidth=654&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">7.“自定义配置”<img src="https://i.loli.net/2021/11/03/8hFBw2GxVEJkTMA.png#id=LHXrm&originHeight=415&originWidth=548&originalType=binary&ratio=1&status=done&style=none#id=JwGau&originHeight=415&originWidth=548&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">8.“VPN访问”和“NAT”<img src="https://i.loli.net/2021/11/03/jfHImPRsBYaO9eb.png#id=v1270&originHeight=270&originWidth=432&originalType=binary&ratio=1&status=done&style=none#id=C4cK2&originHeight=270&originWidth=432&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">9.选择“外网出口”<img src="https://i.loli.net/2021/11/03/7CmhZ3toPGpO6U8.png#id=pKnor&originHeight=134&originWidth=450&originalType=binary&ratio=1&status=done&style=none#id=h2zRq&originHeight=134&originWidth=450&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">10.选择“公用接口连接到Internet”并勾选“在此接口上启用NAT”<img src="https://i.loli.net/2021/11/03/Epmg9djXyVJBLzh.png#id=Sp6f2&originHeight=125&originWidth=509&originalType=binary&ratio=1&status=done&style=none#id=UfhJB&originHeight=125&originWidth=509&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">11.右键选择“属性”<img src="https://i.loli.net/2021/11/03/rjMxIPQoWNyCq9a.png#id=zG0vJ&originHeight=419&originWidth=656&originalType=binary&ratio=1&status=done&style=none#id=ovRJN&originHeight=419&originWidth=656&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">12.创建一个新用户并选择“网络访问权限”为“允许访问”<img src="https://i.loli.net/2021/11/03/We85B1OzPlyNInp.png#id=rn0lI&originHeight=703&originWidth=665&originalType=binary&ratio=1&status=done&style=none#id=vgLFn&originHeight=703&originWidth=665&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="无法启动路由和远程访问的解决办法"><a href="#无法启动路由和远程访问的解决办法" class="headerlink" title="无法启动路由和远程访问的解决办法"></a>无法启动路由和远程访问的解决办法</h3><p>将Windows Firewall和Internet Connection Sharing (ICS)关闭，若无关闭，打开再关闭即可</p>
<h3 id="VPN拨号提示已经拒绝远程连接，因为未识别出你提供的用户名和密码组合，或在远程访问服务器上禁止使用选定的身份验证协议"><a href="#VPN拨号提示已经拒绝远程连接，因为未识别出你提供的用户名和密码组合，或在远程访问服务器上禁止使用选定的身份验证协议" class="headerlink" title="VPN拨号提示已经拒绝远程连接，因为未识别出你提供的用户名和密码组合，或在远程访问服务器上禁止使用选定的身份验证协议"></a>VPN拨号提示已经拒绝远程连接，因为未识别出你提供的用户名和密码组合，或在远程访问服务器上禁止使用选定的身份验证协议</h3><p><img src="https://i.loli.net/2021/11/04/V2zPB5DWM3AT8Gb.png#id=dMGBw&originHeight=571&originWidth=429&originalType=binary&ratio=1&status=done&style=none#id=k58gz&originHeight=571&originWidth=429&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">打开这些</p>
]]></content>
      <tags>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>服务器</tag>
        <tag>系统</tag>
        <tag>Windows_server</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库综述</title>
    <url>/2022/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%BC%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="A-来源声明"><a href="#A-来源声明" class="headerlink" title="A. 来源声明"></a>A. 来源声明</h2><p>书籍来源：Abraham Silberschatz 等：数据库系统概念@2006 (第5版 扫描版).pdf</p>
<ol>
<li>1.1-1.7	数据库本身概念介绍</li>
</ol>
<p>1.7-1.9	数据库用户介绍</p>
<ol start="2">
<li>第二章  对数据库的设计理念进一步延伸，实体与联系模型</li>
</ol>
<p>第三章应该是基于第二章的技术概念上的一次升级</p>
<ol start="3">
<li>第四章——SQL单独介绍、第五章——其他的类型介绍，予读者一种对比概念书，从设计理念到实际设计都有描述</li>
</ol>
<hr>
<p>DBMS（数据库管理系统）：由一个互相关联的数据的集合和一组用以访问这些数据程序组成，这个数据集合通常被称为数据库</p>
<h2 id="1-数据库概念"><a href="#1-数据库概念" class="headerlink" title="1.数据库概念"></a>1.数据库概念</h2><ol>
<li><strong>数据库系统的目的——解决问题</strong><ol>
<li>数据的冗余和不一致</li>
<li>数据孤立</li>
<li>完整性问题</li>
<li>数据访问困难</li>
<li>原子性问题</li>
<li>并发访问异常</li>
<li>安全性问题</li>
<li>……</li>
</ol>
</li>
<li><strong>数据视图——系统隐藏关于数据存储和维护的某些细节</strong><ol>
<li><strong>数据抽象</strong><ol>
<li><strong>用户界面</strong><ol>
<li>物理层——最低层次的抽象，描述数据实际上怎么存储</li>
<li>逻辑层——高于物理层，描述数据库中存储什么数据，以及数据之间的关系</li>
<li>视图层——最高层次的抽象，但只描述整个数据库的某个部分</li>
</ol>
</li>
</ol>
</li>
<li><strong>实例和模式</strong></li>
</ol>
</li>
</ol>
<p>数据库模式：数据库总体设计数据库实例：存储在数据库中的信息的集合</p>
<pre><code>  3. **数据独立性**
</code></pre>
<p>数据独立性：在某个层次上修改模式定义而不影响位于其上一层模式的能力</p>
<ol start="3">
<li><strong>数据模型</strong></li>
</ol>
<p>数据模型：描述数据、数据联系、数据语义及一致性约束的概念工具的集合</p>
<pre><code>  1. **基于对象的逻辑模型**
</code></pre>
<p>用于在逻辑层和视图层上描述数据</p>
<pre><code>     1. **实体-联系模型（E-R）**
</code></pre>
<p>该模型基于对现实世界的一种认识：现实世界是由一组称作实体的基本对象以及这些对象间的联系构成的</p>
<pre><code>        - E-R图
           - 矩形：代表实体集
           - 椭圆：代表属性
           - 菱形：代表实体集间的联系
           - 段：将属性与实体集相连或将实体集与联系相连
     2. **面向对象的模型**
</code></pre>
<p>面对对象的模型是基于对象的一个集合。对象划分为不同的类，含有相同类型的值和相同方法的对象属于同一个类。</p>
<pre><code>     3. **基于记录的逻辑模型**
</code></pre>
<p>基于记录的模型既用来定义数据库的全局逻辑结构，又用来提供关于实现的高层描述</p>
<pre><code>        1. **关系模型**
</code></pre>
<p>用表的集合来表示数据和数据间的关系</p>
<pre><code>        2. **网状模型**
</code></pre>
<p>数据用记录的集合来表示</p>
<pre><code>        3. **层次模型**
</code></pre>
<p>与网状模型类似，分别用记录和链接来表示数据和数据间的联系</p>
<pre><code>        4. **三种模型的差别**
</code></pre>
<p>关系模型同其他的不同在于关系模型不适用指针或链接，而是通过记录所包含的值把记录联系起来。这样的方式可以为关系模型定义规范的数学基础</p>
<pre><code>     4. **物理数据模型**
</code></pre>
<p>最低层次上描述数据。不在本书讨论范围内</p>
<ol start="4">
<li><strong>数据库语言</strong><ol>
<li><strong>数据定义语言（DDL）</strong></li>
</ol>
</li>
</ol>
<p>DDL(数据定义语言)——该语句的编译结构是产生了存储在一个特殊文件中的一系列表，称作数据字典或数据目录数据库中定义存储结构和访问方式由DDL语句来定义数据字典：一个包含元数据的文件，元数据是关于数据的数据。数据库，实际的读取修改前总要先查询该表</p>
<pre><code>  2. **数据操纵语言(DML)**
</code></pre>
<p>数据操作——增删查改两类数据操纵语言：</p>
<pre><code>     - 过程化的DML要求用户指定要什么数据以及如何获取
     - 非过程化的DML要求用户要什么数据，而不需要指明如何获取
</code></pre>
<ol start="5">
<li><strong>事务管理</strong></li>
</ol>
<p>按几个操作合起来形成一个逻辑执行单元事务管理是数据库应用中完成单一逻辑功能的操作集合</p>
<ol start="6">
<li><strong>存储管理</strong></li>
</ol>
<p>数据库系统对数据的组织必须满足使磁盘和主存间数据移动的需求最小化存储管理器负责与文件管理器交互——通过DML语句翻译成底层文件系统命令存储管理器负责数据库中的数据存储、检索和更新</p>
<ol start="7">
<li><strong>数据库管理员（DBA）</strong></li>
</ol>
<p>数据库管理员：对系统进行集中控制的人责任：</p>
<pre><code>  - 模式定义
  - 存储结构及存取方式定义
  - 模式及物理组织的修改
  - 数据访问授权
  - 完整性约束的定义
</code></pre>
<ol start="8">
<li><strong>数据库用户</strong></li>
</ol>
<p>四种类型：</p>
<pre><code>  - 应用程序设计人员——编写通过DML调用的程序，与系统交互
  - 富有经验的用户——并非通过编写语言来同系统交互，而是用数据库查询语言来交互
  - 专门的用户——编写专门的、不适用传统的模式的富有经验的用户
  - 没有经验的用户——通过已经写好的程序同数据库进行交互
</code></pre>
<ol start="9">
<li><strong>系统总体结构</strong></li>
</ol>
<p>大致可以分成——查询处理器部件、存储管理器部件</p>
<pre><code>  - 查询处理器部件
     - DML编译器：将DML翻译成引擎能理解的低级指令
     - 嵌入式DML预编译器：将嵌在应用程序中的DML转换成宿主语言中普遍的过程调用语句，必须同DML编译器相配合
     - DDL解释器：解释DDL语句并将其记录到包含元数据的一系列表中
     - 查询求值引擎
  - 存储管理器部件
     - 权限及完整性管理器
     - 事务管理器
     - 文件管理器
     - 缓冲管理器
     - 一些数据结构
        - 数据文件
        - 数据字典
        - 索引
        - 统计数据
</code></pre>
<h2 id="2-实体-联系模型"><a href="#2-实体-联系模型" class="headerlink" title="2.实体-联系模型"></a>2.实体-联系模型</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><p>E-R数据模型所采用的的三个主要概念：实体集、联系集、属性</p>
<h4 id="2-1-1-实体集"><a href="#2-1-1-实体集" class="headerlink" title="2.1.1 实体集"></a>2.1.1 实体集</h4><ul>
<li>实体集的外延：组成实体集的各实体</li>
<li>属性：实体集中每个成员具有的描述性质</li>
<li>域&#x2F;值集：每个属性其所允许的值的集合</li>
<li>实体是现实世界中可区别于其他对象的“事件”或“物体”。例如：企业中的个人</li>
<li>实体集可相交。例如：企业中的个人和企业中的员工</li>
<li>实体通过一组属性来表示</li>
<li>E-R模型中的属性可以按照如下属性类型来划分<ul>
<li>简单属性：不能划分再小的属性</li>
<li>复合属性——可使属性聚集起来，使模型更清晰</li>
<li>单值属性：该属性只能对一个特定实体都只有单独的一个值</li>
<li>多值属性</li>
<li>NULL属性：当实体在某个属性上没有值时使用null值</li>
<li>派生属性：这类属性的值可以从别的相关属性或实体派生出来<ul>
<li>基属性（存储属性）：派生属性的目标实体或属性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-1-2-联系集"><a href="#2-1-2-联系集" class="headerlink" title="2.1.2 联系集"></a>2.1.2 联系集</h4><ul>
<li>联系：是多个实体间的相互关联</li>
<li>联系集：是同类联系的集合</li>
</ul>
<p><img src="https://s2.loli.net/2022/02/25/chjIJQTNdufRtFw.png#id=BXmiG&originHeight=225&originWidth=476&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ul>
<li>参与：实体集之间的关联</li>
<li>实体的角色：实体在联系中的作用</li>
<li>联系集的度：参与联系集的实体机的数目</li>
</ul>
<h3 id="2-2-设计问题"><a href="#2-2-设计问题" class="headerlink" title="2.2 设计问题"></a>2.2 设计问题</h3><h4 id="2-2-1-用实体集还是用属性"><a href="#2-2-1-用实体集还是用属性" class="headerlink" title="2.2.1 用实体集还是用属性"></a>2.2.1 用实体集还是用属性</h4><ul>
<li>作者的问题<ol>
<li>什么可作为属性？什么可作为实体集？</li>
</ol>
</li>
</ul>
<p>他们的主要区别依赖于被建模的现实世界事实的结构，以及所讨论的属性的相关语义</p>
<h4 id="2-2-2-用实体集还是用联系集？"><a href="#2-2-2-用实体集还是用联系集？" class="headerlink" title="2.2.2 用实体集还是用联系集？"></a>2.2.2 用实体集还是用联系集？</h4><p>可采用的一个原则是，当描述发生在实体间的行为时采用联系集</p>
<h4 id="2-2-3-二元联系集与n元联系集"><a href="#2-2-3-二元联系集与n元联系集" class="headerlink" title="2.2.3 二元联系集与n元联系集"></a>2.2.3 二元联系集与n元联系集</h4><ul>
<li>一个非二元的（n元，n&gt;2）联系集总可以用一组不同的二元联系集来替代</li>
<li>对于为表示联系集而创建的实体集，可能不得不为其创建一个标识属性</li>
</ul>
<h3 id="2-3-映射约束"><a href="#2-3-映射约束" class="headerlink" title="2.3 映射约束"></a>2.3 映射约束</h3><h4 id="2-3-1-映射的基数"><a href="#2-3-1-映射的基数" class="headerlink" title="2.3.1 映射的基数"></a>2.3.1 映射的基数</h4><ul>
<li>映射的基数（基数比例）：指明通过一个联系集能同另一实体相联系的实体数目</li>
</ul>
<p><strong>二元联系集的情况：</strong></p>
<ul>
<li>一对一<ul>
<li>对于一对一的联系集而言，联系的属性可以放到参与联系的任何一个实体集中</li>
</ul>
</li>
<li>一对多——A中的一个实体可以同B中任意数目的实体相联系，而B中的实体至多同A中的一个实体相联系<ul>
<li>多对一——A中最多联系一个B，B中实体无限制联系</li>
<li>多对多——双方都可以任意联系，任意数目</li>
</ul>
</li>
</ul>
<h4 id="2-3-2-存在依赖"><a href="#2-3-2-存在依赖" class="headerlink" title="2.3.2 存在依赖"></a>2.3.2 存在依赖</h4><ul>
<li>假设x的存在依赖于实体y的存在<ul>
<li>那么就说x存在依赖于y</li>
<li>如果y被删除，那么x也要删除</li>
<li>y称作支配实体</li>
<li>x称作从属实体</li>
</ul>
</li>
</ul>
<h3 id="2-4-码"><a href="#2-4-码" class="headerlink" title="2.4 码"></a>2.4 码</h3><h4 id="2-4-1-实体集"><a href="#2-4-1-实体集" class="headerlink" title="2.4.1 实体集"></a>2.4.1 实体集</h4><ul>
<li>超码：一个或多个属性的集合——这个组合可以用于在一个实体集中唯一地标识一个实体</li>
<li>我们通常只对候选码感兴趣</li>
<li>候选码：它们的任意真子集都不能成为超码</li>
<li>主码：代表被数据库设计者选中的，用来在同一实体集中区分不同实体的候选码</li>
</ul>
<h4 id="2-4-2-联系集"><a href="#2-4-2-联系集" class="headerlink" title="2.4.2 联系集"></a>2.4.2 联系集</h4><ul>
<li>联系的主码结构依赖于联系集映射的基数</li>
</ul>
<h3 id="2-5-实体-联系图"><a href="#2-5-实体-联系图" class="headerlink" title="2.5 实体-联系图"></a>2.5 实体-联系图</h3><ul>
<li>主要构件：<ul>
<li>矩形：表示实体集<ul>
<li>下划线：标识关联角色</li>
</ul>
</li>
<li>椭圆：表示属性</li>
<li>菱形：表示联系集<ul>
<li>双边框菱形：对应的标示性联系</li>
</ul>
</li>
<li>线段：将属性连接到实体集或将实体集连接到联系集</li>
<li>双椭圆：表示多值属性</li>
<li>虚椭圆：表示派生属性</li>
<li>双线：表示一个实体全部参与到联系集中</li>
<li>箭头：表示多对一或一对一<ul>
<li>双箭头：一对一</li>
<li>线段：多对多</li>
<li>单箭头：箭头所指的是一，另一头是多</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-6-弱实体集"><a href="#2-6-弱实体集" class="headerlink" title="2.6 弱实体集"></a>2.6 弱实体集</h3><ul>
<li>弱实体集：有些实体集的属性不足以形成主码<ul>
<li>弱实体集只有作为一对多联系的一部分才有意义</li>
<li>任何属性都可以同弱实体集相联系</li>
<li>从属实体集也可以有主码</li>
</ul>
</li>
<li>标示性联系：弱实体集与拥有者之间的联系</li>
<li>强实体集：有主码的实体集</li>
</ul>
<h3 id="2-7-扩展E-R特征"><a href="#2-7-扩展E-R特征" class="headerlink" title="2.7 扩展E-R特征"></a>2.7 扩展E-R特征</h3><h4 id="2-7-1-特殊化"><a href="#2-7-1-特殊化" class="headerlink" title="2.7.1 特殊化"></a>2.7.1 特殊化</h4><ul>
<li>使用标记为ISA三角形构件来表示特殊化</li>
<li>子集中的实体再某些方面区别于实体集中的其他实体</li>
</ul>
<h4 id="2-7-2-概括"><a href="#2-7-2-概括" class="headerlink" title="2.7.2 概括"></a>2.7.2 概括</h4><ul>
<li>高层实体集与低层实体集也可以被分别称为超类和子类</li>
<li>自顶向下的设计——其中区别被显式地表达出来</li>
<li>自底向上的设计——多个实体集综合成一个较高层的实体集</li>
</ul>
<h4 id="2-7-3-属性继承"><a href="#2-7-3-属性继承" class="headerlink" title="2.7.3 属性继承"></a>2.7.3 属性继承</h4><ul>
<li>高层实体集的属性被低层实体集继承</li>
<li>低层实体集同时继承高层实体集所参与的那些联系集</li>
</ul>
<h4 id="2-7-4-约束设计"><a href="#2-7-4-约束设计" class="headerlink" title="2.7.4 约束设计"></a>2.7.4 约束设计</h4><ul>
<li>一类约束：用来确定哪些实体能称为给定低层实体集的成员，成员资格可以是下列的一种<ul>
<li>条件定义的<ul>
<li>条件定义的低层实体集中，成员资格的确定基于实体是否满足一个显式的条件或谓词</li>
</ul>
</li>
<li>用户定义的<ul>
<li>由数据库用户将实体指派给某个实体集</li>
</ul>
</li>
</ul>
</li>
<li>二类约束：用来确定同一个概括中，一个实体是否可以属于多个低层次实体集。低层次实体集可以是下述情况之一：<ul>
<li>不相交的：不相交的约束要求一个实体至多属于一个低层实体集</li>
<li>有重叠的</li>
</ul>
</li>
<li>三类约束：全部性约束，用来确定高层实体集中的一个实体是否必须属于某个概括的至少一个低层实体集<ul>
<li>全部的：每个高层实体不属于任何低层实体集</li>
<li>部分的：允许一些高层实体不属于任何低层实体集</li>
</ul>
</li>
</ul>
<h4 id="2-7-5-聚集"><a href="#2-7-5-聚集" class="headerlink" title="2.7.5 聚集"></a>2.7.5 聚集</h4><ul>
<li>E-R模型的一个局限性在于他不能表达联系间的联系</li>
<li>聚焦：是一种抽象，通过这种抽象，联系被当做高层实体来看待</li>
</ul>
<h2 id="3-关系模型"><a href="#3-关系模型" class="headerlink" title="3. 关系模型"></a>3. 关系模型</h2><p>在商用数据处理应用中，关系模型现在已经成为主要的数据模型</p>
<h3 id="3-1-关系数据库的结构"><a href="#3-1-关系数据库的结构" class="headerlink" title="3.1 关系数据库的结构"></a>3.1 关系数据库的结构</h3><ul>
<li>关系数据库是表的集合，每个表有唯一的名字</li>
</ul>
<h4 id="3-1-1-基本结构"><a href="#3-1-1-基本结构" class="headerlink" title="3.1.1 基本结构"></a>3.1.1 基本结构</h4><ul>
<li>属性：列首</li>
<li>域：属性允许的值</li>
</ul>
<h4 id="3-1-2-数据库模式"><a href="#3-1-2-数据库模式" class="headerlink" title="3.1.2 数据库模式"></a>3.1.2 数据库模式</h4><ul>
<li>数据库模式：数据库模式是数据库的逻辑设计</li>
<li>数据库实例是给定时刻数</li>
<li>据库中数据的一个快照</li>
</ul>
<h4 id="3-1-3-码"><a href="#3-1-3-码" class="headerlink" title="3.1.3 码"></a>3.1.3 码</h4><ul>
<li>超码、候选码和主码的概念也适用于关系模型</li>
<li>强实体集：实体集的主码成为关系的主码</li>
<li>弱实体集。与弱实体集对应以及关系包括<ul>
<li>弱实体机的属性</li>
<li>弱实体集所以来的强实体集的主码</li>
</ul>
</li>
<li>联系集：相关实体集的主码共同构成关系的超码</li>
<li>复合表：</li>
<li>多值属性：多值属性M可以表示为由以M作为属性的实体集</li>
<li>外码：关系模式的属性中包括另一关系模式的主码</li>
</ul>
<h4 id="3-1-4-查询语言"><a href="#3-1-4-查询语言" class="headerlink" title="3.1.4 查询语言"></a>3.1.4 查询语言</h4><ul>
<li>过程化语言：用户指导系统对数据库执行一系列操作以计算所需结果</li>
<li>非过程化语言：用户只需描述所需信息，而不用给出获取该信息的具体过程</li>
</ul>
<h3 id="3-2-关系代数"><a href="#3-2-关系代数" class="headerlink" title="3.2 关系代数"></a>3.2 关系代数</h3><ul>
<li>关系代数是过程化的查询语言。它包括一个运算集合，这个运算以一个或两个关系为输入，产生一个新的关系作为结果</li>
</ul>
<h4 id="3-2-1-基本运算"><a href="#3-2-1-基本运算" class="headerlink" title="3.2.1 基本运算"></a>3.2.1 基本运算</h4><ul>
<li>一元运算：只对一个关系进行运算——选择、投影和更名。</li>
<li>二元运算：另外三个运算对两个关系进行运算</li>
</ul>
<p><strong>PS：本书后面内容均被跳过</strong></p>
<hr>
<p>LZL:</p>
<ol>
<li>引言<ol>
<li>任何系统都是为了解决问题而生</li>
<li>知道如何用，不知道为什么这样用。这是可行的策略。——这可能仅适用于被设计出来的东西</li>
</ol>
</li>
</ol>
<hr>
<h2 id="B-来源声明"><a href="#B-来源声明" class="headerlink" title="B. 来源声明"></a>B. 来源声明</h2><p>书籍来源：Alan Beaulieu：SQL 学习指南@2010 (第2版 扫描版).pdf</p>
<p>工具书，指南书</p>
<ol>
<li>介绍SQL以及MYSQL</li>
<li>2-5——简介SQL数据语句——其中select是重点</li>
<li>集合——盲区<ol>
<li>理论</li>
<li>操作</li>
</ol>
</li>
<li>对数据的处理</li>
<li>分组与聚集——盲区<ol>
<li>概念</li>
<li>作用</li>
</ol>
</li>
<li>子查询<ol>
<li>概念</li>
<li>作用</li>
</ol>
</li>
<li>再谈连接</li>
<li>条件逻辑</li>
<li>事务</li>
<li>索引和约束</li>
<li>视图</li>
<li>元数据</li>
</ol>
<p>侧重于操作的一本书，其中关于理论部分是为了让读者更好接受这些概念才进行的论述。在书中，理论的权重被放置最末尾。但是每一节的开头都是先理论，后操作。因此按照逻辑，应当将作者的对理论的论述确认了之后（除非作者认同可以跳过），才进行下面的阅读。并且，每一章的关联不会很大。</p>
<p>作者要将的东西：在本书中，将分别讨论 SQL语言的几个独立模块，即SQL 方案（schema）语句，用于定义存储于数据库中的数据结构；SQL数据语句，用于操作SQL方案语句所定义的数据结构；以及 SQL 事务语句，用于开始、结束或回滚事务（将在第12章中绍）。</p>
<p>本书中的大部分篇幅将聚焦于SQL语言中的数据相关部分，包括select、update、insert和 delete 命令。</p>
<p>本书并不是一本 MySQL 的 SQL 实现教程。事实上，本书原意是希望教授如何设计 SQL 语句并使之无需修改地运行在 MySQ上，并能在无需或仅需要极少量修改的情况下，执行在服务器上</p>
<p>本书仅针对sql语言进行介绍，通常用到的数据列98%都是简单数据类型，因此本书只涉及字符型、数值型和日期型</p>
<hr>
<h2 id="4-1-两种类型数据库"><a href="#4-1-两种类型数据库" class="headerlink" title="4.1 两种类型数据库"></a>4.1 两种类型数据库</h2><h3 id="4-1-1-非关系数据库"><a href="#4-1-1-非关系数据库" class="headerlink" title="4.1.1 非关系数据库"></a>4.1.1 非关系数据库</h3><ul>
<li>在层次数据库中，以一个或多个树形结构来表示数据</li>
<li>在网状数据库，一个记录可能可以通过多个入口进行访问。这使得网状数据库具有多根层次的特点</li>
<li>这两种数据库仍然存在，尽管主要在大型机领域中使用</li>
</ul>
<h3 id="4-1-2-关系模型"><a href="#4-1-2-关系模型" class="headerlink" title="4.1.2 关系模型"></a>4.1.2 关系模型</h3><ul>
<li>使用表集合来表示数据，但相关条目之间不适用指针来导航</li>
<li>关系数据库中每张表都包含一项作为每行唯一标识的信息（主键），它与其他信息一起构成了对条目的完整描述</li>
</ul>
<h2 id="4-2-SQL内部"><a href="#4-2-SQL内部" class="headerlink" title="4.2 SQL内部"></a>4.2 SQL内部</h2><h3 id="4-2-1-SQL：非过程化语句"><a href="#4-2-1-SQL：非过程化语句" class="headerlink" title="4.2.1 SQL：非过程化语句"></a>4.2.1 SQL：非过程化语句</h3><ul>
<li>使用SQL意味着必须放弃对过程的控制，因为SQL语句只定义必要的输入和输出，而执行语句的方式则交由数据库引擎的一个组件，即优化器处理</li>
</ul>
<h2 id="5-MySQL"><a href="#5-MySQL" class="headerlink" title="5. MySQL"></a>5. MySQL</h2><p>相关链接：<a href="https://www.mysql.com/downloads/">https://www.mysql.com/downloads/</a></p>
<h3 id="5-1-下载安装MySQL数据库"><a href="#5-1-下载安装MySQL数据库" class="headerlink" title="5.1 下载安装MySQL数据库"></a>5.1 下载安装MySQL数据库</h3><table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>下载安装包</td>
<td>略</td>
</tr>
<tr>
<td>2</td>
<td>默认安装</td>
<td>选择【developer default】</td>
</tr>
<tr>
<td>3</td>
<td>打开数据库</td>
<td>找到【MySQL 8.0 Command Line Client】双击启动输入密码</td>
</tr>
</tbody></table>
<h3 id="5-2-创建MySQL数据库"><a href="#5-2-创建MySQL数据库" class="headerlink" title="5.2 创建MySQL数据库"></a>5.2 创建MySQL数据库</h3><table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>启动命令行</td>
<td>略</td>
</tr>
<tr>
<td>2</td>
<td>用root用户登录MySQL</td>
<td>mysql -u root -p</td>
</tr>
<tr>
<td>3</td>
<td>创建示例数据库</td>
<td>create databse bank;</td>
</tr>
<tr>
<td>4</td>
<td>创建用户imssql，并赋予bank数据库的权限</td>
<td>grant all privileges on bank.* to ‘imssql‘@’localhost’ identified by ‘xyz’;</td>
</tr>
<tr>
<td>5</td>
<td>退出mysql工具包</td>
<td>quit;</td>
</tr>
<tr>
<td>6</td>
<td>使用imgsql用户登录MySQL</td>
<td>mysql -u imgsql -p;</td>
</tr>
<tr>
<td>7</td>
<td>关联bank数据库</td>
<td>user bank;</td>
</tr>
</tbody></table>
<h3 id="5-3-使用MySQL命令行工具"><a href="#5-3-使用MySQL命令行工具" class="headerlink" title="5.3 使用MySQL命令行工具"></a>5.3 使用MySQL命令行工具</h3><ul>
<li>now()：mysql的一个内建的函数，返回当前日期与时间</li>
</ul>
<h3 id="5-4-MySQL数据类型"><a href="#5-4-MySQL数据类型" class="headerlink" title="5.4 MySQL数据类型"></a>5.4 MySQL数据类型</h3><p><a href="https://www.runoob.com/mysql/mysql-data-types.html">MySQL数据类型</a></p>
<h4 id="5-4-1-字符型数据"><a href="#5-4-1-字符型数据" class="headerlink" title="5.4.1 字符型数据"></a>5.4.1 字符型数据</h4><ul>
<li><p>定长字符串：固定长度的字符串使用空格向右填充</p>
<ul>
<li>char：最长支持255字节</li>
</ul>
</li>
<li><p>变长字符串</p>
<ul>
<li>varchar：最长支持65535字节</li>
</ul>
</li>
<li><p>字符集</p>
<ul>
<li>每个字符的存储需要多个字节，因此这类字符集被称为多字符集。例如：汉语、日语</li>
<li>可以使用【show character set；】来查看服务器所支持的字符集</li>
<li>支持为数据库中每个字符列选择不同的字符集</li>
<li>支持在同一个表内存储不同的字符集数据</li>
</ul>
</li>
<li><p>文本数据</p>
<ul>
<li>存储的数据&gt;64kb时使用</li>
<li>当数据超过限制，数据将会被截断</li>
<li>对于MySQL而言，一般不需要用到【tinytest】和【test】<table>
<thead>
<tr>
<th>文本类型</th>
<th>最大支持（单位：字节）</th>
</tr>
</thead>
<tbody><tr>
<td>tinytest</td>
<td>255</td>
</tr>
<tr>
<td>test</td>
<td>65 535</td>
</tr>
<tr>
<td>mediumtest</td>
<td>16 777 215</td>
</tr>
<tr>
<td>longtest</td>
<td>4 294 967 295</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>语句</p>
<ul>
<li><code>varchar(20) character set utf8;		#创建一个字符类型，并设定字符集</code></li>
<li><code>create database foreign_sales character set utf8;	#改变【foreign_sales】数据库的数据集</code></li>
</ul>
</li>
</ul>
<h4 id="5-4-2-数值型类型"><a href="#5-4-2-数值型类型" class="headerlink" title="5.4.2 数值型类型"></a>5.4.2 数值型类型</h4><h4 id="5-4-3-浮点型类型"><a href="#5-4-3-浮点型类型" class="headerlink" title="5.4.3 浮点型类型"></a>5.4.3 浮点型类型</h4><h4 id="5-4-4-时间类型"><a href="#5-4-4-时间类型" class="headerlink" title="5.4.4 时间类型"></a>5.4.4 时间类型</h4><h3 id="5-5-表的创建"><a href="#5-5-表的创建" class="headerlink" title="5.5 表的创建"></a>5.5 表的创建</h3><table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
<th>行为</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>设计</td>
<td>选择用于描述的元素</td>
</tr>
<tr>
<td>2</td>
<td>精化</td>
<td>对【设计】进行进一步精化。例如：有无重复元素</td>
</tr>
<tr>
<td>3</td>
<td>构件SQL方案语句</td>
<td>将【精化】后的表转换为SQL语句形式</td>
</tr>
</tbody></table>
<h3 id="5-6-操作与修改表"><a href="#5-6-操作与修改表" class="headerlink" title="5.6 操作与修改表"></a>5.6 操作与修改表</h3><h4 id="5-6-1-插入数据"><a href="#5-6-1-插入数据" class="headerlink" title="5.6.1 插入数据"></a>5.6.1 插入数据</h4><ul>
<li>insert<ul>
<li>语句<ul>
<li>无需指定要插入数据的列明，只需提供被插入的值</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><code>INSERT INTO _table_name_VALUES (_value1_,_value2_,_value3_,...);</code></p>
<pre><code>  - 指定列名及被插入的值：
</code></pre>
<p><code>INSERT INTO _table_name_ (_column1_,_column2_,_column3_,...)VALUES (_value1_,_value2_,_value3_,...);</code></p>
<ul>
<li>三个主要功能<ul>
<li>所要插入数据的表的名称</li>
<li>表中需要使用的列的名称</li>
<li>需要插入到列的值</li>
</ul>
</li>
</ul>
<h4 id="5-6-2-生成数字型主键数据"><a href="#5-6-2-生成数字型主键数据" class="headerlink" title="5.6.2 生成数字型主键数据"></a>5.6.2 生成数字型主键数据</h4><ul>
<li>常用选项<ul>
<li>查看表中当前主键的最大值，并加1</li>
<li>让数据库服务器自动提供</li>
</ul>
</li>
</ul>
<h4 id="5-6-3-更新数据"><a href="#5-6-3-更新数据" class="headerlink" title="5.6.3 更新数据"></a>5.6.3 更新数据</h4><ul>
<li>语法<ul>
<li>update</li>
</ul>
</li>
</ul>
<p><code>UPDATE _table_name_SET _column1_=_value1_,_column2_=_value2_,...WHERE _some_column_=_some_value_;  </code></p>
<h4 id="5-6-4-删除数据"><a href="#5-6-4-删除数据" class="headerlink" title="5.6.4 删除数据"></a>5.6.4 删除数据</h4><ul>
<li>语法<ul>
<li>delete</li>
</ul>
</li>
</ul>
<p><code>DELETE FROM _table_name_WHERE _some_column_=_some_value_;  </code></p>
<h2 id="6-查询入门"><a href="#6-查询入门" class="headerlink" title="6. 查询入门"></a>6. 查询入门</h2><h3 id="6-1-查询机制"><a href="#6-1-查询机制" class="headerlink" title="6.1 查询机制"></a>6.1 查询机制</h3><p>当用户通过身份验证，则为用户创建一个数据库连接。从应用程序发出请求后一直保持，直到应用程序释放连接或关闭服务器连接。MySQL服务器会给每个连接赋予一个标识符</p>
<ul>
<li>当查询发送至服务端时，服务器会执行之前进行以下检查——当检查完整，语句会传递给查询优化器<ul>
<li>用户是否有权限执行该语句？</li>
<li>用户是否有权限访问目标数据？</li>
<li>语句的语法是否正确？</li>
</ul>
</li>
</ul>
<h3 id="6-1-1-查询语句"><a href="#6-1-1-查询语句" class="headerlink" title="6.1.1 查询语句"></a>6.1.1 查询语句</h3><table>
<thead>
<tr>
<th>子句名称</th>
<th>使用目的</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>select</td>
<td>确定结果集中应该包含哪些列</td>
<td>该语句在数据库服务中是被最后评估的</td>
</tr>
<tr>
<td>from</td>
<td>指明所要提取数据表，以及这些表是如何连接的</td>
<td></td>
</tr>
<tr>
<td>where</td>
<td>过滤不需要的数据</td>
<td></td>
</tr>
<tr>
<td>group by</td>
<td>用于对具有相同列值的行进行分组</td>
<td></td>
</tr>
<tr>
<td>having</td>
<td>过滤掉不需要的组</td>
<td></td>
</tr>
<tr>
<td>order by</td>
<td>按一个或多个列，对最后结果集中的行进行排序</td>
<td></td>
</tr>
</tbody></table>
<h3 id="6-1-2-列的别名"><a href="#6-1-2-列的别名" class="headerlink" title="6.1.2 列的别名"></a>6.1.2 列的别名</h3><ul>
<li>尽管mysql命令行工具为查询所返回的每个列提供了默认标签，但或许你希望使用自己定义的标签</li>
</ul>
<h3 id="6-1-3-去除重复的行"><a href="#6-1-3-去除重复的行" class="headerlink" title="6.1.3 去除重复的行"></a>6.1.3 去除重复的行</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">SLECT <span class="keyword">DISTINCT</span> TEST</span><br><span class="line"><span class="keyword">FROM</span> database;</span><br></pre></td></tr></table></figure>

<h2 id="6-2-from子句"><a href="#6-2-from子句" class="headerlink" title="6.2 from子句"></a>6.2 from子句</h2><h3 id="6-2-1-表的概念"><a href="#6-2-1-表的概念" class="headerlink" title="6.2.1 表的概念"></a>6.2.1 表的概念</h3><ul>
<li>存在3种类型的表<ul>
<li>永久表（使用create table创建的表）</li>
<li>临时表（子查询所返回的表）<ul>
<li>子查询：包含在另一个查询中的查询。</li>
</ul>
</li>
<li>虚拟表（create view创建的视图）<ul>
<li>视图：储存在数据字典中的查询，它的行为表现得像一个表，但实际并不拥有任何数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-2-表连接"><a href="#6-2-2-表连接" class="headerlink" title="6.2.2 表连接"></a>6.2.2 表连接</h3><ul>
<li>如果from子句中出现了多个表，那么要求同时包含各表之间的连接条件</li>
</ul>
<h3 id="6-2-3-定义表别名"><a href="#6-2-3-定义表别名" class="headerlink" title="6.2.3 定义表别名"></a>6.2.3 定义表别名</h3><p>在单个查询中连接多个表时。有两种在from之外引用表的方式：</p>
<ul>
<li>使用完整的表名称</li>
<li>为每个表指定别名，并在查询中需要的地方使用该别名</li>
</ul>
<h2 id="6-3-where子句"><a href="#6-3-where子句" class="headerlink" title="6.3 where子句"></a>6.3 where子句</h2><ul>
<li>where子句用于在结果集中过滤掉不需要的行<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> emp_id,fname,lname,start_date,title</span><br><span class="line"><span class="keyword">from</span> employee</span><br><span class="line"><span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;Head Teller&#x27;</span></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>查询employee表，并且只获取title为head teller的数据行</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="6-4-group-by-和having子句"><a href="#6-4-group-by-和having子句" class="headerlink" title="6.4 group by 和having子句"></a>6.4 group by 和having子句</h3><h3 id="6-5-order-by子句"><a href="#6-5-order-by子句" class="headerlink" title="6.5 order by子句"></a>6.5 order by子句</h3><ul>
<li>可以对目标进行排序<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> open_id product_cd</span><br><span class="line"><span class="keyword">from</span> account</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> open_id;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>该语句可以以open_id从小到大依次排序显示</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="6-5-1-升序或降序排序"><a href="#6-5-1-升序或降序排序" class="headerlink" title="6.5.1 升序或降序排序"></a>6.5.1 升序或降序排序</h4><ul>
<li>默认情况下是升序，因此只需要在想降序排序时加上desc关键字即可<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> open_id product_cd</span><br><span class="line"><span class="keyword">from</span> account</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> open_id <span class="keyword">desc</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>该语句可以以open_id从大到小依次排序显示</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="7-过滤"><a href="#7-过滤" class="headerlink" title="7 过滤"></a>7 过滤</h2><h3 id="7-1-条件评估"><a href="#7-1-条件评估" class="headerlink" title="7.1 条件评估"></a>7.1 条件评估</h3><ul>
<li>where子句可能包含1个或多个条件，每个条件之间用操作符and和or分割<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> title <span class="operator">=</span> <span class="string">&#x27;Teller&#x27;</span> <span class="keyword">and</span> start_data <span class="operator">&lt;</span> <span class="string">&#x27;2007-01-01&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-1-1-使用圆括号"><a href="#7-1-1-使用圆括号" class="headerlink" title="7.1.1 使用圆括号"></a>7.1.1 使用圆括号</h4><ul>
<li>当where子句包含3个或更多条件，且同时使用了and和or操作符，那么需要使用圆括号来明确意图<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">where</span> end_date <span class="keyword">is</span> <span class="keyword">null</span></span><br><span class="line">	<span class="keyword">and</span>(title <span class="operator">=</span> <span class="string">&#x27;Teller&#x27;</span> <span class="keyword">or</span> start_date <span class="operator">&lt;</span> <span class="string">&#x27;2007-01-01&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="7-1-2-使用not操作符"><a href="#7-1-2-使用not操作符" class="headerlink" title="7.1.2 使用not操作符"></a>7.1.2 使用not操作符</h4><ul>
<li>对于开发者来说，尽量避免使用not操作符，因为这增加了对条件评估的困难</li>
</ul>
<h3 id="7-2-构件条件"><a href="#7-2-构件条件" class="headerlink" title="7.2 构件条件"></a>7.2 构件条件</h3><ul>
<li>条件通常由1个或多个包含1个到多个操作符的表达式构成。表达式可以是下面类型中的任何一个<ul>
<li>数字</li>
<li>表或视图中的列</li>
<li>内建函数</li>
<li>子查询</li>
<li>表达式列表</li>
<li>比较操作符</li>
<li>算术操作符</li>
</ul>
</li>
</ul>
<h3 id="7-3-条件类型"><a href="#7-3-条件类型" class="headerlink" title="7.3 条件类型"></a>7.3 条件类型</h3><h3 id="7-3-1-相等条件"><a href="#7-3-1-相等条件" class="headerlink" title="7.3.1 相等条件"></a>7.3.1 相等条件</h3><ul>
<li>将一个表达式等同于另一个表达式<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">title <span class="operator">=</span> <span class="string">&#x27;Teller&#x27;</span></span><br><span class="line">fed_id <span class="operator">=</span> <span class="string">&#x27;111-111-111&#x27;</span></span><br><span class="line">drpt_id <span class="operator">=</span> (<span class="keyword">select</span> dept_id <span class="keyword">from</span> department <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;Loans&#x27;</span>)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>第三条语句使用返回值作为值等同</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-1-不等条件"><a href="#7-3-1-不等条件" class="headerlink" title="7.3.1 不等条件"></a>7.3.1 不等条件</h3><ul>
<li>用于判断两个表达式不相等</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h2 id="数据库的模式"><a href="#数据库的模式" class="headerlink" title="数据库的模式"></a>数据库的模式</h2><ul>
<li>分为外模式、模式、内模式。<ul>
<li>所谓的内模式就是硬件存储。</li>
<li>外模式就是客户所看到的结果。</li>
<li>模式就是数据库设计者看到的那些表 。</li>
</ul>
</li>
</ul>
<h2 id="主从数据库"><a href="#主从数据库" class="headerlink" title="主从数据库"></a>主从数据库</h2><ul>
<li>主从复制，是用来建立一个和主数据库完全一样的数据库环境，称为从数据库；主数据库一般是准实时的业务数据库。</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC/%E9%9D%92%E9%BE%99%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<p>title: 青龙脚本<br>date: 2023-4-23 09:20:33<br>tags:</p>
<p>categories: </p>
<ul>
<li>计算机</li>
<li>服务</li>
<li>青龙脚本</li>
</ul>
<p><a href="https://www.govultr.com/qinglong/">https://www.govultr.com/qinglong/</a><br><a href="https://www.hztdst.com/8116.html">https://www.hztdst.com/8116.html</a></p>
]]></content>
  </entry>
  <entry>
    <title>MAC的打印机如何更改打印机设置如账户，色彩等</title>
    <url>/2022/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Mac/MAC%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA%E5%A6%82%E4%BD%95%E6%9B%B4%E6%94%B9%E6%89%93%E5%8D%B0%E6%9C%BA%E8%AE%BE%E7%BD%AE%E5%A6%82%E8%B4%A6%E6%88%B7%EF%BC%8C%E8%89%B2%E5%BD%A9%E7%AD%89/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>步骤</th>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>打开一个excle</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>打印</td>
<td>打开打印界面</td>
</tr>
<tr>
<td>3.1</td>
<td>Job Accounting</td>
<td>打印账户设置</td>
</tr>
<tr>
<td>3.2</td>
<td>Fuji Xerox Feadres</td>
<td>打印机的特点设置</td>
</tr>
<tr>
<td>3.3</td>
<td>Job Tyep</td>
<td>打印类型设置</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>Mac</category>
      </categories>
  </entry>
  <entry>
    <title>Win10电脑的Bitlocker是什么？蓝屏锁了怎么办？</title>
    <url>/2022/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Windows/Win10%E7%94%B5%E8%84%91%E7%9A%84Bitlocker%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E8%93%9D%E5%B1%8F%E9%94%81%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h2><ol>
<li>前提【电脑使用微软账户登录】</li>
</ol>
<p>在其他设备上登录【微软账号】，地址——【<a href="https://login.live.com/">登录你的微软账号</a>】 找到【自己的设备】，查看【Bitlocker】密钥</p>
<ol start="2">
<li>通过<strong>雷电三绕过TPM芯片</strong>读取机器数据</li>
</ol>
<p><a href="https://www.zhihu.com/question/394381044">如何看待所有携带雷电三接口的设备疑似存在漏洞且无法修复？</a></p>
<h2 id="什么是Bitlocker"><a href="#什么是Bitlocker" class="headerlink" title="什么是Bitlocker"></a>什么是<strong>Bitlocker</strong></h2><p><strong>Bitlocker</strong>是一个<strong>数据加密</strong>软件，可以在硬件层面加密自己数据，保护自己的数据安全，密钥是48位数字  用途：</p>
<ol>
<li><strong>加密</strong>硬盘数据，且几乎无法破解</li>
<li>在硬件发生变动时，<strong>锁定</strong>计算机</li>
</ol>
<p>需要知道的几点：</p>
<ul>
<li>绑定微软账户时，<strong>密钥会传到微软的服务器</strong>，在微软账户里，需要的时候记得登录微软账户找回</li>
<li>如果锁定了，自己手上没有密钥，只能重装系统</li>
<li>一些机器是带TPM芯片的，BitLocker会绑定机器硬件，同一块硬盘，即使知道密钥，在别的机器上也打不开</li>
<li>Bitlocker可以手动关闭</li>
</ul>
<h2 id="什么是TPM"><a href="#什么是TPM" class="headerlink" title="什么是TPM"></a>什么是<strong>TPM</strong></h2><p><strong>【TPM】(Trusted Platform Module)安全芯片</strong>是指符合<strong>TPM（可信赖平台模块）标准</strong>的安全芯片，它能有效地保护PC、防止非法用户访问。</p>
<ul>
<li>用于<strong>存储、管理BIOS开机密码以及硬盘密码，</strong>也可以<strong>加密硬盘的任意分区</strong>（TPM提供密钥）</li>
<li>TPM安全芯片包含了分别实现RSA、SHA等算法硬件处理引擎，它既是<strong>密钥生成器</strong>，又是<strong>密钥管理</strong>器件TPM安全芯片首先验证当前底层固件的完整性，如正确则完成正常的系统初始化，然后由底层固件依次验证BIOS和操作系统完整性，如正确则正常运行操作系统，否则停止运行。<strong>（机器开机的时候，TPM芯片会检查硬件完整性，如果有硬件变动，就会锁住数据，必须输入Bitlocker密钥）</strong></li>
</ul>
<p><strong>TPM的优势——</strong></p>
<ul>
<li>相比没有TPM芯片的机器，带TPM的机器<strong>可以储存密钥和关键信息在TPM芯片内部</strong>，相比存在硬盘里的密钥，<strong>TPM芯片更安全</strong></li>
<li>TPM加密的数据，只有这块芯片能解锁，数据和机器&#x2F;芯片绑定，更安全</li>
<li><strong>TPM独立于硬盘之外，破解门槛高</strong>（一般情况没法破解，网上的破解教程基本都是假的）</li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>Linux</title>
    <url>/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Linux/Linux/</url>
    <content><![CDATA[<h2 id="第一章-Linux是什么"><a href="#第一章-Linux是什么" class="headerlink" title="第一章 Linux是什么"></a>第一章 Linux是什么</h2><p>由于不同的硬件他的功能函数并不相同，例如IBM的Power CPU与Intel的x86架构就是不一样！所以同一套操作系统是无法在不同的硬件平台上面运作的！举例来说，如果你想要让x86 上面跑的）操作系统也能够在 Power CPU 上运作时，就得要将该操作系统进行修改才行。如果能够参考硬件的能函数并据以修改你的操作系统程序代码，那经过改版后的操作系统就能够在另一个硬件作了。这个动作我们通常就称为“软件移植”！</p>
<h2 id="第三章-主机规划与磁盘分区"><a href="#第三章-主机规划与磁盘分区" class="headerlink" title="第三章 主机规划与磁盘分区"></a>第三章 主机规划与磁盘分区</h2><p>那么是否每个扇区都一样重要呢？其实整颗磁盘的第一个扇区特别的重要，因为他记录了整颗磁盘的重要信息！ 磁盘的第一个扇区主要记录了两个重要的信息，分别是：</p>
<ul>
<li>主要启动记录区(Master Boot Record, MBR)：可以安装开机管理程序的地方，有 446 bytes分割表（partition table）：记录整颗硬盘分割的状态，有64 bytes</li>
<li>MBR是很重要的，因为当系统在开机的时候会主动去读取这个区块的内容，这样系统才会知道你的程序放在哪里且该如何进行开机。 如果你要安装多重引导的系统，MBR 这个区块的管理就非常非常的重要了！</li>
</ul>
<p>在计算器概论里面我们有谈到那个可爱的BIOS与CMOS两个东西，CMOS 是记录各项硬件参数且嵌入在主板上面的储存器，BIOS 则是一个写入到主板上的一个韧体(再次说明， 韧体就是写入到硬件上的一个软件程序)。这个 BIOS 就是在开机的时候，计算机系统会主动执行的第一个程序了！接下来 BIOS 会去分析计算机里面有哪些储存设备，我们以硬盘为例，BIOS 会依据使用者的设定去取得能够开机的硬盘，并且到该硬盘里面去读取第一个扇区的 MBR位置。MBR 这个仅有446 bytes的硬盘容量里面会放置最基本的开机管理程序，此时BIOS就功成圆满，而接下来就是MBR内的开机管理程序的工作了。这个开机管理程序的目的是在加载(load)核心档案，由于开机管理程序是操作系统在安装的时候所提供的，所以他会认识硬盘内的文件系统格式，因此就能够读取核心档案，然后接下来就是核心档案的工作，开机管理程序也功成圆满，之后就是大家所知道的操作系统的任务啦！</p>
<p>简单的说，整个开机流程到操作系统之前的动作应该是这样的：</p>
<ol>
<li>BIOS：开机主动执行的韧体，会认识第一个可开机的装置；</li>
<li>MBR：第一个可开机装置的第一个扇区内的主要启动记录区块，内含开机管理程序；</li>
<li>开机管理程序(boot loader)：一支可读取核心档案来执行的软件；</li>
<li>核心档案：开始操作系统的功能…由上面的说明我们会知道，BIOS与MBR都是硬件本身会支持的功能，至于 Boot loader则是操作系统安装在 MBR 上面的一套软件了。由于 MBR 仅有 446 bytes 而已，因此这个开机管理程序是非常小而美的。这个 boot loader的主要任务有底下这些项目：提供选单：用户可以选择不同的开机项目，这也是多重引导的重要功能！载入核心档案：直接指向可开机的程序区段来开始操作系统；转交其他 loader：将开机管理功能转交给其他 loader 负责。</li>
</ol>
<p><img src="https://i.loli.net/2021/11/29/ThLG65gt9vFm8jK.png#id=sE12M&originHeight=299&originWidth=456&originalType=binary&ratio=1&status=done&style=none#id=BVsGH&originHeight=299&originWidth=456&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">在上图中我们可以发现，MBR的开机管理程序提供两个选单，选单一(M1)可以直接加载Windows的核心档案来开机；选单二(M2)则是将开机管理工作交给第二个分割槽的启动扇区(boot sector)。当使用者在开机的时候选择选单二时，那么整个开机管理工作就会交给第二分割槽的开机管理程序了。 当第二个开机管理程序启动后，该开机管理程序内(上图中)仅有一个开机选单，因此就能够使用 Linux 的核心档案来开机啰。这就是多重引导的工作情况啦！我们将上图作个总结：</p>
<ul>
<li>每个分割槽都拥有自己的启动扇区(boot sector)</li>
<li>图中的系统槽为第一及第二分割槽，</li>
<li>实际可开机的核心档案是放置到各分割槽内的！</li>
<li>loader只会认识自己的系统槽内的可开机核心档案，以及其他 loader 而已 ;</li>
<li>loader 可直接指向或者是间接将管理权转交给另一个管理程序。</li>
</ul>
<p>那现在请你想一想，为什么人家常常说：『如果要安装多重引导，最好先安装 Windows 再安装Linux」呢？这是因为：Linux 在安装的时候，你可以选择将开机管理程序安装在 MBR 或各别分割槽的启动扇区，而且Linux 的loader可以手动设定选单(就是上图的M1,M2…)，所以你可以在Linux的bootloader 里面加入 Windows 开机的选项；Windows 那你在安装的时候，他的安装程序会主动的覆盖掉 MBR 以及自己所在分割槽的启动扇区，你没有选择的机会，而且他没有让我们自己选择选单的功能。</p>
<p><img src="https://i.loli.net/2021/11/30/etdxWKPgvQ19wFT.png#id=aqzmG&originHeight=191&originWidth=360&originalType=binary&ratio=1&status=done&style=none#id=jyZyG&originHeight=191&originWidth=360&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">如上图所示，所有的档案都是由根目录(&#x2F;)衍生来的，而次目录之下还能够有其他的数据存在。上图中长方形为目录，波浪形则为档案。那当我们想要取得 mydata 那个档案时，系统就得由根目录开始找，然后找到 home 接下来找到dmtsai，最终的档名为：&#x2F;home&#x2F;dmtsai&#x2F;mydata 的意思。</p>
<p><img src="https://i.loli.net/2021/11/30/YI4fbqhtejWvzdn.png#id=DkpqC&originHeight=240&originWidth=492&originalType=binary&ratio=1&status=done&style=none#id=qGv5B&originHeight=240&originWidth=492&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">所谓的『挂载』就是利用一个目录当成进入点，将磁盘分区槽的数据放置在该目录下； 也就是说，进入该目录就可以读取该分割槽的意思。这个动作我们称为『挂载』，那个进入点的目录我们称为『挂载点』。 由于整个 Linux 系统最重要的是根目录，因此根目录一定需要挂载到某个分割槽的。 至于其他的目录则可依用户自己的需求来给予挂载到不同的分割槽。我们以上图来作为一个说明：</p>
<h2 id="第四章、安装-CentOS-5-x-与多重引导小技巧"><a href="#第四章、安装-CentOS-5-x-与多重引导小技巧" class="headerlink" title="第四章、安装 CentOS 5.x 与多重引导小技巧"></a>第四章、安装 CentOS 5.x 与多重引导小技巧</h2><p>那如果按下的是[F5]时，就会进入到救援模式的说明画面，如下图所示：<img src="https://i.loli.net/2021/12/02/YP8iNljTpWAGwdo.png#id=jPUvN&originHeight=210&originWidth=424&originalType=binary&ratio=1&status=done&style=none#id=QadGy&originHeight=210&originWidth=424&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="内存压力测试：memtest86"><a href="#内存压力测试：memtest86" class="headerlink" title="内存压力测试：memtest86"></a>内存压力测试：memtest86</h3><p>CentOS 的 DVD 除了提供一般 PC 来安装 Linux之外，还提供了不少有趣的东西，其中一个就是进行『烧机』的任务！ 这个烧机不是台湾名产烧酒鸡啊，而是当你组装了一部新的个人计算机，想要测试这部主机是否稳定时，就在这部主机上面运作一些比较耗系统资源的程序，让系统在高负载的情下去运作一阵子(可能是一天)，去测试稳定度的一种情况，就称为『烧机』啦！</p>
<h3 id="Kdump-与时区的校正"><a href="#Kdump-与时区的校正" class="headerlink" title="Kdump 与时区的校正"></a>Kdump 与时区的校正</h3><p>完成了防火墙与SELinux的选择后，接下来会出现如下的Kdump窗口。什么是Kdump呢？这个Kdump 就是，当核心出现错误的时候，是否要将当时的内存内的讯息写到档案中，而这个档案就能够给核心开发者研究为啥会当机之用。 我们并不是核心开发者，而且内存内的数据实在太大了，因此常常进行 Kdump 会造成硬盘空间的浪费。 所以，这里建议不要启动 Kdump的功能喔！</p>
<h2 id="第五章、首次登入与在线求助-man-page"><a href="#第五章、首次登入与在线求助-man-page" class="headerlink" title="第五章、首次登入与在线求助 man page"></a>第五章、首次登入与在线求助 man page</h2><h3 id="重新启动X-Window的快速按钮"><a href="#重新启动X-Window的快速按钮" class="headerlink" title="重新启动X Window的快速按钮"></a>重新启动X Window的快速按钮</h3><p>般来说，我们是可以手动来直接修改X Window 的配置文件的，不过，修改完成之后的设定项目并不会立刻被加载，必须要重新启动Ⅹ才行(特别注意，不是重新启动，而是重新启动X！)。那么如何重新启动Ⅹ呢？最简单的方法就是：直接注销，然后再重新登入即可；在 X 的画面中直接按下[Alt] + [Ctrl] + [Backspace]第二个方法比较有趣，[backspace]是退格键，你按下三个按钮后XWindow立刻会被重新启动。 如果你的 X Window 因为不明原因导致有点问题时，也可以利用这个方法来重新启动Ⅹ喔！</p>
<h3 id="X-window-与文本模式的切换"><a href="#X-window-与文本模式的切换" class="headerlink" title="X window 与文本模式的切换"></a>X window 与文本模式的切换</h3><p>我们前面一直谈到的是ⅩWindow的窗口管理员环境，那么在这里面有没有纯文本接口的环境啊？当然有啊！但是，要怎么切换ⅩWindow与文本模式呢？注意喔，通常我们也称文本模式为终端机接口,terminal 或 console 喔 ！ Linux 预设的情况下会提供六个 Terminal 来让使用者登入，切换的方式为使用：[Ctrl] + [Alt] + [F1]<del>[F6]的组合按钮。那这六个终端接口如何命名呢，系统会将[F1]～[F6]命名为 tty1 ~ tty6 的操作接口环境。那么如何回到刚刚的X窗口接口呢？很简单啊！按下[Ctrl] + [Alt] + [F7]就可以了！我们整理一下登入的环境如下：[Ctrl] + [Alt] + [F1] ~ [F6] ：文字接口登入 tty1 ~ tty6 终端机 ;[Ctrl] + [Alt] + [F7] ：图形接口桌面。在 Linux 默认的登入模式中，主要分为两种，一种是仅有纯文本接口(所谓的执行等级 run level 3)的登入环境，在这种环境中你可以有 tty1</del>tty6 的终端界面，但是并没有图形窗口接口的环境喔。 另一种则是图形接口的登入环境(所谓的执行等级 run level 5)，这也是我们第四章安装妥当后的预设环境！在这个环境中你就具有 ttty1<del>tty7 了 ! 其中的 tty7 就是开机完成后的默认等待登入的图形环境！如果你是以纯文本环境启动 Linux 的，预设的 tty7 是没有东西的！万一如此的话，那要怎么启动X窗口画面呢？ 你可以在 tty1</del>tty6 的任意一个终端接口使用你的账号登入后(登入的方法下一小节会介绍)，然后下达如下的指令即可：startx</p>
<h3 id="下达指令"><a href="#下达指令" class="headerlink" title="下达指令"></a>下达指令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[vbird@www ~]$ command [-options] parameter1 parameter2 ...</span><br><span class="line">								指令			选项			参数(1)			参数(2)</span><br><span class="line">说明：</span><br><span class="line">0. 一行指令中第一个输入的部分绝对是『指令(command)！或『可执行文件</span><br><span class="line">1. command 为指令的名称，例如变换路径的指令为 cd 等等；</span><br><span class="line">2. 中刮号[]并不存在于实际的指令中，而加入选项设定时，通常选项前会带 -</span><br><span class="line">例如 -h；有时候会使用选项的完整全名，则选项前带有一符号，例如</span><br><span class="line">help ;</span><br><span class="line">3.parameter1parameter2.. 为依附在选项后面的参数，或者是command参数；</span><br><span class="line">4.选项,参数等这几个咚咚中间以空格来区分，不论空几格都视为一格</span><br><span class="line">5. 按下[Enter]案件后，该指令就立即执行，[Enter]按键代表着一行指令的开始启动</span><br><span class="line">6. 指令太长的时候，可以使用反斜杠（\）来跳脱[Enter]符号，使指令连续到下行。</span><br><span class="line">	注意！反斜杠后就立刻接特殊字符，才能跳脱！</span><br><span class="line">其他：</span><br><span class="line">a.在Linux 系统中，英文大小写字母是不一样的。举例来说， cd 与 CD 并不同</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/12/03/5qAi43OCasZdvQy.png#id=I24Eo&originHeight=228&originWidth=341&originalType=binary&ratio=1&status=done&style=none#id=c7AU1&originHeight=228&originWidth=341&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="重要的几个热键-Tab-ctrl-c-ctrl-d"><a href="#重要的几个热键-Tab-ctrl-c-ctrl-d" class="headerlink" title="重要的几个热键[Tab], [ctrl]-c, [ctrl]-d"></a>重要的几个热键[Tab], [ctrl]-c, [ctrl]-d</h3><p>[Tab]：命令补全[ctrl]-c：中断目前程序的挄键[ctrl]-d：『键盘输入结束(End Of File, EOF 或 End Of Input)』—可以用来取代 exit 的输入</p>
<h3 id="Linux-系统的在线求助-man-page-与-info-page"><a href="#Linux-系统的在线求助-man-page-与-info-page" class="headerlink" title="Linux 系统的在线求助 man page 与 info page"></a>Linux 系统的在线求助 man page 与 info page</h3><p>因为在Linux上开发的软件大多数都是自由软件，而这些软件的开发者为了让大家能够了解指令的用法， 都会自行制作很多的文件，而这些文件也可以直接在在线就能够轻易的被使用者查询出来！这根本就是『联机帮助文件』</p>
<h3 id="正确的关机方法"><a href="#正确的关机方法" class="headerlink" title="正确的关机方法"></a>正确的关机方法</h3><p>将数据同步写入硬盘中的指令： sync</p>
<blockquote>
<p>目前的 shutdown&#x2F;reboot&#x2F;halt 等等指令均已经在关机前进行了 sync 这个工具。不过，多做几次总是比较放心点普通用户仅可对自己的身份的任务进行数据写入更新，root账号可以对整个系统进行数据更新</p>
</blockquote>
<p>惯用的关机指令： shutdown重新启动，关机： reboot, halt, poweroffshutdown可以依据目前已启动的服务来逐次关闭各服务后才关机；至于 halt 却能够在不理会目前系统状况下，进行硬件关机的特殊功能</p>
<h3 id="文件系统错误的问题"><a href="#文件系统错误的问题" class="headerlink" title="文件系统错误的问题"></a>文件系统错误的问题</h3><p>解决的方法其实很简单，不过因为出错扇区所挂载的目录不同，处理的流程困难度就有差异了。 举例来说，如果你的根目录『&#x2F;」并没有损毁，那就很容易解决，如果根目录已经损毁了，那就比较麻烦</p>
<ul>
<li>无损坏</li>
</ul>
<p>进入单机维护工作；假如错误是&#x2F;dev&#x2F;sda7。输入『 fsck &#x2F;dev&#x2F;sda7 』。如果有发现任何的错误时，屏幕会显示： clear [Y&#x2F;N]？ 的询问讯息，就直接输入 Y 吧。最终reboot重启</p>
<ul>
<li>损坏</li>
</ul>
<p>可以将硬盘拔掉，接到另一台 Linux 系统的计算机上，并且不要挂载(mount)该硬盘，然后以 root 的身份执行『 fsck &#x2F;dev&#x2F;sdb1 』；也可以使用近年来径热门的 Live CD</p>
<ul>
<li>如果硬盘整个坏掉</li>
</ul>
<p>能救出来的救出来，然后换一颗硬盘来重新安装Linux 吧</p>
<blockquote>
<p>如何预防发生文件系统错误：划分不同的 partition</p>
</blockquote>
<h3 id="忘记-root-密码"><a href="#忘记-root-密码" class="headerlink" title="忘记 root 密码"></a>忘记 root 密码</h3><p>以单人维护模式登入即可更改你的 root 密码：系统启动–&gt;读秒时按“e”进入grub–&gt;移动至“kernel”一行，再按“e”–&gt;再最后放输入“single”–&gt;回车确认–&gt;按“b”就开机进入单人维护模式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kernel /vmlinuz-2.6.18-128.el5 ro root=LABEL=/ rhgb quiet single</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在这个模式下，你会在 tty1的地方不需要输入密码即可取得终端机的控制权(而且是使用 root 的身份喔！)</p>
</blockquote>
<p>my：根据系统不同自行百度吧。</p>
<h2 id="第六章-Linux-的档案权限与目录配置"><a href="#第六章-Linux-的档案权限与目录配置" class="headerlink" title="第六章 Linux 的档案权限与目录配置"></a>第六章 Linux 的档案权限与目录配置</h2><h3 id="使用者与群组"><a href="#使用者与群组" class="headerlink" title="使用者与群组"></a>使用者与群组</h3><ol>
<li>档案拥有者：档案设定成『只有档案拥有者，就是我，才能看与修改这个档案的内容』， 那举即使其他人知道你有这个相当『有趣』的档案，不过由二你有设定适当的权限， 所以其他人自然也就无法知道该档案的内容</li>
<li>群组概念：限制非自己团队(亦即是群组) 的其他人不能够阅览内容！而且亦可以让自己的团队成员可以修改我所建立的档案！ 同时，如果我自己还有私人隐密的文件，仍然可以设定成让自己的团队成员也看不到我的档案数据</li>
<li>其他人的概念：王三毛这个『档案』的拥有者为王三毛，他属二王大毛这个群组， 而张小猪相对于王三毛，则只是一个『其他人(others)』</li>
<li>root：他可以到达任何他想要去的地方。</li>
</ol>
<hr>
<p><strong>Linux 用户身份与群组记录的档案</strong></p>
<ul>
<li>默认的情况下，所有的系统上的账号不一般身份使用者，还有那个 root 的相关信息， 都是记录在&#x2F;etc&#x2F;passwd 这个档案内的</li>
<li>个人的密码则是记录在&#x2F;etc&#x2F;shadow 这个档案下</li>
<li>Linux 所有的组名都记录在&#x2F;etc&#x2F;group</li>
</ul>
<hr>
<p><strong>Linux文件属性</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls -al:查看文件属性</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2021/12/30/TqPzhwDRAXZS4Bn.png#id=YsGGW&originHeight=183&originWidth=504&originalType=binary&ratio=1&status=done&style=none#id=yLYca&originHeight=183&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><strong>第一栏，为档案类型与权限</strong></p>
<ul>
<li>当为[ d ]则是目录，例如上表档名为 『.gconf』的那一行 ;</li>
<li>当为[ - ]则是档案，例如上表档名为 『install.log』那一行 ;</li>
<li>若是[Ⅰ]则表示为连结档(link file)；</li>
<li>若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) ;</li>
<li>若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)。</li>
</ul>
<p><strong>接下来的字符中</strong>，以三个为一组，且均为「rwx」 的三个参数的组合。[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute)。这三个权限的位置不会改变，如果没有权限，就会出现减号[－]而已。</p>
<p><img src="https://s2.loli.net/2021/12/30/Apd9wPoiFxjDLXr.png#id=fOA9Q&originHeight=249&originWidth=620&originalType=binary&ratio=1&status=done&style=none#id=eWkSN&originHeight=249&originWidth=620&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">第二栏表示有多少档名连结到此节点(i-node)：第三栏表示这个档案(或目录)的『拥有者账号』第四栏表示这个档案的所属群组第五栏为这个档案的容量大小，默认单位为 bytes；第八栏为这个档案的建档日期或者是最近的修改日期：第九栏为这个档案的档名：如果档名前多一个『 . 』，则代表这个档案为『隐藏档』</p>
<hr>
<p><strong>如何改变文件属性的权限</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chgrp : 改收变档案所属群组</span><br><span class="line">chgrp [-R] dirname/filename ...</span><br><span class="line">选项与参数：</span><br><span class="line">-R :递归(recursive)的持续变更</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chown ：改变档案拥有者</span><br><span class="line">chown [-R] 账号名称:组名 档案或目录</span><br><span class="line">选项与参数：</span><br><span class="line">-R :递归(recursive)的持续变更</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod ：改变档案的权限, SUID, SGID, SBIT 等等的特性</span><br><span class="line">权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更</span><br><span class="line"></span><br><span class="line">数字修改权限：r:4;w:2;x:1</span><br><span class="line">chmod [-R] xyz 档案或目录</span><br><span class="line">选顷与参数：</span><br><span class="line">xyz : 就是刚刚提到的数字类型的权限属怅，为 rwx 属性数值的相加。</span><br><span class="line">-R : 进行递归(recursive)的持续变更，亦即连同次目录下的所有档案都会变更</span><br><span class="line"></span><br><span class="line">符号修改权限</span><br><span class="line"> u, g, o, a ：user, group, others, all</span><br><span class="line"> r, w, x</span><br><span class="line"> +(加入)， -(除去)， =(设定)</span><br><span class="line"> </span><br><span class="line"> 例如： chmod u=rwx,go=rx .bashrc</span><br></pre></td></tr></table></figure>

<p>目录与档案之权限意义</p>
<ul>
<li>权限对档案的重要性</li>
</ul>
<p>r (read)：可读取此一档案的实际内容，如读取文本文件的文字内容等；w (write)：可以编辑、新增或者是修改该档案的内容(但不含删除该档案)；x (eXecute)：该档案具有可以被系统执行的权限。为在Windows 底下一个档案是否具有执行的能力是藉由『 扩展名 』来判断的，例如：.exe, bat, .com 等等，但是在Linux底下，我们的档案是否能被执行，则是藉由是否具有x 这个权限来决定的！跟档名是没有绝对的关系的</p>
<ul>
<li>权限对目录的重要性 <ul>
<li>r (read contents in directory) :</li>
</ul>
</li>
</ul>
<p>表示具有读取目录结构列表的权限，所以当你具有读取(r)一个目录的权限时，表示你可以查询该目录下的文件名数据。 所以你就可以利用 Is 这个指令将该目录的内容列表显示出来</p>
<ul>
<li>w (modify contents of directory) :</li>
</ul>
<p>他表示你具有异动该目录结构列表的权限，也就是底下这些权限：建立新的档案与目录；删除已经存在的档案与目录(不论该档案的权限为何！)将已存在的档案或目录进行更名；搬移该目录内的档案、目录位置。</p>
<ul>
<li>x (access directory) :</li>
</ul>
<p>目录的 x 代表的是用户能否进入该目录成为工作目录的用途</p>
<hr>
<h3 id="Linux-档案种类与扩展名"><a href="#Linux-档案种类与扩展名" class="headerlink" title="Linux 档案种类与扩展名"></a>Linux 档案种类与扩展名</h3><ul>
<li>档案种类 <ul>
<li>正规档案(regular file）:</li>
</ul>
</li>
</ul>
<p>第一个字符为[-]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 纯文本档(ASCII)：这是 Linux 系统中最多的一种文件类型啰， 称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。 几乎只要我们可以用来做为设定的档案都属于这一种文件类型。</span><br><span class="line">- 二进制文件(binary)：还我们的系统其实仅认识且可以执行二进制文件(binary file)。你的Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的</span><br><span class="line">- 数据格式文件(data)：有些程序在运作的过程当中会读取某些特定格式的档案，那些特定格式的档案可以被称为数据文件（data file）。</span><br></pre></td></tr></table></figure>

<ul>
<li>目录(directory) :第一个属性为[d]，例如[drwxrwxrwx]。</li>
<li>连结档(link)：就是类似 Windows 系统底下的快捷方式。 第一个属性为<a href="%E8%8B%B1%E6%96%87L%E7%9A%84%E5%B0%8F%E5%86%99">I</a>，例：[lrwxrwxrwx] ;</li>
<li>设备与装置文件(device) :与系统周边及储存等相关的一些档案，通常都集中在&#x2F;dev 这个目录之下！通常又分为两种： <ul>
<li>区块(block)设备档 ：就是一些储存数据，以提供系统随机存取的接口设备，举例来说。硬盘与软盘等。你可以随机的在硬盘的不同区块读写，这种装置就是成组设备啰！你可以自行查一下&#x2F;dev&#x2F;sda 看看，会发现第一个属性为[ b ]喔！</li>
<li>字符(character)设备文件：亦即是一些串行端口的接口设备，例如键盘、鼠标等等！这些设备的特色就是『一次性读取』的，不能够截断输出。 举例来说，你不可能让鼠标『跳到』另一个画面，而是『滑动』到另一个地方啊！第一个属性为[c]。</li>
</ul>
</li>
<li>资料接口文件(sockets) :既然被称为数据接口文件，这种类型的档案通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求，而客户端就可以透过这个socket来进行数据的沟通了。第一个属性为[s]，最常在&#x2F;var&#x2F;run 这个目录中看到这种文件类型了。</li>
<li>数据输送文件（FIFO，pipe）：FIFO 也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个档案所造成的错误问题。 FIFO 是 first-in-first-out 的缩写。第一个属性为[p] 。</li>
<li>Linux档案扩展名</li>
</ul>
<p>Linux 的档案是没有所谓的『扩展名』的，我们刚刚就谈过，一个 Linux 档案能被执行，与他的第一栏的十个属性有关， 与文件名根本一点关系也没有。你的权限当中具有 x 的话，例如[ -rwx-r-xr-x ] 即代表这个档案可以被执过，但可以被执行跟可以执行成功是不一样的。虽然如此，不过我们还是希望可以藉由扩展名来了解该档案是什么东西，所以， 通常我们还是会以适当的扩展名来表示该档案是什么种类的。底下有数种常用的扩展名</p>
<ul>
<li>*.sh：脚本或批处理文件（scripts），因为批处理文件为使用 shell 写成的，所以扩展名就编成 .sh 啰 ;</li>
<li>_Z, _.tar, _.tar.gz, _.zip, *.tgz ：经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名啰！</li>
<li>_.html, _.php：网页相关档案，分别代表 HTML 语法与 PHP 语法的网页档案啰！ .html 的档案可使用网页浏览器来直接开启，至于 .php 的档案，则可以透过 client 端的浏览器来 server端浏览</li>
</ul>
<p>基本上，Linux 系统上的文件名真的只是让你了解该档案可能的用途而已， 真正的执行还是要看权限的规范上述的这种问题最常发生在档案传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的Linux 系统中就是无法执行！呵呵！那举就是可能档案的属性被改变了</p>
<ul>
<li>Linux 档案长度限制：</li>
</ul>
<p>在 Linux 底下，使用预设的 Ext2&#x2F;Ext3 文件系统时，针对档案的档名长度限制为：单一档案或目彔的最大容量文件名为 255 个字符；包括完整路径名称及目彔 (&#x2F;) 之完整档名为 4096 个字符。</p>
<ul>
<li>Linux 文件名的限制：</li>
</ul>
<p>由于 Linux 在文字接口下的些指令操作关系般来说，你在设定 Linux 底下的文件名时，最好可以避免一些特殊字符比较好！例如底下这些：*？&gt; &lt;;&amp;![]|””(){}因为这些符号在文字接口下，是有特殊意义的！另外，文件名的开头为小数点『.』时，代表这个档案为『隐藏档』喔！同时，由于指令下达当中，常常会使用到 -option 之类的选项， 所以你最好也避免将档案档名的开头以 - 或 + 来命名啊！</p>
<hr>
<h3 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h3><ul>
<li>根据FHS(<a href="http://www.pathname.com/fhs/">http://www.pathname.com/fhs/)</a>)的官方文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下， 所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循 FHS 的标准。 也就是说，FHS 的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。</li>
</ul>
<p>FHS 依据文件系统使用的频繁与是否允许使用者随意更动， 而将目录设定成为四种交互作用的形态，用表格来说有点像底下这样：</p>
<p>| </p>
<table>
<thead>
<tr>
<th>可分享的(shareable)</th>
<th>不可分享的(unshareable)</th>
</tr>
</thead>
<tbody><tr>
<td>不变的(static)</td>
<td>&#x2F;usr(软件放置处)</td>
</tr>
<tr>
<td></td>
<td>&#x2F;opt (第三方协力软件)</td>
</tr>
<tr>
<td>可变动的(variable)</td>
<td>&#x2F;var&#x2F;mail (使用者邮件信箱)</td>
</tr>
<tr>
<td></td>
<td>&#x2F;var&#x2F;spool&#x2F;news (新闻组)</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">可分享的：可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是</span><br><span class="line">能够分享给网络上其他主机挂载用的目录；</span><br><span class="line"></span><br><span class="line">不可分享的：自己机器上面运作的装置档案或者是与程序有关的 socket 档案等， 由于仅与自身</span><br><span class="line">机器有关，所以当然就不适合分享给其他主机了。</span><br><span class="line"></span><br><span class="line">不变的：有些数据是不会经常变动的，跟随着 distribution 而不变动。 例如函式库、文件说明</span><br><span class="line">文件、系统管理员所管理的主机服务配置文件等等；</span><br><span class="line"></span><br><span class="line">可变动的：经常改变的数据，例如登录文件、一般户可自行收受的新闻组等。</span><br></pre></td></tr></table></figure>

<hr>
<ul>
<li>根目录 (&#x2F;) 的意义与内容：</li>
</ul>
<p>FHS标准建议：根目录(&#x2F;)所在分割槽应该越小越好，且应用程序所安装的软件最好不要与根目录同一个分割槽内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易问题。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置档案内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;bin</td>
<td></td>
</tr>
</tbody></table>
<p>| 系统有很多放置执行文件的目录，但&#x2F;bin 比较特殊。因为&#x2F;bin 放置的是在单人维护模式下还能够被操作的指令。在&#x2F;bin 底下的指令可以被 root 与一般账号所使用，主要有：cat, chmod, chown, date, mv, mkdir, cp, bash 等等常用的指令。 || &#x2F;boot | 这个目录主要在放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需配置文件等等。 Linux kernel 常用的档名为：vmlinuz，如果使用的是 grub 这个开机管理程序，则还会存在&#x2F;boot&#x2F;grub&#x2F;这个目录 || &#x2F;dev | 在 Linux 系统上，任何装置与接口设备都是以档案的型态存在于这个目录当中的。 你只要透过存取这个目录底下的某个档案， 比要重要的档案有&#x2F;dev&#x2F;null,&#x2F;dev&#x2F;zero,&#x2F;dev&#x2F;tty,&#x2F;dev&#x2F;lp_,&#x2F;dev&#x2F;hd_,&#x2F;dev&#x2F;sd*等等 || &#x2F;etc | 系统主要的配置文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各文件属性是可以让一般使用者查阅的， 但是只有 root 有权力修改。FHS 建议不要放置可执行文件(binary)在这个目录中喔。比较重要的档案有：&#x2F;etc&#x2F;inittab,&#x2F;etc&#x2F;init.d&#x2F;,&#x2F;etc&#x2F;modprobe.conf,&#x2F;etc&#x2F;X11&#x2F;,&#x2F;etc&#x2F;fstab, &#x2F;etc&#x2F;sysconfig&#x2F;等等。另外，其下重要的目录有：</p>
<ul>
<li>&#x2F;etc&#x2F;init.d&#x2F;：所有服务的预设启动 script 都是放在这里的，例如要启动或者关&#x2F;etc闭 iptables 的话：『&#x2F;etc&#x2F;init.d&#x2F;iptables start』、『&#x2F;etc&#x2F;init.d&#x2F;iptablesstop』</li>
<li>&#x2F;etc&#x2F;xinetd.d&#x2F;：这就是所谓的 super daemon管理的各项服务的配置文件目录。</li>
<li>&#x2F;etc&#x2F;X11&#x2F;：与X Window 有关的各种配置文件都在这里，尤其是 xorg.conf这个ⅩServer的配置文件。|| &#x2F;home| 这是系统默认的用户家目录(home directory)。在你新增一个一般使用者账号时， 默认的用户家目录都会规范到这里来。比较重要的是，家目录有两种代号喔：<del>：代表目前这个用户的家目录，而</del>dmtsai : 则代表 dmtsai 的家目录！ || &#x2F;lib| 系统的函式库非常的多，而&#x2F;lib 放置的则是在开机时会用到的函式库， 以及在&#x2F;bin或&#x2F;sbin 底下的指令会呼叫的函式库而已。 什么是函式库呢？妳可以将他想成是『外挂』，某些指令必须要有这些『外挂』才能够顺利完成程序的执行之意。 尤其重要的是&#x2F;lib&#x2F;modules&#x2F;这个目录，因为该目录会放置核心相关的模块(驱动程序)喔！ || &#x2F;media</li>
</ul>
<p>| media 是『媒体』的英文，顾名思义，这个&#x2F;media 底下放置的就是可移除的装置。包括软盘、光盘、DVD 等等装置都暂时挂载于此。常见的档名有：&#x2F;media&#x2F;floppy,&#x2F;media&#x2F;cdrom等等。 || &#x2F;mnt| 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。 在古早时候，这个目录的用途与&#x2F;media 相同啦！只是有了&#x2F;media之后，这个目录就用来暂时挂载用了。 || &#x2F;opt| 这个是给第三方协力软件放置的目录。什么是第三方协力软件啊？举例来说，KDE这个桌面管理系统是一个独立的计划，不过他可以安装到 Linux 系统中，因此 KDE的软件就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软件(非原本的distribution 提供的)，那么也能够将你的软件安装到这里来。 不过，以前的 Linux 系统中，我们还是习惯放置在&#x2F;usr&#x2F;local目录下呢！ || &#x2F;root | 系统管理员(root)的家目录。之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有 root 的家目录，所以我们会希望 root 的家目录与根目录放置在同一个分割槽中。 || &#x2F;sbin</p>
<p>| Linux 有非常多指令是用来设定系统环境的，这些指令只有 root 才能够利用来『设定』系统，其他用户最多只能用来『查询』而已。 放在&#x2F;sbin 底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。 至于某些服务器软件程序，一般则放置到&#x2F;usr&#x2F;sbin&#x2F;当中。至于本机自行安装的软件所产生的系统执行文件(system binary)，则放置到&#x2F;usr&#x2F;local&#x2F;sbin&#x2F;当中了。常见的指令包括：fdisk, fsck,ifconfig, init, mkfs等等。 || &#x2F;srv | srv 可以视为「service』的缩写，是一些网络服务启动之后，这些服务所需要取用的数据目录。 常见的服务例如 WWW, FTP 等等。举例来说，WWW 服务器需要的网页资料就可以放置在&#x2F;srv&#x2F;www&#x2F;里面。 || &#x2F;tmp</p>
<p>| 这是让一般用户或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要数据不可放置在此目录啊！因为FHS 甚至建议在开机时，应该要将&#x2F;tmp 下的数据都删除唷！ |</p>
<p>亊实上 FHS 针对根目录所设定的标准就仅有上面的，不过我们的 Linux 底下还有讲多目录你也需要了解一下的。 底下是几个在 Linux 当中也是非常重要的目录：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>应放置档案内容</th>
</tr>
</thead>
<tbody><tr>
<td>&#x2F;lost+found</td>
<td></td>
</tr>
<tr>
<td>这个目录是使用标准的 ext2&#x2F;ext3 文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时，将一些遗失的片段放置到这个目录下。这个目录通常会在分割槽的最顶层存在，例如你加装一颗硬盘于&#x2F;disk 中，那在这个系统下就会自动产生一个这样的目录 『&#x2F;disk&#x2F;lost+found』</td>
<td></td>
</tr>
<tr>
<td>&#x2F;proc</td>
<td>这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中，例如系统核心、行程信息(process)、周边装置的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的档案例如：&#x2F;proc&#x2F;cpuinfo, &#x2F;proc&#x2F;dma, &#x2F;proc&#x2F;interrupts,</td>
</tr>
<tr>
<td>&#x2F;proc&#x2F;ioports, &#x2F;proc&#x2F;net&#x2F;*等等。</td>
<td></td>
</tr>
<tr>
<td>&#x2F;sys</td>
<td>这个目录其实跟&#x2F;proc 非常类似，也是一个虚拟的文件系统，主要也是记录与核心相关的信息。 包括目前已加载的核心模块与核心侦测到的硬件装置信息等等。这个目录同样不占硬盘容量喔！</td>
</tr>
</tbody></table>
<ul>
<li>&#x2F;usr 的意义与内容：</li>
</ul>
<p>usr 是 Unix Software Resource 的缩写， 也就是『Unix操作系统软件资源』所放置的目录所有系统默认的软件(distribution 发布者提供的软件)都会放置到&#x2F;usr 底下，因此这个目录有点类似 Windows 系统的『C:\Windows\ + C:\Program files\』这两个目录的综合体</p>
<ul>
<li>&#x2F;var 的意义与内容：</li>
</ul>
<p>&#x2F;var 就是在系统运作后才会渐渐占用硬盘容量的目录。 因为&#x2F;var 目录彔主要针对经常变动的档案，包括快取(cache)、登录彔档(log file)以及某些软件运作所产生的档案， 包括程序档案(lock file, run file)，或者例如 MySQL 数据库的档案等等</p>
<ul>
<li>针对 FHS，各家 distributions 的异同</li>
</ul>
<p>由于 FHS 仅是定义出最上层(&#x2F;)及次层(&#x2F;usr, &#x2F;var)的目录内容应该要放置的档案或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。举例来说，CentOS的网络设定数据放在&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F; 目录下，但是SuSE 则是将网络放置在 &#x2F;etc&#x2F;sysconfig&#x2F;network&#x2F; 目录下，目录名称可是不同的。不过只要记住大致的 FHS标准，差异性其实是有限的。</p>
<hr>
<p><strong>目录树(directory tree)</strong></p>
<ul>
<li>目录树有主要特征 <ul>
<li>目录树的启始点为根目录(&#x2F;,root);</li>
<li>每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem。举例来说，可以利用Network File System (NFS) 服务器挂载某特定目录等。</li>
<li>每一个档案在此目录树中的文件名(包含完整路径)都是独一无二的。</li>
</ul>
</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/30/dQ9TuRySpXjO5as.png#id=s14hG&originHeight=636&originWidth=587&originalType=binary&ratio=1&status=done&style=none#id=YXLJ7&originHeight=636&originWidth=587&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<hr>
<p><strong>绝对路径与相对路径</strong></p>
<ul>
<li>绝对路径：由根目录(&#x2F;)开始写起的文件名或目录名称，例如 &#x2F;home&#x2F;dmtsai&#x2F;.bashrc ;</li>
<li>相对路径：相对于目前路径的文件名写法。 例如 .&#x2F;home&#x2F;dmtsai 或 ..&#x2F;..&#x2F;home&#x2F;dmtsai&#x2F;等等。</li>
</ul>
<p>反正开头不是／就属于相对路径的写法. ：代表当前的目录，也可以使用 .&#x2F; 来表示；.. ：代表上一层目录，也可以 ..&#x2F; 来代表。</p>
<hr>
<p><strong>CentOS 的观察</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www ~]# uname -r</span><br><span class="line">2.6.18-128.el5 &lt;==可以察看实际的核心版本</span><br><span class="line">[root@www ~]# lsb_release -a</span><br><span class="line">LSB Version: :core-3.1-amd64:core-3.1-ia32:core-3.1-noarch:graphics-</span><br><span class="line">3.1-amd64:</span><br><span class="line">graphics-3.1-ia32:graphics-3.1-noarch &lt;==LSB 的版本</span><br><span class="line">Distributor ID: CentOS</span><br><span class="line">Description: CentOS release 5.3 (Final) &lt;==distribution 的版本</span><br><span class="line">Release: 5.3</span><br><span class="line">Codename: Fina</span><br></pre></td></tr></table></figure>


<h2 id="第七章-Linux-的档案权限与目录配置"><a href="#第七章-Linux-的档案权限与目录配置" class="headerlink" title="第七章 Linux 的档案权限与目录配置"></a>第七章 Linux 的档案权限与目录配置</h2><p><strong>目录与路径</strong></p>
<ol>
<li><strong>相对路径与绝对路径</strong></li>
</ol>
<p>相对路径意指【相对于目前工作目录】</p>
<hr>
<h4 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h4><p><strong>1 cd：变换目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www /]# cd -</span><br><span class="line"># 表示回到刚刚的那个目录，也就是 /root 啰～</span><br></pre></td></tr></table></figure>

<p><strong>2 pwd :显示当前目录</strong>pwd -P:显示真实路径。例如：联结档<strong>3 mkdir：建立个新的目录</strong>选项与参数 :-m ：配置文件案的权限喔！直接设定，不需要看预设权限 (umask)-p帮助你直接将所需要的目录(包含上层目录)递归建立起来！<strong>4 rmdir :删除空的目录</strong>选项与参数 :-p:递归删除</p>
<hr>
<h4 id="执行文件路径的变量：-PATH"><a href="#执行文件路径的变量：-PATH" class="headerlink" title="执行文件路径的变量：$PATH"></a>执行文件路径的变量：$PATH</h4><p>echo $PATH：显示当前PATH变量</p>
<hr>
<h4 id="档案与目录管理"><a href="#档案与目录管理" class="headerlink" title="档案与目录管理"></a>档案与目录管理</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls [参数] 目录名称</span><br><span class="line">选项与参数：</span><br><span class="line">-d:仅列出目录本身，而不显示目录内的档案数据</span><br><span class="line">-l:长数据串行出，包含档案的属性与权限等等数据</span><br></pre></td></tr></table></figure>

<ol>
<li>cp(复制档案或目录）</li>
</ol>
<p>选项与参数：-a:当我们在进行备份的时候，某些需要特别注意的特殊权限档案，例如密码文件（&#x2F;etc&#x2F;shadow）以及一些配置文件，就不能直接以cp来复制，而必须要加上 -a 或者是 -p 等等-f:若目标文件已经存在时，再覆盖时会先询问动作的进行-p:连同档案的属性一起复制过去，而非使用默认属性-r:递归持续复制，用于目录的复制行为</p>
<ol start="2">
<li>rm(移除档案或目录）</li>
</ol>
<p>-r:递归删除-i:互动模式</p>
<ol start="3">
<li>mv(移动档案与目录，或更名)</li>
</ol>
<p>-f:强制-i:若目标档案已存在，会询问是否删除</p>
<ol start="4">
<li>档案内容查阅：</li>
</ol>
<p>cat：由第一行开始显示档案内容tac：从最后一行开始显示，可以看出 tac 是 cat 的倒着写！nl：显示的时候，顺道输出行号！more：一页一页的显示档案内容less 与 more 类似，但是比 more更好的是，他可以往前翻页！head：只看头几行tail ：只看尾巴几行od：以二进制的方式读取档案内容！</p>
<ol start="5">
<li>修改档案时间或建置新档：touch<ol>
<li>三种时间状态<ol>
<li>mtime:当“内容数据”发生变更时，就会更新这个时间</li>
<li>ctime:当“状态”变更时，就会更新这个时间。例如：权限</li>
<li>atime:当“档案的内容被取用”时，就会更新这个读取时间</li>
</ol>
</li>
<li>最常用的用法<ol>
<li>建立一个空档案</li>
<li>修订档案日期</li>
</ol>
</li>
</ol>
</li>
</ol>
<hr>
<h4 id="档案与目录的默认权限与隐藏权限"><a href="#档案与目录的默认权限与隐藏权限" class="headerlink" title="档案与目录的默认权限与隐藏权限"></a>档案与目录的默认权限与隐藏权限</h4><ol start="6">
<li>档案预设权限：umask</li>
</ol>
<p>参数：不加参数：以数字的方式代表7减去x。x为数字。假如数字为0，即7-0&#x3D;7。即拥有rwx权限-S:以符号类型的方式显示出权限</p>
<ol start="7">
<li><p>档案隐藏属性：</p>
<ol>
<li>chattr(配置文件案隐藏属性）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chattr [+-=][ASacdistu] 档案或目录名称</span><br><span class="line">选项与参数 :</span><br><span class="line">+：增加某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">-：移除某一个特殊参数，其他原本存在参数则不动。</span><br><span class="line">=：设定一定，且仅有后面接的参数</span><br><span class="line"></span><br><span class="line">A:当设定了 A 这个属性时，若你有存取此档案(或目录)时，他的访问时间</span><br><span class="line">atime</span><br><span class="line">	将不会被修改，可避免I/O 较慢的机器过度的存取磁盘。这对速度较慢的计</span><br><span class="line">算机有帮助</span><br><span class="line">S：一般档案是异步写入磁盘的(原理请参考第五章 sync的说明)，如果加上 S</span><br><span class="line">这个</span><br><span class="line">	属性时，当你进行任何档案的修改，该更动会『同步」写入磁盘中。</span><br><span class="line">a：当设定 a 之后，这个档案将只能增加数据，而不能删除也不能修改数据</span><br><span class="line">	只有 root才能设定这个属性。</span><br><span class="line">c：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动</span><br><span class="line">解压缩，</span><br><span class="line">	但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用</span><br><span class="line">的！）</span><br><span class="line"></span><br><span class="line">d:当dump程序被执行的时候，设定 d 属性将可使该档案(或目录)不会被</span><br><span class="line">dump 备份</span><br><span class="line">i：他可以让一个档案『不能被删除、改名、设定连结也无法写入或新增资料！」对于系统安全性有相当大的帮助！只有 root 能设定此属</span><br><span class="line"></span><br><span class="line">s：当档案设定了 s 属性时，如果这个档案被删除，他将会被完全的移除出这个</span><br><span class="line">硬件空间，所以如果误删了，完全无法救回来了喔！</span><br><span class="line">u：与 s 相反的，当使用 u 来配置文件案时，如果该档案被删除了，则数据内容其实还</span><br><span class="line">存在磁盘中，可以使用来救援该档案喔！</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>lsattr(显示档案隐藏属性）</p>
</li>
</ol>
<p>选项与参数：-a：显示隐藏文件的属性-d:如果接的是目录，仅显示目录本身的属性而非目录内的文件名-R:连同子目录的数据也一并列出来</p>
<ol start="9">
<li>档案特殊权限;</li>
</ol>
<p>设置特殊权限后，对应位置应出现小写s。若为大写S，即特殊权限的执行者也没有权限执行。即空权限</p>
<ol>
<li>SUID</li>
</ol>
<ul>
<li>SUID 权限仅对二进制程序(binary program)有效；</li>
<li>执行者对于该程序需要具有 x 的可执行权限；</li>
<li>本权限仅在执行该程序的过程中有效（run-time）;</li>
<li>执行者将具有该程序拥有者 (owner)的权限。</li>
</ul>
<ol start="2">
<li>SGID</li>
</ol>
<ul>
<li>SGID 对二进制程序有用；</li>
<li>程序执行者对于该程序来说，需具备 x 的权限；</li>
<li>执行者在执行的过程中将会获得该程序群组的支持！</li>
</ul>
<p>与SUID非常类似。对项目开发来说非常重要。涉及群组权限</p>
<ol start="3">
<li>SBIT</li>
</ol>
<p>仅对目录有效，对档案没有效果</p>
<ul>
<li>当用户对于此目录具有 w，x 权限，亦即具有写入的权限时；</li>
<li>当用户在该目录下建立档案或目录时，仅有自己与 root 才有权力删除该档案</li>
</ul>
<hr>
<h4 id="观察文件类型-file"><a href="#观察文件类型-file" class="headerlink" title="观察文件类型:file"></a>观察文件类型:file</h4><p>如果你想要知道某个档案的基本数据，例如是属于ASCII或者是data档案，或者是binary，且其中有没有使用到动态函式库（share library）等等的信息，就可以利用file 这个指令来检阅</p>
<hr>
<h4 id="指令与档案的搜索"><a href="#指令与档案的搜索" class="headerlink" title="指令与档案的搜索"></a>指令与档案的搜索</h4><ol start="10">
<li>脚本文件名的搜寻：</li>
<li>which（寻找【执行档】）</li>
</ol>
<p>选项或参数：-a:将所有PATH目录中可以找到的指令均列出，而不止第一个被找到的指令名称</p>
<ol start="11">
<li>档案档名的搜寻：</li>
<li>whereis(寻找特定档案)</li>
</ol>
<p> Linux 系统会将系统内的所有档案都记录在一个数据库档案里面，而当使用whereis或者是底下要说的 locate 时，都会以此数据库档案的内容为准， 因此，有的时后你还会发现使用这两个执行档时，会找到已经被杀掉的档案！而且也找不到最新的刚刚建立的档案呢！参数与选项：-b:只找 binary 格式的档案-m：只找在说明文件manual 路径下的档案-s:只找source 来源档案-u:搜寻不在上述三个项目当中的其他特殊档案</p>
<ol start="2">
<li>locate</li>
</ol>
<p> locate 寻找的数据是由『已建立的数据库 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F;』 里的，不用直接在去硬盘当中存取数据选项与参数:-i:忽略大小写的差异 ;-r:后面可接正规表示法的显示方式</p>
<hr>
<h4 id="更新数据库指令：updatedb"><a href="#更新数据库指令：updatedb" class="headerlink" title="更新数据库指令：updatedb"></a>更新数据库指令：updatedb</h4><p>根据 &#x2F;etc&#x2F;updatedb.conf 的设定去搜寻系统硬盘内的文件名，并更新&#x2F;var&#x2F;lib&#x2F;mlocate 内的数据库档案；</p>
<hr>
<ol start="3">
<li>find</li>
</ol>
<p>选项与参数 :</p>
<pre><code>  1. 与时间有关的选项：
</code></pre>
<p>-mtime n : n为数字，意义为在n天之前的【一天之内！被更动过内容的档案】-mtime +n : 列出在 n 天之前(不含 n 天本身)被更动过内容的档案档名 ;-mtime -n : 列出在 n 天之内(含 n 天本身)被更动过内容的档案档名.-newert file ：file 为一个存在的档案，列出比 file 还要新的档案档名</p>
<pre><code>  2. 与使用者或组名有关的参数：
</code></pre>
<p>-uid n：n为数字，这个数字是用户的账户ID，即UID&#x2F;etc&#x2F;passwd 里面与账号名称对应的数字-gid n ：n 为数字，这个数字是组名的 ID，亦即 GID，这个 GID 记录在&#x2F;etc&#x2F;group -user name : name为使用者账号名称-group name : name为组名，例如 users ;-nouser：寻找档案的拥有者不存在 &#x2F;etc&#x2F;passwd 的人 ！-nogroup：寻找档案的拥有群组不存在于 &#x2F;etc&#x2F;group 的档案！当你自行安装软件时，很可能该软件的属性当中并没有档案拥有者这是可能的！在这个时候，就可以使用-nouser与-nogroup搜寻</p>
<pre><code>  3. 与档案权限及名称有关的参数：
</code></pre>
<p>-name filename：搜寻文件名为 filename 的档案-size [+-]SIZE：搜寻比 SIZE 还要大(+)或小(-)的档案。这个 SIZE 的规格有：c: 代表 byte ,k: 代表 1024bytes。所以，要找比 50KB还要大的档案，就是『-size +50k ]-type TYPE：搜寻档案的类型为 TYPE 的，类型主要有：一般正规档案(f),装置档案 (b, c), 目录 (d), 连结档 (l), socket (s),及 FIFO (p) 等属性。-perm mode：搜寻档案权限『刚好等于」mode 的档案，这个mode为类似chmod的属性值。举例来说，-rwsr-xr-x 的属性为 4755 !【必须全部囊括mode的权限，即4755】-perm +mode:搜索档案权限【包含任一mode 的权限】的档案。即4755的档案，可以-perm -0777</p>
<h2 id="第八章-Linux磁盘与文件系统管理"><a href="#第八章-Linux磁盘与文件系统管理" class="headerlink" title="第八章 Linux磁盘与文件系统管理"></a>第八章 Linux磁盘与文件系统管理</h2><h3 id="认识EXT2文件系统"><a href="#认识EXT2文件系统" class="headerlink" title="认识EXT2文件系统"></a>认识EXT2文件系统</h3><ol>
<li>文件系统特征<ol>
<li>格式化</li>
</ol>
</li>
</ol>
<p>为什么需要进行『格式化』呢？这是因为每种操作系统所设定的文件属性&#x2F;权限并不相同， 为了存放这些档案所需的数据，因此就需要将分割槽进行格式化，以成为操作系统能够利用的『文件系统格式(filesystem)』。但现在已经有新技术可以将一个分割槽格式划分多个文件系统（例如LVM），也能将多个分割槽合成一个文件系统（LVM,RAID）</p>
<ol start="2">
<li>如何运作<ol>
<li>inode（权限与属性区块）</li>
</ol>
</li>
</ol>
<p>例如Linux的档案权限（rwx）</p>
<pre><code>  2. block（实际数据区块）
</code></pre>
<p>实际记录档案的内容，若档案太大，会占用多个block</p>
<pre><code>  3. superblock（超级区块）
</code></pre>
<p>记录整个文件系统的整体信息，包括inode和block的总量、使用量、剩余量等</p>
<ol start="3">
<li>如何读取<ol>
<li>索引式文件系统</li>
</ol>
</li>
</ol>
<p>通过读取inode的信息来确定block号码</p>
<pre><code>  2. FAT文件系统
</code></pre>
<p>不存在inode，所以每个区块记录下一个区块的信息。因此需要磁盘整理</p>
<ol start="2">
<li>linux的EXT2文件系统</li>
</ol>
<p> Ext2 文件系统在格式化的时候基本上是区分为多个区块群组 (block group)的，每个区块群组都有独立的 inode&#x2F;block&#x2F;superblock 系统<img src="https://s2.loli.net/2022/01/14/kgG6LIS1cKOXb89.png#id=D78o7&originHeight=190&originWidth=362&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol>
<li>data block（资料区块）<table>
<thead>
<tr>
<th>block大小</th>
<th>1kb</th>
<th>2kb</th>
<th>4kb</th>
</tr>
</thead>
<tbody><tr>
<td>最大单一档案限制</td>
<td>16gb</td>
<td>256gb</td>
<td>2tb</td>
</tr>
<tr>
<td>最大文件系统总容量</td>
<td>2tb</td>
<td>8tb</td>
<td>16tb</td>
</tr>
</tbody></table>
<ol>
<li>基本限制</li>
</ol>
<ul>
<li>原则上，block的大小与数量在格式化完就不能够再改变了(除非重新格式化)；</li>
<li>每个 block 内最多只能够放置一个档案的数据；</li>
<li>承上，如果档案大于 block的大小，则一个档案会占用多个 block 数量；</li>
<li>承上，若档案小于 block，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)。</li>
</ul>
</li>
<li>inode table(inode表格)<ol>
<li>数据内容</li>
</ol>
<ul>
<li>该档案的存取模式(read&#x2F;write&#x2F;excute) ;</li>
<li>该档案的拥有者与群组(owner&#x2F;group)；</li>
<li>该档案的容量；</li>
<li>该档案建立或状态改变的时间(ctime) ;</li>
<li>最近一次的读取时间(atime)；</li>
<li>最近修改的时间(mtime)；</li>
<li>定义档案特性的旗标(flag)，如SetUID.</li>
<li>该档案真正内容的指向 (pointer) ;</li>
</ul>
<ol start="2">
<li>特征</li>
</ol>
<ul>
<li>每个inode大小均固定为128bytes；</li>
<li>每个档案都仅会占用一个 inode 而已；</li>
<li>承上，因此文件系统能够建立的档案数量与 inode 的数量有关；</li>
<li>系统读取档案时需要先找到 inode，并分析 inode 所记录的权限与用户是否符合，若符合才能够开始实际读取 block 的内容。</li>
</ul>
<ol start="3">
<li>遇到大文件时</li>
</ol>
</li>
</ol>
<p><img src="https://s2.loli.net/2022/01/14/wa5bVl4cshU8ngC.png#id=wfzxX&originHeight=435&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol start="3">
<li>superblock（超级区块）<ol>
<li>主要信息</li>
</ol>
<ul>
<li>block 与 inode 的总量 ;</li>
<li>未使用与已使用的 inode &#x2F; block 数量；</li>
<li>block 与 inode 的大小 (block 为 1, 2, 4K , inode 为 128 bytes) ;</li>
<li>filesystem 的挂载时间、最近一次写入数据的时间、最近一次检验磁盘 (fsck) 的时间等文件系统的相关信息；</li>
<li>一个valid bit数值，若此文件系统已被挂载，则valid bit为0，若未被挂载，则valid bit为1</li>
</ul>
</li>
<li>Filesystem Description (文件系统描述说明)</li>
</ol>
<p>这个区段可以描述每个 block group 的开始与结束的 block 号码，以及说明每个区段 (superblock,bitmap, inodemap, data block) 分别介亍哪一个 block 号码之间</p>
<ol start="5">
<li>block bitmap (区块对照表)</li>
</ol>
<p>从 block bitmap 当中可以知道哪些 block 是空的，因此我们的系统就能够很快速的找到可使用的空间来处置档案</p>
<ol start="6">
<li>inode bitmap (inode 对照表)</li>
</ol>
<p>inode bitmap 则是记录使用不未使用的 inode 号码</p>
<hr>
<ol start="7">
<li>与目录树的关系<ol>
<li>目录</li>
</ol>
</li>
</ol>
<p>当我们在 Linux 下的 ext2 文件系统建立一个目彔时， ext2 会分配一个 inode 不至少一块 block 给该目录。其中，inode 记录该目录的相关权限与属性，并可记录分配到的那块 block 号码； 而 block 则是记录在这个目录下的文件名与该文件名占用的 inode 号码数据。</p>
<pre><code>  2. 档案
</code></pre>
<p>建立一般档案时，ext2会分类一个inode相对于该档案大小的block数量给该档案</p>
<pre><code>  3. file system大小与磁盘读取效能
</code></pre>
<p>随着文件系统增大，数据可存在的区块增多。分散的概率也就增大，随着数据分散，最终可能会导致低效读取的出现</p>
<pre><code>  4. 数据不一致状态
</code></pre>
<p>在早期的 Ext2 文件系统中，如果发生意外断电等错误，导致数据没有正常写入。 那系统在重新启动的时候，就会藉由 Superblock 当中记录的valid bit (是否有挂载) 与 filesystem state (clean 与否) 等状态来判断是否强制强行数据一致性的检查！</p>
<pre><code>     1. 日志式文件系统
</code></pre>
<p>如果在我们的filesystem 当中规划出一个区块，该区块专门在记录写入或修订档案时的步骤， 那不就可以简化一致性检查的步骤了？也就是说：</p>
<pre><code>        1. 预备：当系统要写入一个档案时，会先在日志记录区块中纪录某个档案准备要写入的信息；
        2. 实际写入：开始写入档案的权限与数据；开始更新 metadata 的数据；
        3. 结束：完成数据与 metadata 的更新后，在日志记录区块当中完成该档案的纪录。
</code></pre>
<hr>
<ol start="8">
<li>Linux文件系统的运作</li>
</ol>
<p>Linux 使用的方式是透过一个称为异步处理：当系统加载一个档案到内存后，如果该档案没有被更动过，则在内存区段的档案数据会被设定为干净(clean)的。 但如果内存中的档案数据被更改过了(例如你用 nano 去编辑过这个档案)，此时该内存中的数据会被设定为脏的 (Dirty)。此时所有的动作都还在内存中执行，并没有写入到磁盘中！系统会不定时的将内存中设定为 [Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性。 可以通过sync来强制内存中设定为“Dirty”的档案写回到磁盘中</p>
<ol start="9">
<li>挂载点的意义</li>
</ol>
<p>挂载点一定是目录，该目录为进入该文件系统的入口</p>
<ol start="10">
<li>linux VFS</li>
</ol>
<p>整个Linux的系统都是透过一个名为 Virtual Filesystem Switch的核心功能去读取file system的</p>
<hr>
<h3 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h3><ol>
<li>磁盘与目录的容量<ol>
<li>磁盘与目录的容量：<ol>
<li>df：列出文件系统的整体磁盘使用量</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>-h：以人们较易读的容量格式 (G&#x2F;M) 显示</p>
<pre><code>  2. du：评估文件系统的磁盘使用量（常用于在推估目录所占容量）
</code></pre>
<hr>
<ol start="2">
<li>实体链接与符号链接：ln [-sf] 来源文件 目标文件</li>
</ol>
<p>选项与参数：-s ：如果不加任何参数就进行连结，那就是 hard link，至亍 -s 就是 symboliclink一种是类似 Windows 的快捷方式功能的档案，可以帮助你快速的链接到目标档案(或目录)； 另一种则是透过文件系统的inode 连结来产生新档名，而不是产生新档案！这种称为实体链接 (hard link)。 </p>
<ol>
<li>Hard Link (实体链接, 硬式连结或实际连结)</li>
</ol>
<p>hard link只是再某个目录下新增一笔档名链接到某inode号码的关连记录</p>
<ol start="2">
<li>Symbolic Link (符号链接，亦即是快捷方式)</li>
</ol>
<p>直接指向读取他link的那个档案的档名</p>
<hr>
<h2 id="9-磁盘管理"><a href="#9-磁盘管理" class="headerlink" title="9. 磁盘管理"></a>9. 磁盘管理</h2><h3 id="9-1-磁盘的分割、格式化、检验与挂载"><a href="#9-1-磁盘的分割、格式化、检验与挂载" class="headerlink" title="9.1 磁盘的分割、格式化、检验与挂载"></a>9.1 磁盘的分割、格式化、检验与挂载</h3><p>Linux下划分硬盘步骤</p>
<ol>
<li>对磁盘进行分割，以建立可用的partition;</li>
<li>对该partition进行格式化(format),以建立系统可用的filesystem;</li>
<li>若想要仔细一点，则可对刚刚建立好的filesystem进行检验：</li>
<li>在Liux系统上，需要建立挂载点（亦即是目录），并将他挂载上来；</li>
</ol>
<p>具体操作工具：fdisk（分区工具）、mkfs（格式化工具）、【fsck、badblocks】（磁盘校验工具——检查文件系统是否出错）、badblocks（磁盘坏轨检查工具）、mount（挂载工具）、umount（卸载装置档案）</p>
<h3 id="9-2-内存置换空间（swap）之建置"><a href="#9-2-内存置换空间（swap）之建置" class="headerlink" title="9.2 内存置换空间（swap）之建置"></a>9.2 内存置换空间（swap）之建置</h3><ol>
<li>分割：先使用fdisk在你的磁盘中分割中一个分割槽给系统作为swap。由于Linux的fdisk预设会将分割槽的ID设定为LinUⅸ的文件系统，所以你可能还得要设定一下system ID就是了。</li>
<li>格式化：利用建立swap格式的『mkswap装置文件名」就能够格式化该分割槽成为swap格式</li>
<li>使用：最后将该swap装置启动，方法为：『swapon装置文件名」。</li>
<li>观察：透过free这个指令来观察一下内存的用量</li>
</ol>
<h2 id="10-档案与文件系统的压缩与打包"><a href="#10-档案与文件系统的压缩与打包" class="headerlink" title="10. 档案与文件系统的压缩与打包"></a>10. 档案与文件系统的压缩与打包</h2><p><strong>压缩解压工具：</strong>gzip（压缩与解压工具）、bzip2（为了超越gzip而来的）、tar（打包指令）</p>
<p><strong>备份工具：</strong>dump</p>
<h2 id="11-vim编辑器（略）"><a href="#11-vim编辑器（略）" class="headerlink" title="11. vim编辑器（略）"></a>11. vim编辑器（略）</h2><h2 id="12-BASH"><a href="#12-BASH" class="headerlink" title="12. BASH"></a>12. BASH</h2><h3 id="12-1-硬件、核心与shell"><a href="#12-1-硬件、核心与shell" class="headerlink" title="12.1 硬件、核心与shell"></a>12.1 硬件、核心与shell</h3><p>硬件：当然就是需要你的硬件有『声卡芯片』这个配备核心管理：操作系统的核心可以支持这个芯片组，当然还需要提供芯片的驱动程序应用程序：需要使用者（就是你）输入发生声音的指令</p>
<p>shell即是用户与核心对话的渠道之一</p>
<hr>
<p><strong>shell的优势：各家核心的bash几乎一样、速度快、可以修复系统、支持记忆操作、编写程序化脚本、通配符支持、支持变量功能</strong></p>
<hr>
<p>管道命令：<strong>使用管道操作符“|”可以把一个命令的标准输出传送到另一个命令的标准输入中，连续的|意味着第一个命令的输出为第二个命令的输入，第二个命令的输入为第一个命令的输出</strong></p>
]]></content>
      <tags>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>桌面系统</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>net安装报错</title>
    <url>/2021/12/13/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Windows/net%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99/</url>
    <content><![CDATA[<p>报错样式：</p>
<p><img src="https://s2.loli.net/2021/12/13/xuGgXVtEKNLQ9pM.png#id=bv5go&originHeight=412&originWidth=580&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://s2.loli.net/2021/12/13/UtYiJ41EzNasGR2.png#id=J0Q5W&originHeight=442&originWidth=539&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">解决方法：win+r运行 CMD后，输入 CHKDSK E:&#x2F;R后回车——E:为你出现问题的盘符<img src="https://s2.loli.net/2021/12/13/hMz8PDfdLqaUQCb.png#id=Kcy7H&originHeight=326&originWidth=500&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>NET</tag>
        <tag>报错</tag>
      </tags>
  </entry>
  <entry>
    <title>windows任务计划程序0x41301问题解决方法</title>
    <url>/2022/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Windows/windows%E4%BB%BB%E5%8A%A1%E8%AE%A1%E5%88%92%E7%A8%8B%E5%BA%8F0x41301%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>解决方法：1.bat文件最后一定不要加类似pause的命令，也就是说，不要加有等待的命令，加了话就造成了0x41301报错问题，适用其他类型的脚本。</p>
<p>2.选择“不管用户是否登录都要运行”，勾选最高权限运行，然后用保存密码方式；记住运行此任务的用户；</p>
<p>然后打开“控制面板”、“管理工具”，然后打开“本地安全策略”。在“本地安全策略”窗口中，依次单击“本地策略”、“用户权限分配”，然后单击“作为批处理作业登录”，将此执行此计划任务的用户增加到列表里就可以了。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>数据库</title>
    <url>/2022/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h1><h2 id="1-1-数据库的基本概念"><a href="#1-1-数据库的基本概念" class="headerlink" title="1.1 数据库的基本概念"></a>1.1 数据库的基本概念</h2><h3 id="1-1-1-几个术语"><a href="#1-1-1-几个术语" class="headerlink" title="1.1.1 几个术语"></a>1.1.1 几个术语</h3><ol>
<li>数据库</li>
</ol>
<p><strong>数据库（Database，DB）是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据和数据的定义的集合</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742105272-a5e5485b-cb63-484b-9fc9-c6a7a1989a83.jpeg"></p>
<ol start="2">
<li>数据库管理系统</li>
</ol>
<p><strong>数据库管理系统(DBMS)是指能够对数据库进行有效管理的一个计算机软件，它建立在操作系统的基础上，对数据库进行统一管理和控制。</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742107176-24b88a70-b97a-4bf9-9747-e2962f91cba2.jpeg"></p>
<ol start="3">
<li>数据库系统</li>
</ol>
<p><strong>数据库应用系统简称数据库系统，是指在计算机应用系统中引入数据库后的系统****数据库管理员(Database Administrator，DBA)对数据库进行规划、设计、维护和监视等，在数据库系统中起着非常重要的作用，数据库的运维工作主要由数据库管理员通过对DBMS的配置和各种操纵来完成。</strong></p>
<h3 id="1-1-2-数据库系统的层次结构"><a href="#1-1-2-数据库系统的层次结构" class="headerlink" title="1.1.2 数据库系统的层次结构"></a>1.1.2 数据库系统的层次结构</h3><p><strong>数据库系统的三级模式结构是指数据库是由外模式、模式、内模式三级构成，外模式与模式之间有映像关系、模式和内模式之间也有映像关系</strong>。  <img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652742674803-2892e942-3661-478e-ba51-3c4f7164482d.jpeg"></p>
<ul>
<li>物理数据层：它是数据库的最内层，是物理存储设备上实际存储的数据的集合，这些数据是原始数据，是应用系统加工的对象；</li>
<li>概念数据层：它是数据库的中间层，是数据库的整体逻辑表示，指出了每个数据的逻辑定义及数据间的逻辑联系，是存储记录的集合，是数据库管理员概念下的数据库；</li>
<li>用户数据层：它是用户所看到和使用的数据库，表示了一个或一些特定用户使用的数据集合，即逻辑记录的集合。</li>
</ul>
<ol>
<li>模式</li>
</ol>
<p> 模式也称逻辑模式、概念模式，是对数据库中全体数据的逻辑结构和特征的描述   定义模式时不仅要定义数据的逻辑结构，如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等，而且要定义数据之间的联系，定义与数据有关的安全性、完整性的要求，关系数据库中的表（Table）就是模式的典型代表。  </p>
<ol start="2">
<li>外模式</li>
</ol>
<p> 外模式也称子模式或用户模式，它是对数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图  </p>
<ol start="3">
<li>内模式</li>
</ol>
<p> 内模式也称存储模式，是整个数据库的底层表示，它由许多内部记录型中每一类型的许多值组成，用来描述数据实际上是如何存储的   内模式不仅定义各种存储记录，还说明存在什么索引、存储记录怎么表示、存储记录在什么物理队列中等，如记录按什么存储方式存储，索引按什么方式组织，数据是否压缩存储、是否加密，数据的存储记录结构有何规定等。关系数据库中的索引（Index）就属于内模式的范畴。  </p>
<ol start="4">
<li>数据库的两级映像功能</li>
</ol>
<p>数据库的三级模式对应数据的三个抽象级别，它把数据的具体组织留给DBMS管理数据库管理系统在这三个模式之间提供了两级映像：外模式&#x2F;模式映像、模式&#x2F;内模式映像。</p>
<ol>
<li>外模式&#x2F;模式映像。模式描述的是数据的全局逻辑结构，外模式描述的是数据的局部逻辑结构。对应于同一个模式可以有任意多个外模式，对于每一个外模式，数据库系统都有一个外模式&#x2F;模式映像，它定义了该外模式与模式之间的对应关系，这些映像通常包含在各自外模式的描述中。</li>
</ol>
<p>如果模式改变（如增加新的关系、增加新的属性、改变属性的数据类型等），就要由数据库管理员对各个外模式&#x2F;模式的映像做相应改变，也可以使外模式保持不变，应用程序是依据数据的外模式编写的，因此应用程序也不必修改，从而保证了数据与程序的逻辑独立性，简称<strong>数据的逻辑独立性</strong>。</p>
<ol start="2">
<li>模式&#x2F;内模式映像。模式&#x2F;内模式映像定义了数据全局逻辑结构与存储结构之间的对应关系。例如，说明逻辑记录和字段在内部是如何表示的，该映像定义通常包含在模式描述中。</li>
</ol>
<p>当数据库的存储结构改变时（如采用了另外一种存储结构），由数据库管理员对模式&#x2F;内模式做相应改变，可以使模式保持不变，因此应用程序也不必改变。这就保证了数据与程序的物理独立性，简称<strong>数据的物理独立性</strong>。在数据库的三级模式结构中，数据库模式是数据库的中心与关键，它独立于数据库的其他层次，因此设计数据库模式结构时应首先确定数据库的逻辑模式。数据库的两级映像保证了数据库外模式的稳定性，从而从底层保证了应用程序的稳定性，除非应用需求本身发生变化，否则应用程序一般不需要修改。</p>
<h3 id="1-2-数据库系统运行与维护"><a href="#1-2-数据库系统运行与维护" class="headerlink" title="1.2 数据库系统运行与维护"></a>1.2 数据库系统运行与维护</h3><h3 id="1-2-1-数据库系统运维管控"><a href="#1-2-1-数据库系统运维管控" class="headerlink" title="1.2.1 数据库系统运维管控"></a>1.2.1 数据库系统运维管控</h3><p><strong>1．数据库系统运维的主要内容</strong>数据库系统的平稳运行至关重要，系统产生故障甚至宕机则意味着中断业务，产生混乱，丢失数据。系统故障中断的负面影响不仅限于经济损失，公司形象受损是最让人担心的问题。<strong>数据库运维的目标就是保证数据库系统的高性能、高可用****数据库运维服务是指</strong>针对数据库开展的软件安装、配置优化、预防性巡检、故障排除、备份策略选择及实施、数据恢复等一系列服务，主要包括以下几个方面。<strong>（1）数据库安装与配置。</strong>从图1-1中可以看出，应用系统通过DBMS来访问数据库，由DBMS实例和数据库组成数据库服务器，数据库服务器其实就是运行在网络中的一台或多台服务器上的数据库管理系统软件，数据库服务器为客户应用提供服务，这些服务是查询、更新、事务管理、索引、高速缓存、查询优化、安全及多用户存取控制等。数据库服务器需要定制DBMS的安装配置方案，检查软件安装环境，安装DBMS软件，完成数据库配置并测试。<strong>（2）数据库对象管理。</strong>从图1-2中可以看出，数据库包括模式、内模式、外模式，不同的模式对应不同的数据库对象，如表、索引、视图、约束条件等，这些对象需要经常进行维护，维护的过程成为数据库对象的管理，如数据库对象的创建、删除、修改等。<img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652742923641-45000422-4e74-46c7-b57c-76d9ac069683.png#clientId=udaff6168-4c9f-4&from=paste&id=u09c0ecab&originHeight=544&originWidth=932&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u49e342a7-2072-462b-a1a9-00b64324b34&title=">图1-2 基于数据库三级模式两级映像的数据库系统的层次结构<strong>（3）数据库安全性管理<strong><strong>（4）数据库性能优化</strong></strong>（5）数据库备份与恢复<strong><strong>（6）故障排除</strong></strong>（7）预防性巡检。</strong>定期提供预防性巡检，并完成系统参数、配置调优，以及补丁分发、安装服务。</p>
<h1 id="2-数据库服务器的管理与配置"><a href="#2-数据库服务器的管理与配置" class="headerlink" title="2. 数据库服务器的管理与配置"></a>2. 数据库服务器的管理与配置</h1><h2 id="2-1-MySQL数据库服务器安装"><a href="#2-1-MySQL数据库服务器安装" class="headerlink" title="2.1 MySQL数据库服务器安装"></a>2.1 MySQL数据库服务器安装</h2><h3 id="2-1-1-Windows下MySQL的安装"><a href="#2-1-1-Windows下MySQL的安装" class="headerlink" title="2.1.1 Windows下MySQL的安装"></a>2.1.1 Windows下MySQL的安装</h3><p>百度下载，下一步……自行脑补</p>
<h3 id="2-1-2-ubuntu下MySQL的安装"><a href="#2-1-2-ubuntu下MySQL的安装" class="headerlink" title="2.1.2 ubuntu下MySQL的安装"></a>2.1.2 ubuntu下MySQL的安装</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install mysql-client mysql-server</span><br></pre></td></tr></table></figure>
<p>设置配置文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">配置/etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">!includedir /etc/mysql/mysql.conf.d/</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql的安装目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">basedir=/usr/local/mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">datadir= /var/lib/mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用–skip-external-locking MySQL选项以避免外部锁定。该选项默认开启</span></span><br><span class="line">external-locking = FALSE</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=error.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pid-file=mysqld.pid</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义mysql应该支持的sql语法，数据校验</span></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">[mysql]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[client]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cat /etc/mysql/debian.cnf	#查看默认密码</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service mysql restart	#重启服务</span><br></pre></td></tr></table></figure>



<h3 id="2-1-3-启动、连接、断开和停止MySQL服务器"><a href="#2-1-3-启动、连接、断开和停止MySQL服务器" class="headerlink" title="2.1.3 启动、连接、断开和停止MySQL服务器"></a>2.1.3 启动、连接、断开和停止MySQL服务器</h3><p><strong>1.启动和停止MySQL服务器****启动和停止MySQL服务器的方法有两种：系统服务器和命令提示符（DOS）。</strong>（1）选择“开始”→“控制面板”→ “系统和安全”→ “管理工具”→ “服务”，找到【Mysql】服务进行对应操作（2）cmd</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">net stop mysql	<span class="comment">#停止mysql</span></span><br><span class="line">net start mysql	<span class="comment">#停止mysql</span></span><br></pre></td></tr></table></figure>
<p><strong>2.连接和断开MySQL服务器</strong>首先你得有一个mysql应用可以执行。去到cmd</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mysql -u 账户 -h 主机地址 -p 密码</span><br></pre></td></tr></table></figure>


<h2 id="2-2-MySQL数据库服务器的体系结构"><a href="#2-2-MySQL数据库服务器的体系结构" class="headerlink" title="2.2 MySQL数据库服务器的体系结构"></a>2.2 MySQL数据库服务器的体系结构</h2><h3 id="2-2-1-MySQL数据库服务器的逻辑架构"><a href="#2-2-1-MySQL数据库服务器的逻辑架构" class="headerlink" title="2.2.1 MySQL数据库服务器的逻辑架构"></a>2.2.1 MySQL数据库服务器的逻辑架构</h3><p><strong>数据库</strong>。数据库就是物理操作系统文件或其他形式文件类型的集合，是指以一定方式存储在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。<strong>数据库实例</strong>。数据库实例由后台线程和一个共享内存组成，是位于用户与操作系统之间的一层数据管理软件，用户对数据库的定义、运行控制，及对数据的查询、维护等都是通过数据库实例来完成的。数据库实例概念中所说的数据管理软件就是DBMS软件，启动一个MySQL数据库服务器，就是建立了一个MySQL数据库实例，数据库实例与数据库通常是一对一的关系<strong>1．MySQL数据库服务器的分层结构</strong>MySQL数据库服务器的架构主要体现在存储引擎的架构上，插件式的存储引擎架构将查询处理和其他的系统任务以及数据的存储提取相分离。如图2-13所示，MySQL数据库服务器总体可以分为四层，不同的层由不同的组件构成，<strong>MySQL主要分为以下几个组件：连接池组件、管理服务和工具组件、SQL接口组件、分析器组件、优化器组件、缓冲组件、插件式存储引擎、物理文件等。</strong><img src="https://s2.loli.net/2022/05/17/H7BFWXbjzK5yxTC.png#id=DPeb4&originHeight=600&originWidth=751&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">（1）第一层是一些客户端和连接服务，包含本地socket通信和大多数基于客户端&#x2F;服务端工具实现的类似于TCP&#x2F;IP（Transmission Control Protocol&#x2F;Internet Protocol，传输控制协议&#x2F;网际协议）的通信（2）第二层主要完成大多数的核心服务，如SQL接口进行DML、DDL、存储过程、视图、触发器等数据库对象的操作和管理，并完成缓存的查询，以及SQL的分析和优化及部分内置函数的执行（3）第三层是存储引擎层，存储引擎真正负责MySQL中数据的存储和提取，服务器通过API（Application Programming Interface，应用程序编程接口）与存储引擎进行通信。（4）第四层是数据存储层，其主要是将数据存储在文件系统之上，并完成与存储引擎的交互。可在该层查看操作系统上的各种文件，即前面所说的数据的集合。以上四层也可以简单说成是两层，以图2-13中的虚线为分割线，上半部分为SQL层，下半部分的两层为存储引擎层。SQL层主要功能包括权限判断、SQL解析和查询缓存处理等，由存储引擎完成对底层数据库的存储操作<strong>2．MySQL数据库服务器的模块结构</strong>MySQL数据库服务器启动过程首先是初始化，初始化从配置文件中读取系统参数和命令参数（完成缓存、环境的各种设置），并按照参数初始化整个系统，同时启动存储引擎。按照逻辑功能，<strong>MySQL又可以分成连接管理模块、线程模块、用户模块、查询缓存模块、日志缓存模块、查询优化模块、变更管理模块等。</strong>MySQL数据库服务器完成初始化工作启动后，等候客户端的各种请求。用户请求被服务器监听后，根据相应的模块做进一步处理，如图2-15所示。<img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652745838384-4a7b3d37-e348-418f-a162-deea7d252e0f.png#clientId=udaff6168-4c9f-4&from=paste&id=u80a4e231&originHeight=748&originWidth=745&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u931c99de-933d-479c-861d-35d55bd2a5b&title="></p>
<h3 id="2-2-2-MySQL存储引擎"><a href="#2-2-2-MySQL存储引擎" class="headerlink" title="2.2.2 MySQL存储引擎"></a>2.2.2 MySQL存储引擎</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1652745859344-2708a5cf-21a2-4945-9d74-e880521aa847.png#clientId=udaff6168-4c9f-4&from=paste&id=ud41c5547&originHeight=720&originWidth=914&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1204b37b-e74b-4b7a-bf23-28d0e6c73b4&title=">BlackHole、Archive等，需要特别注意的是，<strong>存储引擎是基于表的，而不是基于数据库的，最常见的两种存储引擎是InnoDB和MyISAM。</strong></p>
<p><strong>数据库事务</strong>数据库事务(Database Transaction)是指作为单个逻辑工作单元执行的一系列操作，要么完全执行，要么完全不执行。<strong>1．InnoDB存储引擎****InnoDB给MySQL的表提供了事务处理、回滚、崩溃修复能力和多版本并发控制的事务安全，其支持事务，主要面向OLTP（</strong>On-Line Transaction Processing，<strong>联机事务处理）方面的应用</strong>，其特点是行锁设置、支持外键，并支持类似于Oracle的非锁定读，即默认情况下读不产生锁。</p>
<p><strong>OLTP和OLAP</strong>数据库应用系统大致可以分成两大类： OLTP（On-Line Transaction Processing，联机事务处理）和OLAP（On-Line Analytical Processing，联机分析处理）。OLTP表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，主要用于基本的、日常的事务处理。在这样的系统中，单个数据库每秒处理的事务往往超过几百个，或者是几千个，Select语句的执行量每秒有几千甚至几万个。典型的OLTP系统有电子商务系统、银行、证券等。OLTP系统强调数据库的内存效率，强调内存各种指标的命中率，强调绑定变量，强调并发操作。OLAP有的时候也叫决策支持系统（Decision Support System，DSS），就是所谓的数据仓库。在这样的系统中，语句的执行量不是考核标准，其强调SQL的执行效率，强调磁盘I&#x2F;O等。因为一条语句的执行时间可能会非常长，读取的数据也非常多，所以其考核的标准往往是磁盘子系统的吞吐量（带宽），比如该磁盘子系统的吞吐量能达到多少MB&#x2F;s。</p>
<p><strong>关于LRU</strong>LRU的全称是Least Recently Used，也称为最少使用算法。LRU的设计原则是：如果一个数据在最近一段时间没有被访问到，那么它在将来被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</p>
<p><strong>2．MyISAM存储引擎</strong>数据库系统与文件系统的一个很大的不同之处在于对事务的支持，事务是关系型数据库的核心，但在现实应用中（特别是互联网），为了提高性能，在某些场景下（如简单的报表查询）可以摒弃事务。<strong>MyISAM存储引擎的特点是不支持事务、表锁和全文索引，主要面向一些OLAP数据库应用，</strong>操作速度快。</p>
<p><strong>3．Memory存储引擎</strong>Memory存储引擎（之前称为Heap存储引擎）将表中数据存放在内存中，这些特性都与InnoDB、MyISAM存储引擎不同。需要注意的是，服务器需要足够的内存来维持Memory存储引擎的表的使用，如果不需要了，可以释放内存，甚至删除不需要的表。Memory存储引擎默认使用哈希索引，这使得它们对于单值查找非常快速，并且对于创建临时表非常有用。当然如果你想用B型树索引（3.5中有详细解释），可以在创建索引时指定。因此，基于Memory的表的生命周期很短，一般都是一次性的。</p>
<h2 id="2-3-MySQL服务器配置工作原理"><a href="#2-3-MySQL服务器配置工作原理" class="headerlink" title="2.3 MySQL服务器配置工作原理"></a>2.3 MySQL服务器配置工作原理</h2><h3 id="2-3-MySQL配置文件"><a href="#2-3-MySQL配置文件" class="headerlink" title="2.3. MySQL配置文件"></a>2.3. MySQL配置文件</h3><p><strong>my.ini文件就是MySQL数据库服务器的配置文件。</strong>数据库服务器启动的第一项工作就是对整个数据库做的一些初始化操作，如各种系统环境变量的初始化，各种缓存、存储引擎初始化设置等，这些工作的约定来源于配置文件my.ini。Windows平台上的MySQL数据库首先会读取&#x2F;my.ini文件，该选项主要用来设置MySQL全局选项。MySQL读取完my.ini之后，接下来会解析MySQL_HOME&#x2F;my.ini。在这个过程中，服务器会到MySQL安装目录下解析数据库的相关配置。MySQL启动初始化接着会解析default-extra-file附带选项，修改该参数可以指定系统配置文件，接下来数据库会解析有关用户的选项。MySQL系统可以通过“mysqld—verbose–help”命令来查看当前系统所有参数的设置。服务器的配置应该符合它的工作负载、数据，以及应用需求，而并不是仅看硬件的情况。创建一个好配置的最快的方法是从理解MySQL内核和行为开始（对2.2内容的理解非常有利于对配置的把握），然后利用这些知识来指导配置MySQL。理解MySQL的配置机制，首先应该知道的是<strong>MySQL从哪里获得配置信息：命令行参数和配置文件。</strong>可以通过使用操作系统的启动脚本，也可以在命令行指定设置。长期使用的设置都应该写到全局配置文件中，而不是在命令行特别指定，否则如果偶然在启动时忘了设置就会有风险。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@basedir</span>	#可以查询安装目录位置</span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@datadir</span>	#可以查询配置文件位置</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">!includedir /etc/mysql/conf.d/</span><br><span class="line">!includedir /etc/mysql/mysql.conf.d/</span><br><span class="line">[mysqld]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置3306端口</span></span><br><span class="line">port=3306</span><br><span class="line">bind-address=0.0.0.0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql的安装目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">basedir=/usr/local/mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql数据库的数据的存放目录</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">datadir= /var/lib/mysql</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许最大连接数</span></span><br><span class="line">max_connections=200</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统</span></span><br><span class="line">max_connect_errors=10</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">服务端使用的字符集默认为UTF8</span></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用–skip-external-locking MySQL选项以避免外部锁定。该选项默认开启</span></span><br><span class="line">external-locking = FALSE</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新表时将使用的默认存储引擎</span></span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">默认使用“mysql_native_password”插件认证</span></span><br><span class="line">default_authentication_plugin=mysql_native_password</span><br><span class="line"></span><br><span class="line">[mysqld_safe]</span><br><span class="line">log-error=error.log</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">pid-file=mysqld.pid</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">定义mysql应该支持的sql语法，数据校验</span></span><br><span class="line">sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</span><br><span class="line">[mysql]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端默认字符集</span></span><br><span class="line">default-character-set=utf8mb4</span><br><span class="line">[client]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置mysql客户端连接服务端时默认使用的端口</span></span><br><span class="line">port=3306</span><br><span class="line">default-character-set=utf8mb4</span><br></pre></td></tr></table></figure>

<p><strong>1．关于InnoDB存储引擎的配置</strong>选择InnoDB作为默认的存储引擎，InnoDB在大多数情况下是最好的选择，但并不总是如此。例如，一些第三方的软件，可能假设默认存储引擎是MyISAM，所以创建表时没有指定存储引擎，这可能会导致软件故障。如果希望持久化的表使用InnoDB，而所有临时表使用MylSAM，那应该确保在CREATE TABLE语句中明确指定了存储引擎。如图2-19给出了创建表时指定存储引擎的示例。接下来将阐述InnoDB的基础配置。如果想让InnoDB运行得很好，配置大小合适的缓冲池（Buffer Pool）和日志文件（Log File）是必须的，一般默认值都偏小，需要调整。其他所有的InnoDB设置都是可选的，配置示例中考虑到可管理性和灵活性，启用了 innodb_file_per table（即每个表对应一个后缀为.ibd的数据文件）。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1652745920475-75e92c00-d6f1-4ed0-9f2b-201b421b23b9.jpeg#clientId=udaff6168-4c9f-4&from=paste&id=u7a777a6c&originHeight=405&originWidth=485&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uc431d207-2aa0-4579-b73c-928d90d44b2&title=">图2-19 创建表时指定存储引擎一个流行的经验法则是把缓冲池大小设置为服务器内存的75%~80%，更好的办法是按照如下思路进行。（1）从服务器内存总量开始。（2）减去操作系统的内存占用，如果MySQL不是唯一运行在这个服务器上的程序，还要扣除其他程序可能占用的内存空间。（3）减去一些MySQL自身需要的内存空间，例如，为每个查询操作分配的一些缓冲。（4）减去足够让操作系统缓存InnoDB日志文件的内存空间。（5）减去其他配置的MySQL缓存和缓存需要的内存空间，例如，MyISAM的键缓存（Key Cache)或者查询缓存（Query Cache)。（6）除以105%，把结果四舍五入，向下取一个合理的数值，这差不多接近InnoDB管理缓冲池增加的自身管理开销。</p>
<h3 id="2-4-2-MySQL的日志文件"><a href="#2-4-2-MySQL的日志文件" class="headerlink" title="2.4.2 MySQL的日志文件"></a>2.4.2 MySQL的日志文件</h3><p><strong>MySQL数据库拥有的日志文件主要分为二进制日志、错误日志、慢查询日志和通用查询日志****在MySQL所支持的日志文件里，除了二进制文件外，其他日志文件都是文本文件</strong></p>
<p>（1）二进制日志：该日志文件会以二进制的形式记录数据库的各种操作，但是不记录查询语句。（2）错误日志：该日志文件会记录MySQL服务器启动、关闭和运行时出错等信息。（3）慢查询日志：记录执行时间超过指定时间的各种操作，通过工具分析慢查询日志可以定位MySQL服务器性能瓶颈所在。（4）通用查询日志：该日志记录MySQL服务器的启动和关闭信息、客户端的连接信息、更新数据记录SQL语句和查询数据记录SQL语句。启动日志有优点也有缺点，启动日志后，虽然可以帮助数据库管理员对MySQL服务器进行维护，但是会降低MySQL软件的执行速度，因此是否启动上面类型的日志要根据具体情况来决定。<strong>1.错误日志文件****错误日志，顾名思义，应该是记录错误信息的日志，MySQL中的错误日志文件不仅记录错误信息，MySQL服务进程即mysqld启动或关闭的信息也会被记录。</strong>，只有服务进程运行过程中发生的关键错误才会被记录</p>
<p><strong>2.二进制日志文件****二进制日志</strong>（Binary Log）：记录数据库中的修改事件，包括所有的DDL语句和DML语句，但是不包括数据查询语句，语句以“事件”的形式保存，它描述了数据的更改过程。通过二进制日志文件，用户可以详细了解MySQL数据库中进行了哪些操作。<strong>二进制日志文件（Binary Log File）：</strong>保存数据库中修改事件的文件。（1）二进制日志有以下两个重要功能。<strong>①用于复制。</strong>将MySQL Master（主数据库）端的二进制日志发送至Slave（从数据库）端，Slave端即可根据二进制日志中的内容在本地重做，以达到主从同步的目的<strong>②用于恢复。</strong>二进制日志可用于数据恢复，当使用备份了数据库后，通过应用二进制日志文件，能够将数据库恢复到故障发生前的状态<strong>（2）二进制日志的操作包括启动二进制日志、查看二进制日志、删除二进制日志和停止二进制日志。</strong></p>
<p><strong>3.慢查询日志文件****慢查询日志为MySQL软件非常重要的日志之一，主要用来记录执行时间超过指定时间的查询语句。通过查看该类型日志文件，可以查找哪些查询语句的执行效率低，从而找出MySQL服务器的性能瓶颈并进行优化。</strong>慢查询日志</p>
<p><strong>4.通用查询日志文件</strong>MySQL的查询日志有两种，一种是前面提到的慢查询日志（Slow Query Log），还有一种是<strong>通用查询日志（Gerneral Query Log），通用查询日志不仅记录执行慢的查询，而且会将所有执行的查询语句都记录下来。****通用查询日志为MySQL软件非常重要的日志之一，其主要用来记录用户关于MySQL服务器的所有操作，包含MySQL服务器的启动和关闭信息、客户端的连接信息、更新数据记录SQL语句和查询数据记录SQL语句。</strong>由于该日志记录了客户端连接MySQL的所有请求，如果当前示例访问量较大，此日志会急剧增加，会抢占系统IO导致影响MySQL的性能，一般建议关闭此日志，需要时再打开。</p>
<h3 id="2-5-2-全局共享内存"><a href="#2-5-2-全局共享内存" class="headerlink" title="2.5.2 全局共享内存"></a>2.5.2 全局共享内存</h3><p><strong>全局共享内存主要是MySQL实例（mysqld进程）以及底层存储引擎用来暂存各种全局运算及可共享的暂存信息，</strong>如存储查询缓存的Query Cache，缓存连接线程的Thread Cache，缓存表文件句柄信息的Table Cache，缓存二进制日志的Binlog Buffer，缓存MyISAM存储引擎索引键的Key Buffer以及存储InnoDB数据和索引的InnoDB Buffer Pool，等等，类似于Oracle的SGA。下面针对MySQL主要的共享内存进行简单的分析。<strong>1.查询缓存（Query Cache）</strong>查询缓存是MySQL比较独特的一个缓存区域，用来缓存特定Query的结果集（Result Set）信息，且共享给所有客户端。MySQL接收到每一个SELECT类型的Query之后都会先在Query Cache中查找是否有相应的缓存，如果有，则直接将Cache的结果集返回给客户端，如果没有，再进行后续操作，得到对应的结果集之后将该结果集缓存到Query Cache中，再返回给客户端。<strong>2.连接线程缓存（Thread Cache）</strong>连接线程是MySQL为了提高创建连接线程的效率，将部分空闲的连接线程保持在一个缓存区以备新进连接请求的时候使用的，当通过thread_cache_size设置了连接线程缓存池可以缓存的连接线程的大小之后，可以通过(Connections - Threads_created)&#x2F;Connections*100%计算出连接线程缓存的命中率。需要注意的是，这里设置的是可以缓存的连接线程的数目，而不是内存空间的大小。<strong>3.表缓存（Table Cache）</strong>表缓存区主要用来缓存表文件的文件句柄信息，在MySQL 5.1.3之前的版本通过table_cache参数设置，但从MySQL 5.1.3开始改为通过table_open_cache来设置其大小。<strong>4.表定义信息缓存（Table definition Cache）</strong>表定义信息缓存是从MySQL 5.1.3版本才开始引入的一个新的缓存区，用来存放表定义信息（表的定义信息可以称为元数据或者数据字典）。<strong>5.二进制日志缓冲区（Binlog Buffer）</strong>二进制日志缓冲区主要用来缓存由于各种数据变更操做所产生的日志信息<strong>6.MyISAM索引缓存（Key Buffer）</strong>MyISAM索引缓存将MyISAM表的索引信息缓存在内存中，以提高其访问性能。</p>
<h1 id="3-MySQL数据库对象管理"><a href="#3-MySQL数据库对象管理" class="headerlink" title="3.MySQL数据库对象管理"></a>3.MySQL数据库对象管理</h1><h2 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h2><h3 id="3-1-1-数据库对象"><a href="#3-1-1-数据库对象" class="headerlink" title="3.1.1 数据库对象"></a>3.1.1 数据库对象</h3><p><strong>数据库对象是数据库的组成部分，有表、索引、视图、触发器、存储过程、用户（User）等</strong></p>
<ol>
<li><strong>1. 表（Table）</strong></li>
</ol>
<p>表是关系数据库最基础的数据库对象。数据库中的表与我们日常生活中使用的表格类似，它也是由行（Row）和列（Column）组成的，每列由同类的信息组成，每列又称为一个字段，每列的标题称为字段名。一行数据称为一个或一条记录，它表达有一定意义的信息组合。一个数据库表由一条或多条记录组成，没有记录的表称为空表。典型的关系数据库往往包含多个表，每个表中通常都有一个主键列，用于唯一确定的一条记录。很多表包含关键信息，用来将一个表中的行关联到另一个表中的行（外键约束）。<strong>2. 索引（Index）</strong>索引是针对表中数据的一种存储方式，是根据指定的数据库表列建立起来的顺序。建立索引是加快查询速度的一种有效手段，可监督表的数据，使其索引所指向的列中的数据不重复<strong>3. 视图（View）</strong>视图是关系数据库系统提供给用户从多种角度观察数据库中数据的重要机制。一个表上可以定义若干个视图，一个视图也可以定义在若干个表上。视图是表与外模式之间的映像，一个数据库的所有视图构成数据库应用系统三级结构中的外模式。<strong>4. 触发器（Trigger）</strong>触发器是DBMS提供给程序员和数据分析员用于保证数据完整性的一种方法，它是与表事件相关的特殊的存储过程，它的执行不是由程序调用，也不是由手工启动，而是由事件来触发，例如，当对一个表进行操作（insert、delete、update）时触发器就会被激活。触发器是一个用户定义的SQL事务命令的集合，当操作事件发生时，这组命令就会自动执行。<strong>5. 存储过程（Stored Procedure）</strong>存储过程是指一组为了完成特定功能而存储在数据库服务器中的、由SQL语句和流程控制语句组成的程序体，它可以将常用或复杂的工作预先用SQL语句和流程控制语句写好，并用一个指定名称存储起来，以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用CALL存储过程名字，即可自动执行存储过程中的命令。存储过程中允许用户声明变量，同时，存储过程可以接收和输出参数、返回执行存储过程的状态值，也可以嵌套调用。一个存储过程是一个可编程的函数，它在数据库中创建并保存。当希望在不同的应用程序或平台上执行相同的函数或者封装特定的功能时，存储过程是非常有用的。数据库中的存储过程可以看作对编程中面向对象方法的模拟，它允许控制数据的访问方式。<strong>6. 用户（User）</strong>用户就是操作数据库的一个人或者客户端，一个数据库面对许多用户，甚至在数据库运行的过程中，还会有新的用户进来、老的用户退出等变化，因此就有了用户管理。</p>
<h3 id="3-1-2-数据字典"><a href="#3-1-2-数据字典" class="headerlink" title="3.1.2 数据字典"></a>3.1.2 数据字典</h3><p>根据<strong>数据库</strong>的定义【数据库（Database，简称DB）是以一定方式储存在一起、能为多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据和数据的定义的集合。】可以看出，数据库中包含了两类数据，一类是应用程序要使用的数据（或者称为用户的数据），另一类是数据的定义，数据的定义也是数据（或者系统要使用的数据），也放在了数据库中，这类数据可以称为数据字典（Dictionary）或者元数据（Metadata）。<strong>数据字典是描述数据的信息集合，是对系统中使用的所有数据元素的定义的集合，数据字典是一种用户可以访问的记录数据库和数据库对象的目录</strong></p>
<h2 id="3-2-管理库"><a href="#3-2-管理库" class="headerlink" title="3.2 管理库"></a>3.2 管理库</h2><h3 id="3-2-1-创建数据库"><a href="#3-2-1-创建数据库" class="headerlink" title="3.2.1 创建数据库"></a>3.2.1 创建数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> &#123;DATABASE <span class="operator">|</span> SCHEMA&#125; [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>]database_name		<span class="operator">/</span><span class="operator">/</span>（IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>）即当数据库不存在时方创建</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database test;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-查看和选择数据库"><a href="#3-2-2-查看和选择数据库" class="headerlink" title="3.2.2 查看和选择数据库"></a>3.2.2 查看和选择数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> basedata;	#查看数据库</span><br><span class="line">use test;	#选择数据库</span><br></pre></td></tr></table></figure>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><table>
<thead>
<tr>
<th><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345617641-d617d3e3-690c-4522-bd57-8a45c0c555d6.png#clientId=u736bb5e6-27d0-4&from=paste&id=uf9fb592c&originHeight=77&originWidth=314&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u473c8258-4752-45ab-9998-89ce5b09bd3&title=">图3-13 选择不存在的数据库</th>
<th><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345617599-7e75a78a-ca81-4eb7-bea7-8c98db7931dd.png#clientId=u736bb5e6-27d0-4&from=paste&id=u37d4ad51&originHeight=77&originWidth=175&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua60c8ccc-ca3f-40e0-84a0-65ce5edf61b&title=">图3-14 选择数据库</th>
</tr>
</thead>
</table>
<h3 id="3-2-3-修改数据库"><a href="#3-2-3-修改数据库" class="headerlink" title="3.2.3 修改数据库"></a>3.2.3 修改数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> databse test;</span><br><span class="line"><span class="keyword">default</span> charcter <span class="keyword">set</span> gb2312;</span><br><span class="line"><span class="keyword">default</span> <span class="keyword">collate</span> gb2312_chinese_ci;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span>执行<span class="keyword">ALTER</span> DATABASE语句修改之前创建的database_test数据库的默认字符集和校对规则</span><br></pre></td></tr></table></figure>


<h3 id="3-2-4-删除数据库"><a href="#3-2-4-删除数据库" class="headerlink" title="3.2.4 删除数据库"></a>3.2.4 删除数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">dorp database test;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-管理表"><a href="#3-3-管理表" class="headerlink" title="3.3 管理表"></a>3.3 管理表</h2><h3 id="3-3-1-MySQL表中支持的数据类型"><a href="#3-3-1-MySQL表中支持的数据类型" class="headerlink" title="3.3.1 MySQL表中支持的数据类型"></a>3.3.1 MySQL表中支持的数据类型</h3><table>
<thead>
<tr>
<th>类型</th>
<th>大小&#x2F;字节</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>CHAR</td>
<td>0 ~ 255</td>
<td>定长字符串</td>
</tr>
<tr>
<td>VARCHAR</td>
<td>0 ~ 255</td>
<td>变长字符串</td>
</tr>
<tr>
<td>TINYBLOB</td>
<td>0 ~ 255</td>
<td>不超过255个字符的二进制字符串</td>
</tr>
<tr>
<td>TINYTEXT</td>
<td>0 ~ 255</td>
<td>短文本字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0 ~ 65 535</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>TEXT</td>
<td>0 ~ 65 535</td>
<td>长文本数据</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0 ~ 16 777 215</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0 ~ 16 777 215</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td>LOGNGBLOB</td>
<td>0 ~ 4 294 967 295</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0 ~ 4 294 967 295</td>
<td>极大文本数据</td>
</tr>
</tbody></table>
<p>表3-2 MySQL数值类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>最小值</th>
<th>最大值</th>
</tr>
</thead>
<tbody><tr>
<td>TINYINT</td>
<td>1</td>
<td>有符号-128无符号0</td>
<td>有符号127无符号255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>有符号-32 768无符号0</td>
<td>有符号32 767无符号65 535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>有符号-8 388 608无符号0</td>
<td>有符号8 388 607无符号16 777 215</td>
</tr>
<tr>
<td>INT或INTEGER</td>
<td>4</td>
<td>有符号-2 147 483 648无符号0</td>
<td>有符号-8 388 608无符号4 294 967 295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>有符号-9233372936854775808无符号0</td>
<td>有符号9233372936854775807无符号0</td>
</tr>
<tr>
<td>FLOAT</td>
<td>4</td>
<td>±1.75494351E-38</td>
<td>±3.402823466E+38</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>8</td>
<td>±2.2250738585072014E-308</td>
<td>±1.7976931348623157E+308</td>
</tr>
<tr>
<td>DECIMAL(m，d)</td>
<td>m+2</td>
<td>依赖于m和d的值</td>
<td>依赖于m和d的值</td>
</tr>
</tbody></table>
<p>表3-3 MySQL支持的日期和时间类型</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>范围</th>
<th>格式</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>DATE</td>
<td>3</td>
<td>1000-01-01 ~ 9999-12-31</td>
<td>YYYY-MM-DD</td>
<td>日期值</td>
</tr>
<tr>
<td>TIME</td>
<td>3</td>
<td>-838:59:59 ~ 838:59:59</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td>YEAR</td>
<td>1</td>
<td>1901 ~ 2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8</td>
<td>1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>8</td>
<td>1970-01-01 00:00:00 ~ 2037年某时</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody></table>
<h3 id="3-3-2-创建表"><a href="#3-3-2-创建表" class="headerlink" title="3.3.2 创建表"></a>3.3.2 创建表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test (</span><br><span class="line">              id  <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">primary</span> key,</span><br><span class="line">              task <span class="type">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">              sign TINYINT(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">              <span class="type">time</span> <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span></span><br><span class="line">              )</span><br><span class="line">              <span class="operator">/</span><span class="operator">/</span>属性名 数据类型 约束条件</span><br></pre></td></tr></table></figure>


<h3 id="3-3-3-查看表结构"><a href="#3-3-3-查看表结构" class="headerlink" title="3.3.3 查看表结构"></a>3.3.3 查看表结构</h3><h3 id="3-3-4-DESCRIBE语句查看表定义"><a href="#3-3-4-DESCRIBE语句查看表定义" class="headerlink" title="3.3.4 DESCRIBE语句查看表定义"></a>3.3.4 DESCRIBE语句查看表定义</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">describe</span> data_tests;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>Field</th>
<th>Type</th>
<th>Null</th>
<th>Key</th>
<th>Default</th>
<th>Extra</th>
</tr>
</thead>
<tbody><tr>
<td>显示列名</td>
<td>显示列的数据类型</td>
<td>标识该列是否可以为空，显示NO表示不能为空，显示YES表示运行为空。</td>
<td>标识该列是主键列或者索引列，为空的话表示该列上没有创建任何索引。</td>
<td>用于显示该列的默认值，为空表示没有默认值。</td>
<td>用于显示一些额外的附加信息，比如说该列如果定义为自增列，则会显示为“AUTOINCREMENT对于TIMESTAMP列如果定义了on updata选项，则此处也会显示相应的关键字。</td>
</tr>
</tbody></table>
<h3 id="3-3-5-修改表"><a href="#3-3-5-修改表" class="headerlink" title="3.3.5 修改表"></a>3.3.5 修改表</h3><h4 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test RENAME test_test;</span><br></pre></td></tr></table></figure>

<h4 id="增加字段"><a href="#增加字段" class="headerlink" title="增加字段"></a>增加字段</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test_test <span class="keyword">ADD</span> this <span class="type">varchar</span>(<span class="number">20</span>);	#在表最后添加</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test_test <span class="keyword">ADD</span> this_one <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">FIRST</span>;	#在表第一个位置检查</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test_test <span class="keyword">ADD</span> this_two <span class="type">varchar</span>(<span class="number">20</span>) AFTER this_one;	#指定字符后添加</span><br></pre></td></tr></table></figure>


<h4 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h4><p>对于表，可以在修改表时进行字段的增加操作，也可以在修改表时进行字段的删除操作。所谓删除字段是指删除已经在表中定义好的某个字段。在MySQL中删除字段同样可以通过SQL语句ALTER TABLE来实现，其语法如下：ALTER TABLE table_name DROP 属性名;上述语句中，table_name参数表示所要修改表的表名，“属性名”参数为所要删除的字段名。</p>
<h4 id="修改字段"><a href="#修改字段" class="headerlink" title="修改字段"></a>修改字段</h4><p>如果要修改字段，除了可以修改字段名外，还可以实现修改字段所能存储的数据类型。由于一个表中会拥有许多字段，因此还可以实现修改字段的顺序。<strong>1. 修改字段的数据类型</strong>在MySQL中修改字段的数据类型通过SQL语句ALTER TABLE来实现，其语法如下：ALTER TABLE table_name MODIFY 属性名 属性类型;上述语句中，table_name参数表示所要修改表的表名，“属性名”参数为所要修改字段的名称，“属性类型”参数为所要修改字段的数据类型。<strong>2. 修改字段的名字</strong>在MySQL中修改字段的名称通过SQL语句ALTER TABLE来实现，其语法如下：ALTER TABLE table_name CHANGE 旧属性名 新属性名 旧数据类型;上述语句中，table_name参数表示所要修改表的表名，“旧属性名”参数为所要修改字段的名称，“新属性名”参数表示所要修改成的字段名。<strong>3. 同时修改字段的名字和属性</strong>通过关键字MODIFY可以修改字段的数据类型，通过关键字CHANGE可以修改字段的名字。同时修改字段的名字和数据类型，其语法如下：ALTER TABLE table_name CHANGE 旧属性名 新属性名 新数据类型;上述语句中，“新属性名”参数表示所要修改成的字段名，“新数据类型”参数表示所要修改成的数据类型。<strong>4. 修改字段的顺序</strong>修改字段的顺序通过SQL语句ALTER TABLE来实现，其语法如下：ALTER TABLE table_name MODIFY 属性名1 新数据类型 FIRST|AFTER 属性名2;table_name参数表示所要修改表的名字，“属性名1”参数表示所要调整顺序的字段名，“FIRST”参数表示将字段调整到表的第一个位置，“AFTER 属性名2”参数表示将字段调整到属性名2字段位置之后。需要注意的是，属性名1和属性名2必须是表中已经存在的字段名。</p>
<h3 id="3-3-6-复制表"><a href="#3-3-6-复制表" class="headerlink" title="3.3.6 复制表"></a>3.3.6 复制表</h3><p>在MySQL中复制表通过CREATE TABLE来实现，其语法形式如下：CREATE [TEMPORY] TABLE [IF NOT EXISTS] table_bame[( ) LIKE old_table_name[ ] ]| [AS (select_statement) ];上述语句中，使用LIKE关键字创建一个与old_table_name表的结构相同的新表，列名、数据类型、空指定和索引也将被复制，但是表的内容不会被复制，因此，创建的新表是一个空表。使用AS关键字可以复制表的内容，但索引和完整性约束是不会被复制的，select_statement表示一个完整的SELECT语句。<strong>例</strong>将数据库company中名为t_dept的表复制到名为test的表中，使用CREATE TABLE test LIKE t_dept，其结果如图3-24所示。创建t_dept表的一个名为test1的复制，并且复制其内容，采用SQL语句CREATE TABLE test1 AS（SELECT * FROM t_dept），其结果如图3-25所示。</p>
<table>
<thead>
<tr>
<th><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345717033-8737d287-8da7-4928-9e9d-0ceaf575bb03.png#clientId=u736bb5e6-27d0-4&from=paste&id=u38b74b1d&originHeight=53&originWidth=323&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u4b46b9c5-a575-42c7-871a-82df9d64dc1&title=">图3-24 复制表t_dept</th>
<th><img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653345717002-8c29f92b-f641-43a7-819d-b354a83e3b93.png#clientId=u736bb5e6-27d0-4&from=paste&id=u73b8b727&originHeight=79&originWidth=315&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u23142341-0bd6-451f-9e59-6056c8f733e&title=">图3-25 复制并复制内容</th>
</tr>
</thead>
</table>
<h3 id="3-3-7-删除表"><a href="#3-3-7-删除表" class="headerlink" title="3.3.7 删除表"></a>3.3.7 删除表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> test_test;	#删除数据库</span><br><span class="line">rename <span class="keyword">table</span> test.test_test <span class="keyword">to</span> test_test.test	#从test数据库中将test_test表移动至test_test数据库并另命名为test</span><br></pre></td></tr></table></figure>

<h2 id="3-4-管理索引"><a href="#3-4-管理索引" class="headerlink" title="3.4 管理索引"></a>3.4 管理索引</h2><h3 id="3-4-1-索引的概念"><a href="#3-4-1-索引的概念" class="headerlink" title="3.4.1 索引的概念"></a>3.4.1 索引的概念</h3><p>索引由一系列存储在磁盘上的索引项组成，索引项第一列是索引键，第二列是行的地址，索引项按索引键排序。改变表中的数据（如增加、删除、修改记录）时，索引将自动更新。索引建立后，在查询使用该列时，系统可以自动使用索引进行查询。索引是一把双刃剑，由于要建立索引页面，索引也会减慢更新的速度。索引数目无限制，但索引越多，更新数据的速度就越慢。仅用于查询的表可多建索引，数据更新频繁的表则应少建索引。</p>
<h3 id="3-4-2-索引的利与弊"><a href="#3-4-2-索引的利与弊" class="headerlink" title="3.4.2 索引的利与弊"></a>3.4.2 索引的利与弊</h3><p><strong>1. 索引的利</strong>创建索引可以大大提高系统的查询性能，此为正面作用。具体来讲包括以下几方面。①通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。②可以大大加快数据的检索速度，这也是创建索引最主要的原因。③可以加速表和表之间的连接，在实现数据的参考完整性方面特别有意义。④在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。⑤通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。<strong>2. 索引的弊</strong>创建索引要消耗系统的一些资源，降低数据更新的性能，此为负面作用。具体如下。①创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。②索引需要占用物理空间，除数据表占用数据空间以外，每一个索引还要占用一定的物理空间。如果有大量的索引，则索引占用的空间可能会比数据表占用的空间还大。如果要建立聚簇索引，那么需要的空间会更大。③当对表中的数据进行插入、删除和修改时，对索引也要进行动态维护，这样就降低了数据的维护速度。表中的索引越多，更新表的时间就越长。</p>
<h3 id="3-4-2-索引的类型与创建原则"><a href="#3-4-2-索引的类型与创建原则" class="headerlink" title="3.4.2 索引的类型与创建原则"></a>3.4.2 索引的类型与创建原则</h3><p>索引是创建在数据库表对象上的，由表中的一个字段或多个字段生成的键组成，这些键存储在数据结构（B树或哈希表）中，通过MySQL可以快速有效地查找与键值相关联的字段。InnoDB和MyISAM存储引擎的表默认创建的都是B树类型索引。</p>
<h3 id="3-4-3-索引的类型"><a href="#3-4-3-索引的类型" class="headerlink" title="3.4.3 索引的类型"></a>3.4.3 索引的类型</h3><p>MySQL大部分索引都是以B树方式存储的。B树方式构建为包含多个节点的一棵树，顶部的节点构成了索引的开始点，叫作根，每个节点中含有索引列的几个值，节点中的每个值又都指向另一个节点或者指向表中的一行，一个节点中的值必须是有序排列的。指向一行的节点叫作叶子页。叶子页本身也是相互连接的，一个叶子页有一个指针指向下一组。这样，表中的每一行都会在索引中有一个对应值，查询时就可以根据索引值直接找到所在的行。索引中的节点是存储在文件中的，所以索引也要占用物理空间。MySQL将一个表的所有索引都保存在同一个索引文件中。如果更新表中的一个值或者向表中添加或者删除一行，MySQL会自动地更新索引，因此，索引树总是和表的内容保持一致。1. 聚簇索引与非聚簇索引根据索引的顺序与数据表的物理顺序是否相同，可以把索引分成两种类型，一种是数据表的物理顺序与索引顺序相同的聚簇索引，另一种是数据表的物理顺序与索引顺序不相同的非聚簇索引。<strong>（1）聚簇索引</strong>MySQL聚簇索引构成了一个树状结构，树的叶子节点存储了表中所有字段上的数据，而不是存储了索引项（键值加地址）。在聚簇索引中，数据值的顺序总是按照升序排列。<strong>（2）非聚簇索引</strong>非聚簇索引的结构也是树状结构，在非聚簇索引中，树的叶子节点仅仅保存索引项（包含键值及其地址），而没有包含数据行。2. 普通索引与主键索引MySQL按B树方式存储索引，根据索引值的唯一性、索引字段的类型等，其主要的索引类型有普通索引、唯一性索引、主键索引、全文索引。<strong>（1）普通索引</strong>这是最基本的索引类型，它没有唯一性之类的限制。创建普通索引的关键字是INDEX。<strong>（2）唯一性索引</strong>这种索引和普通索引基本相同，但是有一个区别：索引列的所有值都只能出现一次，即必须是唯一的。创建唯一性索引的关键字是UNIQUE。<strong>（3）主键索引</strong>主键索引是一种唯一性索引，必须指定为PRIMARY KEY。主键一般在创建表时指定，也可以通过修改表的方式加入主键，但是每个表只能有一个主键。在创建主键约束时，系统自动创建了一个唯一性的聚簇索引<strong>（4）全文索引</strong>MySQL支持全文检索和全文索引。在MySQL中，全文索引的索引类型为FULLTEXT。全文索引只能在VARCHAR或TEXT类型的列上创建，并且只能在MyISAM表中创建。</p>
<h3 id="3-4-4-索引的创建原则"><a href="#3-4-4-索引的创建原则" class="headerlink" title="3.4.4 索引的创建原则"></a>3.4.4 索引的创建原则</h3><p>（1）经常被搜索的字段，创建索引可以加快搜索的速度。（2）作为主键的字段，创建索引可强制该列的唯一性和组织表中数据的排列结构。（3）经常用在连接的字段上，这些字段主要是一些外键，创建索引可以加快连接的速度。（4）经常需要根据范围进行搜索的字段，因为索引已经排序，所以指定的范围是连续的。（5）经常需要排序的字段，因为索引已经排序，这样查询可以利用索引的排序，缩短排序查询时间。（6）经常在WHERE子句中使用的列，创建索引可以加快条件的判断速度。</p>
<p>不应该创建索引的字段有下列特点（1）在查询中很少被使用或者参考的字段不应该创建索引，这是因为既然这些字段很少使用，那么有索引或者无索引并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度，且增加了空间需求。（2）对于那些只有很少数据值的字段不应该创建索引，这是因为这些列的取值很少，如人事表的性别字段，在查询的结果中，结果集的数据行占了表中数据行很大的比列，即需要在表中搜索的数据行的比例很大，增加索引并不能明显加快检索速度。（3）对于那些定义为TXEXT、IMAGE和BIT数据类型的字段不应该增加索引，这是因为这些字段的数据量要么相当大，要么取值很少。（4）当更新性能远远大于检索性能时不应该创建索引，这是因为更新性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低更新性能；当减少索引时，会提高更新性能，但是会降低检索性能。</p>
<h3 id="3-4-5-创建和查看索引"><a href="#3-4-5-创建和查看索引" class="headerlink" title="3.4.5 创建和查看索引"></a>3.4.5 创建和查看索引</h3><p>所谓普通索引，就是在创建索引时不附加任何限制条件（唯一、非空等限制）。该类型的索引可以创建在任何数据类型的字段上。<strong>1.创建表时创建普通索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_two (</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    task <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    INDEX test (task(<span class="number">20</span>) <span class="keyword">DESC</span>)	# [<span class="keyword">ASC</span> <span class="operator">|</span> <span class="keyword">DESC</span>]<span class="operator">=</span><span class="operator">=</span>升序<span class="operator">|</span>降序</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><strong>2. 在已经存在的表上创建普通索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> INDEX test_test <span class="keyword">ON</span> test (this(<span class="number">20</span>)<span class="keyword">asc</span>);</span><br></pre></td></tr></table></figure>
<p><strong>3. 通过SQL语句ALTER TABLE创建普通索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> test <span class="keyword">ADD</span> INDEX test_two_two (task);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-6-创建唯一索引"><a href="#3-4-6-创建唯一索引" class="headerlink" title="3.4.6 创建唯一索引"></a>3.4.6 创建唯一索引</h3><p>所谓唯一索引，就是在创建索引时限制索引的值必须是唯一的。在MySQL中，根据创建索引方式，可以分为自动索引和手动索引两种。所谓自动索引，是指在数据库表里设置完整性约束时，该表会被系统自动创建索引。所谓手动索引，是指手动在表上创建索引。当设置表中的某个字段设置主键或者唯一完整性约束时，系统会自动创建关联该字段的唯一索引。<strong>1. 创建表时创建唯一索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_two_two(</span><br><span class="line">	id  <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    test <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    <span class="keyword">unique</span> index id (id)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>
<p>UNIQUE KEY表示创建唯一索引。<strong>2. 在已经存在的表上创建唯一索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index test <span class="keyword">on</span> test_two_two (test); </span><br></pre></td></tr></table></figure>

<h3 id="3-4-7-创建全文索引"><a href="#3-4-7-创建全文索引" class="headerlink" title="3.4.7 创建全文索引"></a>3.4.7 创建全文索引</h3><p>全文索引主要关联在数据类型为CHAR、VARCHAR和TEXT的字段上，以便能够更加快速地查询数据量较大的字符串类型的字段。<strong>1. 创建表时创建全文索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_three(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span> auto_increment <span class="keyword">primary</span> key,</span><br><span class="line">    test <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    fulltext key test (test)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
<p>其中FULLTEXT INDEX或FULLTEXT KEY表示创建全文索引。<strong>2. 通过SQL语句ALTER TABLE创建全文索引</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> test_three <span class="keyword">add</span> fulltext index name(name);</span><br></pre></td></tr></table></figure>

<h3 id="3-4-8-删除索引"><a href="#3-4-8-删除索引" class="headerlink" title="3.4.8 删除索引"></a>3.4.8 删除索引</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index name <span class="keyword">on</span> test_three;	#name<span class="operator">=</span><span class="operator">=</span>索引名 test_three<span class="operator">=</span>表名</span><br></pre></td></tr></table></figure>

<h2 id="3-5-管理视图"><a href="#3-5-管理视图" class="headerlink" title="3.5 管理视图"></a>3.5 管理视图</h2><h3 id="3-5-1-视图的概念和作用"><a href="#3-5-1-视图的概念和作用" class="headerlink" title="3.5.1 视图的概念和作用"></a>3.5.1 视图的概念和作用</h3><p>视图作为数据库对象的一种形式，在实际应用中十分常用，视图在数据库体系结构中处于用户层。</p>
<h3 id="3-5-2视图的概念"><a href="#3-5-2视图的概念" class="headerlink" title="3.5.2视图的概念"></a>3.5.2视图的概念</h3><p>视图是一个虚表，即<strong>视图所对应的数据不进行实际存储，数据库中只存储视图的定义</strong>。对视图的数据进行操作时，系统根据视图的定义操作与视图相关联的基本表。视图中的数据来源于原来的基本表，所以当基本表中的数据发生变化时，从视图中查询出的数据也就随之改变。</p>
<h3 id="3-5-3-视图的作用"><a href="#3-5-3-视图的作用" class="headerlink" title="3.5.3 视图的作用"></a>3.5.3 视图的作用</h3><p><strong>（1）简化用户的数据操作</strong>视图机制使用户可以将注意力集中在所关心的数据上，如果这些数据不是基本表中的全部，则可以通过定义视图，使数据库看起来结构简单、清晰，并且简化用户的数据查询操作。<strong>（2）使用户能以多种角度看待同一数据</strong>视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。<strong>（3）提供了一定程度的逻辑独立性</strong>数据的逻辑独立性是指用户的应用程序不依赖于数据库的逻辑结构。当数据库重构造（数据库结构改变），如增加新的表或对原有的表增加新的字段时，用户的应用程序会尽量不受到影响（否则要重新开发程序，耗时、费力且成本增加）。<strong>（4）视图能够对机密数据提供安全保护</strong>有了视图机制，就可以在设计数据库应用系统时对不同的用户定义不同的视图，使机密数据不出现在不应看到这些数据的用户视图上，这样视图机制就自动提供了对机密数据的安全保护功能。</p>
<h3 id="3-5-4-创建视图"><a href="#3-5-4-创建视图" class="headerlink" title="3.5.4 创建视图"></a>3.5.4 创建视图</h3><p><strong>创建视图主要是指明视图的名字、其数据来源于关系数据库中的哪些表、视图中的新列名称。</strong></p>
<ol>
<li>创建视图语句</li>
</ol>
<p>定义或创建视图使用CREATE VIEW语句，其语法格式为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> REPLACE] [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION];</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">OR REPLACE==能够替换已有的同名视图——可选</span></span><br><span class="line"><span class="string">ALGORITHM==可选的ALGORITHM子句是对标准SQL的MySQL扩展——可选</span></span><br><span class="line"><span class="string">view_name==视图名——必填</span></span><br><span class="line"><span class="string">column_list==为列定义明确的名称——可选</span></span><br><span class="line"><span class="string">select_statement==用于创建视图的SELECT语句——必填</span></span><br><span class="line"><span class="string">——例：CREATE VIEW test AS SELECT * FROM test2;</span></span><br><span class="line"><span class="string">WITH CHECK OPTION==可选</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>单源表视图</li>
</ol>
<p>视图的数据可以来自一个基本表的部分行、列，这样的视图可以称为单源表视图。</p>
<ol start="3">
<li>多源表视图</li>
</ol>
<p>视图不仅可以建立在单个基本表上，也可以建立在多个基本表上。视图的数据可以来自多个表，这样定义的视图称为多源表视图。多源表视图一般只用于查询，不用于修改数据。</p>
<ol start="4">
<li>在已有的视图上定义新视图</li>
</ol>
<p><strong>视图不仅可以建立在一个或多个基本表上，也可以建立在一个或多个已定义好的视图上，或建立在基本表与视图上。</strong>5.  带表达式的视图由于视图中的数据并不实际存储，所以定义视图时，可以根据应用的需要设置一些派生属性列。这些派生属性列由于在基本表中并不实际存在，故也称它们为<strong>虚拟列</strong>。带虚拟列的视图也称为<strong>带表达式的视图</strong>。</p>
<ol start="6">
<li>修改视图定义<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> [ALGORITHM <span class="operator">=</span> &#123;UNDEFINED <span class="operator">|</span> <span class="keyword">MERGE</span> <span class="operator">|</span> TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> select_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> <span class="operator">|</span> <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> OPTION]；</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-5-5-查看视图定义"><a href="#3-5-5-查看视图定义" class="headerlink" title="3.5.5 查看视图定义"></a>3.5.5 查看视图定义</h3><p><strong>1. 访问views表</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> database.views；</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用DESCRIBE语句</strong><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DESCRIBE</span> 视图名;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-5-6-使用视图"><a href="#3-5-6-使用视图" class="headerlink" title="3.5.6 使用视图"></a>3.5.6 使用视图</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> view_name;</span><br></pre></td></tr></table></figure>

<h4 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h4><p><strong>更新视图是指通过视图对数据进行插入(INSERT)、删除(DELETE)和修改(UPDATE)操作。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> database.view_name (key,key2)</span><br><span class="line">                       <span class="keyword">VALUES</span></span><br><span class="line">                       (<span class="string">&#x27;value1&#x27;</span>, <span class="string">&#x27;value2&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>视图是不实际存储数据的虚表，其没有数据。在视图中进行插入、删除、修改操作，最终要转换为对基本表的更新，这实际上是在其原始表中进行的，视图更新并不会对性能有太大影响。</p>
<h4 id="删除视图"><a href="#删除视图" class="headerlink" title="删除视图"></a>删除视图</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> database.view_name;</span><br></pre></td></tr></table></figure>

<h1 id="4-数据库安全性与完整性控制"><a href="#4-数据库安全性与完整性控制" class="headerlink" title="4 数据库安全性与完整性控制"></a>4 数据库安全性与完整性控制</h1><h2 id="4-1-数据库风险与安全需求"><a href="#4-1-数据库风险与安全需求" class="headerlink" title="4.1 数据库风险与安全需求"></a>4.1 数据库风险与安全需求</h2><h3 id="4-1-1-数据库隐私"><a href="#4-1-1-数据库隐私" class="headerlink" title="4.1.1 数据库隐私"></a>4.1.1 数据库隐私</h3><p><strong>1.隐私泄露的渠道</strong></p>
<ul>
<li>数据收集——互联网上存储着的信息资料（公开的）</li>
<li>非法获取——个人或团队对互联网安全性较弱的数据进行窃取</li>
<li>信息服务——用户喜好推荐这类功能</li>
<li>搜索引擎——字面意思</li>
</ul>
<p><strong>2.隐私防范的规则</strong></p>
<ul>
<li>提供者同意</li>
</ul>
<p>对于数据库当中每一条个人信息记录，都应该征得提供者对于其个人信息入库的同意。</p>
<ul>
<li>收集限制</li>
</ul>
<p>在提供者同意的前提下，不过多收集信息提供者的多余信息，把信息内容控制在指定目的的最小范围之内。</p>
<ul>
<li>使用限制</li>
</ul>
<p>收集的信息只用于收集时双方约定的目的，不作其他用途。</p>
<ul>
<li>泄露限制</li>
</ul>
<p>同一信息提供者对于目的A的数据信息不能与该提供者对于目的的数据信息，进行交流。</p>
<ul>
<li>保留限制</li>
</ul>
<p>个人信息只在须完成指定目的时才可保留，否则无效销毁。</p>
<ul>
<li>准确性</li>
</ul>
<p>数据库中存储的个人信息必须是正确、完整、有迹可循、更新至最新状态的，不能是杂乱无章、缺损、虚假、过时的。</p>
<ul>
<li>开放</li>
</ul>
<p>信息拥有者应有权限访问自己所收集并存储到数据库当中的所有信息。</p>
<ul>
<li>遵守</li>
</ul>
<p>信息拥有者应该具有验证以上规侧的能力，以对数据库隐私安全进行把控。</p>
<h3 id="4-1-2-数据库安全性威胁"><a href="#4-1-2-数据库安全性威胁" class="headerlink" title="4.1.2 数据库安全性威胁"></a>4.1.2 数据库安全性威胁</h3><ol>
<li><strong>来自硬件的威胁</strong></li>
</ol>
<p><strong>硬件设备是否完好从根本上决定了数据库系统的安全与否</strong></p>
<ol start="2">
<li><strong>来自系统软件的威胁</strong></li>
</ol>
<p>**存储文件包括数据库的数据文件、备份文件、日志文件等，只要能够通过操作系统访问或得到数据库存储文件，就可以获得数据库中的信息。 **</p>
<ol start="3">
<li><strong>来自网络的威胁</strong></li>
</ol>
<ul>
<li>黑客非法侵入</li>
<li>SQL注入</li>
</ul>
<p>在$QL注入攻击中，入侵者通常将未经授权的数据库语句插入（或“注入”）有漏洞的$SQL数据信道中。</p>
<ul>
<li>数据库通信协议漏洞</li>
</ul>
<p>在所有数据库供应商的数据库通信协议中，也有可能存在安全漏洞，针对这些漏洞的欺骗性活动包括未经授权的数据访问、数据破坏以及拒绝服务。更糟糕的是，由于自身数据库审计机制不审计协议操作，所以在自身审计记录中不存在这些欺骗性活动的记录。</p>
<ul>
<li>身份验证不足</li>
</ul>
<p>弱口令等可以轻易获取进入系统权限的方法</p>
<ul>
<li>拒绝服务</li>
</ul>
<p><strong>4.来自用户的威胁</strong>用户的威胁可以是滥用过高权限或者滥用合法权限<strong>5.来自开发人员和数据库管理员的威胁</strong></p>
<ul>
<li><strong>开发人员故意使应用程序留有“后门”</strong></li>
<li><strong>审计记录不足</strong></li>
</ul>
<p>审计自动记录所有敏感的或异常的数据库事务，其应该是所有数据库部署基础的一部分，如果数据库管理人员不尽职，数据库审计策略不足，则将在很多级别上面临重大风险。</p>
<ul>
<li><strong>备份数据暴露</strong></li>
</ul>
<h3 id="4-1-3-数据库安全性需求"><a href="#4-1-3-数据库安全性需求" class="headerlink" title="4.1.3 数据库安全性需求"></a>4.1.3 数据库安全性需求</h3><p><strong>物理数据库的安全性：</strong>对于数据库管理系统以及数据本身所存储的硬件设备不受外力而损坏，不因为自然、人为灾害而遭受损失。<strong>逻辑数据库的安全性：</strong>在软件层面上保证数据库系统以及数据库本身不易受到侵害，可以理解为数据库中各种数据库对象的定义，包括表、视图、索引等不受侵害。<strong>元素安全性：</strong>数据库元素本身的安全性，保证存储到数据库当中的所有数据都是正确的、相容的、有意义的，如数据库中每个表中、每条记录、每个字段上的值都是符合语义的，都是可信的。<strong>可审计性：</strong>每次对于数据库中数据的增加和更新都有迹可循，记录数据库的完整日志，使得数据库修改过程可回溯。<strong>访问控制：</strong>不同的数据模块由不同权限的人控制，确保只有授权用户和程序可以访问该模块数据。<strong>身份认证：</strong>身份作为衡量权限的唯一标识，用于访问控制和审计，只有通过身份验证的用户才能接近数据库，才能对数据库中的数据进行操纵。<strong>可用性：</strong>对于有授权的合法用户，应保证其具有随时随地能够正常使用和访问数据库的权利，能够调取其授权范围内的数据。<strong>规则推理：</strong>不同权限或者不同领域的人之间通过共享信息、合谋拼凑信息等方式由合法的低安全等级数据推导出高安全等级数据的内部构造或者数据内容。<strong>多级保护：</strong>根据数据保密程度划分多个保护级别，同一个数据库表中不同值的保密程度也可不同。</p>
<h2 id="4-2-数据库安全性控制措施"><a href="#4-2-数据库安全性控制措施" class="headerlink" title="4.2 数据库安全性控制措施"></a>4.2 数据库安全性控制措施</h2><h3 id="4-2-1-数据库安全性控制措施概述"><a href="#4-2-1-数据库安全性控制措施概述" class="headerlink" title="4.2.1 数据库安全性控制措施概述"></a>4.2.1 数据库安全性控制措施概述</h3><p>从技术上讲，数据库隐私的防护主要分为两个方面，即物理设备防护和数据库管理系统防护，在防护过程中，通常物理防护和数据库管理系统防护甚至操作系统防护应该是相互配合、密切联系的。（1）物理设备防护主要在于对磁盘的管理。数据库由无数条记录构成，如果从磁盘中能直接读取可用信息条目（或者记录），那么就存在一定的隐私泄露风险。通过对磁盘信息的解密、转换才能得到可用信息条目的磁盘才足够安全。（2）数据库管理系统防护主要在逻辑上进行权限的划分，对用户的数据库访问进行控制，对用户数据进行加密解密，以及对敏感隐私数据访问进行审计，等等。</p>
<h3 id="4-2-2-用户认证与鉴别"><a href="#4-2-2-用户认证与鉴别" class="headerlink" title="4.2.2 用户认证与鉴别"></a>4.2.2 用户认证与鉴别</h3><p><strong>用户认证和鉴别的过程不仅在连接数据库的时候进行，而且在连接成功后进行数据库查询（或者数据库访问）时，还要进行用户的身份认证</strong></p>
<h3 id="4-2-3-数据库访问控制"><a href="#4-2-3-数据库访问控制" class="headerlink" title="4.2.3 数据库访问控制"></a>4.2.3 数据库访问控制</h3><p><strong>数据库访问控制是维护数据库安全最主要、最基本、最核心的方法。****1.自主访问控制</strong>在自主访问控制中，用户可按照自己的需求对系统相应参数进行修改，以决定满足哪些条件的用户可以访问相应数据，“自主”来源于可访问数据资源的用户能够自主地将他所拥有的权限授予其他在该系统登录的任意用户。用户对于不同的数据对象有不同的存取权限，不同用户对同一对象也有不同的存取权限，用户还可以将其拥有的权限转授给其他用户，其最基本的实现方式可以用一个三元组来表示：（S，O，M）<strong>其中S表示主体，即操作用户；O表示客体，即数据；M表示数据库基本的查询、修改、添加、删除等操作。</strong>主体、客体、操作三元组的自主访问控制存在些许不足，即数据范围不能被约束，也就是客体不受约束，为此还可以进一步对客体进行约束，形成四元组：（S，O，M，P）新增的P元素用来表示约束条件，只有当满足P条件时，S才对O进行M授权。对访问控制添加了约束条件后，可以对用户进行等级划分，将授权指定给某最大级用户组s，根据先前制定好的权限传播策略传递给其他用户。例如，某数据库指定某授权给教师，根据传播策略，英语老师和语文老师都属于老师，都应该得到该授权，这里存在老师、某科目老师两个层次的抽像，这样大大提升了授权的精确性。</p>
<p><strong>2.基于角色的访问控制****基于角色的访问控制模型，该模型中心思想为将角色作为访问控制对象，对角色赋予其安全特征，并且对用户主体赋予角色语义，一个用户可以拥有许多角色，每种角色对应一定的安全权限，一个用户所拥有的安全权限为其拥有所有角色相应权限的并集</strong></p>
<p><strong>3.强制访问控制</strong>强制访问控制与自主访问控制相比，更适合于安全级别更高的数据库系统，因为自主访问控制可以由授权用户将权限任意传递，造成了数据库访问控制权限十分自由，使数据库安全受到了威胁。强制访问控制通过不可逾越的访问限制来保障数据库不受各种直接或间接的攻击，保证数据库的安全。DBMS中对于客体和主体所分配的所有权限在系统安全策略不发出调整时不能被改变。强制访问控制是一种基于安全级标记的访问控制方法，对每个数据对象都标记为一定的密级，这种标记分为几个不同的级别，每个用户也被授予某个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取，其强制存取控制相对比较严格。强制访问控制机制虽然在一定程度上提高了数据库系统的安全性，但是由于框定了各种访问约束，导致系统的灵活性受限，影响了实际应用中方便的性能。</p>
<h3 id="4-2-4-视图"><a href="#4-2-4-视图" class="headerlink" title="4.2.4 视图"></a>4.2.4 视图</h3><p>视图是一个虚表，对视图的数据进行操作时，系统根据视图的定义操作与视图相关联的基本表。视图中的数据来源于原来的基本表中，所以当基本表中的数据发生变化时，从视图中查询出的数据也就随之改变。视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。</p>
<h3 id="4-2-5-数据库加密"><a href="#4-2-5-数据库加密" class="headerlink" title="4.2.5 数据库加密"></a>4.2.5 数据库加密</h3><p><strong>加密的基本思想是根据一定的算法将原始数据（明文，plain text）变换为不可直接识别的格式（密文，cipher text），从而使得不知道解密算法的人无法获知数据的内容。</strong></p>
<h3 id="4-2-6-数据库审计"><a href="#4-2-6-数据库审计" class="headerlink" title="4.2.6 数据库审计"></a>4.2.6 数据库审计</h3><p><strong>数据库审计功能将用户的操作自动记录到审计日志（Audit Log）中，数据库运维人员可以根据审计日志信息将用户对数据库的一系列操作进行重现，找出非法存取数据的人、时间和内容，使得数据库恢复有迹可循，并且能够追踪攻击者并对其定责</strong></p>
<p>审计的作用就是将用户操作记录到日志中，国际信息安全评估通用准则提出安全审计系统的主要功能包括以下几点。（1）审计数据产生：审计数据包括两部分，一部分记录可审计事件并且记录相关数据信息，这部分数据信息可以包括访问、删除敏感数据项的操作，权限的设定和更改乃至取消，改变用户主体或数据客体的安全级别，以及操作发生时间、类型、对象、造成的影响或改变等；另一部分记录用户信息，将可审计事件和用户形成联系，该模块能够将用户和其操作可审计事件进行对应。（2）审计自动响应：由审计系统判断出一个操作事件存在安全隐患，自动进行报警或阻止进一步操作甚至中断数据库服务并及时通知数据库管理员进一步进行排查。（3）审计分析：对系统行为和产生的审计数据进行分析，发现已经发生的或者潜在的安全违规问题。（4）审计浏览：数据库运维人员需要通过对审计记录的查看进行系统维护判断，审计系统应提供审计记录的浏览工具。审计记录的访问也需要设定权限，不同的权限设定方式匹配不同的用户级别。（5）审计事件选择：为不同的应用场合选择不同的审计事件，并且只对该情况下安全威胁较为严重的属性进行审计。可以直接在可审计事件标记是否接受审计，也可以通过对一些关键字进行筛选，审计筛选出的可审计事件。（6）审计事件存储：审计完成后应对审计过程和对象进行记录并维护，保证审计记录的有效性，防止未授权用户的修改，并且应有一定的容灾策略。除了存储审计记录，防止未授权篡改以及在硬件和软件上都保证存储的有效性之外，还应该预防审计记录的丢失。</p>
<h2 id="4-3-MySQL的安全性控制"><a href="#4-3-MySQL的安全性控制" class="headerlink" title="4.3 MySQL的安全性控制"></a>4.3 MySQL的安全性控制</h2><h3 id="4-3-1-MySQL的安全性控制概述"><a href="#4-3-1-MySQL的安全性控制概述" class="headerlink" title="4.3.1 MySQL的安全性控制概述"></a>4.3.1 MySQL的安全性控制概述</h3><p><strong>MySQL自身的安全机制主要有用户的身份验证管理、基于权限系统的访问控制</strong></p>
<h3 id="4-3-2-MySQL访问控制"><a href="#4-3-2-MySQL访问控制" class="headerlink" title="4.3.2 MySQL访问控制"></a>4.3.2 MySQL访问控制</h3><p>MySQL安全性目标：保证所有的访问和操作都是由正确的用户发起的、进行的是正确的访问和操作、访问或操作的是正确的数据内容。<strong>1.MySQL支持的权限</strong></p>
<ul>
<li>select权限</li>
</ul>
<p>用于控制用户对数据库表的查询操作。</p>
<ul>
<li>insert权限</li>
</ul>
<p>用于控制用户对数据库表元素的插入操作。</p>
<ul>
<li>update权限</li>
</ul>
<p>用于控制用户对数据库表指定数据进行更新。</p>
<ul>
<li>delete权限</li>
</ul>
<p>用于控制用户对数据库表元组的刪除操作。</p>
<ul>
<li>index权限</li>
</ul>
<p>用于控制用户对数据库表建立或删除索引。</p>
<ul>
<li>alter权限</li>
</ul>
<p>用于控制用户所修改的数据表或修改数据表中某列属性</p>
<ul>
<li>create权限</li>
</ul>
<p>用于控制用户建立数据库、数据库表和索引。</p>
<ul>
<li>drop权限</li>
</ul>
<p>用于控制用户册除数据库或表。</p>
<ul>
<li>granti权限</li>
</ul>
<p>用于向特定用户授子各种权限。</p>
<ul>
<li>reload权限</li>
</ul>
<p>用于控制用户对服务器的f1ush操作。</p>
<ul>
<li>shudown权限</li>
</ul>
<p>用于控制用户关闭数据库服务器。</p>
<ul>
<li>process权限</li>
</ul>
<p>用于控制用户查看和杀死数据库服务器上的线程。</p>
<ul>
<li>file权限</li>
</ul>
<p>用于控制用户是否能够存取系统服务器文件。其中select权限、insert权限、update权限、delete权限为数据层级操作权限，用于数据的查询、插入、修改和删除，剩余权限则主要用于数据库层级的管理，操作对象为表、数据库等其他逻辑层面。</p>
<p><strong>2.权限系统工作原理</strong>MySQL成功安装后会自动创建超级管理员root账户，用来管理MySQL所有资源，<strong>MySQL资源主要包括数据库本身、数据库表、临时表、索引、表空间、字段、存储过程、存储函数、视图、触发器、文件、事件、MySQL命令等。</strong>在实际使用过程中，使用一个超级用户控制数据库所有资源显然不合理，因此，需要创建多个不同的账户协同管理数据库资源。MySQL权限系统对用户可操作行为的<strong>认证分两个部分，首先，通过用户名密码与数据库记录相匹配，</strong>以及对IP进行联合确认来验证用户身份，也就是说，如果用户名和密码都匹配，但是IP不合法，那么认定该用户访问不合法。合法用户直接进入下一步，不合法用户直接被拒绝访问；<strong>其次，对通过验证的用户进行权限匹配，赋予其应有权限，随后用户可以在授权范围内对数据库进行操作</strong>。MySQL在确定身份中考虑用户的主机IP和用户名，这样做允许用相同的用户名从不同的主机连接同一个MySQL服务器，同名用户属于不同的身份。</p>
<p><strong>MySQL服务器安装时，自动建立两个数据库，首先是mysql数据库，该数据库是MySQL权限系统的核心，包含以下5个表：user、db、host、tables-priv和columns-priv</strong></p>
<p>MySQL的存取控制包含以下两个步骤：首先由服务器检查是否允许用户连接；其次若认证成功从而允许用户连接，服务器检查用户的每个请求，查询对其赋予的权限，查看其是否有足够的权限实施。</p>
<p><strong>3.权限表****MySQL服务器在存取控制的两个阶段使用的user、db、host、tables-priv、columns-priv、procs_priv表，这些权限表放在mysql数据库中</strong></p>
<h3 id="4-3-3-MySQL用户管理"><a href="#4-3-3-MySQL用户管理" class="headerlink" title="4.3.3 MySQL用户管理"></a>4.3.3 MySQL用户管理</h3><p><strong>1.使用CREATE USER创建新用户****使用CREATE USER语句来创建用户</strong></p>
<p><strong>2.通过直接操作user表创建新用户****使用INSERT语句直接操作mysql中user表创建新用户</strong>的语法如下：INSERT INTO mysql.user(Host,User,Password)VALUES(‘host_name’, ‘user_name’,PASSWORD(‘password’))；</p>
<p><strong>3.修改用户名和主机名****使用RENAME USER语句修改一个已经存在于数据库系统中的用户名，</strong>其具体语法格式如下：RENAME USER old_username@host_name TO new_username@host_name,[ old_username@host_name TO new_username@host_name]…；</p>
<p><strong>4.修改root用户密码****（1）使用mysqladmin命令操作在命令行终端中修改密码，</strong>其基本语法如下：</p>
<p><strong>（2）使用UPDATE语句</strong>修改mysql数据库的user表，改变root用户的密码。所有的用户信息包括用户名、主机名、密码、权限，都写在mysql数据库中的user表内，root用户也不例外。root用户登录数据库系统后，由于其拥有所有权限，可以通过使用UPDATE语句修改user表中root用户记录的password字段来修改root用户的密码，该操作语句语法格式如下：UPDATE mysql.user SET password&#x3D;PASSWORD(‘rootpassword’)WHERE user&#x3D;”root” and host&#x3D;”host_name”；其中mysql.user表示mysql数据库中的user表，PASSWORD()表示加密函数，括号内容为用户指定明文密码，用户名为root，主机名为host_name。修改完成后，由user表中root@host_name记录相应password已经修改成功，但是通过后续登录验证可能发现，用新密码登录被系统返回Access denied，虽然user表中已经修改完成，但是并没有刷新用户权限，因此需要使用flush privileges重新加载用户权限。<strong>（3）使用SET语句修改root账户密码。</strong>SET PASSWORD操作语句可以用来修改本账户的登录密码，也可以用来修改其他普通账户的登录密码，使用SET PASSWORD的语法格式如下：SET PASSWORD&#x3D;PASSWORD(‘rootpassword’)；其中PASSWORD()密码加密函数在这里是必须使用的，rootpassword表示要修改成的root账户新密码。输入上述指令之后，mysql.user表中root@localhost账户加密后的密码发生了改变，表明在mysql.user表中相应项修改成功。<strong>5.修改普通用户密码</strong>root用户可以<strong>使用SET语句及UPDATE语句对普通账户密码进行修改。</strong></p>
<p><strong>6.root密码丢失的处理</strong>普通用户密码丢失可以通过各方请求验证，随后由root用户进行修改，如果root密码丢失，该数据库其他用户无法通过修改root账户密码的方式找回。考虑到这种情况，MySQL提出一种机制，可以使用特殊方式登录MySQL服务器，然后在root用户内直接重设自己的密码，其具体分为以下几个步骤。（1）查看MySQL是否已经启动，如果已经启动，就停止。在Windows系统中，可以用mysqld启动MySQL，具体命令如下：mysqld –skip-grant-tables由于修改MySQL中root用户的密码需要慎重执行，所以这里要求使用该计算机的管理员操作权限。（2）打开一个新的终端命令行窗口，使用mysql -uroot指令，不需要密码可直接登录到MySQL系统root账户中。mysql –uroot（3）如果不想修改密码，只是想看原来的密码，可以在命令行执行下面的语句SELECT host,user,password FROM mysql.user；即可查看到用户和密码。（4）如果要修改密码，在命令行下依次执行下面的语句USE MYSQLUPDATE mysql.user SET password&#x3D;PASSWORD(‘new_password’)WHERE user&#x3D;”root”；FLUSH PRIVILEGES；EXIT；（5）重新启动MySQL，再次登录时即可采用新的密码登录root账户。验证新密码登录成功后记得关闭mysql_safe进程，使得MySQL功能提供完整。</p>
<p><strong>7.查看用户账户信息</strong>可以<strong>通过SHOW GRANTS对账户信息进行查看，</strong>语法如下：SHOW GRANTS [FOR “user_name@host_name”]；</p>
<p><strong>8.删除用户****（1）使用DROP USER语句删除用户</strong>的语法格式如下：DROP USER use_name@host_name [, user_name@host_name] …</p>
<p>（2）使用DELETE语句直接删除mysql数据库中user表的该账户条目，其语法如下：DELETE FROM mysql.user WHERE user&#x3D;use_name and host&#x3D;host_name；</p>
<p><strong>9.退出账户</strong>另外一种方式是登录进入mysql后，利用键盘中断的方式，或输入MySQL可识别的命令退出MySQL。键盘中断的方式是control+z，而<strong>MySQL可识别的命令有“\q”“exit”“quit”。</strong></p>
<p><strong>10.限制MySQL账户资源次数</strong>所谓限制MySQL账户资源次数，就是指在用户表的资源控制列对某用户行进行控制。一般默认mysql.user表中的资源控制列字段的值均为0，表示不受限制。其数据类型是unsigned int，大于0的数值表示限制次数，该列有4个字段。（1）max_questions表示限定每小时内该用户账户向MySQL服务器发送查询语句或者mysql命令的最大允许次数，其对应参数值为max_queries_per_hour。（2）max_updates表示限定每小时内该用户账户向MySQL服务器发送更新语句所允许的最大次数，其对应参数值为max_updates_per_hour。（3）max_connections表示限定每小时内该用户账户可被允许连接MySQL服务器的最大请求数，其对应参数值为max_connections_per_hour。（4）max_user_connections表示限定同时段内该用户账户连接到MySQL服务器的最大并发连接数，其对应参数值为max_user_connections。mysql&gt;grant all on <em>.</em> to ‘username1’@’localhost’ with max_queries_per_hour 10max_updates_per_hour 5 max_connections_per_hour 5 max_user_connections 4；</p>
<h3 id="4-3-4-MySQL权限管理"><a href="#4-3-4-MySQL权限管理" class="headerlink" title="4.3.4 MySQL权限管理"></a>4.3.4 MySQL权限管理</h3><p><strong>权限可以分为多个不同层级：全局层级、数据库层级、表层级、列层级和子程序层级，</strong>（1）全局层级。全局层级也称用户层级，该级别权限指定的是某服务器下全部的数据库，在该服务器上登记备案的所有用户拥有的全部权限都被记录到mysql数据库的user表内。（2）数据库层级。数据库层级次于全局层级，只覆盖一个数据库的权限范围。（3）表层级。表层级次于数据库层级，其覆盖范围为数据库中某表的所有列。（4）列层级。列层级用来赋予指定数据库中指定表的某一列，列层级权限的管理都存储在mysql数据库的columns_priv表中。（5）子程序层级。GRANT、ALTER ROUTINE、EXECUTE等都可用于数据库中存储的函数或子程序，存储于mysql数据库的procs_priv当中。</p>
<p><strong>2.权限授予语句****授予权限使用的是GRANT语句，</strong>该语句的语法结构如下：    GRANT priv_type [(column_list)] [, priv_type [(column_list)]] …       ON [object_type] {table_name | * | <em>.</em> | db_name.<em>}       TO user_name [IDENTIFIED BY [PASSWORD] ‘password’]         [, user_name [IDENTIFIED BY [PASSWORD] ‘password’]] …       [WITH with_option [with_option] …] 其中object_type的格式为TABLE| FUNCTION| PROCEDUREwith_option的格式为GRANT OPTION| MAX_QUERIES_PER_HOUR count| MAX_UPDATES_PER_HOUR count| MAX_CONNECTIONS_PER_HOUR count| MAX_USER_CONNECTIONS count在上述语句中，priv_type是权限的名称，如SELECT、UPDATE等，给不同的对象授予权限，priv_type的值也不相同，一个GRANT语句当中可以赋予多个权限类别，每个权限类别可以指定某一列进行授权，即指定column_list值；ON关键字后面给出的是要授予权限的数据库或表名，object_type可以包括表table、函数function、过程procedure，主要用在MySQL升级时。为保证授权不受影响，通常使用object_type语句确定权限作用对象类型；db_name表示数据库名，table_name表示表名，用来指定授权该用户的是db_name数据库的table_name表中数据，或者使用</em>.<em>表示授权数据库系统中所有数据库内容，或者使用</em>授权当前数据库所有表的某权限，或者使用*.table_name表示授权为所有数据库的table_name表，或者使用以逗号分隔的多个表名来表示授权覆盖范围为授权的列所在的表，使用user_name@host_name表示用户名和主机名指定的账户基本信息；TO子句用来设定用户以及密码；PASSWORD表示可以使用密码加密函数对明文密码进行加密；‘password’表示设置的明文密码；WITH关键字后可以跟多个值，可以是GRANT OPTION，用来表示该用户有将自己所拥有权限赋给其他用户的权限；MAX_QUERIES_PER_HOUR用来设置每个小时可以执行的查询次数，该次数由其后count参数指定；MAX_UPDATES_PER_HOUR用来设置每个小时可以执行的更新次数，该次数由其后count参数指定；MAX_CONNECTIONS_PER_HOUR用来设置每个小时可以建立的连接次数，该次数由其后count参数指定；MAX_USER_CONNECTIONS用来设置某用户可同时建立的连接数，该连接数由其后count参数指定。（1）授予表权限和列权限。授予表权限时，priv_type可以是以下值。</p>
<table>
<thead>
<tr>
<th>①SELECT</th>
<th>给予用户使用SELECT语句访问特定的表的权限。用户也可以在一个视图公式中包含表，但用户必须对视图公式中指定的每个表（或视图）都有SELECT权限。</th>
</tr>
</thead>
<tbody><tr>
<td>②INSERT</td>
<td>给予用户使用INSERT语句向一个特定表中添加行的权限。</td>
</tr>
<tr>
<td>③DELETE</td>
<td>给予用户使用DELETE语句向一个特定表中删除行的权限。</td>
</tr>
<tr>
<td>④UPDATE</td>
<td>给予用户使用UPDATE语句修改特定表中值的权限。</td>
</tr>
<tr>
<td>⑤REFERENCES</td>
<td>给予用户创建一个外键来参照特定的表的权限。</td>
</tr>
<tr>
<td>⑥CREATE</td>
<td>给予用户使用特定的名字创建一个表的权限。</td>
</tr>
<tr>
<td>⑦ALTER</td>
<td>给予用户使用ALTER TABLE语句修改表的权限。</td>
</tr>
<tr>
<td>⑧INDEX</td>
<td>给予用户在表上定义索引的权限。</td>
</tr>
<tr>
<td>⑨DROP</td>
<td>给予用户删除表的权限。</td>
</tr>
<tr>
<td>⑩ALL或ALL PRIVILEGES</td>
<td>表示所有权限名。</td>
</tr>
</tbody></table>
<p>在授予表权限时，ON关键字后面跟table_name，这里table_name是表名或视图名。授予username2@localhost用户在bookmanage数据库中book表的Book_name列对应的select权限，并且限定该用户此种select访问权限的每小时最多访问次数为20次，其语句如下：mysql&gt;GRANT SELECT(Book_name) ON bookmanage.book TO username2@localhost WITH MAX_QUERIES_PER_HOUR 20；仍在root账户使用flush privileges进行权限更新后，登录username2@localhost账户，然后输入select * from bookmanage.book，查询bookmanage数据库中的book表的所有信息，由于权限分配时只授予了该用户对于bookmanage数据库中book表的Book_name列的select权限，所有book表的第一列也就是Book_id列就无权实现select操作，从而导致返回SELECTION command denied结果。由于username2@localhost账户没有对mysql数据库的任何权限，所以继续使用root账户访问，查看mysql数据库user表中username2@localhost账户信息，能够发现select用户层级权限被设置成‘N’，db表内select相关权限同样为‘N’，说明该账户在用户层级和数据库层级不存在select权限。接下来继续在root账户查看mysql数据库中的tables_priv表，找到username2@localhost账户对应的表授权信息，能够看出host为localhost，user为username2，拥有对于bookmanage数据库的book表中某一列的select权限。再查询mysql数据库中columns_priv表中所有信息，查阅到host为localhost、user为username2的账户拥有对bookmanage数据库的book表内Book_name列的select权限。（2）授予数据库权限。表权限适用于一个特定的表，MySQL还支持针对整个数据库的权限。例如，在一个特定的数据库中创建表和视图的权限。授予数据库权限时，priv_type可以是以下值。</p>
<table>
<thead>
<tr>
<th>①SELECT</th>
<th>给予用户使用SELECT语句访问特定数据库中所有表和视图的权限。</th>
</tr>
</thead>
<tbody><tr>
<td>②INSERT</td>
<td>给予用户使用INSERT语句向特定数据库中所有表添加行的权限。</td>
</tr>
<tr>
<td>③DELETE</td>
<td>给予用户使用DELETE语句删除特定数据库中所有表的行的权限。</td>
</tr>
<tr>
<td>④UPDATE</td>
<td>给予用户使用UPDATE语句更新特定数据库中所有表的值的权限。</td>
</tr>
<tr>
<td>⑤REFERENCES</td>
<td>给予用户创建指向特定的数据库中的表外键的权限。</td>
</tr>
<tr>
<td>⑥CREATE</td>
<td>给予用户使用CREATE TABLE语句在特定数据库中创建新表的权限。</td>
</tr>
<tr>
<td>⑦ALTER</td>
<td>给予用户使用ALTER TABLE语句修改特定数据库中所有表的权限。</td>
</tr>
<tr>
<td>⑧INDEX</td>
<td>给予用户在特定数据库中的所有表上定义和删除索引的权限。</td>
</tr>
<tr>
<td>⑨DROP</td>
<td>给予用户删除特定数据库中所有表和视图的权限。</td>
</tr>
<tr>
<td>⑩CREATE TEMPORARY TABLES</td>
<td>给予用户在特定数据库中创建临时表的权限。</td>
</tr>
<tr>
<td>⑪CREATE VIEW</td>
<td>给予用户在特定数据库中创建新的视图的权限</td>
</tr>
<tr>
<td>⑫SHOW VIEW</td>
<td>给予用户查看特定数据库中已有视图的视图定义的权限。</td>
</tr>
<tr>
<td>⑬CREATE ROUTINE</td>
<td>给予用户为特定的数据库创建存储过程和存储函数的权限。</td>
</tr>
<tr>
<td>⑭ALTER ROUTINE</td>
<td>给予用户更新和删除数据库中已有存储过程和存储函数的权限。</td>
</tr>
<tr>
<td>⑮EXECUTE ROUTINE</td>
<td>给予用户调用特定数据库的存储过程和存储函数的权限。</td>
</tr>
<tr>
<td>⑯LOCK TABLES</td>
<td>给予用户锁定特定数据库的已有表的权限。</td>
</tr>
<tr>
<td>⑰ALL或ALL PRIVILEGES</td>
<td>表示以上所有权限名。</td>
</tr>
</tbody></table>
<p>登录root账户后，使用GRANT语句对username2@localhost账户授予对bookmanage数据库上的所有表的create权限，该权限作用范围为某数据库内所有表，是数据库层级的权限。mysql&gt;GRANT CREATE ON bookmanage.* TO username2@localhost WITH GRANT OPTION；下面分别探究各个层级上访问控制权限表的内容。登录root账户，查询mysql数据库user表，create操作权限所对应的Create_priv字段，该字段值为‘N’，表明用户层级上没有create权限。查询mysql数据库db表，create操作权限对应字段值为‘Y’表示该账户在数据库层级拥有create权限。查询mysql数据库的tables_priv表，host为localhost、user为username2的账户不存在create权限的任何表示，说明该用户不存在表级别的create权限。输入Select * from columns_priv \G，查看mysql数据库中columns_priv表的全部内容，可以看到，host为localhost、user为username2的账户中不存在create相关权限的内容，于是不属于列层级权限。（3）授予用户权限。对于需要授予数据库权限的所有语句，也可以定义在用户权限上。例如，在用户级别上授予某人CREATE权限，这个用户可以创建一个新的数据库，也可以在所有的数据库（而不是特定的数据库）中创建新表。MySQL授予用户权限时，priv_type还可以是以下值。</p>
<table>
<thead>
<tr>
<th>①CREATE USER</th>
<th>给予用户创建和删除新用户的权限。</th>
</tr>
</thead>
<tbody><tr>
<td>②SHOW DATABASES</td>
<td>给予用户使用SHOW DATABASES语句查看所有已有的数据库的定义的权限。</td>
</tr>
</tbody></table>
<p>登录root账户后，使用GRANT操作对username2@localhost账户赋予全局的，也就是用户层级的insert操作权限。mysql&gt;GRANT INSERT ON <em>.</em> TO username2@localhost；登录root账户查看mysql数据库的user表，查看username2@localhost账户的对应insert权限的相应字段为‘Y’,说明该授权作用范围为整个数据库，为用户层级。查看db表中所有username2@localhost账户的行中insert权限对应字段都为‘N’。查询mysql数据库的tables_priv表的username2@localhost账户的信息，没有有关insert授权的描述。同样，columns_priv表中也没有该账户insert权限的信息。<strong>3.权限回收</strong>权限回收是指撤销目标用户对某层级范围的数据库对象执行某种操作的权利，管理用户权限时，通过权限回收使得数据库安全的保障机制得以提升。<strong>使用REVOKE语句回收权限</strong>后，改变mysql数据库中的相应权限字段。撤销权限时首先撤销其权限的使用，然后再改变其在mysql数据库的user表中相应的字段值。权限的回收可以是将被分配的所有权限的回收，也可以是回收其权限范围内的部分数据库、部分表甚至部分列的权限。使用“REVOKE ALL PRIVILEGES，GRANT OPTION FROM ‘user_name’@‘host_name’[，‘user_name’@‘host_name’]…”语句回收某个账户或多个账户的所有权限，包括其将权限授予其他用户的权限。REVOKE语句的语法如下：REVOKE priv_type [(column_list)] [, priv_type [(column_list)]] …    ON {table_name | * | <em>.</em> | db_name.<em>}    FROM user_name@host_name [, user_name@host_name] … 或者REVOKE ALL PRIVILEGES, GRANT OPTION FROM user [, user] …第一种格式用来回收某些特定的权限，第二种格式用来回收所有该用户的权限。其中priv_type表示所要撤回权限的类型，column_list表示可以对某列的该权限进行撤回，每种权限的撤回都可以覆盖多列的范围，若不指定该参数，则作用范围是整个表。一次执行REVOKE语句可以撤销多个类型的权限，db表示撤销权限所覆盖的数据库范围，该处为‘</em>’时代表对所有数据库执行此操作。table_name表示对数据库中某表做限制，user_name表示用户名，host_name表示主机名，一次调用REVOKE语句可撤销多个用户账户中的权限。某用户能够使用REVOKE语句的前提是需要拥有对mysql数据库的create user权限或者对mysql中所有表的update权限。对username1@localhost账户撤销全部权限，操作语句如下：mysql&gt;REVOKE ALL PRIVILEGES,GRANT OPTION FROM ‘username1’@’localhost’；然后再次查看该账户的权限，得到的结果相当于只是存在了一个无访问权限的空壳账户。<strong>4.更改账户权限</strong>对账户权限的更改包括为账户增加权限和为账户撤销权限这两种。为某账户增加权限需要当前登录账户拥有待增加权限且当前登录账户需要有对其他账户赋予自己拥有权限的权利，也就是查看权限时的“WITH GRANT OPTION”。使用GRANT语句操作已有账户时就是对该账户赋予权限的过程，使用REVOKE语句操作已有账户的已有权限时就是收回该账户权限的过程。如下语句所示，当hostname1@localhost存在且其对应密码为123456时，对其在所有数据库中全部表的范围授予select、delete、create权限。若用户名—主机名对在mysql.user表中不存在，则创建这个账户，若密码与mysql.user表中不符，还可修改密码为 ‘123456’。mysql&gt;GRANT SELECT,DELETE,CREATE ON <em>.</em> TO hostname1@localhost IDENTIFIED BY ‘123456’；登录root账户后，执行如下操作：mysql&gt;REVOKE SELECT,CREATE ON <em>.</em> FROM hostname1@localhost；则收回hostname1@localhost用户在所有数据库中全部表的范围的select、create权限。<strong>5.权限转移或限制****GRANT语句后若添加WITH GRANT OPTION则表示TO子句指定的所有用户账户都拥有把自己所拥有的所有权限授予其他用户的权利，</strong>不受其他用户当前授权情况的影响。登录root用户，用下列操作创建一个新的用户账户username3@localhost，设定其密码为‘123456’，将整个数据库系统的所有数据库中所有表的select权限赋予该用户，并赋予该用户将自己所拥有权限赋予其他用户的权利。mysql&gt;GRANT SELECT ON <em>.</em> TO username3@localhost IDENTIFIED BY ‘123456’ WITH GRANT OPTION；但是需要注意一点，在登录uername3@localhost账户权限授予时，不能使用GRANT语句授予不存在的用户账户，因为当授予不存在的用户账户时，等价于创建新用户，然而username3@localhost账户没有create用户的权限，于是此次操作被服务器拒绝。在root账户创建username4@localhost账户后，登录username3@localhost账户对username4@localhost账户进行全局的select授权，系统返回授权成功的结果。mysql&gt;GRANT SELECT ON <em>.</em> TO username4@localhost；登录username4@localhost后查看本账户所拥有权限，发现username3@localhost已经成功将全局的select权限授予username4@localhost账户。<strong>6.权限生效时机</strong>用户更改权限时，不论是设置权限还是撤销权限，都是对权限的一种更新，这种更新会直接作用到数据库表中，而在数据库系统运行过程中，user表是提前加载到内存的，如果在某一时间，root用户正在修改正处于登录状态的某账户的权限列，并且使用的是对数据库user表直接修改的方式，那么在被修改账户的登录状态下权限维持修改之前状态不变。只有当外存中的数据表内该字段信息更新至内存后才能真正修改对该用户的权限，除非重新连接MySQL服务器或者打开该用户新连接，或者<strong>使用FLUSH PRIVILEGES语句才能将数据表中字段写入内存，</strong>举例如下。例（1）登录username1@localhost账户，使用SHOW GRANTS查看自己的授权，可以发现具有所有表上的所有权限，不退出username1@localhost账户。mysql&gt;SHOW GRANTS；（2）在root账户中使用REVOKE语句修改其权限，收回username1@localhost账户的select和create权限。mysql&gt;REVOKE SELECT,CREATE ON <em>.</em> FROM username1@localhost；（3）在username1@localhost账户下查看自己的权限，用户可以发现其还具有所有表上的所有权限，包括select。（4）通过root账户使用UPDATE语句修改mysql.user表中username1@localhost账户的相关信息。mysql&gt;UPDATE mysql.user SET Insert_priv&#x3D;’N’,Update_priv&#x3D;’N’,Delete_priv&#x3D;’N’WHERE user&#x3D;’username1’ and host&#x3D;’localhost’；（5）仍在保持登录状态的username1@localhost账户中查看自己的权限，发现并没有撤销insert、update、delete三个权限。（6）在root账户中执行FLUSH PRIVILEGES操作：mysql&gt;FLUSH PRIVILEGES；（7）仍在保持登录状态的username1@localhost账户中使用SHOW GRANTS语句查看自己所拥有的权限，发现已经不存在insert、update、delete权限了。</p>
<h3 id="4-3-5-MySQL审计"><a href="#4-3-5-MySQL审计" class="headerlink" title="4.3.5 MySQL审计"></a>4.3.5 MySQL审计</h3><p>为了安全和操作的可追溯性考虑，MySQL 5.5企业版推出了相关的审计功能，到5.6.20版本，其功能进一步完善，下面介绍MySQL审计的使用过程。（1）mysql 5.6中的审计是通过server_audit插件来实现的，首先应该在相关网站下载server_audit.so插件。（2）登录MySQL，执行如下命令获取MySQL的plugin目录，一般Windows环境下数据库的插件目录默认是&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin。mysql&gt; SHOW GLOBAL VARIABLES LIKE ‘plugin_dir’；（3）将server_audit.so插件上传到&#x2F;usr&#x2F;lib&#x2F;mysql&#x2F;plugin&#x2F;目录下。（4）在命令行下安装server_audit.so（卸载该插件可以使用UNINSTALL PLUGIN server_audit）；mysql&gt;INSTALL PLUGIN server_audit SONAME ‘server_audit.so’；（5）查看变量开启设置情况，一般默认都是关闭的。mysql&gt;SHOW variables like ‘%audit%’；（6）编辑my.ini添加配置（应该在server_audit插件被安装好，并且已经运行之后添加这些配置，否则过早在配置文件添加这个选项，会导致MySQL发生启动错误）。server_audit_events&#x3D;’CONNECT,QUERY,TABLE,QUERY_DDL,QUERY_DML,QUERY_DCL’ 备注：指定哪些操作被记录到审计日志文件中server_audit_logging&#x3D;on 备注：启动审计server_audit_file_path &#x3D;&#x2F;data&#x2F;mysql&#x2F;auditlogs&#x2F; 备注：审计日志存放路径，该路径下会生成一个server_audit.log文件，就会记录相关操作记录server_audit_file_rotate_size&#x3D;200000000 备注：限制审计日志文件的大小server_audit_file_rotations&#x3D;200 备注：指定审计日志文件的数量server_audit_file_rotate_now&#x3D;ON防止server_audit插件被卸载，需要在配置文件中添加[mysqld]server_audit&#x3D;FORCE_PLUS_PERMANENT（7）重启服务，登录MySQL后发现，在MySQL环境下执行的任何命令都会被记录到&#x2F;data&#x2F;mysql&#x2F;auditlogs&#x2F;server_audit.log，如果审计日志文件达到指定的大小，会自动将文件进行切割。配置文件中可以对审计做约定，参数如下。</p>
<table>
<thead>
<tr>
<th>server_audit_output_type</th>
<th>指定审计日志输出类型，可为SYSLOG或FILE。</th>
</tr>
</thead>
<tbody><tr>
<td>server_audit_logging</td>
<td>启动或关闭审计。</td>
</tr>
<tr>
<td>server_audit_events</td>
<td>指定记录事件的类型，可以用逗号分隔多个值（connect、query、table），如果开启了查询缓存（Query Cache），查询直接从查询缓存返回数据，审计日志中将没有table记录。</td>
</tr>
<tr>
<td>server_audit_file_path</td>
<td>如server_audit_output_type为FILE，使用该变量设置存储审计日志的文件，可以指定目录，默认存放在数据目录的server_audit.log文件中。</td>
</tr>
<tr>
<td>server_audit_file_rotate_size</td>
<td>限制审计日志文件的大小。</td>
</tr>
<tr>
<td>server_audit_file_rotations</td>
<td>指定审计日志文件的数量，如果为0，审计日志将从不切换。</td>
</tr>
<tr>
<td>server_audit_file_rotate_now</td>
<td>强制审计日志文件切换。</td>
</tr>
<tr>
<td>server_audit_incl_users</td>
<td>指定哪些用户的活动将被记录，connect不受此变量影响，该变量比server_audit_excl_users优先级高。</td>
</tr>
<tr>
<td>server_audit_syslog_facility</td>
<td>默认为LOG_USER，指定facility。</td>
</tr>
<tr>
<td>server_audit_syslog_ident</td>
<td>设置ident，作为每个syslog记录的一部分。</td>
</tr>
<tr>
<td>server_audit_syslog_info</td>
<td>指定的info字符串将添加到syslog记录。</td>
</tr>
<tr>
<td>server_audit_syslog_priority</td>
<td>定义记录审计日志的syslogd priority。</td>
</tr>
<tr>
<td>server_audit_excl_users</td>
<td>该列表的用户行为将不被记录，connect不受该设置影响。</td>
</tr>
<tr>
<td>server_audit_mode</td>
<td>标识版本，可用于开发测试。</td>
</tr>
</tbody></table>
<p>审计日志名称为server_audit.log，默认存放在MySQL数据文件目录data路径下，下面给出一个审计日志文件内容的示意，从该示意内容可以看出审计日志文件中记录了用户对MySQL数据库的操纵行为，审计员通过对审计日志文件的理解和检查，可以得出审计报表，在这里不作过多阐述。20180310 15:58:10,node02,root,192.168.2.71,7,8,QUERY,,’SHOW DATABASLES’,106420180310 15:58:14,node02,root,192.168.2.71,7,9,QUERY,,’SHOW DATABASES’,0</p>
<h2 id="4-4-MySQL的完整性控制"><a href="#4-4-MySQL的完整性控制" class="headerlink" title="4.4 MySQL的完整性控制"></a>4.4 MySQL的完整性控制</h2><h3 id="4-4-1-实体完整性约束"><a href="#4-4-1-实体完整性约束" class="headerlink" title="4.4.1 实体完整性约束"></a>4.4.1 实体完整性约束</h3><p>实体完整性就是指数据表中的每条记录（或元组）都表示了现实世界中一个客观存在的实体，在现实世界中由于实体在实际情况当中是唯一存在的，实体完整性规则要求：表中的记录（或元组）既不能为空，也不能重复。<strong>MySQL实体完整性实现分为主键完整性和唯一索引约束两个方面。****1.主键完整性</strong>主键是指定数据库中某表的一列或多列的组合作为唯一确定该记录的标志性内容。主键列中所有记录的值都是唯一且存在的。<strong>在创建表时，使用PRIMARY KEY子句指定当前创建表的主键，</strong>PRIMARY KEY所约束的列中任何元组内该值均不为空。</p>
<p><strong>2.唯一索引约束（替代键约束）</strong>唯一索引指的是在某表内除主键以外的某一列，每一元组该列的取值都是唯一的。由于主键有最小化原则，所以逻辑上虽然有其他一列或多列可以唯一确定某一记录（或元组），那么如果仍存在某列要求该列所有记录（或元组）中的值唯一，我们称该列为替代键，是没有被选作主键的候选键，<strong>使用UNIQUE子句来定义唯一索引约束。</strong>例</p>
<h3 id="4-4-2-参照完整性约束"><a href="#4-4-2-参照完整性约束" class="headerlink" title="4.4.2 参照完整性约束"></a>4.4.2 参照完整性约束</h3><p>一张数据表中某列数据只能引用另一数据表中关键字的数据，保证表之间数据的一致性，防止没有意义或不存在的数据出现，称为参照完整性（Referential Integrity）。<strong>在SQL中的CREATE TABLE语句中添加外码FOREIGN KEY子句来声明参照完整性。</strong>例如，在stuandcour表中我们可以用foreign key(stuno) references stuinfo来表明在每个选课记录中指定的学生学号stuno必须在stuinfo数据表中存在。一旦违反了参照完整性约束，一般数据库系统都会采取拒绝执行导致完整性破坏的操作措施，如更新操作或删除操作等。<strong>1.创建外键****创建外键可以通过CREATE TABLE和ALTER TABLE语句来完成。</strong></p>
<h3 id="4-4-3-用户自定义完整性约束"><a href="#4-4-3-用户自定义完整性约束" class="headerlink" title="4.4.3 用户自定义完整性约束"></a>4.4.3 用户自定义完整性约束</h3><p>用户自定义完整性就是针对某一具体关系数据库的约束条件，它反映了在某一具体应用场景当中，数据信息所涉及的由数据库系统必须满足的语义要求<strong>用户自定义完整性可以有元组约束、关系间约束和域约束等形式。****1.元组约束</strong>元组约束指的是在某表中两列间存在某种关系，使得记录中其中某一列的值确定了，那么拥有这种关系的另外一个值也就确定了。例如，数据库中学生信息表包括学生出生年份字段和学生年龄字段，一旦知道了某学生的出生年份，就能计算出该学生的年龄，反之也成立，如果知道某学生的年龄，根据系统时间也可以计算出该学生的出生年份。这种元组之间存在关系且可以由某一值确定另一值时，可以使用元组约束防止数据不正确。例如下操作，创建student2表，使得学生生日为int型，age也为int型，在创建表的声明中插入CHECK子句，使得学生年龄age的值等于当前年份减去学生出生年份stubir的值：mysql&gt; CREATE TABLE student2     (stuno varchar(10),     Stubir int,     Age int check(age&#x3D;2018-stubir))； 需要注意的是，当前MySQL中对于CHECK子句的支持仅停留在表定义的阶段，只是在定义的阶段检查其输入不会产生错误，但是在插入数据时并不会对用户所插入的内容进行这方面的判断，例如，向上表中输入如下操作语句，发现虽然28不等于2018减去1999，但是该值依然插入成功了：mysql&gt; INSERT INTO student2 values(‘2016211001’,1999,28)；所以MySQL数据库中如果需要构造元组约束，需要使用触发器对该约束进行描述。    mysql&gt; delimiter&#x2F;&#x2F;     mysql&gt;CREATER TRIGGER age_birth3 before insert on student2 for each row         begin             declare msg varchar(200)；             declare sumval int；             set sumval&#x3D;new.age+new.stubir；             if sumval&#x3D;2018 then                 set msg&#x3D;”Age and stubirth is not math,cannot insert”；                     signal sqlstate ‘HY000’ SET message_text&#x3D;msg；             end if；         end&#x2F;&#x2F; 首先使用delimiter定界符构造可以输入触发器定义语句的环境，然后定义一个在student2数据表中的触发器，使得在该表中每插入一行数据前都要进入触发器中进行该项检验，在这里取得输入的学生年龄age项写为new.age，取得所输入的学生生日stubir项写为new.stubir，然后声明一个msg用来存储返回错误信息字符串，声明一个sumval的整型变量，使其作为学生年龄和学生出生年份的和，然后判断sumval值是否等于当前年份2018，如果等于当前年份则不作任何操作，如果不等于当前年份则要求将前面声明的msg变量赋值，这里选择将该错误记为年龄与学生生日不匹配错误，然后将这个signal发送给用户以提示用户该输入不合法，但是就算是此种方法也不能解决当前问题，因为即使检测到学生年龄加上出生年份不等于当前年份，那么也只能抛出信号，然后就无能为力了，因为MySQL不存在undo机制，于是INSERT操作并没有被数据库系统拒绝，而是在抛出错误信号后继续执行。图4-23为使用INSERT语句插入出生年份与当前年龄不匹配的数据时，MySQL数据库系统返回的结果。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572517064-341243d1-8427-4af2-acca-16b6a71a57c0.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u3e09088b&originHeight=66&originWidth=906&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9929b734-fe1f-41f9-a273-046e92a929f&title=">图4-23 不满足元组约束可以观察到，向student2表中添加数据时，如果出生年份与该学生年龄不相符则不允许插入，返回错误提示信息为在触发器定义的msg变量中的内容，说明触发器触发成功，并且能够成功阻止不合法数据输入数据库。我们知道系统返回的“ERROR 1644 (HY000): Age and stubirth is not match. Cannot insert.”信息是自己在构造触发器过程中制造的返回语句，进一步从数据库表student2中确定，查找学号stuno为“2010211001”记录的所有列的信息，得到该搜索结果为空集，从而可以确定，使用触发器来保证元组完整性的作用方法在MySQL中完全可行。<strong>2.关系间约束</strong>关系间约束表示的是不同表的两列或多列之间可能存在的直接要求关系，这种直接要求关系涉及两个不同的表，是两个不同关系之间的约束行为，我们可以通过一个例子来理解这种关系间约束的需求是如何产生的，并且讨论关系间约束的实现方法。例我们创建一个数据库，使得数据库中存在三个表：学生信息表、课程信息表、学生选课表，这三个表中存在参照关系如下。student7的学生信息表，表中存在两个字段：学号stuno列（varchar(3)）和标志（int）是否毕业的graduate字段，其中学号stuno列为主键。course1的课程信息表，包括课程的课程号courno（varchar(1)）以及该课程的学分credit（int），其中课程号courno为主键。stuandcour的学生选课表，该表中有三个字段：学生学号stuno（varchar(3)）、课程号courno（varchar(1)）和选课编号scno（varchar(1)）。其中，选课编号scno作为主键，学生学号stuno作为参照学生信息表中学号stuno的外键，课程号courno作为参照课程信息表中课程号courno的外键。现在有一种用户需求，要求多个关系直接满足一定的条件。如要求学生表graduate字段如果填入1，则该学生其所修学分必须达到10学分。该约束条件在除MySQL以外的一些数据库中，可以在数据库模式下利用断言（ASSERTION，限于篇幅本书不详细讨论）来完成，但MySQL数据库不支持创建断言，因此在MySQL中可以解决这个问题的方法就是使用触发器进行关系间约束。下面创建一个触发器来解决当其所修学分数不足10分时，UPDATE操作不能将graduate置为1的关系间约束：mysql&gt; delimiter&#x2F;&#x2F; mysql&gt;CREATER TRIGGER graduate_check1 after update on student7 for each row     begin         declare graduate int；         declare sumcredit int；         declare ssno char(10)；         declare msg varchar(200)；         set ssno&#x3D;old.stuno,graduate&#x3D;new.graduate；         select sum(credit) into sumcredit from stuandcour1 a,course1 b              where a.courno&#x3D;b.courno and a.stuno&#x3D;ssno group by a.stuno；         if (graduate&#x3D;1 and sumcredit&lt; 10) then&lt;             set msg&#x3D;”Credit is not enough for graduate,cannot update”；         上面语句使用delimiter分隔符提示进入创建触发器状态，然后创建了一个在有用户对数据表student7进行UPDATE操作之后的响应触发器，名为graduate_check1。该触发器取得修改前的学生表中学生学号为ssno，取得修改后的graduate值为graduate，然后计算该条记录对应的学号在stuandcour1表对应所选课程号，通过该课程号对应course1表中对应的学分credit值。将记录中学生所修所有课程的所有学分相加之和赋值给sumcredit变量，然后判断如果graduate值为1，也就是说该学生已毕业，但是sumcredit值小于10，说明该学生没有修够毕业所需分数，这种情况是数据库系统不允许的，所以给用户返回“Credit is not enough for graduate,cannot update”的信息，表示该UPDATE不合法。通过实验可以发现通过触发器解决了要求学生表graduate字段如果填入1，则该学生其所修学分必须达到10学分的问题，使得学分总数与毕业与否两个处于不同表之间的关系的约束控制得以实现。**3.域完整性**所谓域完整性，就是用来指定数据类型来说明某字段可以接受的值都有哪些，是什么样的。比如说性别、国籍等这种取值范围限定在一些字符串数组中的数据类型，或者是一些基于整型的数据，在取值范围上对输入数据有所要求，从而可以使得输入的国籍由于不存在于世界上任何一个国家的情况而被数据库系统拒绝，输入性别时不至于输入为“中”等此种情况的发生。在数据插入阶段，其在一定程度上维护了数据库的安全性。这里我们分两个方面来分析，第一个方面是关于可例举的数据的处理方法，第二个方面是对于整型数据这种连续型数据类型的范围框定的处理方法。（1）例举方法，对于可例举的数据，如对于性别的选择，使用CHECK子句，可以定义为如下形式：mysql&gt; CREATE TABLE student3     (stuno varchar(10),     Sex varchar(1) check(sex in(‘M’,’F’)),     Primary key (stuno))； 上面语句创建了一个新表student3，在该表中建立两列，学号stuno列和性别sex列，其中加入对sex变量的check检查，这里指定sex的取值为‘M’或者‘F’，其中M代表Male男性，F代表Female女性，指定stuno为主键。尝试向student3表中插入一个记录，stuno为‘2017211001’，sex为‘S’，插入记录的两列都符合创建两列时对数据类型的要求，但是sex字段不符合CHECK对值的要求，由于MySQL没有对CHECK语句进行实质上的响应，于是MySQL并没有拒绝这次INSERT操作。对于这种约束的实现，可以使用ENUM子句进行：mysql&gt; CREATE TABLE student4     (stuno varchar(10),     Sex enum (‘M’,’F’),     Primary key (stuno))； 在sex字段声明的数据类型处使用ENUM，其后括号内表示该字段的可取值范围。与CHECK不同，ENUM在MySQL数据库中既能够进行合法声明又具有域约束功能。对使用ENUM创建的域约束进行验证，在student4表中使用ENUM声明sex字段进行域约束，然后向student4表中插入一条新记录，使得该记录的学号stuno符合要求，sex的取值赋予‘M’和‘F’之外的某字符，可以看到，数据库系统返回的结果表示系统拒绝该次插入操作，表示输入的sex列数据不合法，然后输入一条拥有正确的性别取值和正确的学号类型的记录，可以验证插入成功。域约束还有另外一种实现思想，就是当某数据库中存在一个表，其某列所有数据值构成的集合可以作为另外一个表的某一列数值的取值范围。这样的枚举型数据可以在CHECK子句中加入如下SELECT语句来实现：mysql&gt; CREATE TABLE student6     (stuno varchar(10),     Sex char(1) check(sex in (select sex from student4) ),     Primary key (stuno))； 上面语句创建了一个新的数据表student6，使得数据表中性别sex的取值范围由student4表中sex列出现的所有值来确定。若student4表中加入了新的sex字段取值，那么student6表中sex字段的取值范围同样加入了新的取值。同样，在MySQL数据库中无法对该模式进行识别，只能停留在定义阶段，这种实现想法对于MySQL数据库的实现仍然能够通过触发器的方式实现，具体实现方法这里不再赘述，可以由读者自行实现。（2）第二种域约束是指数据类型为数值类，然后经过对数值的边界进行约束，从而对该列取值作约束。这种域约束类型不能通过ENUM子句完成，此外，由于MySQL不支持CHECK语句的使用，尽管声明处语法合乎要求，但是不会实际在用户插入数据时对其访问进行限制，只能继续选择触发器方式。mysql&gt; delimiter&#x2F;&#x2F; mysql&gt;CREATER TRIGGER stu_age before insert on student5 for each row     begin         declare msg varchar(200)；         if new.age&lt;&#x3D;6 then             set msg&#x3D;”Age is inappropriate,cannot insert”；                 signal sqlstate ‘HY000’ SET message_text&#x3D;msg；         end if；     end&#x2F;&#x2F; 使用delimiter分隔符来插入触发器创建语句，然后对表student5创建一个名为stu_age的触发器，该触发器的触发时机在于每当向student5数据表中使用INSERT语句插入信息时，作用为对插入信息的age字段值进行校验，当age大于6时合法，当age小于或等于6时对用户该操作返回一个提醒signal，使得插入用户可以清晰地定位当前操作错误源。对由触发器创建的第二类域约束进行验证，保证学号字段符合该字段定义的数据类型，年龄字段同样符合该字段的数据类型，并且使得该数值为触发器定义中所不允许的数值，比如向student5表中插入“‘2017211002’，2”记录，该记录的返回结果为“Age is inappropriate，cannot insert”，表明触发器已经启用并且成功判断输入值不符合对于该表的约束，然后继续查证数据库中student5表是否存在学号stuno字段为‘2017211002’的数据记录，从而得出上述INSERT语句并没有成功运行，非法数据并没有被插入数据库中。</p>
<h3 id="4-4-4-命名完整性"><a href="#4-4-4-命名完整性" class="headerlink" title="4.4.4 命名完整性"></a>4.4.4 命名完整性</h3><p>使得数据库中每个完整性约束都有一个名字，并且这个名字能够体现完整性约束种类以及作用表的名称。例</p>
<h3 id="4-4-5-删除完整性"><a href="#4-4-5-删除完整性" class="headerlink" title="4.4.5 删除完整性"></a>4.4.5 删除完整性</h3><p>在一个复杂的数据库中，每改动一个记录都受到重重的约束条件判断，如果直接删除某个表，难免会使得数据库系统发生错乱甚至崩溃，尤其在涉及一些参照约束、关系间约束等有关表与表之间相关性的其中的某个表时，所以在删除表之前，需要人工手动将与该表相关的所有约束都清理掉，根据实际要求对与要删除的数据表有约束关系的数据记录进行约束剔除或修改。这里需要用到ALTER TABLE语句对数据表中完整性约束作改变。</p>
<h1 id="第5章-数据库备份与恢复"><a href="#第5章-数据库备份与恢复" class="headerlink" title="第5章 数据库备份与恢复"></a>第5章 数据库备份与恢复</h1><h2 id="5-1-备份与恢复原理"><a href="#5-1-备份与恢复原理" class="headerlink" title="5.1 备份与恢复原理"></a>5.1 备份与恢复原理</h2><h3 id="5-1-1-故障种类"><a href="#5-1-1-故障种类" class="headerlink" title="5.1.1 故障种类"></a>5.1.1 故障种类</h3><p>数据库系统中可能发生各种故障，<strong>故障种类可以分为事务故障、系统故障、介质故障、计算机病毒等</strong>。<strong>1.事务故障</strong>撤销已做的数据修改，从而使得数据库恢复到正确的状态在大多数情况下，事务故障是非预期的，不能由事务程序处理，有以下两种错误都可能造成事务执行失败。</p>
<p>事务故障也就是说事务最终没有达到预期的目标（COMMIT或显式的ROLLBACK），所以数据库可能会处于不正确的状态。此类故障的解决办法是在不影响其他事务运行的情况下强行回滚（ROLLBACK）该事务，即撤销该事务已经做出的任何修改，回到事务执行之前的状态，我们称此方法为事务撤销（UNDO）。</p>
<p><strong>2.系统故障</strong>系统故障是指造成系统停止运转的事件，使得系统要重启的故障，如突然停电、CPU故障、操作系统故障、DBMS代码错误等。这类故障会导致内存中存储的数据丢失，并使得事务处理终止。换句话说，此类故障会影响正在运行的所有事务，但不破坏数据库。发生此类故障时，主存的内容尤其是数据库缓冲区中存储的数据都会丢失，所有正在运行的事务都会非正常终止。数据库系统为了提高效率，对数据库对象操作的结果不是立刻写入磁盘，而是保留在缓冲区中，从而可以被不同事务一次又一次地使用，如果它变得不常用，则可写入磁盘并清出缓冲区（参见2.2.2节，InnoDB存储引擎的内容）。缓冲区采用最少使用算法（LRU）决定最长时间内未被使用的缓冲区被写入磁盘的数据文件中。缓冲区是否写入磁盘数据文件与其中的数据是否提交无关，即未提交的数据也有可能被先写入磁盘。数据库写进程只服从于LRU，不服从于事务。为了防止因故障原因使留在缓冲区但已提交的数据反映不到磁盘上，或者写入磁盘的数据没有提交，可以利用日志来记录对数据库的更新操作，使用日志项记录更新操作的足够信息。发生系统故障时，主要数据库存在以下两种可能的不正确的状态。（1）未完成的事务的结果可能已经写入磁盘。此类故障的解决办法是清除这些事务对数据库进行的所有的更改操作，即事务撤销（UNDO）。（2）完成的事务结果可能有一部分甚至全部留在缓冲区，并没有写入磁盘。此类故障的解决办法是将这些事务已提交的结果重新写入数据库，即事务重做（REDO）。处理系统故障，就是要撤销所有未完成的事务，重做所有已完成的事务。</p>
<p><strong>3.介质故障</strong>介质故障是指在数据传送操作的过程中由于磁头损坏、瞬时强磁场干扰等造成的磁盘块上的内容丢失。</p>
<p><strong>4.计算机病毒</strong>计算机病毒是一种人为的故障或破坏，是一些恶作剧者研制的一种计算机程序。它可以像病毒一样繁殖和传播，这种程序会对计算机系统包括数据库造成危害。计算机病毒是计算机系统的主要威胁，也是数据库系统的主要威胁。以上几种故障都可能会破坏数据的完整性、一致性。DBMS所提供的备份与恢复机制可以将这些故障引起的错误状态恢复到某一已知的正确状态（可能是一致状态或完整状态）。<strong>数据库恢复用到是数据转储和登记日志文件。</strong>数据转储不仅在上述的故障恢复中具有重要的地位，在数据库的升级过程中，有时候也需要知道数据或数据库模式在过去的某个时间点是什么样的。例如，或许被卷入一场法律官司，或发现了应用的一个Bug，想知道这段代码之前干了什么（有时候仅仅依靠代码的版本控制还不够）。</p>
<h3 id="5-1-2-恢复机制的原理"><a href="#5-1-2-恢复机制的原理" class="headerlink" title="5.1.2 恢复机制的原理"></a>5.1.2 恢复机制的原理</h3><p><strong>我们将数据库的恢复原理概括为冗余</strong>。数据库中任何一部分数据的破坏或者不正确的数据都可以根据存储在系统中的冗余数据来建立。<strong>建立冗余数据最常用的技术是数据转储和登记日志文件。</strong></p>
<p>（1）数据转储。数据转储也称为数据备份。数据备份是数据库恢复中最基本的技术，其<strong>是由数据库管理员或者运维人员定期将整个数据库复制到磁带、磁盘或者其他存储介质保存起来的过程，这些备用的数据成为后备副本或后援副本</strong>。</p>
<p>（2）登记日志文件。前面章节中我们不止一次地提到日志文件，日志文件是用来记录事务对数据库的更新操作的文件，该文件在MySQL中也称为二进制日志文件，由MySQL自动维护。<strong>以事务为单位的日志文件中需要登记的内容包括各个事务的开始、各个事务的结束、各个事务的所有更新操作。这里的每个事务的开始标记、每个事务的结束标记和每个更新操作均为日志文件中的一个日志记录。每个日志记录的内容主要包括事务标识（用于表明是哪一个事务）、操作的类型（包括插入、删除或更新）、操作对象（记录内部标识）、操作前的值和操作后的值等。</strong>对于日志来说，MySQL有一个控制准则叫作“写日志优先准则”，即当数据库执行更新操作时，先把更新信息写进日志，然后更新数据库，这种机制保证了通过日志可以还原用户对数据库的更新操作，所以当数据库发生故障时，利用日志对执行完的更新操作进行重做（将更新后的值强行写入数据库中），可以恢复数据库。</p>
<p><strong>1．事务故障的恢复****事务故障的恢复主要是利用日志文件撤销此事务已对数据库进行的更改</strong>。事务故障的恢复是由DBMS自动完成的，系统的恢复步骤如下。（1）反向扫描日志文件，查找该事务的更新操作。（2）对该事务的更行操作执行逆操作，如果日志记录中是插入操作，则相当于做一个删除操作；如果日志记录中是删除操作，则相当于做一个插入操作；如果日志记录中是修改操作，则相当于用修改前的值代替修改后的值。（3）继续反向扫描日志文件，查找该事务的更新操作，并做同样处理，直到读到此事务的开始标记，事务故障恢复就完成了。</p>
<p><strong>2．系统故障的恢复</strong>系统故障造成数据库不一致状态的原因主要有两个，一个是未完成的事务对数据库的更新可能已经写入数据库中，另一个是已提交事务对数据库的更新可能还留在缓冲区，还没来得及写入数据库，因此，<strong>系统故障的恢复操作就是要撤销故障发生时未完成的事务，重做已经完成的事务。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572775955-6cdb5c2d-0e61-414f-af0f-b3a36b198c99.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u05be4568&originHeight=317&originWidth=680&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u1db0f0b2-bd2c-4457-8b1f-4cc18543c33&title="><strong>3．介质故障的恢复</strong>发生介质故障后，磁盘上的物理数据和日志文件都被破坏，这是最为严重的一种故障，恢复的方法是重装数据库，然后重做已完成的事务。（1）装入最新的数据库的后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。对于动态转储的数据库副本，还需要同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法，才能将数据库恢复到一致性状态。（2）装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务。<strong>介质故障的恢复需要数据库管理员重装数据库副本和有关的各日志文件副本，然后执行系统提供的恢复命令，</strong>具体的恢复操作仍由DBMS完成。<strong>4．具有检查点的恢复</strong>利用日志文件进行数据库恢复时，恢复系统必须搜索日志，确定哪些事务需要重做，哪些事务需要撤销。一般来说，需要检查所有日志记录，这样做有两个问题，一是搜索整个日志文件将耗费大量的时间，二是很多需要重做处理的事务实际上已经将它们的更新操作结果写入了数据库中，然而恢复子系统又重新执行了这些操作，浪费了大量时间。为了解决这些问题，又发展了具有检查点的恢复技术，<strong>检查点的恢复技术在日志文件中添加了一类新的记录——检查点记录，数据库的恢复只需要找到最近的一个检查点记录，恢复该检查点以后的日志信息</strong>。检查点记录的内容包括建立检查点时刻所有正在执行的事务清单和这些事务最近一个日志记录的地址。DBMS动态维护日志文件，周期性地执行建立检查点、保存数据库状态的操作。具体包括将当前日志缓冲区中的所有的日志记录写入磁盘的日志文件上；在日志文件中写入一个检查点记录；将当前数据缓冲区的所有数据记录写入磁盘的数据库中；把检查点记录在日志文件中的地址写入一个重新开始的文件。DBMS可以定期或不定期地建立检查点，保存数据库状态；也可以按照预定的一个时间间隔建立检查点，如每隔一小时建立一个检查点；也可以按照某种规则建立检查点，如日志文件写满一半时建立一个检查点。使用检查点的方法可以改善恢复效率。当事务T在一个检查点之前提交，T对数据库所做的修改一定都写入数据库，写入时间是在这个检查点建立之前或在这个检查点建立之时，这样在进行恢复处理时，就没必要对事务T执行重做操作。DBMS使用检查点的方法进行恢复的步骤如下。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572775998-4951e3f7-a849-47e9-87a2-aee61111ac6b.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u787e88db&originHeight=430&originWidth=680&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u101100ed-c678-41bc-8a23-c9fc934a576&title="></p>
<h3 id="5-1-3-备份的类型"><a href="#5-1-3-备份的类型" class="headerlink" title="5.1.3 备份的类型"></a>5.1.3 备份的类型</h3><p>根据不同的划分标准，<strong>备份划分为在线备份与离线备份，物理备份与逻辑备份，完全备份、增量备份与差异备份，本地备份与异地备份等不同形式</strong>。<strong>1.在线备份与离线备份</strong>按照备份时服务器是否继续提供服务，备份分为在线备份和离线备份。（1）在线备份（Online Backup）：也称作热备份（Hot Backup）。在线备份不要求数据库服务器系统中无运行的事务，也就是数据库服务器不需要关闭，其在数据库服务器正在运行时直接备份，备份过程中不影响前端用户对数据库进行存取或修改，数据备份和前端提交的事务可以并发执行（2）离线备份（Offline Backup）：也称作冷备份（Cold Backup）。数据库进行备份时在系统中无运行事务，即备份操作开始的时刻，数据库处于一致性的状态，而备份期间则不允许对数据库进行任何存取和修改操作。</p>
<p><strong>2.物理备份与逻辑备份</strong>按照备份的操作方式，备份分为物理备份与逻辑备份。（1）物理备份：原始数据在操作系统呈现什么样的表现形式，备份出来也是什么样。这种方式属于纯I&#x2F;O型的备份方式，从备份形式上看，其就是将组成数据库的数据文件、配置文件等相关的文件复制到其他路径上保存。换句话说，物理备份是以磁盘文件为基本单位的，这种备份较适合大型、重要、出现故障时需要快速恢复的场景。（2）逻辑备份：逻辑备份是对数据库的逻辑结构（通过CREATE DATABASE、CREATE TABLE等语句创建的数据库表对象）以及其所存储的数据（转换为INSERT INTO）进行备份，这种备份方式非常灵活，但是对于大型系统来讲，使用逻辑备份进行恢复时性能较低。换句话说，逻辑备份是以表或者记录集合为基本单位的，备份出来的结果往往以文件形式保存。</p>
<p><strong>3.完全备份、增量备份与差异备份</strong>按照是否备份全部数据或是只备份部分数据可将备份分为完全备份、增量备份与差异备份。（1）完全备份（Full Backup）：每次对数据进行完整的备份。当发生数据丢失的灾难情况时，完全备份无须依赖其他信息，即可实现100%数据恢复，其恢复时间最短且操作最方便。</p>
<p>（2）增量备份（Incremental Backup）： 增量备份是指在一次全备份或上一次增量备份后，每次的备份只需要备份与前一次相比增加和修改的文件。这就意味着第一次增量备份的对象是进行完全备份后所产生的增加和修改的文件；第二次增量备份的对象是进行第一次增量备份后所产生的增加和修改的文件，以此类推。</p>
<p><strong>4.本地备份与远程备份</strong>（1）本地备份：MySQL服务运行的服务器上执行的备份。本地备份生成的备份集一般都是在本地保存的。（2）远程备份：非本地服务器上执行的备份。远程备份生成的备份集不一定在远程，有些备份方案只是备份操作命令在远端执行，但备份集仍然是创建于MySQL所运行的本地服务器上的。</p>
<h2 id="5-2-MySQL备份方案"><a href="#5-2-MySQL备份方案" class="headerlink" title="5.2 MySQL备份方案"></a>5.2 MySQL备份方案</h2><h3 id="5-2-1-备份策略的影响因素和备份内容"><a href="#5-2-1-备份策略的影响因素和备份内容" class="headerlink" title="5.2.1 备份策略的影响因素和备份内容"></a>5.2.1 备份策略的影响因素和备份内容</h3><p>在实际工作中，MySQL备份方式的选择受到很多因素的影响。MySQL允许通过各种不同的方式来备份数据库中的数据，但是这些方式又各自有优缺点，数据库管理员需要根据自己的生产环境来考虑最适用的备份方式。<strong>1.MySQL备份策略的影响因素****制定MySQL的备份策略受到很多因素的影响，主要包括数据库的可用性、MySQL存储引擎、数据库锁策略、MySQL拓扑等因素。</strong>（1）数据库的可用性。如果数据库在某个时间段没有用户对其进行访问，此时数据库并不要求可用，这个时间段就成为维护数据库的绝佳窗口。例如，系统运行的不是“24×7”的业务，这些业务就可能存在维护窗口，这样的时间段为我们做数据库备份提供了机会。（2）MySQL存储引擎。2.2.2节中对MySQL存储引擎进行了介绍，在MySQL数据库中，不同的数据表可以选择不同的存储引擎，不同的MySQL存储引擎有着不同的锁需求和一致性要求，因此表所使用的存储引擎对于最终备份方案的选择会产生很大的影响。</p>
<p><strong>2.备份内容</strong>具体备份的过程中，我们需要备份什么呢？备份的内容是由备份的需要决定的，其中最简单、最低要求的就是备份数据和表定义。在实际的生产环境中，<strong>MySQL在备份上需要考虑更多的内容，主要包括表定义和数据、非显著数据、代码、服务器配置、复制配置和操作系统文件</strong>。表的结构信息（或者表的定义信息）和数据可以称为显著数据。（1）非显著数据。不要忘记那些容易被忽略的数据，如二进制日志和InnoDB事务日志，正如5.1节所说，这些日志信息在数据库恢复时起着非常重要的作用。（2）代码。MySQL服务器可以存储表和索引，也可能还存储着许多代码，如触发器和存储过程。如果备份了MySQL数据库，那么大部分这类代码也备份了，但如果需要还原单个业务数据库（如只是备份了自己创建的数据库）就会比较麻烦，因为诸如存储过程，实际是存放在MySQL数据库（参见第3章数据字典）中的。（3）服务器配置。假定要从一个实际的灾难中恢复，比如说地震过后在一个新的数据中心构建服务器，备份中包含的服务器配置很关键，服务器配置一般在配置文件中。（4）复制配置。如果恢复一个涉及MySQL复制的服务器，应该备份所有与复制相关的文件，如二进制日志、中继日志、日志索引文件和.info文件，至少应该包含SHOW MASTER STATUS和SHOW SLAVE STATUS的输出。执行FLUSH LOGS也非常有好处，可以让MySQL从一个新的二进制日志开始，从日志文件的开头做基于故障时间点的恢复要比从中间进行更容易。（5）操作系统文件。由于MySQL的数据库和表是直接通过目录和表文件实现的，因此，可以通过直接复制文件的方法来备份数据库（第2章的数据库实例和第3章的数据库对象中都讲述了一个数据库所对应的磁盘文件）。这些建议在许多场景下会被当作“备份一切”，然而如果有大量的数据，这样做的开销会非常高，需要更加明智地考虑如何做备份，特别是可能需要在不同备份中备份不同的数据。例如，可以单独地备份数据、二进制日志和操作系统及系统配置。</p>
<h3 id="5-2-2-文件系统冷备份"><a href="#5-2-2-文件系统冷备份" class="headerlink" title="5.2.2 文件系统冷备份"></a>5.2.2 文件系统冷备份</h3><p>如果MySQL实例存在维护窗口，那么我们可以通过干净而适当的关机来停止MySQL实例，就有可能执行一次<strong>文件系统冷备份，这是对文件系统上的文件的物理复制，即直接使用操作系统提供的复制命令就可以完成备份</strong>。在Windows操作系统平台下，MySQL数据库缺省的安装目录为C:\Program Files\MySQL\MySQL Server 5.6，MySQL数据库存放目录默认为C:\Program Files\MySQL\MySQL Server 5.6\data，也可以是其他用户自定义的目录。前面3.3.1节中讲到，在MySQL中创建一个数据库，就会在操作系统下形成一个同名的目录，因此如果要对某一个数据库进行文件系统的冷备份，可以在操作系统下找到这个同名的目录，然后对该目录下的所有文件进行复制（参见3.2.4表对象文件格式）。为了确保能够成功地备份所有重要的MySQL数据，可以通过查询MySQL配置变量来获得各种文件的位置，应该仔细检查这些文件的位置，并将其包含在要备份的文件列表中，应该在服务器运行时获得这些变量的值。配置文件中不会定义所有的变量，MySQL将对未定义的变量使用预先设置的默认值。我们可以通过MySQL的命令SHOW VARIABLES查看变量对应的值，找到备份目录所在的具体位置。为了能够更快地查找到我们需要的变量，可以使用通配符来实现，不同的目录以及存放的内容如下。（1）datadir：MySQL数据目录。（2）innodb_data_home_dir：InnoDB Data数据目录。（3）innodb_data_file_path：单独的InnoDB数据文件，它可能包含特定的不同目录。（4）log-bin：二进制日志目录。（5）log-bin-index：二进制日志索引文件。（6）relay-log：中继日志记录。（7）relay-log-index：中继日志索引文件。通过SHOW VARIABLES LIKE ‘%dir%’命令可以查看MySQL的数据所在目录，操作结果如图5-1所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819171-6bf276cf-0af2-4bb0-9d54-68a0fb7fe631.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u3929182c&originHeight=351&originWidth=845&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=udcc94fa6-3994-4292-b969-8f24b47d909&title=">图5-1 查看MySQL数据库所在目录除了上述的数据文件之外，备份MySQL的配置文件页也非常重要，因为这些设置对于成功运行MySQL来讲十分重要，尤其是innodb_data_file_path和innodb_log_file_size包含着底层文件，如果所配置的文件大小与这些文件的大小不一致，将导致MySQL实例不能启动。我们举一个简单的实例来说明文件系统冷备份的具体步骤，首先使用show tables查看MySQL数据库employees下的数据表，该数据库共有6张表，如图5-2所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819196-2d0a04d7-6e04-4fc9-8ff5-fdd0ba33d1fd.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u46e8e81e&originHeight=309&originWidth=674&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u427e85f2-4091-46f9-8138-db8489415e4&title="><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819189-4a1d842d-dd5b-41e7-a9c0-83943c2e2a54.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8d2deae7&originHeight=204&originWidth=223&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=uaa7bcf7d-90ed-46a5-a620-1d237c86d02&title=">图5-2 查看MySQL数据库employees下的数据表<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819157-df519c98-586b-446d-8c57-d272a93e775c.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue5070452&originHeight=193&originWidth=673&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u896f61cb-2d15-4ff2-9fa4-9573195cffe&title="><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653572819190-1ce5faff-be81-472e-a954-1c4e4c11b085.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u2a4920ee&originHeight=44&originWidth=431&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u80856453-c7c9-41bc-b4cf-51bcb9c5153&title=">图5-3 employees中salaries出错情形图5-3中出现了Table doesn’t exist（表不存在）这个错误，错误的原因是上述备份的数据库中数据表的所有存储引擎都是使用的InnoDB存储引擎。InnoDB存储引擎的表格与其他存储引擎的表格不同，InnoDB表对应的表结构文件存储在后缀为.frm的文件中，即存储在数据库的目录中，也就是说在上述的操作过程中我们成功地复制了表结构文件，但是InnoDB的数据文件则存储在根目录下的ibdata1文件中，所以在进行之前的文件复制中一定要在复制数据库目录文件的同时，将ibdata1的文件一并复制，并将其保存至数据库的根目录，替换原来的文件，此时再次执行查询命令，查询成功，至此employees数据库备份还原成功。对于只有MyISAM存储引擎的数据库，数据库向对应的目录下复制相应的数据文件，不需要复制ibdata1文件，即可备份成功。在大多数实际情况下，一个MySQL数据库中通常包含了不同存储引擎的表，对于物理文件冷备份，为了备份成功，须注意将ibdata1文件一起进行复制。文件系统冷备份策略过程简单，而且允许使用任何文件系统备份工具来进行备份，但是这种备份策略存在一些严重的缺点。在备份过程中，MySQL实例是不可用的，而且在恢复的过程中需要一个相似的配置系统，这个系统要具有与原系统相同的操作系统和目录结构。当重启MySQL时，MySQL实例的内存池要重新初始化，这样会耗费一些时间。</p>
<h3 id="5-2-3-逻辑备份"><a href="#5-2-3-逻辑备份" class="headerlink" title="5.2.3 逻辑备份"></a>5.2.3 逻辑备份</h3><p>逻辑备份并不是对MySQL文件的备份，而是对SQL语句的备份或者是以符号分割的方式将数据库表中数据存放在文件中，<strong>逻辑备份可以使用SELECT…INTO…OUTFILE语句，或者使用mysqldump工具和Workbench工具来完成</strong>。<strong>1.使用SELECT…INTO…OUTFILE备份</strong></p>
<p><strong>2.使用mysqldump备份</strong>mysqldump是MySQL数据库逻辑备份的常用工具，在日常的维护工作中经常会用到。</p>
<p><strong>3.使用MySQL Workbench备份</strong>上述的逻辑备份是通过使用mysqldump实现的，而MySQL Workbench是MySQL官方为 MySQL提供的一款可视化管理工具，可以在里面通过可视化的方式直接管理数据库中的内容，同样可以完成MySQL的逻辑备份。</p>
<h3 id="5-2-4-二进制日志"><a href="#5-2-4-二进制日志" class="headerlink" title="5.2.4 二进制日志"></a>5.2.4 二进制日志</h3><p>前面章节中不止一次地提及MySQL二进制日志的概念，二进制日志文件是备份和恢复过程中的重要组成部分。数据库备份除了需要进行某个时刻的备份之外，后续可能还需要执行一个时间点的恢复，以便将数据库恢复到最近的某个一致状态，或者是恢复到某个人为确定的时刻，这就是为人熟知的<strong>基于时间点的恢复，它是通过将MySQL二进制日志应用到某个数据库副本上来执行的</strong>。</p>
<h3 id="5-2-5-InnoDB事务日志"><a href="#5-2-5-InnoDB事务日志" class="headerlink" title="5.2.5 InnoDB事务日志"></a>5.2.5 InnoDB事务日志</h3><p>前面5.1.2节中讲过，事务日志包括重做日志Redo和回滚日志Undo。<strong>InnoDB的事务日志也包括重做日志Redo log和回滚日志Undo log，</strong>InnoDB重做日志记录的是已经全部完成的事务，就是执行了commit的事务，记录在文件ib_logfile0 ib_logfile1或者ib_logfile<em>里面；InnoDB回滚日志记录的是已部分完成并且写入硬盘的未完成的事务，默认情况下其是记录在表空间中的（共享表空间或者独享表空间对应ibdata</em>文件，存储的是Check point日志序列号）。</p>
<h2 id="5-3-MySQL数据库的恢复"><a href="#5-3-MySQL数据库的恢复" class="headerlink" title="5.3 MySQL数据库的恢复"></a>5.3 MySQL数据库的恢复</h2><h3 id="5-3-1-基于复制文件的恢复"><a href="#5-3-1-基于复制文件的恢复" class="headerlink" title="5.3.1 基于复制文件的恢复"></a>5.3.1 基于复制文件的恢复</h3><p>5.2节讲述了MySQL允许通过各种不同的方式来备份数据库中的数据，根据备份方式的不同，数据的恢复也不同，数据的恢复取决于所用的备份方法。对一个文件系统进行复制恢复就是重新安装所有的MySQL的备份数据文件和备份配置文件。首先停止MySQL服务，然后将需要恢复的库的文件夹复制出来，注意还有ibdata1，覆盖到能够启动的MySQL的data文件夹的目录下，最后重新启动MySQL服务，这个时候就会发现数据库已经可以打开。需要特别提醒的是，如果两个MySQL的版本不一样，基于复制文件的恢复就可能无法实现。</p>
<h3 id="5-3-2-逻辑备份的恢复"><a href="#5-3-2-逻辑备份的恢复" class="headerlink" title="5.3.2 逻辑备份的恢复"></a>5.3.2 逻辑备份的恢复</h3><p>与逻辑备份相同，逻辑备份的恢复也对应着多种方式，MySQL允许将数据导出到外部文件，也可以从外部文件导入数据。</p>
<p><strong>1.使用LOAD DATA INFILE导入</strong></p>
<p><strong>2.使用mysqlimport导入</strong>使用mysqlimport可以导入文本文件，并且不需要登录MySQL客户端。<strong>mysqlimport命令提供了许多与LOAD DATA INFILE语句相同的功能，大多数选项直接对应LOAD DATA INFILE子句</strong>。使用mysqlimport命令需要指定所需的选项、导入的数据库名称以及导入的数据文件的路径和名称。mysqlimport命令的基本语法格式为</p>
<p><strong>3.SQL格式的恢复</strong>5.2.3节使用的mysqldump备份的默认方式是SQL导出的方式，通过这种方式导出的数据都是由一条条SQL语句构成的，所以恢复的过程就变得非常简单，直接执行这些SQL语句即可，因为这样的SQL语句不止一条，并不适合使用MySQL的命令行模式逐条进行执行，下面有两种简单的操作方式。（1）使用mysql命令行工具。借助命令行工具和重定义输入&#x2F;输出，将SQL脚本作为条件输入mysql命令，下面例子将导入我们之前备份的employees数据库的数据表deparmtents，在导入之前先删除employees数据库中的数据表departments。mysql –uroot –p123456 employees&lt; &#x2F;users&#x2F;admins&#x2F;file.sqlfile.sql文件是之前导出的内容，接下来我们使用SHOW TABLES命令可以查看employees下的数据表，成功地恢复了删掉的数据表。（2）我们还可以使用mysql命令行模式提供的source命令。source命令并不是标准的SQL语句，而是由mysql命令行工具提供的客户端命令，该命令可执行指定的SQL脚本。在使用source命令的过程中需要首先连接到数据库，与上述的例子一样，导入employees数据库中的departments的SQL格式文件，在使用source导入的过程中要提供文件的绝对路径，具体的命令如下：mysql&gt;source &#x2F;users&#x2F;admins&#x2F;file.sql</p>
<p><strong>4.使用MySQL Workbench进行恢复</strong></p>
<h3 id="5-3-3-基于时间点的恢复"><a href="#5-3-3-基于时间点的恢复" class="headerlink" title="5.3.3 基于时间点的恢复"></a>5.3.3 基于时间点的恢复</h3><p><strong>基于时间点恢复可以使用mysqlbinlog工具。</strong></p>
<h3 id="5-3-4-InnoDB崩溃恢复"><a href="#5-3-4-InnoDB崩溃恢复" class="headerlink" title="5.3.4 InnoDB崩溃恢复"></a>5.3.4 InnoDB崩溃恢复</h3><h3 id="5-3-5-使用复制来进行恢复"><a href="#5-3-5-使用复制来进行恢复" class="headerlink" title="5.3.5 使用复制来进行恢复"></a>5.3.5 使用复制来进行恢复</h3><p>第7章我们将专门讲述MySQL复制，复制和时间点恢复使用相同的机制，都是使用二进制日志，这意味着在恢复过程中，<strong>复制也是一种非常有用的工具，</strong>复制比mysqlbinlog更可靠，因为mysqlbinlog可能会有一些导致异常行为的奇怪的Bug和不常见的情况。（1）延迟复制以实现快速恢复。发生故障后，停止从属服务器，然后使用START SLAVE UNTIL语句重放事件，接下来执行SET GLOBAL SQL_SLAVE_ SKIP_COUNTER &#x3D; 1跳过错误的语句。执行START SLAVE并让从机运行，直到完成其中继日志，这样就可以完成时间点恢复的所有烦琐工作。即使没有延迟复制从服务器来加速恢复，从从属服务器也很有用，因为它将主服务器的二进制日志读取到另一台计算机上。如果主磁盘发生故障，从属服务器的中继日志可能是唯一可以获得主服务器二进制日志的最新副本的地方。（2）使用日志服务器进行恢复。把从属服务器设置为日志服务器。使用日志服务器可以执行更复杂的过滤，例如，通过日志服务器可以很轻松地恢复单个表。</p>
<h2 id="5-4-MySQL备份恢复工具"><a href="#5-4-MySQL备份恢复工具" class="headerlink" title="5.4 MySQL备份恢复工具"></a>5.4 MySQL备份恢复工具</h2><h3 id="用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。"><a href="#用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。" class="headerlink" title="用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。"></a>用于备份恢复的工具有很多。对于大型应用，不建议使用mysqldump，因为它对服务器有影响，并且还原时间也不可预知。</h3><p><strong>1.MySQL Enterprise Backup</strong>MySQL Enterprise Backup是MySQL“官方”的备份工具，它是一个多平台、高性能的工具，提供在线备份、增量和差异备份、选择性备份和恢复等功能，支持直接云存储备份、备份加密和压缩等丰富功能。</p>
<p><strong>2.XtraBackup</strong>XtraBackup与MySQL Enterprise Backup在很多方面都非常类似，它是由知名的数据库软件服务企业Percona提供的一款热备份工具，是开源并且免费的。XtraBackup备份时具有读写无阻塞、支持增量等特点。除了核心备份工具外，还有一个用Perl写的封装脚本，可以提供更多的高级功能，它支持类似流、增量、压縮和多线程（并行）备份操作。也有许多特别的功能，用以减小在高负载的系统上备份的影响。</p>
<p><strong>3.mylvmbackup</strong>mylvmbackup是一种快速创建MySQL服务器数据文件的完整物理备份的工具，是一个Perl脚本。为了执行备份，mylvmbackup在所有表上获得读锁定并将所有服务器缓存刷新到磁盘，为包含MySQL数据目录的卷制作LVM（Logical Volume Manager，逻辑卷管理）快照，然后再次解锁表。快照过程只需要很短的时间。完成后，服务器可以继续正常操作，而实际文件备份继续进行。</p>
<p><strong>4.mydumper</strong>mydumper是一个针对MySQL数据库备份的轻量级第三方的开源工具，备份方式为逻辑备份。它支持多线程，备份速度远高于原生态的mysqldump。mysqldump工具支持单线程工作，依次导出多个表，没有一个并行的机，这就使得它无法迅速备份数据。mydumper作为一个实用工具，能够良好地支持多线程工作，可以并行多线程从表中读入数据并同时写到不同的文件里，这使得它在处理速度方面快于传统的mysqldump。其特征之一是在处理过程中需要对列表加以锁定，因此如果需要在工作时段执行备份工作，那么可能会引起DML阻塞，但一般现在的MySQL都有主从，备份也大部分在从上进行，所以锁的问题可以不用考虑，这样mydumper能更好地完成备份任务。<strong>5.mysqlhotcopy</strong>mysqlhotcopy是一个Perl脚本，最初由Tim Bunce编写并提供，它将FLUSH TABLES、LOCK TABLES以及cp&#x2F;scp等命令封装调用，能够直接对数据库或某些指定的表对象创建备份，方便用户执行。但是因为调用操作系统命令（cp或scp）实现的原因，它只能进行本地备份，除此之外也只能支持在线备份。该备份工具与备份对象所用的存储引擎强相关，并不适用于所有的场景，只用于备份MyISAM和ARCHIVE存储引擎的对象。<strong>6.Zmanda Recovery Mananger</strong>Zmanda Recovery Manager for MySQL（ZRM）为数据库管理员提供了一套方便、灵活、强大的MySQL数据库备份和复原的解决方案。</p>
<h1 id="第6章-数据库性能监视与优化"><a href="#第6章-数据库性能监视与优化" class="headerlink" title="第6章 数据库性能监视与优化"></a>第6章 数据库性能监视与优化</h1><h2 id="6-1-数据库性能检测工具"><a href="#6-1-数据库性能检测工具" class="headerlink" title="6.1 数据库性能检测工具"></a>6.1 数据库性能检测工具</h2><h3 id="6-1-1-数据库性能检测工具概述"><a href="#6-1-1-数据库性能检测工具概述" class="headerlink" title="6.1.1 数据库性能检测工具概述"></a>6.1.1 数据库性能检测工具概述</h3><p>数据库部署于服务器上面，若服务器的性能下滑，势必影响数据库的性能，所以<strong>数据库性能监视不仅要对MySQL当前的状态，如InnoDB、线程状态、锁状态、慢查询等进行检测，而且还要适当延伸到对OS进行监视，如收集OS的内存利用情况、IO情况、网络使用情况等</strong>，因此MySQL监视是一个很复杂的任务，不同的监测工具有不同的侧重。</p>
<h3 id="6-1-2-非交互性监视工具"><a href="#6-1-2-非交互性监视工具" class="headerlink" title="6.1.2 非交互性监视工具"></a>6.1.2 非交互性监视工具</h3><p><strong>1.Nagios****Nagios是一款开源的操作系统、数据库系统和网络监视工具</strong>，能有效监视Windows、Linux和Unix操作系统的主机状态，在系统或服务状态异常时发出邮件或短信报警，第一时间通知运维人员，在状态恢复后发出正常的邮件或短信通知。</p>
<p><strong>2.Monyog****Monyog是MySQL监视工具</strong>，该工具可以积极主动地监视数据库环境，并会就如何优化性能、加强安全或为MySQL系统减少停机时间提供意见。Monyog提供了一个日志分析模块，可以方便地识别在服务器上运行缓慢的语句和应用程序，同时可以监视MySQL的错误日志，可以提取错误日志的内容，Monyog还可以通过邮件或SNMP向我们发送警报，及时告知我们mysql服务器的状态。</p>
<h3 id="6-1-3-交互性监视工具"><a href="#6-1-3-交互性监视工具" class="headerlink" title="6.1.3 交互性监视工具"></a>6.1.3 交互性监视工具</h3><p><strong>1.Innotop****Innotop是一个通过文本模式显示MySQL和InnoDB的监测工具</strong>，它能详细地监视当前MySQL和InnoDB运行的状态，让数据库管理员根据结果合理地优化MySQL。事务列表可以显示InooDB当前的全部事务，查询列表可以显示当前正在运行的查询，可以显示当前锁和锁等待的列表，可以显示服务器状态和变量的汇总信息，同时有多种模式可用来显示InnoDB内部信息（缓冲区、死锁、外键错误、I&#x2F;O活动、行操作等）。<strong>2.Mytop****Mytop是一个基于命令行的工具，用于监视MySQL服务器的线程和整体性能</strong>。如图6-1所示，第一行显示了主机名称、MySQL的运行时间(以days hour:minutes: seconds为格式)；第二行、第三行的Queries显示了执行的SQL查询语句总数，另外还有目前每秒处理的查询数和速度；第四行的Key Efficiency显示了缓存命中率；最下方的区域就是目前链接到数据库的各个线程。</p>
<h2 id="6-2-数据库性能监视剖析"><a href="#6-2-数据库性能监视剖析" class="headerlink" title="6.2 数据库性能监视剖析"></a>6.2 数据库性能监视剖析</h2><h3 id="6-2-1-数据库性能监视剖析"><a href="#6-2-1-数据库性能监视剖析" class="headerlink" title="6.2.1 数据库性能监视剖析"></a>6.2.1 数据库性能监视剖析</h3><p><strong>数据库性能监视的出发点就是在整个数据库应用系统实际运行在生产环境或者测试环境时，对数据库服务器的各项指标进行定量的检测和收集</strong>。这些数据将成为以后优化分析的基础，比如磁盘I&#x2F;O、网络延时或者是语句等，详尽的数据收集是数据库优化的第一步。数据库性能监视首先要明确监视指标，下面介绍一些常用的指标，在不同的具体应用中则需要从更多方面去衡量。<strong>1.吞吐量****吞吐量指的是单位时间内的事务处理数</strong>，这个指标一直是最经典的数据库应用测试指标，在一些标准的测试之中广泛地使用。吞吐量代表了数据库处理请求的能力，一个数据库应用系统的吞吐量与请求对CPU的消耗、外部接口、I&#x2F;O等紧密关联。单个请求对CPU的消耗越高，外部接口、I&#x2F;O反应速度越慢，数据库吞吐量越低，反之则越高。在一些测试中（如TPC-C），主要针对在线事务处理的吞吐量非常适用于多用户的交互式应用，常用的测试单位有每秒事务数量（TPS，Transaction Per Second）或者每分钟事务数量（TPM，Transaction Per Minute），以及每秒查询数量（QPS, Query Per Second）。<strong>2.并发性****并发性经常表示有多少用户在同一时间内同时操纵数据库应用系统</strong>，数据库的并发性和创建数据库的连接不完全是一回事。一个良好设计的应用同时可以打开成百上千的MySQL数据库服务器的连接，但是可能只有很少数的连接同时在执行真正的查询任务，所以同时有上万个用户在访问，并不代表有上万个并发请求发送到了MySQL数据库。我们应该关注的问题是同时工作的并发操作，当并发请求增多的时候，吞吐量是否下降，响应时间是否变长。每当应用处于访问峰值的时候，整体应用的效率就会降低，影响用户体验。<strong>3.响应时间和延迟时间****响应时间和延迟时间指的是一种度量方式，其是指一条查询或者更新语句从发出请求到接收完数据的时间</strong>，通常测试的单位为微秒、毫秒、秒或者分钟。根据不同的单位计算平均响应时间和最大响应时间，因为最大响应时间的不确定性和不可重复性，所以一般使用X%的查询响应时间作为指标。如果值为95%为10 ms，意味着95%的查询会在10 ms内返回。对于联机事务处理过程查询来说，在50 ms内返回是比较理想的结果，超过200 ms的查询则被视为慢查询。我们可以将一段时间内的检测数据使用统计图表的方式来呈现，通常为饼状图或者柱状图，可以看到时间的具体分布，再根据MySQL提供的慢日志查询来收集运行时间超过一定阈值的语句，当90%的语句都能够在50 ms以内完成，那么阈值就可以设为50 ms，当发现一条SQL语句执行超过了5 s，就可以根据这条记录复现查询，分析耗时原因，做出相应优化。</p>
<h3 id="6-2-2-MySQL主要指标监视方法"><a href="#6-2-2-MySQL主要指标监视方法" class="headerlink" title="6.2.2 MySQL主要指标监视方法"></a>6.2.2 MySQL主要指标监视方法</h3><p>前面3.1节中讨论过数据字典的概念，MySQL中有一个自带的数据库performance_schema，记录了数据库服务器的运行状态信息，该数据库可用于数据库性能的监视和优化。同时我们知道，可以通过访问服务器状态变量获得MySQL运行中的一些信息。以下从MySQL吞吐量、查询性能、连接检查、InnoDB缓冲区、查询缓存、临时表、访问表的数量等几个方面来讲述MySQL的主要指标监视方法，主要指标类型分为吞吐量、响应时间、并发性、利用率、错误率等。<strong>1.吞吐量****MySQL中关于吞吐量可以从Questions、Com_select、Com_insert、Com_update、Com_delete几个指标值获取</strong>。Questions是内部计数器（这是一个服务器状态变量），客户端每发送一个查询语句，其值就会加一。也可以监视读指令、写指令分别的执行情况，从而监视数据库的工作负载，从中寻找可能出现的问题。读指令由Com_select的值表示，而写指令（Writes）由插入、更新、删除这三种语句综合表示，这三种语句分别是Com_insert、Com_update、Com_delete，可以通过查询这三个值的和来反映当前的读写压力。若总的查询量突然增大或者突然减少，同时变化幅度非常大，超过正常预期，这就预示着某些严重的问题已经发生。同时随着磁盘IO的增大，读写命令数没有相应变化，可能和当前设备的读写速度或缓冲区设置不当有着密切的联系。表6-1介绍了吞吐量指标采集方法。</p>
<p><strong>2.查询性能</strong></p>
<p><strong>3.连接检查</strong>在MySQL中每个连接（Connection）对应一个线程，<strong>MySQL关于连接检查的相关指标有Threads_connected、Threads_running、Connection_errors_internal、Aborted_connects和Connection_errors_max_connections</strong>，见表6-3。通过监视当前连接的线程数Threads_connected，就可以知道当前连接数，通过其余剩余资源来确定还可容纳新的连接数。通过监视Threads_running变量可以知道当前任意时间正在活跃的线程数，而剩余线程就是处于连接闲置状态。当连接数达到max_connections限制，新的连接将被拒绝，Connection_errors_max_connection会随着被拒绝连接的数量递增，每拒绝一个将会增加一个，与此同时指示所有失败连接的指标Aborted_connects也会增加。Connection_errors_internal指标反映的是由于内部错误而失败的连接数量，该指标会在错误来自于服务器本身时而增加，内部错误反映了内存不足或者是服务器无法开启新的线程而导致。</p>
<p><strong>4.InnoDB缓冲区</strong>通常MySQL的默认存储引擎为InnoDB，InnoDB为了减少实际的I&#x2F;O次数并提高效率而使用了缓冲区的技术，缓冲区用于缓存数据和索引。若缓冲区设置不当，往往会导致数据库的效率降低，对缓冲区监视有助于对问题进行排查。例如，当I&#x2F;O一直处于高位，而数据库的性能却降低了，这代表缓冲区页面命中的概率减少，可以适当扩大缓冲区，以缓存更多数据来减少实际的I&#x2F;O次数。缓冲区大小默认为128 MiB，也可以根据服务器的内存大小来手动设置。缓冲区并不是越大越好，内存本身是有限制的，通常成本较高。InnoDB的内存开销可能提高超过缓冲池大小10%的内存占用，并且如果物理内存耗尽了，系统会求助于分页，这样会导致数据库性能严重受损。<strong>InnoDB缓冲区的指标有Innodb_buffer_pool_pages_total、Innodb_buffer_pool_read_requests、Innodb_buffer_pool_reads及缓冲池使用率</strong></p>
<p><strong>5.查询缓存****缓存命中率指的是当一模一样的查询语句重复执行时，能够直接从查询缓存中取得结果集的次数除以查询语句的数量</strong>。缓存命中率也是MySQL重要的指标之一，MySQL会自动将之前查询的语句以及查询返回的结果都缓存下来，并且在它们之间建立映射关系。当MySQL收到一条如SELECT类型的语句时，MySQL会对这条查询语句进行hash计算而得到一个hash值，然后通过该hash值到查询缓存中去匹配，如果没有得到匹配结果，则会将这个hash值存放在一个hash链表中，同时将此次查询的结果存放至缓存中。存放hash值的链表的每个节点都会存放相应查询返回结果在缓存中的地址，以及该次查询所涉及的一些表的相关信息。如果通过hash值匹配到相同的查询，则会直接将缓存中相应的查询结果返回给客户端；如果MySQL的任何一张表中的任何一条数据发生了变化，便会通知查询缓存，将和这张表相关的查询缓存全部变为失效，并释放占用的内存空间。查询缓存的工作原则是执行查询最快的方式就是不去执行，当客户端执行一条查询语句的时候，首先会去查询缓存中查找，并且同时交给解析器进行解析，如果在查询缓存中命中，则终止解析器的SQL语句解析工作，直接返回缓存的数据。</p>
<p><strong>6.临时表</strong>在MySQL中，临时表分为外部临时表和内部临时表。通过CREATE TEMPORARY TABLE创建的临时表被称为外部临时表，这种临时表只对当前用户可见，当前会话结束的时候，该临时表会自动关闭。这种临时表的命名与非临时表可以同名（同名后非临时表将对当前会话不可见，直到临时表被删除）。内部临时表是一种特殊轻量级的临时表，用来进行性能优化，这种临时表会被MySQL自动创建并用来存储某些操作的中间结果，这些操作可能包括在优化阶段或者执行阶段，这种内部表对用户来说是不可见的，但是通过EXPLAIN或者SHOW STATUS可以查看MYSQL是否使用了内部临时表用来帮助完成某个操作。内部临时表在SQL语句的优化过程中扮演着非常重要的角色，MySQL中的很多操作都要依赖内部临时表进行优化。</p>
<p><strong>7.访问表的数量</strong>MySQL在访问一张表的时候，将其放入缓存中，如果数据库中有许多的表，通常将其放入缓存中，可对性能的提升带来帮助。当打开的表的数量不断增多的时候，缓存会被逐渐填满，如果新打开的表不在缓存中，MySQL会将一些旧的表移出缓存。</p>
<h3 id="6-2-3-MySQL-PROCESSLIST"><a href="#6-2-3-MySQL-PROCESSLIST" class="headerlink" title="6.2.3 MySQL PROCESSLIST"></a>6.2.3 MySQL PROCESSLIST</h3><p>仅仅通过6.2.1节中介绍的指标进行判断，能够发现出现了何种问题，给出一个大概的参考，如果需要进一步地定位问题并快速处理，那就需要SHOW PROCESSLIST命令协助进行故障诊断。SHOW PROCESSLIST命令可以显示用户正在运行的线程，需要注意的是，除了root用户能看到所有正在运行的线程外，其他用户只能看到自己正在运行的线程，而看不到其他用户正在运行的线程，除非单独将这个用户赋予了PROCESS权限。PROCESSLIST命令运行结果如图6-14所示。</p>
<h3 id="6-2-4-慢查询日志解析"><a href="#6-2-4-慢查询日志解析" class="headerlink" title="6.2.4 慢查询日志解析"></a>6.2.4 慢查询日志解析</h3><p>正如3.2.2节中所说，<strong>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句</strong>，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10 s以上的语句。在默认情况下，MySQL数据库并不启动慢查询日志，需要手动设置该参数，当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少对性能带来一定的影响。慢查询日志支持将日志记录写入文件，也支持将日志记录写入数据库表。慢查询主要体现在慢上，通常意义上来讲，只要返回时间大于1 s的查询都可以称为慢查询。慢查询会导致CPU、内存消耗过高，数据库服务器压力陡然增大，对于大部分情况来讲，基本都是由某些慢查询导致的。<strong>慢查询日志中不止包含了执行时间过长的语句（大于设置的long_query_time阈值），还包含了未使用索引或者未使用最优的索引</strong>，这两种日志默认都是没有打开的。未使用索引的日志内容一般来讲会有很多，导致日志文件非常大，通常不记录这种日志或者限制其每分钟输出的日志数量（设置遍历</p>
<h2 id="6-3-查询性能优化"><a href="#6-3-查询性能优化" class="headerlink" title="6.3 查询性能优化"></a>6.3 查询性能优化</h2><h3 id="6-3-1-查询执行过程与优化技术"><a href="#6-3-1-查询执行过程与优化技术" class="headerlink" title="6.3.1 查询执行过程与优化技术"></a>6.3.1 查询执行过程与优化技术</h3><p><strong>1.查询执行过程****服务器端的SQL处理过程大体包括：查询缓冲、语句解析、查询优化、语句执行、提取数据，</strong>如图6-15所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573112631-f9567555-8a7b-49fa-9691-82be0708e6a5.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8c6ecec0&originHeight=122&originWidth=546&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u883a92f2-559a-4dbd-ab72-a0386141271&title=">图6-15 SQL语句处理过程（1）查询缓冲。数据库服务器在接到客户端传送过来的SQL语句时，不会直接去数据库查询，而是会先在数据库的高速缓存中去查找，是否存在相同语句的执行计划，如果找到，则服务器进程就会直接执行这个SQL语句，省去后续的工作，这样可以提高SQL语句的查询效率。（2）语句解析。当在高速缓存中找不到对应的SQL语句时，则服务器会开始对这条语句进行解析，语句解析通过解析器完成，主要包括语法和语义检查、获得对象锁、访问权限核对等过程。（3）查询优化。如果语法与语义都没有问题，权限也匹配的话，服务器还是不会直接对数据库文件进行查询。服务器会根据一定的规则，对这条语句进行优化，这个工作主要由优化器完成。<strong>关于查询优化器</strong>（4）语句执行。SQL语句执行也分两种情况，一种情况是若被查询的数据块已经读取到数据缓冲区的话，则服务器会直接把这个数据传递给客户端，而不是从数据库文件中去查询数据；另一种情况是若数据不在缓冲区中，则服务器将从数据库文件中查询相关数据，并把这些数据放入数据缓冲区中。（5）提取数据。当语句执行完成之后，查询到的数据还是在服务器中，还没有被传送到客户端，所以在服务器端有一个专门负责数据提取的一段代码，其作用就是把查询到的数据结果返回给用户端进程，从而完成整个查询动作。我们从整个查询处理过程中了解到，绝大部分SQL语句都是按照这个过程处理的，数据库管理员或者数据库运维人员了解这些语句的处理过程，对于我们进行查询优化是非常有帮助的。有时候掌握这些处理原则可以减少排错和优化的时间。<strong>2.查询优化技术</strong>前面我们大概理解了一条查询语句执行的过程之后会发现，主要的查询优化的工作都是对SQL语句进行的，也就是进行SQL层面的优化。<strong>查询语句优化主要有以下几种方法：查询重用、查询重写、并行查询</strong>，等等。（1）查询重用。对于服务器来说，所有的查询处理、语句分析、查询优化、生成查询计划都是一个非常昂贵的开销。</p>
<p>（2）查询重写。我们知道对于同一个查询任务，存在多种查询语句的写法，不同的语句其查询效率不一样。在针对同一个任务时，重写原有的SQL语句，从而使其提高执行效率，这就是查询重写的思想。</p>
<h3 id="6-3-2-逻辑查询优化"><a href="#6-3-2-逻辑查询优化" class="headerlink" title="6.3.2 逻辑查询优化"></a>6.3.2 逻辑查询优化</h3><p><strong>1.子查询优化</strong>当一个查询是另一个查询的子部分时，称之为子查询，子查询是查询语句中相对耗时的操作。从子查询出现的位置来看，可以出现在WHERE子句、JOIN&#x2F;ON子句、FROM子句、GROUPBY子句、HAVING子句和ORDERBY子句中，子句出现的位置的不同，对优化的影响程度不同。（1）MySQL支持的优化。<strong>MySQL子查询优化（MySQL优化器优化）只局限于对简单SELECT查询中的子查询进行优化，</strong>简单SELECT语句中的子查询会被MySQL优化器自动上拉到父层，这样可以提高效率。<strong>2.视图重写</strong>视图是指计算机数据库中的视图，是一个虚拟表，其内容由查询定义。视图并不在数据库中以存储的数据值集形式存在，行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。<strong>视图重写也就是在查询语句中出现视图对象(先将视图转化为子查询，再进行优化)，查询优化后，视图对象消失，消失的视图对象的查询语句融合到初始查询中。</strong></p>
<p><strong>3.等价谓词重写****等价谓词重写，主要就是使其能更好地利用索引，有些谓词是可以利用索引的，所以将表达式写成更高效的形式能够有效提高查询的执行效率，这就是等价谓词重写。</strong></p>
<p><strong>4.条件化简</strong>在SQL语句中，WHERE、HAVING、ON的条件由许多表达式组成，而这些表达式在特定时候存在关系。利用等式和不等式的性质可以将其化简。具体条件化简的方式包括以下几种常见的形式。</p>
<h3 id="6-3-3-物理查询优化"><a href="#6-3-3-物理查询优化" class="headerlink" title="6.3.3 物理查询优化"></a>6.3.3 物理查询优化</h3><p>6.3.2节讲述的逻辑查询优化解决的是如何找出SQL语句等价的变换形式，使得SQL执行更为高效，而物理查询优化解决的问题是从可选的单表扫描方式中挑选什么样的单表扫描方式是最优的；在两个表做连接时，如何连接最优；多表连接时，连接顺序有多种组合，哪种连接顺序是最优的。多表连接，连接顺序有多种组合，是否要对每种组合都探索？如果不全部探索，怎么找到最优的一种组合？这当中就需要对查询的代价进行估算，根据估算值进行比较选择，此外，能在索引上完成的查询，尽量避免扫描表。<strong>1.查询代价估算</strong>查询代价估算的重点，也就是物理查询优化的核心是代价估算模型。查询代价估算是基于CPU代价和IO代价进行的，<strong>代价模型的公式如下所示</strong>：总代价&#x3D; I&#x2F;O代价(数据读取) +CPU代价(数据计算处理)COST &#x3D; pages×a_page_cpu_time+W×T式中，pages：计划运行时访问的页面数；a_page_cpu_time：每个页面读取的时间花费。pages×a_page_cpu_time反映了I&#x2F;O花费。T：访问的元组数，反映了CPU花费（存储层是以页面为单位，数据以页面的形式被读入内存，每个页面上可能有多条元组，访问元组需要解析元组结构，才能把元组上的字段读出，这消耗的是CPU）。如果是索引扫描，则还会包括索引读取的花费。W：权重因子，表明I&#x2F;O到CPU的相关性，又称选择率。选择率用于表示在关系R中，满足条件“A  col”的元组数与R的所有元组数N的比值。选择率W在代价估算模型中占有重要地位，其精准程度直接影响最优化的计划的选取。选择率计算可以采用抽样方法，从数据库中抽取部分样本元组，针对这些样本进行查询，然后收集统计数据，只有足够的样本被测试之后才能达到预期的精度。</p>
<p><strong>2.索引</strong>3.4节比较详细地讲述了索引的概念、索引的类型和创建原则，过多地使用索引将会造成滥用，因此索引也会有它的缺点：虽然索引大大提高了查询速度，但会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE操作。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件，而建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果在一个大表上创建了多种组合索引，索引文件会膨胀得很快。索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。</p>
<h2 id="6-4-优化数据库对象"><a href="#6-4-优化数据库对象" class="headerlink" title="6.4 优化数据库对象"></a>6.4 优化数据库对象</h2><h3 id="6-4-1-优化表的数据类型"><a href="#6-4-1-优化表的数据类型" class="headerlink" title="6.4.1 优化表的数据类型"></a>6.4.1 优化表的数据类型</h3><p>表需要根据应用来判断使用何种数据类型。虽然应用设计的时候需要考虑字段的长度留有一定的冗余，但是不推荐让很多字段都留有大量的冗余，这样既浪费存储也浪费内存。<strong>我们可以使用PROCEDURE ANALYSE()对当前已有应用的表类型进行判断，该函数可以对数据表中的列的数据类型提出优化建议，可以根据应用的实际情况酌情考虑是否实施优化</strong>。PROCEDURE ANALYSE()的语法如下：</p>
<p><strong>1.数据类型选择的总体原则</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573186402-3967a422-db29-42a5-a4c5-1207a0dbd7c6.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9e4cb0db&originHeight=598&originWidth=699&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u78b79890-8778-4fd1-848a-8c376b503f6&title="><strong>2.数据类型的使用建议</strong>3.4.1节中讲述了数据库表支持的数据类型，我们在为列选择数据类型的时候，不仅要考虑存储类型大小，还要考虑MySQL如何对它们进行计算和比较。例如，MySQL在内部把ENUM和SET类型保存为整数，但是在比较的时候把它们转换为字符串。我们要在相关表中使用同样的类型，类型之间要精确匹配，包括诸如UNSIGNED这样的属性。混合不同的数据类型会导致性能问题，即使没有性能问题，隐式的类型转换也能导致难以察觉的错误。选择最小的数据类型要考虑将来留出的增长空间。例如，中国的省份，我们知道不会有成千上万个，因此不必用INT，用TINYINT就足够了，它比INT小3个字节。整数通常是最佳的数据类型，因为它速度快，并且能使用AUTO_INCREMENT。要尽可能避免将字符串作为列的数据类型，因为它们占用了很多空间，并且通常比整数类型要慢。MyISAM默认情况下为字符串使用了压缩索引，这使得查找更为缓慢。</p>
<h3 id="6-4-2-拆分表"><a href="#6-4-2-拆分表" class="headerlink" title="6.4.2 拆分表"></a>6.4.2 拆分表</h3><p><strong>拆分表是按照一定的方式将一张表拆分成多张表或者使用MySQL分区，</strong>这样做可以有效提高表的查询和更新效率，也有助于将耦合的数据解耦合。拆分的方法可以分成两种情况：水平拆分或者垂直拆分。</p>
<h3 id="6-4-3-逆规范化"><a href="#6-4-3-逆规范化" class="headerlink" title="6.4.3 逆规范化"></a>6.4.3 逆规范化</h3><p>数据库设计时要满足何种规范化的要求，同时需要遵守数据库三范式，但是并不是任何时候我们都需要遵守规范和范式，因为规范化越高，产生的关系就越多，关系过多的直接结果就是导致表之间的连接操作越频繁，而表之间的连接操作是性能较低的操作，直接影响査询的速度，所以对于査询较多的应用，就需要根据实际情况运用逆规范化对数据进行设计，通过逆规范化来提高査询的性能。<strong>逆规范化（Denormalization）是一种通过添加冗余数据的数据库优化技术，</strong>可以帮助我们减少关系数据库中耗时的JOIN运算。在一般的规范化的数据库中，我们将数据存在不同的表中是为了减少冗余数据，所以我们会尝试使每条数据在数据库中只有一份。比如说，在一个规范化的数据库中，我们有Courses表和Teachers表，每个Courses表的一项都会保存teacherID，但是没有teacherName，当我们想要返回Course和teacherName时，我们需要联合两个表。当老师需要改名时，我们只需要修改Teachers表，这是这样做的好处，但是当表很大的时候，联合两表就会很耗时。逆规范化使我们容忍部分冗余数据和更新表所需多余的一些工作，以此换来快速高效的检索和较少的JOIN操作。很多公司都会同时使用规范化和逆规范化数据库。</p>
<h3 id="6-4-4-缓存表和汇总表"><a href="#6-4-4-缓存表和汇总表" class="headerlink" title="6.4.4 缓存表和汇总表"></a>6.4.4 缓存表和汇总表</h3><p>在数据库设计的时候我们需要在统计效率和数据冗余之间作出取舍，在同一张表中保存衍生的冗余数据可以极大地提升性能，有时候也需要创建一张完全独立的汇总表或缓存表。建立汇总表的原因就在于：无论通过粗略的统计计算还是严格的计数，都比计算原始表的所有行有效的多。建立缓存表的原因则是优化检索和查询语句，这些查询语句经常需要特殊的表和索引，跟普通的OLTP操作表有一些区别。</p>
<h3 id="6-4-5-ALTER-TABLE加速"><a href="#6-4-5-ALTER-TABLE加速" class="headerlink" title="6.4.5 ALTER TABLE加速"></a>6.4.5 ALTER TABLE加速</h3><p>ALTER TABLE操作的性能对MYSQL来说是个大问题。MySQL执行大部分修改表结构操作的方法是用新的结构创建一个空表，从旧表中查出所有数据插入新表，然后删除旧表。这样的操作非常耗费时间，尤其是在数据量非常大且内存不足的情况下，如果还有很多索引那么时间将会更长，一个ALTER TABLE将会耗费数小时甚至数天才可以完成。一般而言，大部分ALTER TABLE操作将导致MySQL服务中断。对常见的场景，能使用的技巧只有以下两种。（1）先在一台不提供服务的机器上执行ALTER TABLE操作，然后和提供服务的主库进行切换。（2）影子复制。影子复制的技术是用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。<strong>1.修改.frm文件</strong>MySQL中列的相关信息被存放在.frm文件中，当使用ALTER TABLE语句修改列的默认值时，MySQL将新建一张相同结构的空表，然后执行插入操作。其实我们可以跳过创建新表的步骤，直接修改这个文件，但是MySQL没有采用这个方式。下面这些操作是有可能不需要重建表的。（1）移除(不是增加)一列的AUTO_INCREMENT属性。（2）增加、移除或更改ENUM和SET常量。如果移除的是已经有行数据用到其值的常量，查询将会返回一个空字串值。<strong>2.InnoDB快速载入数据</strong>在MyISAM中有一个常用的技巧是禁用索引（只能禁用非唯一索引）、载入数据，然后重新启用索引。在现代版本的InnoDB版本中，有一个类似的技巧，这依赖于InnoDB的快速在线索引创建功能。这个技巧是先删除所有的非唯一索引，然后增加新的列，最后重新创建删除掉的索引。此外，也可以使用ALTER TABLE的骇客访求加速这个操作，但需要多做一些工作并承担一定的风险，这对从备份中载入数据是很有用的。例如，当已经知道所有数据都是有效的且没有必要做唯一性检查时就可以操作。下面是操作步骤。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573220679-45a1e8b6-22c2-4c35-b1aa-a1529a49013b.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1bcdaa68&originHeight=546&originWidth=575&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ud6ca0625-4743-4d35-beff-c8071975156&title="></p>
<h2 id="6-5-应用优化"><a href="#6-5-应用优化" class="headerlink" title="6.5 应用优化"></a>6.5 应用优化</h2><h3 id="6-5-1-使用连接池"><a href="#6-5-1-使用连接池" class="headerlink" title="6.5.1 使用连接池"></a>6.5.1 使用连接池</h3><p>当App或者Web应用投入实际的生产中后，这个应用的整体性能受其各个组件的制约，比如网络、硬件、操作系统和应用程序，当然数据库性能也是其中的一部分。根据木桶效应的原理，当数据库性能降低，直至成为整个应用的短板时，应用整体的性能就会随之降低。如果用户在每一次的单击背后都在等待着数据库返回结果，而数据库却迟迟不能完成这个简单的查询，这时就需要对整个数据库进行优化了。<strong>1.连接池的概念和优点</strong>对于访问数据库来说，数据库连接是一种关键的、有限的、昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。对数据库连接的管理能显著影响整个应用程序的伸缩性和健壮性，影响应用程序的性能指标，因此，有必要建立连接池以提高访问的性能，数据库连接池正是针对这个问题提出来的。<strong>连接池是一个存放连接的池子，需要直接访问数据库的请求，从这个池子里面获取连接来使用，数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个，</strong>因为池子中的连接都已经预先创建好，可以直接分配给应用使用，所以大大减少了创建连接所耗费的资源。连接返回后，本次访问将连接交还给连接池，以供新的访问使用。数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有一定的连接数。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入等待队列。使用<strong>连接池的优势</strong>有以下几点。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236147-74e62cef-be60-488d-bab8-f6f31c3b9e73.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u19ae6dc1&originHeight=331&originWidth=700&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua8ca6364-46de-4580-82fd-f9d80632b13&title="><strong>2.连接池的设置</strong>数据库连接池的最小连接数和最大连接数的设置要考虑以下几个因素。（1）最小连接数是连接池一直保持的数据库连接，如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费。（2）最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过次数，后面的数据库连接请求将被加入到等待队列中，这会影响以后的数据库操作。（3）如果最小连接数与最大连接数相差很大，那么最先连接请求将会获利，之后超过最小连接数量的连接请求等价于建立一个新的数据库连接。不过，这些大于最小连接数的数据库连接在使用后不会马上被释放，其将被放入连接池中等待重复使用或是在空间超时后被释放。MySQL默认的最大连接数为151，MySQL服务器允许的最大连接数为16 384。可以使用SHOW VARIABLES命令查看最大连接数，如图6-16所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236100-d6f2b118-75cd-483a-8dd4-e12d6d8a2426.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u5fa71f6e&originHeight=119&originWidth=353&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47ed1e63-2755-4ae5-be8f-3b6fec7e2b6&title=">图6-16 查看最大连接数可以使用两种方法修改最大连接数，第一种方法是直接修改MySQL的配置文件my.ini或者my.cnf，将其中的max_connections修改为合适的值，重启MySQL生效；第二种方法是通过SET命令修改，如图6-17所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573236195-d0961f06-730c-45d5-a4ac-905ceb03c10f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u34058ee3&originHeight=39&originWidth=313&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u8e380e7d-03f9-4a9b-abc0-d70d8d33d6f&title=">图6-17 修改连接数最大连接数的修改可以根据实际情况动态决定，一般可以使用SHOW GLOBAL STATUS命令查询使用的连接数：mysql&gt; show global status like ‘Max_used_connections’;如果使用的连接数占上限的85%左右是相对理想的情况，如果比例在10%以下那就是设置过高，需要动态调整。</p>
<h3 id="6-5-2-减少对MySQL的访问"><a href="#6-5-2-减少对MySQL的访问" class="headerlink" title="6.5.2 减少对MySQL的访问"></a>6.5.2 减少对MySQL的访问</h3><p><strong>1.避免重复检索</strong>应用中需要厘清对数据库的访问逻辑，需要对相同表的访问，尽量集中SQL语句访问，一次SQL一次提取结果，减少对数据库的重复访问。虽然MySQL会对重复的查询有缓存的机制，但是对于频繁修改的表，缓存也会失效。重复查询会降低数据获取效率，同时增加MySQL的压力，减少对MySQL访问的次数可以节省宝贵的资源。编写SQL语句的时候就要通过一个SQL语句中查询出需要的数据，需要对整个数据库模式有着非常清楚的认知和良好的设计，这是对使用者而言的基本要求。<strong>2.使用查询缓存</strong>查询缓存存储SELECT查询的文本，以及发送给客户端的相应结果。如果随后收到一个相同的查询，服务器从查询缓存中重新得到查询结果，而不再需要解析和执行查询，其适用范围为不发生数据更新的表。当表更改（包括表结构和表数据）后，查询缓存值的相关条目被清空。在大部分的MySQL版本中，Query Cache功能默认都是打开的，我们可以通过调整 MySQL Server的参数选项打开该功能。Query Cache的主要参数query_cache_limit、query_cache_min_res_unit、query_cache_size、query_cache_type在6.2.1节中已经做了详细讲述。除了以上4个参数还有query_cache_wlock_invalidate，该参数控制当有写锁定发生在表上的时刻是否先失效该表相关的Query Cache，如果设置为1(TRUE)，则在写锁定的同时将失效该表相关的所有Query Cache，如果设置为0(FALSE)，则在锁定时刻仍然允许读取该表相关的 Query Cache。Query Cache是以客户端请求提交的查询为对象来处理的，只要客户端请求的是一个查询，无论这个查询是一个简单的单表查询还是多表Join，或者是带有子查询的复杂SQL，都被当作成一个查询，不会被分拆成多个查询来进行Cache，所以存在子查询的复杂查询也只会产生一个Cache对象，子查询不会产生单独的Cache内容。UNION[ALL]类型的语句也同样如此，Query Cache中缓存的内容仅仅只包含该查询所需要的结果数据，其是结果集。当然，并不仅仅只是结果数据，还包含与该结果相关的其他信息，比如产生该Cache的客户端连接的字符集、数据的字符集，以及客户端连接的Default Database等。Query Cache的查找是在MySQL接收到客户端请求后在对查询进行权限验证之后，SQL解析之前。也就是说，当MySQL接收到客户端的SQL后，仅仅只需要对其进行相应的权限验证后就会通过Query Cache来查找结果，甚至都不需要经过优化器进行执行计划的分析优化，更不需要发生任何存储引擎的交互，减少了大量的磁盘IO和CPU 运算，所以效率非常高。由于Query Cache在内存中是以HASH 结构来进行映射，HASH算法的基础就是组成SQL语句的字符，所以必须要整个SQL语句在字符级别完全一致，才能在Query Cache 中命中，即使多一个空格也不行。为了保证Query Cache中的内容与实际数据绝对一致，当表中的数据有任何变化，包括新增、修改、删除等，都会使所有引用该表的SQL的Query Cache失效。当开启了Query Cache之后，尤其是当我们的query_cache_type参数设置为1以后，MySQL会对每个SELECT语句都进行Query Cache查找，查找操作虽然比较简单，但仍然要消耗一些CPU运算资源，而由于Query Cache的失效机制的特性，可能由于表上的数据变化比较频繁，大量的Query Cache频繁地被失效，所以Query Cache的命中率就可能比较低下，所以在有些场景下，Query Cache不仅不能提高效率，反而可能造成负面影响。<strong>3.使用cache层</strong>在应用中，可以在应用端增加cache层来达到减轻数据库负担的目的。cache层有很多种，也有很多种实现的方式，只要能达到降低数据库的负担又能满足应用就可以，这就需要根据应用的实际情况进行特殊处理。</p>
<h3 id="6-5-3-负载均衡"><a href="#6-5-3-负载均衡" class="headerlink" title="6.5.3 负载均衡"></a>6.5.3 负载均衡</h3><p>负载均衡是在一个服务器集群中尽可能地平均负载量，通常的做法是在服务器前端设置一个负载均衡器（专门的硬件设备），MySQL的负载均衡通常都离不开数据分片（把数据分割成小块，存储到不同的DB节点中）、复制等操作。负载均衡的主要贡献除了均发数据库请求之外，还可提供管理读&#x2F;写策略。其在分发请求时会确定哪些节点可写、可读，随即将请求发送到指定节点上执行操作。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573250887-c05e193b-0105-4b1c-92c4-f24cc82ef23e.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=uc517ff05&originHeight=354&originWidth=552&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u721aecdf-9b53-4756-b0ca-00d9f15d56e&title="><strong>（1）MySQL读写分离</strong>。MySQL复制（第7章专门讲述数据库复制）时，产生了多个数据副本（从库），为减少服务器压力，从库用于处理读操作，主库可同时处理读写是MySQL集群实现读写分离的常用策略。由于从库的复制是异步的，无法实时同步，读写分离的主要难点也在于从库上的脏数据。通常如果使用从库进行读取，一般对数据的实时性要求不能太高。对此，MySQL提供了几种常见的读写分离方式，如基于查询、基于脏数据、基于会话的读写分离等。MySQL设置的读写分离减少了主库的请求量，将大量读的操作发送给从数据库，实现负载均衡。利用MySQL的主从复制可以有效地分流更新操作和查询操作，多台从服务器一方面用来确保可用性，另一方面可以创建不同的索引，满足不同查询的需要。对于主从之间不需要复制全部表的情况，可以通过在主服务器上搭建一个虚拟的从服务器，将需要复制到从服务器的表设置成blackhole引擎，然后定义replicate-do-table参数只复制这些表，这样就过滤出需要复制的binlog，减少了传输binlog的带宽。因为搭建的虚拟从服务器只起到过滤binlog的作用，并没有实际纪录任何数据，所以对主数据库服务器的性能影响也非常有限。通过复制分流查询存在的问题是主数据库上更新频繁或者网络出现问题的时候，主从之间的数据可能存在差异，造成查询结果的异议，应用在设计的时候需要有所考虑。<strong>（2）修改DNS</strong>。通过n个服务器IP指定到一个域名，根据请求的不同标识特征，将请求发送给不同的IP服务器进行处理，但是修改DNS存在许多问题，首先DNS一般都有缓存，通常在失效之前如果某台服务器无法提供服务，如MySQL的某个数据库宕机或者通信链路存在问题，服务请求方是无法探测到这些问题的，还依旧按照缓存的DNS中的IP来访问，这样就会出现问题。<strong>（3）使用中间件</strong>。例如，引入MySQL官方提供的MySQL负载中间件，MySQL_proxy也需要在服务器安装，修改配置文件（MySQL服务器的IP），其实质与NGINX是类似的，其也是一个负载均衡代理服务器。此外，还可以使用<strong>分布式数据库架构</strong>来实现负载均衡。分布式数据库架构适合大数据量、负载高的情况，它具有良好的扩展性和高可用性。通过在多台服务器之间分布数据，可以实现在多台服务器之间的负载平均，提高访问的执行效率。具体实现的时候，可以使用MySQL的CLUSTER功能或者通过用户自己编写的程序来实现全局事务。需要注意的是，当前分布式事务只支持InnoDB存储引擎，因此如果通过自己编写程序来实现分布式架构数据库，那么就必须采用InnoDB存储引擎。</p>
<h1 id="第7章-数据库复制"><a href="#第7章-数据库复制" class="headerlink" title="第7章 数据库复制"></a>第7章 数据库复制</h1><h2 id="7-1-数据库复制原理"><a href="#7-1-数据库复制原理" class="headerlink" title="7.1 数据库复制原理"></a>7.1 数据库复制原理</h2><h3 id="7-1-1-数据库复制原理概述"><a href="#7-1-1-数据库复制原理概述" class="headerlink" title="7.1.1 数据库复制原理概述"></a>7.1.1 数据库复制原理概述</h3><p>前面我们介绍的都是基于单台MySQL数据库的情形，但在实际的生产环境中，无论是在安全性、高可用性及高并发等各个方面，由单台MySQL作为独立的数据库服务器可能不能完全满足实际需求，因此，可以考虑通过主从复制（Master-Slave）的方式同步数据，再通过读写分离（MySQL-Proxy）提升数据库的并发负载能力。在MySQL复制（Replication）的过程中一个服务器充当主数据库服务器（Master），而另一个或多个其他服务器充当从数据库服务器（Slave），从数据库也称备库。<strong>复制解决的基本问题是让一个主数据库服务器的数据与其他从数据库服务器的数据保持同步。****MySQL复制的基本原理是将主数据库服务器的DDL和DML操作通过二进制日志传到从数据库服务器上，然后在从数据库服务器上将这些日志文件重新执行，从而使从数据库服务器和主数据库服务器的数据保持同步。</strong>简单来说，复制有三个步骤：<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573280552-8b1760e3-cb83-4498-891b-da9c930ffb93.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1f8d4fe3&originHeight=202&originWidth=677&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u7201c300-6e23-4f69-a57d-eb235ad2ab9&title="></p>
<h3 id="7-1-2-复制的架构和用途"><a href="#7-1-2-复制的架构和用途" class="headerlink" title="7.1.2 复制的架构和用途"></a>7.1.2 复制的架构和用途</h3><p><strong>1.复制的架构****MySQL复制的基本原理就是基于二进制日志，</strong>不过复制作为一项专门技术，当然不仅仅是这么简单，主数据库服务器更新重新写入二进制日志文件，并维护文件的一个索引以跟踪日志循环，这些日志可以记录发送到从数据库服务器的更新。当一个从数据库服务器连接主数据库服务器时，它通知主数据库服务器、从数据库服务器在日志中读取的最后一次成功更新的位置，从数据库服务器接受从那时起发生的任何更新，然后封锁并等待主数据库服务器通知新的更新。<strong>为了实现主数据库二进制文件在从数据库的复用，在从数据库服务器中引入了中继日志文件、I&#x2F;O线程和SQL线程，如图7-1所示，更详细地描述了复制的架构。</strong>（1）在从数据库服务器上执行sart slave命令开启主从复制开关，开始进行主从复制（7.2节会详细讲述复制的设置），然后在主数据库记录二进制日志，每次准备提交事务完成数据更新前，主数据库将数据更新的事件会被记录到二进制日志中。MySQL会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志。在记录二进制日志后，主数据库会告诉存储引擎可以提交事务了。（2）从数据库服务器会启动一个工作线程，称为I&#x2F;O线程，I&#x2F;O线程跟主数据库建立一个普通的客户端连接，然后在主数据库上启动一个特殊的二进制转储（Binlog Dump）线程，这个二进制转储线程会读取主数据库上二进制日志中的事件，它不会对事件进行轮询。此时，从数据库服务器的I&#x2F;O线程会通过在主数据库服务器上已经授权的复制用户权限请求连接主数据库服务器，并请求从执行binlog日志文件的指定位置（日志文件名和位置就是在配置主从复制服务时执行change master命令指定的）之后开始发送binlog日志内容。<img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653573289858-f4a4dd86-0cd8-4c8a-b584-4d13c164c80c.png#clientId=ud43d93cd-6fda-4&from=paste&id=ue8cf501f&originHeight=598&originWidth=997&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u51ba1d81-e789-4ab5-94ac-87dbac298c9&title=">图7-1 复制的架构（3）主数据库服务器接收到来自从数据库服务器的I&#x2F;O线程的请求后，二进制转储线程会根据从数据库服务器的I&#x2F;O线程请求的信息分批读取指定binlog日志文件指定位置之后的binlog日志信息，然后返回从数据库服务器端的I&#x2F;O线程。返回的信息中除了binlog日志内容外，还有在主数据库服务器端记录的新的binlog文件名称，以及在新的binlog中的下一个指定更新位置。（4）当从数据库服务器的I&#x2F;O线程获取到主数据库服务器上二进制转储线程发送的日志内容、日志文件及位置点后，会将binlog日志内容依次写到从数据库服务器端自身的中继日志（Relay Log）文件（MySQL-relay-bin.xxx）的最末端，并将新的binlog文件名和位置记录到master-info文件中，以便下一次读取主数据库服务器端新binlog日志时能告诉主数据库服务器从新binlog日志的指定文件及位置开始读取新的binlog日志内容。如果从数据库服务器的I&#x2F;O线程追赶上了主数据库，它将进入睡眠状态，直到主数据库服务器发送信号量通知其有新的事件产生时才会被唤醒。（5）从数据库服务器端的SQL线程从中继日志中读取事件并在从数据库上执行，从而实现从库数据的更新，SQL线程会实时检测本地中继日志中I&#x2F;O线程新增的日志内容，然后及时把中继日志文件中的内容解析成SQL语句，并在自身从数据库服务器上按解析SQL语句的位置顺序执行应用这样的SQL语句，且在relay-log.info中记录当前应用中继日志的文件名和位置点。当SQL线程追赶上I&#x2F;O线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低，SQL线程执行的事件也可以通过配置选项来决定是否写入其自己的二进制日志中，它对于我们稍后提到的场景非常有用。图7-1显示了在从数据库有两个运行的线程，和其他普通连接一样，由从数据库发起的连接，在主数据库上同样拥有一个线程。这种复制架构实现了获取事件和重放事件的解耦，允许这两个过程异步进行，也就是说I&#x2F;O线程能够独立于SQL线程之外工作。当然，仔细分析，这种架构也可能限制复制的过程，其中最重要的一点是在主数据库上并发运行的查询，在从数据库只能串行化执行，因为只有一个SQL线程来重放中继日志中的事件，这也可能造成工作负载的性能瓶颈。一个简单复制环境只需要两台运行MySQL的主机即可，甚至可以在一台物理服务器主机上启动两个MySQL实例，一个作为master，而另一个作为slave来完成复制环境的搭配，但在实际应用环境中，可以根据实际的业务需求利用MySQL复制的功能自己搭建出其他多种更利于扩展的复制架构，如最常用的主从架构。<strong>主从架构指的是使用一台MySQL服务器作为master，使用一台或多台MySQL服务器作为slave，将master的数据复制到slave上</strong>。在实际应用场合，主从架构模式是MySQL复制最常用的。一般在这种架构下，系统的写操作都是在master中进行的，而读操作则分散到各个slave中进行，因此这种架构特别适合现在互联网高读写的问题。此外，从数据库本身也可以被配置成另外一台服务器的主数据库，主数据库和从数据库之间可以有多种不同的组合方式。<strong>MySQL簇</strong>Mysql cluster（又称MySQL簇）就是由多台MySQL数据库服务器组成的服务器群，而多台服务器之间的数据同步就依赖于Mysql replicaion（复制）。Mysql replicaion（复制）本身是一个比较简单的结构，即一台从服务器（Slave）从一台主服务器（Master）读取二进制日志，然后再解析并应用到自身。<strong>2.复制过滤****复制过滤就是对用于复制的数据进行过滤，允许仅复制服务器上的一部分数据，而不是全部数据。</strong>有两种复制过滤方式：在主数据库上过滤记录到二进制日志中的事件，以及在从数据库上过滤记录到中继日志的事件，图7-2显示了这两种类型。<img src="https://cdn.nlark.com/yuque/0/2022/png/22295732/1653573289819-2ae3892c-b938-466e-9b02-7f731906cf93.png#clientId=ud43d93cd-6fda-4&from=paste&id=u74778b01&originHeight=596&originWidth=1176&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u376d1d41-3b26-4afb-8803-7fc16f25a55&title=">图7-2 两种过滤方式在主数据库上使用选项binlog_do_db和binlog_ignore_db来控制过滤，在从数据库上，可以通过设置replicate_<em>选项，在从中继日志中读取事件时进行过滤。可以复制或忽略一个或多个数据库，把一个数据库重写到另外一个数据库，或使用类似LIKE的模式复制或忽略数据库表。</em><em>do</em> db和*_ignore_db有一些作用，但非常有限，必须要很小心地去使用这些参数，否则很容易造成主备不同步或复制出错。<strong>3.复制的用途</strong>通过对复制架构的理解，可以知道通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力，或者用来作为主备机的设计，保证在主机停止响应之后在很短的时间内就可以将应用切换到备机上继续运行。数据库集群系统具有多个数据库节点，在单个节点出现故障的情况下，其他正常节点可以继续提供服务；如果主服务器上出现了问题可以切换到从服务器上；通过复制可以在从服务器上执行查询操作，降低了主服务器的访问压力，实现数据分布和负载均衡；可以在从服务器上进行备份，以避免备份期间影响主服务器的服务。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573289819-5c4e0ff9-c0fc-44d5-a193-c0425a909062.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0d201b78&originHeight=351&originWidth=506&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u858a2e37-15a4-44b2-b777-53e4d6f374a&title=">（1）数据分布。MySQL复制通常不会对带宽造成很大的压力，可以随意地停止或开始复制，在不同的地理位置来分布数据备份，形成不同的数据中心。即使在不稳定的网络环境下，远程复制也可以工作。数据分布可以让一个业务模块读取一个数据库，再针对不同的业务场景进行数据库的索引创建和根据业务选择MySQL存储引擎，不同的从数据库可以根据不同需求设置不同索引和存储引擎。（2）负载均衡。读写分离也算是负载均衡的一种，通过MySQL复制可以将读操作分布到多个服务器上，实现对读密集型应用的优化，一般都是有多台数据库服务器的，所以可以将读操作指定到某一从数据库服务器上（需要代码控制，通过简单的代码修改就能实现基本的负载平衡），同时也可以把一些大量计算的查询指定到另一台从数据库服务器上，这样就不会影响主数据库服务器的写入及其他查询。在一个主数据库多个备数据库的架构中，写操作会被执行多次，这时候整个系统的性能取决于写入最慢的那部分。对于小规模的应用，可以简单地对机器名做硬编码或使用DNS轮询（将一个机器名指向多个IP地址），当然也可以使用更复杂的方法，如通过网络负载均衡这一类的标准负载均衡解决方案，能够很好地将负载分配到不同的MySQL服务器上。当使用一主库多备库的架构时，可能会造成一些浪费，因为本质上它会复制大量不必要的重复数据。例如，对于一台主库和10台备库，会有11份数据复制，并且这11台服务器的缓存中存储了大部分相同的数据，这和在主服务器上有11路RAID1类似，这不是一种经济的硬件使用方式，但这种复制架构却很常见。（3）备份。对于备份来说，复制是一项很有意义的技术补充，但复制既不是备份也不能取代备份。一般我们都会做数据备份，可能是写定时任务，一些特殊行业可能还需要手动备份，有些行业要求备份和原数据不能在同一个地方，所以主从就能很好地解决这个问题，不仅备份及时，而且还可以多地备份，保证数据的安全可靠。（4）高可用性和故障切换。复制能够帮助应用程序避免MySQL单点失败，因为数据都是相同的，所以当主数据库服务器挂掉后，可以指定一台从数据库服务器充当主服务器继续保证服务运行，这表明数据具有一致性（如果当插入主数据库时挂掉，可能不一致，因为同步也需要时间）。一个包含复制的设计良好的故障切换系统能够显著地缩短宕机时间。复制通常不会增加主库的开销，主要是启用二进制日志带来的开销，但出于备份或及时从崩溃中恢复的目的，这些开销也是必要的。此外，每个备库也会对主库增加一些负载（如网络I&#x2F;O开销），尤其当备库请求从主库读取旧的二进制文件时，可能会造成更高的I&#x2F;O开销，而锁竞争也可能阻碍事务的提交，还有如果是从一个高吞吐量（如5 000或更高的TPS）的主库上复制到多个备库，唤醒多个复制线程发送事件的开销将会增加。（5）MySQL升级测试。这种做法比较普遍，使用一个更高版本的MySQL作为备库，保证在升级全部实例前查询能够在备库按照预期执行。</p>
<h3 id="7-1-3-复制的格式"><a href="#7-1-3-复制的格式" class="headerlink" title="7.1.3 复制的格式"></a>7.1.3 复制的格式</h3><p>在MySQL复制中，有一个被称为复制格式（Replication Formats）的概念，复制格式有些时候也称为复制模式。<strong>复制模式分为三种：</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573299657-75a2e4e3-b242-40f3-89c3-9399431cb422.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue0f2693c&originHeight=236&originWidth=485&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u74d7e563-e745-4eda-9fcd-954bd724d2f&title=">（1）基于语句的复制（Statement-Based Replication，SBR）模式。MySQL中基于语句的复制（也称为逻辑复制）模式早在MySQL 3.23版本中就存在，就是靠复制SQL语句到目标端执行的方式，也就是说，二进制日志文件中保存的就是执行的SQL语句，在MySQL 5.1.4及之前的版本，只有这一种日志记录方式。（2）基于行的复制（Row-Based Replication，RBR）模式。从MySQL 5.1.4版本开始，MySQL又引入了全新的基于行粒度的日志记录格式，这种技术就是关注表中发生变化的记录，而非以前的照抄二进制日志模式。在这种格式下，当将事件写入二进制日志文件时，记录的是变更的记录行的信息。（3）混合记录（Mixed-Based Replication，MBR）模式。到后来的MySQL 5.1.8版本，MySQL又近了一步，在将事件记入二进制日志时，MySQL服务器能够根据需要动态修改日志的格式，就是所谓的混合模式。大家注意混合记录是一种模式，而不是一种格式。在这种模式下，还是会默认选择基于语句的格式进行记录，只有在需要的场景下才会自动切换成基于行的格式进行记录，具体选择何种格式，要看当前执行的语句，以及操作对象所使用的存储引擎而定。就像前面说的，MySQL的复制原理主要就是依赖于二进制日志。与复制模式一致，<strong>二进制日志在记录事件时也支持三种格式，</strong>由binlog_format参数控制。（1）基于语句记录（Statement-Based Logging，SBL），对应的参数值为statement。（2）基于行格式记录（Row-Based Logging，RBL），对应的参数值为row。（3）混合模式记录（Mixed-Based Logging，MBL），对应的参数值为mixed。在MySQL 5.6版本中，尽管默认的日志记录格式是基于语句，但是一般我们都会手动将其改为混合模式（当然，不是所有人都能随意更改的，只有拥有SUPER权限的用户才可以修改系统变量）。日志格式是由binnlog_format系统参数控制的，在MySQL服务运行期间可以动态地对binlog_format系统变量进行修改，而且既可以在会话级进行设置，也可以指定为全局有效。<strong>例</strong>在配置文件中设置：binlog_format&#x3D;”statement” #binlog_format&#x3D;”row” #binlog_format&#x3D;”mixed” 在运行时动态修改binlog的格式：Mysql&gt; set session binlog_format&#x3D;”statement”不同的日志记录格式都有其适用的场合，各有利弊，明确SBR或RBR的特点及其优势很有必要，下面简单描述它们各自的特点，以帮助读者找到最佳应用场景。<strong>1.基于语句的复制模式</strong>在基于语句的复制（SBR）模式下，主数据库会记录那些造成数据更改的SQL语句，当从数据库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。这种方式既有好处，也有缺点。</p>
<table>
<thead>
<tr>
<th>SBR的优点</th>
<th>①最明显的优点是实现相当简单。从理论上讲，简单地记录和执行这些语句，能够让主从数据库保持同步，目前这个技术较为成熟，自3.23版本开始提供对这种记录格式的支持。②二进制日志里的事件更加紧凑，生成日志少，特别是对于大量更新及删除的操作，所以相对而言，基于语句的模式不会使用太多带宽，一条更新好几兆数据的语句在二进制日志里可能只占几十个字节。③mysqlbinlog工具（第1章和第3章介绍过，本章多处也会提到）是使用基于语句的日志的最佳工具，由于能够记录下数据库做过的所有变更操作，日志可用于数据库审计（参见4.3.4节）。</th>
</tr>
</thead>
<tbody><tr>
<td>SBR的缺点</td>
<td>①存在数据安全隐患。主数据库中产生的修改操作（含INSERT、DELETE、UPDATE、REPLACE）并不是都能通过基于语句方式完整地复制到从数据库中，对于不确定的行为在基于语句复制时，很难确保从数据库会执行并获得正确的数据，比如同一条SQL在主数据库和从数据库上执行的时间可能会不同，主数据库和从数据库分别执行FOUND_ROWS()、SYSDATE()、UUID()、NOW()这类函数，可能返回不同的结果。如果使用了这些函数，那么语句执行时会抛出下列警告信息（客户端通过SHOW WARNINGS查看）：06489 18:08:54 [Warning] Statement is not safe to log in statement format.②存在一些无法被正确复制的SQL，例如，存储过程和触发器在使用基于语句的复制模式时可能存在问题。③更新必须是串行的，这需要更多的锁。执行INSERT…SELECT语句时需要持有更多行锁（相比RBR而言），UPDATE要扫表（无可用索引的情况下）时需要持有更多行锁（相比RBR而言）。④对于复杂的语句，从数据库执行SQL语句时必须先被评估，也就是语法、词法分析等，而对于基于row格式复制，则从数据库只需要修改具体的记录即可（不必执行跟主数据库端相同的SQL语句，这既是优点也是缺点）。⑤为了避免冲突，数据库对象定义必须拥有唯一键。⑥不是所有的存储引擎都支持这种复制模式，尽管这些存储引擎是包括在MySQL 5.5及之前版本中发行的。</td>
</tr>
</tbody></table>
<p><strong>2.基于行的复制模式</strong>基于行的复制（RBR）模式会将实际数据记录在二进制日志中，最大的好处是可以正确地复制每一行。</p>
<table>
<thead>
<tr>
<th>RBR的优点</th>
<th>①所有修改都能被安全地复制到从数据库中。对于像GRANT&#x2F;REVOKE这类操作，以及存储过程、触发器、视图等数据库对象的维护操作，会被使用SBR模式复制到从数据库端。对于CREATE TABLE…SELECT这类DDL+DML的操作，CREATE创建对象部分使用SBR模式复制。②主数据库端执行修改操作时，仅需极少的锁持有，因此可获得更高的并发性能。③从数据库端执行INSERT&#x2F;UPDATE&#x2F;DELETE时也仅需持有少量锁, 使用基于行的复制模式能够更高效地复制数据。由于无须重放更新主库数据的SQL，重放一些SQL的代价可能会很高。例如，下面有一个SQL将数据从一个大表中汇总到小表：mysql&gt; INSERT INTO summary_table(col1, co12, sum_co13)     一&gt;SELECT col1, co12, sum(co13)     一&gt;FROM enormous_table     一&gt;GROUP  BY col1, co12; 想象一下，如果表enormous_table的列col1和col2有三种组合，这个查询可能在源表上扫描多次，但最终只在目标表上产生三行数据。但使用基于行的复制方式，在从数据库库上开销会小很多。在这种情况下，基于行的复制模式更高效。</th>
</tr>
</thead>
<tbody><tr>
<td>RBR的缺点</td>
<td>①RBR可能会生成更多的日志，比如执行DML语句，基于语句格式记录日志的话，仅记录所执行的SQL语句，相比之下，基于行格式记录日志的话，会将所有变化了的行记录到二进制日志文件中，如果语句触发的记录变得特别多，即使执行的操作随后被回滚，其生成的二进制日志也会非常多。这同样也意味着创建备份及恢复需要更多的时间，以及二进制日志会被更长时间加锁以写数据，也可能还会带来额外的并发性能上的问题。例如，下面这条语句使用基于语句的复制方式代价会小很多：mysql&gt; UPDATE enormous_table SET col1&#x3D;0;由于这条语句做了全表更新，使用基于行的复制开销会很大，因为每行的数据都会被记录到二进制日志中，这使得二进制日志事件非常庞大，并且会给主数据库上记录日志和复制增加额外的负载，更慢的日志记录则会降低并发度。②如果有BLOB值，则需要花费比基于语句格式日志更长的时间，因为BLOB列的值是被记录的，而不是语句生成的。③不能通过分析日志来获取曾经执行过的语句（不能做语句级的审计），只能通过mysqlbinlog命令看到哪些数据被修改了。④对于非事务存储引擎，比如MyISAM表对象，从数据库端INSERT操作时，使用RBR模式要比使用SBR模式持有更强的锁定，也就是说，使用RGB模式在从数据库端没有并行插入的概念。</td>
</tr>
</tbody></table>
<p><strong>3.哪种模式更优</strong>我们已经讨论了这两种复制模式的优点和缺点，那么在实际应用中哪种模式更优呢？由于没有哪种模式对所有情况都是完美的，所以MySQL能够在这两种复制模式间动态切换，默认情况下使用的是基于语句的复制模式，但如果发现语句无法被正确地复制，其就会切换到基于行的复制模式，此外，其还可以根据需要设置会话级别的变量binlog_format，控制二进制日志格式。以上描述尽管内容枯燥了一些，但信息量很大，下面用最简单的例子描述SBR和RBR应用在不同场景时的表现。<strong>例</strong>假设有多条复杂的SQL语句，在主数据库端执行了一个多小时，最终才成功修改了一条记录。采用基于语句的复制模式，二进制日志中记录的事件就是这条SQL语句，那么这个记录被复制到从数据库节点后，也需要至少一个多小时才能艰难地执行。若采用基于行的复制模式会怎么样呢？不管主数据库节点执行了多长时间，最终变更的记录只有一条，那么二进制中记录的事件就是这一条记录的更新，日志被同步到从数据库节点后，相信秒速就被执行完了。<strong>例</strong>假设有条简单的SQL语句，在主数据库节点执行时向库中插入了一千多万条记录。若采用基于行复制模式，由这一千万条记录生成的二进制日志数量相当庞大，从数据库要全部接收完，而后还得花费相当长的时间慢慢同步。若是采用基于语句的复制模式，则二进制日志文件中记录的事件就是该条SQL语句，相对节省时间，从数据库节点也可以很快接收完，尽管在应用这条语句时，执行的时间依然不短（因其数据量大，这一步无法提速），但是总体时间还是基于语句的复制模式更快。<strong>在多数场景下，使用混合复制模式能够提供不错的数据完整性保护和性能。</strong>对于混合复制模式，默认情况下它依然是基于语句记录事件。应对例一的场景时，其表现跟基于语句的复制模式没有区别，那么混合复制模式的应用场景究竟是什么呢？简单理解的话，它只是当遇到SBR模式记录事件，存在数据安全隐患时，自动将日志记录格式变更为基于行格式记录，也就是RBR模式。所以没有万能的参数，没有最佳设置，每种模式都有它适合的场景，参数没有相对的好坏，只有能不能把它用好，因此深入了解不同模式的原理和特点就显得非常有必要。SBR&#x2F;RBR该怎么选，哪种模式最好，这取决于要怎么用。此外，MySQL复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备份库，但反过来，将老版本作为新版本服务器的备份库通常是不可行的，因为它可能无法解析新版本所采用的新的特性或语法，而所使用的二进制文件的格式也可能不相同。例如，不能从MySQL 5.1复制到MySQL 4.0。在进行大的版本升级前，如从4.1升级到5.0，或从5.1升级到5.5，最好先对复制的设置进行测试，但对于小版本号升级，如从5.1.51升级到5.1.58，则通常是兼容的。</p>
<h3 id="7-1-4-复制相关的文件类型"><a href="#7-1-4-复制相关的文件类型" class="headerlink" title="7.1.4 复制相关的文件类型"></a>7.1.4 复制相关的文件类型</h3><p>3.2.3节中介绍过中继日志文件和复制状态文件，MySQL数据库中有二进制日志文件，用于记录所执行的变更事件，复制特性正是基于这类文件实现“复制”操作。从数据库（Slaves）端有两个线程，其中I&#x2F;O线程用于接收和保存二进制日志，SQL线程用于应用这些日志，这样听起来分工明确、合理且有效，不过我们应该有这样的疑问：I&#x2F;O线程将接收的二进制日志保存在了哪里呢？本地的二进制日志文件看起来是无法直接保存的，因为从数据库端也是MySQL服务器，也有可能产生自己的操作事件，这类事件默认是肯定要写到二进制日志文件中，若将收到的来自主数据库端的事件也写入本地二进制日志文件中，尽管技术上一定可以实现，但是会给SQL线程解析日志时造成很大难度。MySQL数据库在处理这个问题时的思路是：既然来自于主数据库的二进制文件在从数据库没有现成的地方保存（不能保存在从数据库的二进制文件中），那就专门给它设置一个地方保存，于是就有了中继日志（Relay Log）。<strong>Oracle的Standby</strong>对于熟悉Oracle的读者，这听起来像Standby Redolog Files，类似于Oracle Dataguard特性中的逻辑Standby，而非物理Standby的原因。<strong>1.中继日志文件</strong>从文件类型上来看，中继日志文件和二进制日志文件极为相似，两者唯一的区别是逻辑上的，即<strong>二进制日志文件用于保存节点自身产生的事件，而中继日志文件则是保存接收来自其他节点的事件（也是二进制格式的）。</strong>中继日志文件拥有与二进制日志文件相同的结构，当然也可以通过mysqlbinlog命令解析。在默认情况下，中继日志文件按照[host_name]-relay-bin.[nnnnn]的命名规则保存在mysql的data目录下，其中[host_name]表示主机名，[nnnn]表示递增序列，从000001开始计数。跟二进制日志文件一样，中继日志文件也有一个日志的索引文件，中继日志索引文件默认名为[host_name]-relay-bin.index，同样保存在msql的data目录下。中继日志文件和日志文件索引的保存路径可以通过–relay-log和–relay-log-index参数进行自定义。需要注意的是，如果从数据库节点使用默认中继文件的命名规则（就是说没有修改过–relay-<em>参数的参数值），那么一旦修改了从数据库节点所在服务器的主机名，复制环境也会受到影响，复制进程会抛出“Failed to open the relay log” “Could not find target log during relay log initialization”等错误信息（参见BUG#2122），因此对于主机名可能发生修改的服务器，建议在创建从数据库节点之初，就先使用–relay-log和–relay-log-index参数自定义中继日志文件的文件名。修改配置文件my.ini，可以在[mysqld]块中增加如下两行内容：relay-log &#x3D; ..&#x2F;binlog&#x2F;relay-binrelay-log-index &#x3D; ..&#x2F;binlog&#x2F;relay-bin.index如果是在部署好的复制环境中遇到了从数据库节点主机名修改的情况，那么临时的解决方案可以通过修改中继日志、相关日志文件名的方式解决，比如将文件名中主机名部分修改为新的主机名即可。注意只需要修改中继日志索引文件名称即可，中继日志文件不要修改，不然会导致与索引文件中的记录不符，导致另外的错误。从数据库节点会在满足下列条件时触发创建新的中继日志文件，并更新相关的索引文件。（1）启动Slaves节点I&#x2F;O线程时。（2）执行日志刷新命令，比如FLUSH LOGS或mysqladmin flush-logs等。（3）中继日志文件达到指定最大值，有下列两种情况：如果max_relay_log_size参数值大于0，则日志文件超过该值后即会重建；如果max_relay_log_size参数值0，则通过max_binlog_size确定单个Relay日志文件的最大值。中继日志文件的管理可以完全交由从数据库节点的SQL线程来维护，它会自动删除无用的中继日志文件，至于如何删除及何时删除，并没有明确的机制，SQL线程会自己搞定。<strong>2.状态文件</strong>除了中继日志文件之外，<strong>复制环境中的从数据库节点还会创建两个复制环境的状态文件，即master.info和relay-log.info，</strong>这两个文件默认都保存在mysql的data目录下，用户也可以通过–master-info-file和–relay-log-info-file参数修改文件的名称和保存路径。这两个状态文件中保存的信息类似于SHOW SLAVE STATUS中显示的信息，当然没有SHOW SLAVE STATUS语句中显示得全面，而且更为重要的是，SHOW SLAVE STATUS语句只是显示信息，而master.info和relay-log.info在启动时都有重要作用，从数据库需要读取这里两个文件中的信息，以确定从什么位置继续处理日志。（1）master.info：顾名思义，当然是保存复制环境中连接主数据库节点的配置信息，比如说从数据库节点连接主数据库使用的用户名&#x2F;密码&#x2F;IP端口等均在其中，格式为纯文本（每行一个值）。随着版本的增长，这个文件中保存的内容也越来越丰富。在MySQL 5.6版本之前，这些信息日志总是保存在master.info文件中，默认在MySQL的data路径下，而进入MySQL 5.6版本后，数据库管理员也可以选择将这些信息保存在mysql.slave_master_info表对象中。（2）relay-log.info：保存处理进度及中继日志文件的位置, 不要删除这个文件，否则在从数据库重启后将无法获知从哪个位置开始复制，可能会导致重放已经执行过的语句。与前面的日志信息相似，在MySQL 5.6版本之前，其也都是保存在文本格式中，位于data路径下的relay-log.info文件中，不过从MySQL 5.6版本开始，我们也可以将这个信息保存在mysql.slave_relay_log_info表对象中。注意为了保证宕机后表对象数据的安全性和一致性，前面提到的两个表对象最好使用支持事务的存储引擎，尤其是对master.info文件需要特别保护，因为其中保存的有复制环境的配置及连接主库的用户名和密码等重要信息。之前默认的都是MyISAM存储引擎，不过从MySQL 5.6.6版本开始，这两个表对象就会是InnoDB存储引擎。不管是作为文本格式文件还是表对象，主数据库信息和中继日志信息都不要手动去编辑或修改，否则极有可能导致出现不可预料的错误。需要注意的是，relay-log.info中的内容与SHOW SLAVE STATUS语句显示的内容有可能不一致，通常是因为relay-log.info未被及时更新。master.info和relay-log.info两个文件的更新也是有分工的，I&#x2F;O线程负责更新master.info文件，SQL线程负责更新relay-log.info文件。通过MySQL服务处于启动状态时，可以通过SHOW SLAVE STATUS语句查看相关状态，只有当MySQL服务处于关闭状态时，才会通过这两个文件查看其状态。<strong>3.其他文件</strong>*</em>除了二进制日志文件和中继日志文件，其实还有其他的文件会被用到，比如mysql-bin.index和mysql-relay-bin-index。**在默认情况下不同版本的MySQL可能将这些文件放到不同的目录里，其大多取决于具体的配置选项，可能在data目录或者包含服务器.pid文件的目录下。mysql-bin.index：当在服务器上开启二进制日志时，同时会生成一个和二进制日志同名的但以后缀为.index的文件，该文件用于记录磁盘上的二进制日志文件。这里的“index”并不是指表的索引，而是说这个文件的每一行都包含了二进制文件的文件名。这个文件并不是多余的，MySQL依赖于这个文件，除非在这个文件里有记录，否则MySQL识别不了二进制日志文件。mysql-relay-bin-index：这个文件是中继日志的索引文件，和mysql-bin.index的作用类似。</p>
<h2 id="7-2-配置复制"><a href="#7-2-配置复制" class="headerlink" title="7.2 配置复制"></a>7.2 配置复制</h2><h3 id="7-2-1-配置复制"><a href="#7-2-1-配置复制" class="headerlink" title="7.2.1 配置复制"></a>7.2.1 配置复制</h3><p>为MySQL服务器配置复制非常简单。最基本的场景是新安装的主数据库和从数据库，<strong>总的来说分为以下几个步骤。</strong><img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573329991-c15840b1-811a-4f26-9a7d-df3ca7ce6f62.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u7d201c52&originHeight=208&originWidth=480&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6f7a2087-9616-40e4-a6da-69ba73a2712&title=">这里假定大部分配置采用默认值即可，在主数据库和从数据库都是全新安装并且拥有同样的数据。现实中由于场景不同，其基本的步骤可能有所差异。接下来将展示如何配置复制：系统使用Windows操作系统，假设有服务器Server1 （IP地址10.210.69.228）和服务器Server2（IP地址10.210.69.237），我们将解释如何为一个已经运行的服务器配置从数据库，并探讨推荐的复制配置。</p>
<h3 id="7-2-2-创建复制账号"><a href="#7-2-2-创建复制账号" class="headerlink" title="7.2.2 创建复制账号"></a>7.2.2 创建复制账号</h3><p>MySQL会赋予一些特殊的权限给复制线程。在从数据库运行的I&#x2F;O线程会建立一个到主数据库的TCP&#x2F;IP连接，这意味着必须在主数据库创建一个用户（创建用户的方法参见4.3.2节），并赋予其合适的权限。从数据库I&#x2F;O线程以该用户名连接到主数据库并读取其二进制日志。Windows通过如下语句创建用户账号，操作界面如图7-3所示。mysql&gt;grant replication slave on <em>.</em> to ‘slave_user‘@’10.210.69.237’ identified by ‘12345’ ;<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338647-2b678428-50b7-4de5-9b2b-a62a75900d5f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ufb1e60d7&originHeight=50&originWidth=1019&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u444856ef-3eac-4f3c-b306-9526e7889ea&title=">图7-3 创建用户账号在主数据库创建该账号slave_user，在从数据库用root账号。注意我们把这个账户限制在本地网络，因为这是一个特权账号（尽管该账号无法执行select或修改数据，但仍然能从二进制日志中获得一些数据）。这里有一点需要说明，复制账户事实上只需要有主数据库上的REPLICATION SLAVE权限，并不一定需要每一端服务器都有REPLICATION CLIENT权限，那为什么要给主数据库、从数据库都赋予这两种权限呢？有两个原因：一是用来监视和管理复制的账号需要REPLICATION CLIENT权限，并且针对这两种目的使用同一个账号更加容易（而不是为某个目的单独创建一个账号）；二是如果在主数据库上建立了账号，然后从主数据库将数据克隆到从数据库上时，从数据库也就设置好了（变成主数据库所需要的配置），这样后续有需要可以方便地交换主、从数据库的角色。可以用flush privileges语句来刷新权限操作界面，如图7-4所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338941-5c430d9d-8596-42c7-935d-4eee649722bc.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ua9b9d750&originHeight=58&originWidth=442&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u3ae27434-4992-4258-a512-7ef9c144a00&title=">图7-4 刷新权限然后查看是否配置成功，使用select user,host from mysql.user语句查询状态，操作界面如图7-5所示，图中可以看到10.210.69.237（也就是从数据库）有了访问slave_user的权限。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573338609-6ae513e7-b27d-4aee-85aa-3139871e0d59.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u88e4d2e4&originHeight=242&originWidth=474&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u662ef947-40b8-41bb-b172-95d672c195c&title=">图7-5 查询配置结果</p>
<h3 id="7-2-3-配置主数据库和从数据库"><a href="#7-2-3-配置主数据库和从数据库" class="headerlink" title="7.2.3 配置主数据库和从数据库"></a>7.2.3 配置主数据库和从数据库</h3><p>下一步需要在主库上开启一些设置，假设主库是服务器serverl，需要打开二进制日志并指定一个独一无二的服务器ID（server ID）。<strong>1.主数据库的配置</strong>在主数据库的my.ini文件中增加或修改如下内容，修改后的配置文件使用写字板打开，如图7-6所示。server-id&#x3D;1log_bin&#x3D;master-binlog_bin-index&#x3D;master-bin.index<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573347962-328ac465-ce00-49fb-9ab2-bb4cfeb9fc08.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u06c41a59&originHeight=640&originWidth=886&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u0bde01f9-99b1-48ec-9693-4926a633b37&title=">图7-6 my.ini添加二进制日志路径结果必须明确地指定唯一的服务器ID，默认服务器ID通常为1（这和版本相关，一些MySQL版本根本不允许使用这个值）。使用默认值可能会导致和其他服务器的ID冲突，因此这里我们选择10作为服务器ID。通用的做法是使用服务器IP地址的末8位，或者选择一些有意义的约定，但要保证它是不变且唯一的（例如，服务器都在一个子网里）。如果之前没有在MySQL的配置文件中指定log-bin选项，就需要重新启动MySQL。为了确认二进制日志文件是否已经在主库上创建，可使用SHOW MASTER STATUS命令检查输出是否与如下的一致。MySQL会为文件名增加一些数字，所以这里看到的文件名和定义的会有点不一样，操作界面如图7-7所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348009-999a77bb-f080-455c-9c88-45d51c930486.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9cc7730c&originHeight=57&originWidth=395&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6b4963cd-1c3e-465e-b247-fefb07577d3&title=">图7-7 查看主服务器状态注意图7-7中显示为Empty，是因为二进制日志路径并没有设置正确或者并未重启数据库，可以使用show variables like ‘%log_bin’查看二进制日志状态，操作界面如图7-8所示，可以看到log_bin是OFF，此时需要重启计算机，或者重启数据库并刷新权限，再次查询界面，如图7-9所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348005-17d551a8-cd40-4502-aedc-bb3146cfbfc4.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=ue170527f&originHeight=252&originWidth=487&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2b0b6e9f-fe64-41ef-b273-ea5a6359ffb&title=">图7-8 查看二进制日志状态<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573347934-72f4ccd8-24d5-466b-8718-2998f7597375.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u4be0221b&originHeight=161&originWidth=430&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u9a2212f8-17b7-46b4-afb6-6045b6d5497&title=">图7-9 查看刷新后的二进制日志状态之后使用show binary logs命令查询二进制日志具体信息，操作界面如图7-10所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573349559-52c84b88-dc3d-42cf-b85f-d7c2327f0c34.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=udcd59cd6&originHeight=335&originWidth=460&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2f951161-a752-4d5f-9988-35c65ab0fc6&title=">图7-10 查看二进制日志具体信息此时在mysql文件夹下产生二进制日志文件，如图7-11所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348641-dede61c9-4036-4fb6-bff2-ef4fcb895a22.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0d5c2c08&originHeight=278&originWidth=799&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u6ef58218-dac4-4010-832f-d6f59f4475a&title=">图7-11 二进制日志文件的位置配置好二进制日志文件后使用show master status命令查看主服务器状态，操作界面如图7-12所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348878-f5685775-a427-49c0-a6d2-215333cc4e8f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u5f287508&originHeight=151&originWidth=934&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u27266cae-1657-4d7f-baec-6df06b6a774&title=">图7-12 查看主服务器状态<strong>2.从数据库的配置</strong>从数据库上也需要在my.ini中增加类似的配置，并且同样需要重启服务器，如图7-13所示是配置完my.ini的效果。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573348833-a6769b18-be9c-4342-b85a-4f6d2188990d.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9e060a1c&originHeight=508&originWidth=769&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u641694f4-eefc-4b55-a334-6cb8ba146fb&title=">图7-13 从数据库my.ini配置其中一些选项我们只是显式地列出了默认值，事实上只有server_id是必需的。默认情况下，它是根据机器名来命名的，但如果机器名发生变化可能会出现问题。为了简便，可以将主数据库和从数据库上的log-bin设置为相同的值，当然也可以设置成别的值。配置选项relay_log为指定中继日志的位置和命名。<strong>3.一主多从的配置****log_slave_updates选项可以让从数据库变成其他服务器的主数据库，</strong>也就是有一个主数据库，两个从数据库，从数据库1又是从数据库2的主数据库。在设置该选项后，MySQL会将其执行过的事件记录到它自己的二进制日志中，这样它的从数据库就可以从其日志中检索并执行事件。在这种场景下，主数据库将数据更新事件写入二进制日志，从数据库1提取并执行这个事件。这时候一个事件的生命周期应该已经结束了，但由于设置了log_slave_updates，从数据库1会将这个事件写到它自己的二进制日志中，这样从数据库2就可以将事件提取到它的中继日志中并执行。这意味着作为源服务器的主数据库可以将其数据变化传递给没有与其直接相连的从数据库上。默认情况下这个选项是被打开的，这样在连接到从数据库时就不需要重启服务器。</p>
<h3 id="7-2-4-启动复制"><a href="#7-2-4-启动复制" class="headerlink" title="7.2.4 启动复制"></a>7.2.4 启动复制</h3><p>配置完成后，下一步是告诉<strong>从数据库如何连接到主数据库并重放其二进制日志，</strong>这一步不通过修改my.ini来配置，而是<strong>使用CHANGE MASTER TO语句，</strong>该语句完全替代了my.ini中相应的设置，并且允许指向别的主数据库时无须重启从数据库。下面是启动复制的基本语句。change master to master_host&#x3D;’10.210.69.228’,master_user&#x3D;’slave_user’,master_password&#x3D;’12345’,port&#x3D;3307,master_logfile&#x3D;master_bin.000010,master_log_pos&#x3D;2148当执行完这条语句后，使用start slave语句启动从数据库，可以通过SHOW SLAVE STATUS\G语句来检查复制是否正确执行，如图7-14所示。Slave_IO_Running和Slave_SQL_Running这两行为YES时表示配置成功，从输出可以看出I&#x2F;O线程和SQL线程都已经开始运行，Seconds_Behind_Master的值也不再为NULL。I&#x2F;O线程正在等待从主数据库传递过来的事件，这意味着I&#x2F;O线程已经读取了主数据库所有的事件。日志位置发生了变化，表明已经从主数据库获取和执行了一些事件。如果在主数据库上做一些数据更新，就会看到从数据库的文件或者日志位置都可能会增加，备库中的数据同样会随之更新。我们还可以使用SHOW PROCESSLIST语句从线程列表中看到复制线程（6.2.2节中使用线程查看用于数据库性能查看），在主数据库上可以看到由从数据库I&#x2F;O线程向主数据库发起的连接，如图7-15所示。同样，在从数据库也可以看到相应的线程。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356668-32b265aa-b1a6-4b74-87e1-c6e66c8ec590.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u1223e575&originHeight=1261&originWidth=909&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ucbc8f1ee-82d3-4025-a10f-6bd824a57dd&title=">图7-14 查看SLAVE STATUS<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356630-ef35905d-32bc-48b4-a6b6-62ace57d41da.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u27a44d28&originHeight=421&originWidth=779&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ub4fced5e-c3d4-4aa0-9ce9-a7802376548&title=">图7-15 查看PROCESSLIST然后进行主从验证，在主数据库创建数据库和一张表，查看从数据库中是否与主数据库同步，也有了刚创建的数据库和表。在主数据库创建一个名为test的数据库，在该数据库下创建一个名为person的表，如图7-16所示。在从数据库中查看是否存在相应的库和表，查询结果如图7-17所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356664-35c05a20-5c39-4005-aa2d-63a1a4b13fd3.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u69d4a760&originHeight=300&originWidth=413&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u47ad0541-0d3b-4f28-940d-653f9034a36&title=">图7-16 主数据库创建库和表<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573356681-6a698e0d-e551-4123-81e1-dd9fca18e32f.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u8ed701e2&originHeight=445&originWidth=262&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ueb2af69a-42f2-4ac9-a025-9babeef3692&title=">图7-17 在从数据库中查看对应的库和表</p>
<h3 id="7-2-5-从另一个服务器开始复制"><a href="#7-2-5-从另一个服务器开始复制" class="headerlink" title="7.2.5 从另一个服务器开始复制"></a>7.2.5 从另一个服务器开始复制</h3><p>前面的设置都是假定主数据库、从数据库均为刚刚安装好且都是默认的数据，也就是说两台服务器上数据相同，并且知道当前主数据库的二进制日志，这不是典型的案例。大多数情况下是有一个已经运行了一段时间的主数据库，然后用一台新安装的从数据库与之同步，此时这台从数据库还没有数据。有几种方法来初始化从数据库或者从其他服务器复制数据到从数据库（在从数据库的主机上安装MySQL，注意从数据库的版本不能低于主数据库），包括从主数据库复制数据、从另外一台从数据库复制数据，以及使用最近的一次备份来启动从数据库，都需要获得以下三个条件来让主数据库和从数据库保持同步。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573365937-273a3ad9-d2f0-4869-b755-55e5797f473a.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u0e148467&originHeight=515&originWidth=603&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ua20137a6-aa87-4b1a-8c95-85b0c485cec&title="><strong>1.使用主数据库备份</strong>（1）使用冷备份。最基本的方法是关闭主数据库，把数据复制到从数据库。重启主数据库后，会使用一个新的二进制日志文件，在从数据库通过执行CHANGE MASTER TO指向这个文件的起始处。这个方法明显的缺点是在复制数据时需要关闭主数据库。（2）使用热备份。如果仅使用了MyISAM表，可以在主数据库运行时使用mysqlhotcopy或rsync来复制数据到从数据库。（3）使用mysqldump。如果只包含InnoDB表，那么可以使用mysqldump来转储主数据库数据并将其加载到从数据库，然后设置相应的二进制日志坐标。Mysql&gt;mysqldump –single-transaction –all-databases –master-data&#x3D;1–host&#x3D;server1|mysql –host&#x3D;server2选项–single-transaction使得转储的数据为事务开始前的数据，如果使用的是非事务型表，可以使用–lock-all-tables选项来获得所有表的一致性转储。（4）使用快照或者备份。只要知道对应的二进制日志坐标，就可以使用主数据库的快照或者备份来初始化从数据库（如果使用备份，需要确保从备份的时间点开始的主数据库二进制日志都要存在），只需要把备份或快照恢复到从数据库，然后使用CHANGE MASTER TO指定二进制日志的坐标，也可以使用LVM快照、SAN快照及EBS快照。<strong>2.使用另外的从数据库</strong>我们可以使用任何一种复制技术来从任意一台从数据库上将数据复制到另外一台服务器，但是如果使用的是mysqldump的–master-data选项就会不起作用。此外，不能使用SHOW MASTER STATUS来获得主数据库的二进制日志坐标，而是要在获取快照时使用SHOW SLAVE STATUS来获取从数据库在主数据库上的执行位置。使用另外的从数据库进行数据复制最大的缺点是，如果这台从数据库的数据已经和主数据库不同步，复制得到的就是脏数据。<strong>3.使用Percona Xtrabackup</strong>Percona Xtrabackup是一款开源的热备份工具，它能够在备份时不阻塞服务器的操作，因此可以在不影响主数据库的情况下设置从数据库，其可以通过克隆主数据库或另一个已存在的从数据库的方式来建立从数据库。如果是从主数据库获得备份，可以从xtrabackup_binlog_pos_innodb文件中获得复制开始的位置；如果是从另外的从数据库获得备份，可以从xtrabackup_slave_info文件中获得复制开始的位置。不建议使用LOAD DATA FROM MASTER命令或LOAD TABLE FROM MASTER命令进行数据复制。不管最后选择哪种技术，都要能熟练运用，要记录详细的文档或编写脚本，因为可能不止一次需要做这样的事情，甚至当错误发生时也要能够处理。</p>
<h3 id="7-2-6-推荐的复制配置"><a href="#7-2-6-推荐的复制配置" class="headerlink" title="7.2.6 推荐的复制配置"></a>7.2.6 推荐的复制配置</h3><p>有许多参数可以用于控制复制，其中一些会对数据安全和性能产生影响。接下来推荐的一种“安全”的配置，可以最小化问题发生的概率。在主数据库上二进制日志最重要的选项是sync_binlog。Sync_binlog&#x3D;1如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证在服务器崩溃时不会丢失事件。如果禁止该选项，则服务器会少做一些工作，但二进制日志文件可能在服务器崩溃时损坏或丢失信息。在一个不需要作为主数据库的从数据库上，该选项带来了不必要的开销，它只适用于二进制日志，而非中继日志。如果使用InnoDB，我们推荐设置如下选项：Innodb_flush_longs_at_trx_commit #Flush every log writeInnodb_support_xa&#x3D;1 #MySQL5.0 and newer onlyInnodb_safe_binlog #MySQL4.1 only roughly equivalent to innodb_support_xa推荐明确指定二进制日志的名字，以保证二进制日志名字在所有服务器上是一致的，避免因为服务器名的变化导致的日志文件名的变化。如果不指定二进制日志名字，当在服务器间转移文件、复制新的从数据库、转储备份或者其他场景下，可能会导致很多问题。为了避免这些问题，需要给log_bin选项指定一个参数，可以随意地给一个绝对路径，但必须明确地指定基本的命名。Log_bin&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql_bin在备库上，同样推荐开启如下配置选项，为中继日志指定绝对路径。Relay_log&#x3D;&#x2F;path&#x2F;to&#x2F;logs&#x2F;relay_binSkip_slave_startRead_only通过设置relay_log可以避免中继日志文件基于机器名来命名，指定绝对路径可以避免多个MySQL版本中存在的Bug，这些Bug可能会导致中继日志在一个意料外的位置创建。skip_slave_start选项能够阻止从数据库在崩溃后自动启动复制，如果从数据库在崩溃后自动启动并且处于不一致的状态，就可能会导致更多的损坏，最后将不得不把所有数据丢弃，并重新开始配置从库。read_only选项可以阻止大部分用户更改非临时表，除了复制SQL线程和其他拥有超级权限的用户之外，这也是要尽量避免给正常账号授予超级权限的原因之一。即使开启了所有推荐的选项，从数据库仍然可能在崩溃后被中断，默认情况下甚至不会刷新到磁盘，直到MySQL 5.5版本才有选项来控制这种行为。如果正在使用MySQL 5.5版本并且不介意额外的fsync()导致的性能开销，最好设置以下选项：Sync_master_info&#x3D;1Sync_relay_log&#x3D;1Sync_relay_log_info&#x3D;1如果从数据库与主数据库的延迟很大，从数据库的I&#x2F;O线程可能会写很多中继日志文件，SQL线程在重放完一个中继日志中的事件后会尽快将其删除（通过relay_log_purge选项来控制）。但如果延迟非常严重，I&#x2F;O线程可能会把整个磁盘撑满。解决办法是配置relay_log_space_limit变量，如果所有中继日志的大小之和超过这个值，I&#x2F;O线程会停止，等待SQL线程释放磁盘空间。但有一个隐藏的问题，如果从数据库没有从主数据库上获取所有的中继日志，这些日志可能在主库崩溃时丢失。除非磁盘空间真的非常紧张，否则最好让中继日志使用其需要的磁盘空间，这也是为什么没有将relay_log_space_limit列入推荐的配置选项的原因。</p>
<h2 id="7-3-复制管理和维护"><a href="#7-3-复制管理和维护" class="headerlink" title="7.3 复制管理和维护"></a>7.3 复制管理和维护</h2><h3 id="7-3-1-监视复制"><a href="#7-3-1-监视复制" class="headerlink" title="7.3.1 监视复制"></a>7.3.1 监视复制</h3><p>配置复制一般来说不会是需要经常做的工作，除非有很多服务器。但是一旦配置了复制， 不管有多少服务器，监视和管理复制就成为数据库运维一项日常工作。<strong>复制的管理和维护大体有监视复制、测量从数据库延迟、判断主数据库、从数据库是否一致、主数据库重新同步从数据库、改变主数据库等。</strong>复制相关的命令见表7-1。表7-1 复制相关的命令</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>Slave start</td>
<td>启动复制线程</td>
</tr>
<tr>
<td>Slave stop</td>
<td>停止复制线程</td>
</tr>
<tr>
<td>Reset slave</td>
<td>重置复制线程</td>
</tr>
<tr>
<td>Show slave status</td>
<td>显示复制线程状态</td>
</tr>
<tr>
<td>Show slave status\g</td>
<td>显示复制线程状态（分行显示）</td>
</tr>
<tr>
<td>Show master status\G</td>
<td>显示主数据库的状态（分行显示）</td>
</tr>
<tr>
<td>Show master logs</td>
<td>显示主数据库日志</td>
</tr>
<tr>
<td>Change master to</td>
<td>动态改变到主数据库的配置</td>
</tr>
<tr>
<td>Show processlistv</td>
<td>显示有哪些线程正在运行</td>
</tr>
</tbody></table>
<p>尽管复制发生在主数据库和从数据库上，但大多数工作是在从数据库上完成的，这也正是最常出问题的地方。是否所有的从数据库都在工作？最慢的从数据库延迟是多大？MySQL本身提供了大量可以回答上述问题的信息，但要实现自动化监视过程及使复制更健壮，还是需要运维人员做更多的工作。在主数据库上，可以使用SHOW MASTER STATUS命令查看当前主数据库的二进制日志位置和配置（参见7.2.1节介绍的“配置主数据库和备库”部分），还可以使用show master logs命令查看主数据库当前有哪些二进制日志是在磁盘上的，如图7-18所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573392690-9559cff5-1f47-43c0-b135-0a1714b249b7.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u9c4eb90c&originHeight=338&originWidth=385&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u2eec520e-fc17-4f14-bd3a-90692538511&title=">图7-18 主数据库在磁盘上的二进制文件还可以通过SHOW BINLOG EVENTS命令来查看复制事件，如图7-19所示。<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/22295732/1653573392652-f5cca40e-9f68-44f9-b9d3-972ea50ab3c2.jpeg#clientId=ud43d93cd-6fda-4&from=paste&id=u81034386&originHeight=198&originWidth=1136&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u49f528be-ede6-42d2-bf7d-e793e03f35f&title=">图7-19 查看复制事件</p>
<h3 id="7-3-2-测量从数据库延迟"><a href="#7-3-2-测量从数据库延迟" class="headerlink" title="7.3.2 测量从数据库延迟"></a>7.3.2 测量从数据库延迟</h3><p>一个比较普遍的问题是如何监视从数据库落后主数据库的延迟有多大。虽然<strong>SHOW SLAVE STATUS输出的Seconds_ behind_ master列理论上显示了从数据库的延时，</strong>但由于各种各样的原因，其并不总是准确的，主要问题如下。（1）从数据库Seconds_ behind_ master的值是通过将服务器当前的时间戳与二进制日志中事件的时间戳相对比得到的，所以只有在执行事件时才能报告延迟。（2）如果从数据库复制线程没有运行，就会报延迟为NULL。（3）一些错误（例如，主从的max_attowed_packet不匹配，或者网络不稳定）可能中断复制或者停止复制线程，但Seconds_behind_master将显示为0而不是显示错误。（4）即使从数据库线程正在运行，从数据库有时候可能无法计算延时，如果发生这种情况，从数据库会报0或者NULL。（5）一个大事务可能会导致延迟波动，例如，有一个事务更新数据长达一个小时，最后提交，这条更新将比它实际发生时间要晚一个小时才被记录到二进制日志中。当从数据库执行这条语句时，会临时地报告从数据库延迟为一个小时，然后又很快变成0。（6）如果分发主数据库落后了，并且其本身也有已经迫赶上它的从数据库，从数据库的延迟将显示为0，而事实上和源主数据库之间是有延迟的。解决这些问题的办法是忽略Seconds_ behind_ master的值，并使用一些可以直接观察和衡量的方式来监视从数据库延迟，最好的解决办法是使用heartbeat record，这是一个在主数据库上会每秒更新一次的时间戳。为了计算延时，可以直接用从数据库当前的时间戳减去心跳记录的值，这个方法能够解决前面提到的所有问题，这样做另外一个好处是还可以通过时间戳知道从数据库当前的复制状况，包含在Percona Toolkit（1.4.2中介绍过该工具）里的pt-heartbeat脚本是“复制心跳”最流行的一种实现。心跳还有其他好处，记录在二进制日志中的心跳记录拥有许多用途，如在一些很难解决的场景下可以用于灾难恢复。</p>
<h3 id="7-3-3-判断主数据库、从数据库是否一致"><a href="#7-3-3-判断主数据库、从数据库是否一致" class="headerlink" title="7.3.3 判断主数据库、从数据库是否一致"></a>7.3.3 判断主数据库、从数据库是否一致</h3><p>在理想情况下，从数据库和主数据库的数据应该是完全一样的，但事实上从数据库可能发生错误并导致数据不一致，即使没有明显的错误，从数据库同样可能因为MySQL自身的特性导致数据不一致，如MySQL的Bug、网络中断、服务器崩溃等非正常关闭或者其他一些错误。按照经验来看，主从一致应该是一种规范，而不是例外，也就是说，<strong>检查主从一致性应该是运维的一个日常工作，</strong>特别是当使用从数据库来做备份时尤为重要，因为不可能从一个已经损坏的从数据库里获得备份数据。MySQL并没有内建的方法来比较一台服务器与别的服务器的数据是否相同，它提供了一些组件来为表和数据生成校验值，如CHECKSUM TABLE，但当复制正在进行时，这种方法是不可行的。Percona Toolkit里的pt-table-checksum能够解决上述几个问题（适应于linux系统，通过操作理解，不难在Windows中手工进行），其主要特性是用于确认从数据库与主数据库的数据是否一致。其工作方式是<strong>通过在主数据库上执行INSERT. SELECT查询，这些查询对数据进行校验并将结果插入到一个表中，这些语句通过复制传递到从数据库，并在从数据库执行一遍，然后可以比较主从上的结果是否一样</strong>。由于该方法是通过复制工作的，它能够给出一致的结果而无须同时把主从上的表都锁上。通常情况下可以在主数据库上运行该工具，参数如下：pt-table-checksum –replicate&#x3D;test.checksum 该命令将检查所有的表，并将结果插入test.checksum表中。当查询在从数据库执行完后，就可以简单地比较主从之间的不同了，pt-table_checksum能够发现服务器所有的从数据库，在每台从数据库上运行查询，并自动地输出结果。pt-table-checksum是唯一能够有效地比较主从一致性的工具。</p>
<h3 id="7-3-4-主数据库重新同步从数据库"><a href="#7-3-4-主数据库重新同步从数据库" class="headerlink" title="7.3.4 主数据库重新同步从数据库"></a>7.3.4 主数据库重新同步从数据库</h3><p>最简单的办法是使用mysyldump转储受影响的数据并重新导入。在整个过程中，如果数据没有发生变化，这种方法会很好。可以在主数据库上简单地锁住表然后进行转储，再等待从数据库赶上主数据库，然后将数据导入从数据库中（需要等待从数据库赶上主数据库，这样就不至于为其他表引入新的不一致，如那些可能通过和失去同步的表做join后进行数据更新的表）。虽然这种方法在许多场景下是可行的，但在一个繁忙的服务器上有可能行不通。其另外一个缺点是在从数据库上通过非复制的方式改变数据。通过复制改变从库数据（通过在主数据库上执行更新）通常是一种安全的技术，因为它避免了竞争条件和其他意料之外的事情。如果表很大或者网络带宽受限，转储和重载数据的代价依然很高。在一个有一百万行的表上对只有一千行不同的数据做转储和重载表是非常浪费资源的。pt-table-sync是Percona Toolkit中的另外一个工具，可以解决该问题，该工具能够高效地查找并解决表之间的不同，它同样通过复制工作，在主数据库上执行查询，在从数据库上重新同步，这样就没有竞争条件。它是结合pt-table-checksum生成的checksum表来工作的，所以只能操作那些已知不同步的表的数据块。但该工具不是在所有场景下都有效，为了正确地同步主数据库和从数据库，该工具要求复制是正常的，否则就无法工作。pt-table-sync设计得很高效，但当数据量非常大时效率还是会很低。比较主数据库和从数据库上1 TB的数据不可避免地会带来额外的工作，尽管如此，在很多场景中，该工具依然能节约大量的时间。</p>
<h3 id="7-3-5-改变主数据库"><a href="#7-3-5-改变主数据库" class="headerlink" title="7.3.5 改变主数据库"></a>7.3.5 改变主数据库</h3><p>数据库运维中或许是为了更迭升级服务器，或许是希望重新分配容量，或许是主数据库出现问题时需要把一台从数据库转换成主数据库。不管出于什么原因，现实中有可能存在改变主数据库的情形，其大体分为计划内的改变或者计划外的改变（如主数据库突然出现了问题）。对于计划内的改变会比较容易（至少比紧急情况下要容易），只需要在从数据库简单地使用CHANGE MASTER TO命令，并指定需要改变的项即可。<strong>1.计划内的改变</strong>把从数据库改变为主数据库在理论上是很简单的，大体有以下步骤：停止向老的主数据库写入；让备库追赶上主数据库；将一台从数据库配置为新的主数据库；将从数据库和写操作指向新的主数据库，然后开启主数据库的写入。更深入一点，下面是大多数配置需要的步骤。（1）停止当前主数据库上的所有写操作，如果可以，最好能将所有的客户端程序关闭（除了复制连接）。为客户端程序建立一个“do not run”这样的类似标记，如果正在使用虚拟IP地址，也可以简单地关闭虚拟IP，然后断开所有的客户端连接，以关闭其打开的事务。（2）通过FLUSH TABLES WITH READ LOCK在主数据库上停止所有活跃的写入，这一步是可选的，也可以在主数据库上设置read_only选项。从这一刻开始，应该禁止向即将被替换的主数据库做任何写入，因为一旦它不是主数据库，写入就意味着数据丢失。注意，即使设置read_only也不会阻止当前已存在的事务继续提交。为了更好地保证这一点，可以“kill”所有打开的事务，这将会真正地结束所有写入。（3）选择一个从数据库作为新的主数据库，并确保它已经完全跟上主数据库（例如，让它执行完所有从主数据库中获得的中继日志）。（4）确保新的主数据库和旧的主数据库的数据是一致的。（5）在新的主数据库上执行STOP SLAVE。（6）在新的主数据库上执行CHANGE MASTER TO MASTER_HOST&#x3D;”，然后再执行RESET SLAVE，使其断开与老的主数据库的连接，并丢弃master.info里记录的信息（如果连接信息记录在my.ini里，会无法正确工作，这也是前面建议不要把复制连接信息写到配置文件里的原因之一）。（7）执行SHOW MASTER STATUS，记录新的主数据库的二进制日志坐标。（8）确保其他从数据库已经追赶上。（9）关闭旧的主数据库。（10）在MySQL 5.1及以上版本中，如果需要，激活新的主数据库上的事件。（11）将客户端连接到新的主数据库。（12）在每台从数据库上执行CHANGE MASTER TO语句，使用之前通过SHOW MASTER STATUS获得的二进制日志坐标，来指向新的主数据库。<strong>从数据库提升为主数据库</strong>当将从数据库提升为主数据库时，要确保从数据库上任何特有的数据库、表和权限已经被移除。此外，可能还需要修改从数据库特有的配置选项，如innodb_flush_log_at_trx_commit选项。同样的，如果是把主数据库降级为从数据库，也要保证进行需要的配置。如果主从的配置相同，就不需要做任何改变。<strong>2.计划外的改变</strong>当主数据库崩溃时，需要提升一台从数据库来代替它，这个过程可能比较烦琐。如果只有一台从数据库，可以直接使用这台从数据库。但如果有超过一台的从数据库，就需要做一些额外的工作。此外，还有潜在的丢失复制事件的问题，可能出现主数据库上已发生的修改还没有更新到它的任何一台从数据库上的情况，甚至还可能有一条语句在主数据库上执行了回滚，但在从数据库上没有回滚，这样从数据库可能超过主数据库的逻辑复制位置。如果能在某一点恢复主数据库的数据，也许就可以取得丢失的语句并手动执行它们。在以下步骤中，需要确保在计算中使用Master_Log_File和Read_Master_Log_Pos的值。以下是对主从拓扑结构中的从数据库进行提升的过程。（1）确定哪台从数据库的数据最新。检查每台从数据库上SHOW SLAVE STATUS命令的输出，选择其中Master_Log_File&#x2F;read_Master Log_Pos的值为最新的那个。（2）所有从数据库执行完所有从崩溃前的旧的主数据库那里获得的中继日志。如果在未完成前修改从数据库的主数据库，它会抛弃剩下的日志事件，从而无法获知该从数据库在什么地方停止。（3）执行前面计划内的改变中的第（5）～（7）步。（4）比较每台从数据库和新的主数据库上的Master_Log_File&#x2F;Read_ Master_Log_Pos的值。（5）执行前面计划内的改变中的第（10）～（12）步。正如7.1节开始我们推荐的，假设已经在所有的从数据库上开启了log_bin和log_stave_updates，可以帮助我们快速将所有的从数据库恢复到一个一致的时间点。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务</category>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>关闭win10更新</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Windows/%E5%85%B3%E9%97%ADwin10%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<p>用联想工具关闭一下，不行的话再根据下面设置<img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633672853992-cb3a863b-5c41-4d08-8984-bd6ef8cea4d4.png#clientId=u949d7cd2-36a8-4&from=paste&height=291&id=u4e2df62c&name=%E5%9B%BE%E7%89%87.png&originHeight=291&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=111284&status=done&style=none&taskId=uc13f3282-ef82-462c-a304-f1af1a83e3b&title=&width=554" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633672859029-f4d78003-afab-4c53-84ee-e31bffcddc1e.png#clientId=u949d7cd2-36a8-4&from=paste&height=489&id=uac2f48ff&name=%E5%9B%BE%E7%89%87.png&originHeight=489&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=109100&status=done&style=none&taskId=u8098a88d-de93-469f-90cf-395cf81d461&title=&width=554" alt="图片.png"></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>系统</tag>
        <tag>关闭win10更新</tag>
      </tags>
  </entry>
  <entry>
    <title>封装系统</title>
    <url>/2022/01/10/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Windows/%E5%B0%81%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<ol>
<li>定制母盘 （略）</li>
<li>下载镜像后解压使用NTLite打开<ol>
<li>组件移除</li>
<li>移除无用版本</li>
</ol>
</li>
</ol>
<hr>
<ol start="2">
<li>准备系统封装环境 （略）</li>
<li>安装母盘 </li>
<li>使用VM虚拟机安装母盘系统</li>
<li>在系统引导安装界面按Ctrl+shift+f3进入审核模式</li>
<li>启用内置Administrator账号</li>
<li>激活系统</li>
<li>安装运行库</li>
</ol>
<hr>
<ol start="4">
<li>系统优化清理 </li>
<li>鱼儿系统工具<ol>
<li>系统系统</li>
<li>系统清理</li>
<li>免疫流氓软件(暂时略过)</li>
</ol>
</li>
<li>Dism++清理<ol>
<li>空间回收</li>
</ol>
</li>
<li>软媒<ol>
<li>一键清理</li>
<li>系统瘦身</li>
<li>磁盘占用（删除与WindowsDefender相关）（暂时略过）</li>
</ol>
</li>
</ol>
<hr>
<ol start="5">
<li>常用软件安装及设置 </li>
<li>基础软件安装</li>
<li>激活office</li>
<li>拷贝维护工具至C盘</li>
</ol>
<hr>
<ol start="6">
<li>封装前再次优化清理 </li>
<li>鱼儿系统<ol>
<li>系统清理</li>
<li>原创工具-&gt;个性设置与应用关联备份还原-&gt;默认应用关联（系统中，封装前)</li>
</ol>
</li>
<li>关闭磁盘索引</li>
<li>软媒<ol>
<li>一键清理</li>
<li>系统隐私</li>
</ol>
</li>
<li>Dism<ol>
<li>空间回收</li>
</ol>
</li>
<li>备份系统个性设置（PE中，封装前）</li>
</ol>
<hr>
<ol start="7">
<li>使用ES5S进行封装 </li>
<li>制作自解压文件(可略过)<ol>
<li>制作压缩文件<ol>
<li>文件参数：<ol>
<li>压缩格式：7z</li>
<li>压缩等级：极限压缩</li>
<li>压缩方法：LZMA</li>
<li>字典大小：64M</li>
<li>单词大小：64</li>
<li>固实数据大小：4GB</li>
<li>加密算法：AES-256</li>
<li>更新方式：添加并替换文件</li>
</ol>
</li>
</ol>
</li>
<li>压缩文件制作成exe自解压文件<ol>
<li>导入7z压缩包</li>
<li>基本设置<ol>
<li>解压路径：%HOMEPATH%\Desktop\</li>
<li>文件覆盖模式：跳过已有文件</li>
<li>解压后自删除：关闭</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>ES5封装第一阶段设置<ol>
<li>参数：<ol>
<li>安全更新：不安装</li>
<li>右边勾全部打钩</li>
<li>完成后退出</li>
</ol>
</li>
</ol>
</li>
<li>ES5封装第二阶段<ol>
<li>拷文件至Sysprep文件夹内<ol>
<li>驱动</li>
<li>自解压程序</li>
<li>激活工具</li>
</ol>
</li>
<li>ES5封装第二阶段设置（PE中）<ol>
<li><p>优化：全选</p>
</li>
<li><p>部署</p>
<ol>
<li>部署控制：开</li>
<li>万能驱动：关</li>
<li>一键运行库：关</li>
<li>右侧勾选项<ol>
<li>自动删除万能驱动解压的驱动文件：开</li>
<li>自动查找并清理可能存在的“AutoRun”病毒：开</li>
</ol>
</li>
</ol>
</li>
<li><p>系统</p>
<ol>
<li>系统还原：关闭</li>
<li>系统休眠：打开</li>
<li>电池方案：平衡</li>
<li>变更用户目录：关</li>
<li>转移虚拟内存：关</li>
<li>左下角勾选项<ol>
<li>彻底清理系统中残留的驱动信息（慎用）：关</li>
</ol>
</li>
</ol>
</li>
<li><p>用户</p>
<ol>
<li>创建新用户：关</li>
<li>启动admin账户：开</li>
<li>避免产生Admin.xxx用户目录：开</li>
<li>自动登录：关</li>
</ol>
</li>
<li><p>网络：全关</p>
</li>
<li><p>任务</p>
<table>
<thead>
<tr>
<th>部署中</th>
<th>运行</th>
<th>%SystemDrive%\Sysprep……(驱动文件)</th>
</tr>
</thead>
<tbody><tr>
<td>部署中</td>
<td>运行</td>
<td>%SystemDrive%\Sysprep……(自解压文件)</td>
</tr>
<tr>
<td>部署后</td>
<td>运行</td>
<td>%SystemDrive%\Sysprep……  &#x2F;k19(激活工具-激活Windows) PS:需要使用静默参数</td>
</tr>
<tr>
<td>部署后</td>
<td>运行</td>
<td>%SystemDrive%\Sysprep……  &#x2F;o(激活工具-激活office) PS:需要使用静默参数</td>
</tr>
</tbody></table>
</li>
<li><p>其他：全关</p>
</li>
</ol>
</li>
<li>注入目标系统的RunOnce.reg注册表文件和内容，目的是让系统进入桌面后执行一次指定路径的批处理文件（略）</li>
<li>还原系统个性设置和默认应用关联</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>系统</tag>
        <tag>封装系统</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>控制面板</title>
    <url>/2022/01/21/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Windows/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="工作网络-家庭网络-公共网络"><a href="#工作网络-家庭网络-公共网络" class="headerlink" title="工作网络 家庭网络 公共网络"></a>工作网络 家庭网络 公共网络</h2><ol>
<li>家庭网络：充分信任的网络——“网络发现”开启、相互”权限”较高</li>
<li>工作网络：”网络发现”开启、允许共享文件与打印机等</li>
<li>公共网络：不信任网络——大部分设置都将关闭</li>
</ol>
<h2 id="国内时间服务器"><a href="#国内时间服务器" class="headerlink" title="国内时间服务器"></a>国内时间服务器</h2><p> ntp1.aliyun.com	ntp2.aliyun.com	ntp3.aliyun.com	ntp4.aliyun.com	ntp5.aliyun.com	ntp6.aliyun.com	ntp7.aliyun.com  </p>
<ol>
<li>1</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>Windows</category>
        <category>系统设置</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>系统</tag>
        <tag>Windows</tag>
        <tag>系统设置</tag>
      </tags>
  </entry>
  <entry>
    <title>模板文件</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Windows/%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<ol>
<li>截屏全黑</li>
</ol>
<p>原因可能是操作不当，或是设置不对或者是系统为了能正常运行一些大型游戏等而在显卡显示中默认启用了DirectDraw加速，就会导致截图黑屏解决方法HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\GraphicsDrivers\DCI，将Timeout的数值数据从“7”更改为“0”。然后重启资源管理器</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>系统问题</tag>
        <tag>系统系统</tag>
        <tag>计算机计算机</tag>
      </tags>
  </entry>
  <entry>
    <title>测试杀软代码</title>
    <url>/2022/03/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/%E6%9D%80%E8%BD%AF/%E6%B5%8B%E8%AF%95%E6%9D%80%E8%BD%AF%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<ol>
<li>创建一个文本文档，复制 [X5O!P%@AP<a href="mailto:X5O!P%@AP[4/PZX54%28P^%297CC%297%7d$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H">4&#x2F;PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H</a>*  </li>
<li>使用杀软扫描</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>杀软</category>
      </categories>
  </entry>
  <entry>
    <title>智能宽带超级管理员默认账号</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A1%AC%E4%BB%B6/%E5%85%89%E7%8C%AB/%E6%99%BA%E8%83%BD%E5%AE%BD%E5%B8%A6%E8%B6%85%E7%BA%A7%E7%AE%A1%E7%90%86%E5%91%98%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7/</url>
    <content><![CDATA[<p>移动：账号:     CMCCAdmin密码:     aDm8H%MdA</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>硬件</category>
        <category>光猫</category>
      </categories>
      <tags>
        <tag>智能宽带超级管理员默认账号</tag>
      </tags>
  </entry>
  <entry>
    <title>错误代码操作</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A1%AC%E4%BB%B6/%E6%89%93%E5%8D%B0%E6%9C%BA/%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>0x0000011b</p>
<ol>
<li>卸载这些补丁KB5005569&#x2F;KB5005573&#x2F;KB5005568&#x2F;KB5005566&#x2F;KB5005565</li>
<li>关闭自动更新</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>硬件</category>
        <category>打印机</category>
      </categories>
      <tags>
        <tag>错误代码操作</tag>
        <tag>打印机</tag>
      </tags>
  </entry>
  <entry>
    <title>打印机扫描</title>
    <url>/2021/11/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A1%AC%E4%BB%B6/%E6%89%93%E5%8D%B0%E6%9C%BA/%E6%89%93%E5%8D%B0%E6%9C%BA%E6%89%AB%E6%8F%8F/</url>
    <content><![CDATA[<p>安装<img src="https://i.loli.net/2021/11/24/h4NMvqW7esJwt2D.png#id=nNoE5&originHeight=20&originWidth=272&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://i.loli.net/2021/11/24/Jzk8gLtu6IPBGh2.png#id=rOcfA&originHeight=310&originWidth=974&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://i.loli.net/2021/11/24/FtDKqQEJSZrgMHv.png#id=N6iMY&originHeight=340&originWidth=864&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">使用<img src="https://i.loli.net/2021/11/24/RqozUEdPIy4rOxw.png#id=Dbb4b&originHeight=316&originWidth=304&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://i.loli.net/2021/11/24/pwkntTcdLhAX18r.png#id=xALX0&originHeight=419&originWidth=497&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://i.loli.net/2021/11/24/ZjBtMGdDFmcy8i2.png#id=S32H5&originHeight=186&originWidth=517&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://i.loli.net/2021/11/24/2Sj1pW4tMxhNKOA.png#id=qcRSj&originHeight=441&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>硬件</category>
        <category>打印机</category>
      </categories>
      <tags>
        <tag>打印机</tag>
        <tag>打印机扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>扫描枪</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A1%AC%E4%BB%B6/%E6%89%AB%E7%A0%81%E6%9E%AA/%E6%89%AB%E6%8F%8F%E6%9E%AA/</url>
    <content><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673738101-f7685829-5b9a-4792-a175-7ace7997870f.png#clientId=uc5978666-63e2-4&from=paste&height=450&id=uc64b86fc&name=%E5%9B%BE%E7%89%87.png&originHeight=450&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=false&size=461562&status=done&style=none&taskId=u15ce657c-e4df-45ed-9d5b-c104aabb412&title=&width=504" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673741142-ab4b058d-b56e-4e91-a27d-e201834a1b16.png#clientId=uc5978666-63e2-4&from=paste&height=314&id=u5bb421a3&name=%E5%9B%BE%E7%89%87.png&originHeight=314&originWidth=296&originalType=binary&ratio=1&rotation=0&showTitle=false&size=260500&status=done&style=none&taskId=u8643bd2f-6e89-41c2-abc8-50be1efb217&title=&width=296" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673744189-5612db07-1466-4c16-8238-524ac472e1b3.png#clientId=uc5978666-63e2-4&from=paste&height=399&id=u3d150885&name=%E5%9B%BE%E7%89%87.png&originHeight=399&originWidth=393&originalType=binary&ratio=1&rotation=0&showTitle=false&size=383626&status=done&style=none&taskId=udcd3d395-fdf8-4c3a-999b-02c06e876e6&title=&width=393" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673747831-fa099c8f-aa1b-46eb-8fe6-63aa24f354d8.png#clientId=uc5978666-63e2-4&from=paste&height=554&id=u534e8861&name=%E5%9B%BE%E7%89%87.png&originHeight=554&originWidth=421&originalType=binary&ratio=1&rotation=0&showTitle=false&size=515224&status=done&style=none&taskId=ud34d65c5-4491-48a5-9ee6-ed42614928e&title=&width=421" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673750528-78899e1f-8dcd-47ef-ba7a-817937d6cd30.png#clientId=uc5978666-63e2-4&from=paste&height=325&id=u5cf777f4&name=%E5%9B%BE%E7%89%87.png&originHeight=325&originWidth=276&originalType=binary&ratio=1&rotation=0&showTitle=false&size=262385&status=done&style=none&taskId=ub2714738-15f4-413f-9ac3-c5864545a4a&title=&width=276" alt="图片.png"></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>硬件</category>
        <category>扫描枪</category>
      </categories>
      <tags>
        <tag>扫描枪</tag>
        <tag>硬件</tag>
        <tag>基本设置</tag>
      </tags>
  </entry>
  <entry>
    <title>键盘用不了</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A1%AC%E4%BB%B6/%E9%94%AE%E7%9B%98/%E9%94%AE%E7%9B%98%E7%94%A8%E4%B8%8D%E4%BA%86/</url>
    <content><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673686294-d31a8899-7d04-4278-9b2a-f14097c48f0a.png#clientId=u3fd74067-8a20-4&from=paste&height=199&id=uaf2f6c2a&name=%E5%9B%BE%E7%89%87.png&originHeight=199&originWidth=364&originalType=binary&ratio=1&rotation=0&showTitle=false&size=126674&status=done&style=none&taskId=u7a9acd6f-863a-4bc1-9a1e-dfbd69223c2&title=&width=364" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673689527-54c7e3d4-5d7e-4a5f-bf7f-1baabee04c8e.png#clientId=u3fd74067-8a20-4&from=paste&height=228&id=u3c806af4&name=%E5%9B%BE%E7%89%87.png&originHeight=228&originWidth=493&originalType=binary&ratio=1&rotation=0&showTitle=false&size=80797&status=done&style=none&taskId=u36eb03cc-c596-4501-b21c-6226531dfbf&title=&width=493" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673693379-7c68ad52-0471-4065-bc6b-a6389d31c8ed.png#clientId=u3fd74067-8a20-4&from=paste&height=152&id=u23c69b88&name=%E5%9B%BE%E7%89%87.png&originHeight=152&originWidth=338&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31910&status=done&style=none&taskId=u264f0cd4-9764-4cef-942e-e8f350cfb1a&title=&width=338" alt="图片.png">HKEY_LOCAL_MACHINESYSTEMCurrentControlSetControlClass{4D36E96B-E325-11CE-BFC1-08002BE10318}<img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673702418-320961aa-90af-4b7e-85e2-3006e50905bf.png#clientId=u3fd74067-8a20-4&from=paste&height=224&id=u5ac6e8fc&name=%E5%9B%BE%E7%89%87.png&originHeight=224&originWidth=489&originalType=binary&ratio=1&rotation=0&showTitle=false&size=63989&status=done&style=none&taskId=u0b813686-8c44-4044-9864-74a42e79d89&title=&width=489" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673705487-33253102-4230-4e1b-a4d7-2ae04dc89b63.png#clientId=u3fd74067-8a20-4&from=paste&height=271&id=u162e0d36&name=%E5%9B%BE%E7%89%87.png&originHeight=271&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75397&status=done&style=none&taskId=udecc61bb-08a6-456a-99f1-876cb8cad59&title=&width=554" alt="图片.png">再次进入刚才的文档，点击右键，选择新建字符串值。添加项目名称: UpperFilters 内容 :kbdclass。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>硬件</category>
        <category>键盘</category>
      </categories>
      <tags>
        <tag>键盘用不了</tag>
      </tags>
  </entry>
  <entry>
    <title>Python To EXE</title>
    <url>/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/Python%20To%20EXE/</url>
    <content><![CDATA[<h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><ol>
<li>Pyinstaller<ol>
<li>安装命令：pip install pyinstaller</li>
<li>软件说明：pyinstaller是一个独立可执行的软件包，它会自行分析python代码需要的模块和库，自行将python打包成可以脱离于python环境下独立运行的程序</li>
</ol>
</li>
</ol>
<h2 id="打包步骤"><a href="#打包步骤" class="headerlink" title="打包步骤"></a>打包步骤</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 假定C盘下有一个1.py的文件</span><br><span class="line"># 打包cmd</span><br><span class="line">cd C:\</span><br><span class="line">pyinstaller -F 1.py</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">例子：</span><br><span class="line">installer -F py_word.py 打包exe</span><br><span class="line">Pyinstaller -F -w py_word.py 不带控制台的打包</span><br><span class="line">Pyinstaller -F -w -i chengzi.ico py_word.py 打包指定exe图标打包</span><br></pre></td></tr></table></figure>
<p>打包完成后有一个dist文件夹，可执行文件就在里面</p>
<h2 id="进阶：压缩打包-amp-更多指令参考"><a href="#进阶：压缩打包-amp-更多指令参考" class="headerlink" title="进阶：压缩打包&amp;更多指令参考"></a>进阶：压缩打包&amp;更多指令参考</h2><p><a href="https://blog.csdn.net/libaineu2004/article/details/112612421">Python脚本打包成exe，看这一篇就够了！</a></p>
]]></content>
  </entry>
  <entry>
    <title>Python目录结构</title>
    <url>/2022/01/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/Python%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>&#x2F;<strong>–docs————说明文档</strong><strong>–db————数据库相关</strong><strong>–projectname————源代码</strong>—-__pycache__————标注该目录为模块–tests————测试文件目录–main.py————主程序入口–README.md————项目版本说明文件–readme.txt————项目说明文件–requirements.txt——依赖包记录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip freeze &gt; requirements.txt   <span class="comment">#生成requirements.txt文件</span></span><br></pre></td></tr></table></figure>
<p>–setup——脚本安装–test_main.py——测试程序</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>Python目录结构</tag>
        <tag>Python</tag>
        <tag>计算机语言</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/Python%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85%E5%8F%8A%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>title: Python程序安装及基础配置<br>date: 2023-4-19 15:05:29<br>tags:<br>●<br>categories:<br>● 计算机<br>● 计算机语言<br>● Python</p>
<ol>
<li><p>下载和安装</p>
</li>
<li><p>配置环境变量</p>
</li>
<li><p>配置PIP环境变量<br>pip文件在Scripts里面。例如：C:\Python27\Scripts<br>添加到path即可<br>pip –version测试</p>
</li>
<li><p>更换下载源<br>pip install -i <a href="https://pypi.douban.com/simple/">https://pypi.douban.com/simple/</a> pyinstaller #豆瓣源<br>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> pyinstaller #清华源</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Python错误处理</title>
    <url>/2022/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/Python%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="python运行代码不显示warning输出"><a href="#python运行代码不显示warning输出" class="headerlink" title="python运行代码不显示warning输出"></a>python运行代码不显示warning输出</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"> </span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h1 id="运行程序时出现SyntaxError-Non-UTF-8-code-starting错误"><a href="#运行程序时出现SyntaxError-Non-UTF-8-code-starting错误" class="headerlink" title="运行程序时出现SyntaxError: Non-UTF-8 code starting错误"></a>运行程序时出现SyntaxError: Non-UTF-8 code starting错误</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line">或者</span><br><span class="line"><span class="comment"># coding=UTF8</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Android CameraX 使用入门</title>
    <url>/2022/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Android/Android%20CameraX%20%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="1-添加Gradle依赖"><a href="#1-添加Gradle依赖" class="headerlink" title="1. 添加Gradle依赖"></a>1. 添加Gradle依赖</h2><ol>
<li><p>打开build.gradle(Module: app)文件，并将CameraX依赖项添加到我们的应用Gradle文件中的“ 依赖项”部分中：  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">def camerax_version = <span class="string">&quot;1.0.0-beta03&quot;</span></span><br><span class="line"><span class="comment">// CameraX core library using camera2 implementation</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-camera2:<span class="variable">$camerax_version</span>&quot;</span></span><br><span class="line"><span class="comment">// CameraX Lifecycle Library</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-lifecycle:<span class="variable">$camerax_version</span>&quot;</span></span><br><span class="line"><span class="comment">// CameraX View class</span></span><br><span class="line">implementation <span class="string">&quot;androidx.camera:camera-view:1.0.0-alpha10&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>CameraX需要Java 8中的某些方法，因此我们需要相应地设置编译选项。在该android块的末尾，紧接着buildTypes，添加以下内容：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">compileOptions &#123;</span><br><span class="line">    sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-设置MainActivity-kt"><a href="#2-设置MainActivity-kt" class="headerlink" title="2. 设置MainActivity.kt"></a>2. 设置MainActivity.kt</h2><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.cameraxapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.Manifest</span><br><span class="line"><span class="keyword">import</span> android.content.pm.PackageManager</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> android.widget.Button</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast</span><br><span class="line"><span class="keyword">import</span> androidx.core.app.ActivityCompat</span><br><span class="line"><span class="keyword">import</span> androidx.core.content.ContextCompat</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors</span><br><span class="line"><span class="keyword">import</span> androidx.camera.core.*</span><br><span class="line"><span class="keyword">import</span> androidx.camera.lifecycle.ProcessCameraProvider</span><br><span class="line"><span class="keyword">import</span> androidx.camera.view.PreviewView</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat</span><br><span class="line"><span class="keyword">import</span> java.util.*</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService</span><br><span class="line"><span class="keyword">typealias</span> LumaListener = (luma: <span class="built_in">Double</span>) -&gt; <span class="built_in">Unit</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> preview: Preview? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> imageCapture: ImageCapture? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> imageAnalyzer: ImageAnalysis? = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> camera: Camera? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> outputDirectory: File</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> cameraExecutor: ExecutorService</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Request camera permissions</span></span><br><span class="line">        <span class="keyword">if</span> (allPermissionsGranted()) &#123;</span><br><span class="line">            startCamera()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ActivityCompat.requestPermissions(</span><br><span class="line">                <span class="keyword">this</span>, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setup the listener for take photo button</span></span><br><span class="line">        camera_capture_button.setOnClickListener &#123; takePhoto() &#125;</span><br><span class="line"></span><br><span class="line">        outputDirectory = getOutputDirectory()</span><br><span class="line"></span><br><span class="line">        cameraExecutor = Executors.newSingleThreadExecutor()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预览将要拍摄的照片</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//创建【ProcessCameraProvider】实例</span></span><br><span class="line">        <span class="keyword">val</span> cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        cameraProviderFuture.addListener(Runnable &#123;</span><br><span class="line">            <span class="comment">// Used to bind the lifecycle of cameras to the lifecycle owner</span></span><br><span class="line">            <span class="keyword">val</span> cameraProvider: ProcessCameraProvider = cameraProviderFuture.<span class="keyword">get</span>()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Preview</span></span><br><span class="line">            preview = Preview.Builder()</span><br><span class="line">                .build()</span><br><span class="line"></span><br><span class="line">            imageCapture = ImageCapture.Builder()</span><br><span class="line">                .build()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Select back camera</span></span><br><span class="line">            <span class="keyword">val</span> cameraSelector = CameraSelector.Builder().requireLensFacing(CameraSelector.LENS_FACING_BACK).build()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Unbind use cases before rebinding</span></span><br><span class="line">                cameraProvider.unbindAll()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Bind use cases to camera</span></span><br><span class="line">                camera = cameraProvider.bindToLifecycle(</span><br><span class="line">                    <span class="keyword">this</span>, cameraSelector, preview, imageCapture)</span><br><span class="line">                preview?.setSurfaceProvider(viewFinder.createSurfaceProvider(camera?.cameraInfo))</span><br><span class="line">            &#125; <span class="keyword">catch</span>(exc: Exception) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Use case binding failed&quot;</span>, exc)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, ContextCompat.getMainExecutor(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//拍照功能</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">takePhoto</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// Get a stable reference of the modifiable image capture use case</span></span><br><span class="line">        <span class="keyword">val</span> imageCapture = imageCapture ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建一个文件来保存图像。添加时间戳，以便文件名是唯一的。</span></span><br><span class="line">        <span class="keyword">val</span> photoFile = File(</span><br><span class="line">            outputDirectory,</span><br><span class="line">            SimpleDateFormat(FILENAME_FORMAT, Locale.US</span><br><span class="line">            ).format(System.currentTimeMillis()) + <span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Create output options object which contains file + metadata</span></span><br><span class="line">        <span class="keyword">val</span> outputOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setup image capture listener which is triggered after photo has</span></span><br><span class="line">        <span class="comment">// been taken</span></span><br><span class="line">        imageCapture.takePicture(</span><br><span class="line">            outputOptions, ContextCompat.getMainExecutor(<span class="keyword">this</span>), <span class="keyword">object</span> : ImageCapture.OnImageSavedCallback &#123;</span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(exc: <span class="type">ImageCaptureException</span>)</span></span> &#123;</span><br><span class="line">                    Log.e(TAG, <span class="string">&quot;Photo capture failed: <span class="subst">$&#123;exc.message&#125;</span>&quot;</span>, exc)</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onImageSaved</span><span class="params">(output: <span class="type">ImageCapture</span>.<span class="type">OutputFileResults</span>)</span></span> &#123;</span><br><span class="line">                    <span class="keyword">val</span> savedUri = Uri.fromFile(photoFile)</span><br><span class="line">                    <span class="keyword">val</span> msg = <span class="string">&quot;Photo capture succeeded: <span class="variable">$savedUri</span>&quot;</span></span><br><span class="line">                    Toast.makeText(baseContext, msg, Toast.LENGTH_SHORT).show()</span><br><span class="line">                    Log.d(TAG, msg)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">allPermissionsGranted</span><span class="params">()</span></span> = REQUIRED_PERMISSIONS.all &#123;</span><br><span class="line">        ContextCompat.checkSelfPermission(</span><br><span class="line">            baseContext, it) == PackageManager.PERMISSION_GRANTED</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getOutputDirectory</span><span class="params">()</span></span>: File &#123;</span><br><span class="line">        <span class="keyword">val</span> mediaDir = externalMediaDirs.firstOrNull()?.let &#123;</span><br><span class="line">            File(it, resources.getString(R.string.app_name)).apply &#123; mkdirs() &#125; &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">if</span> (mediaDir != <span class="literal">null</span> &amp;&amp; mediaDir.exists())</span><br><span class="line">            mediaDir <span class="keyword">else</span> filesDir</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CameraXBasic&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> FILENAME_FORMAT = <span class="string">&quot;yyyy-MM-dd-HH-mm-ss-SSS&quot;</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> REQUEST_CODE_PERMISSIONS = <span class="number">10</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.CAMERA)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//权限判断</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRequestPermissionsResult</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        requestCode: <span class="type">Int</span>, permissions: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;, grantResults:</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">IntArray</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (requestCode == REQUEST_CODE_PERMISSIONS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allPermissionsGranted()) &#123;</span><br><span class="line">                startCamera()</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>,</span><br><span class="line">                    <span class="string">&quot;Permissions not granted by the user.&quot;</span>,</span><br><span class="line">                    Toast.LENGTH_SHORT).show()</span><br><span class="line">                finish()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-请求相机权限"><a href="#3-请求相机权限" class="headerlink" title="3. 请求相机权限"></a>3. 请求相机权限</h2><ol>
<li>打开AndroidManifest.xml并在application标签之前添加这些行。  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;uses-feature android:name=<span class="string">&quot;android.hardware.camera.any&quot;</span> /&gt;</span><br><span class="line">&lt;uses-permission android:name=<span class="string">&quot;android.permission.CAMERA&quot;</span> /&gt;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Android studio</category>
      </categories>
  </entry>
  <entry>
    <title>Android studio</title>
    <url>/2022/03/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Android/Android%20studio/</url>
    <content><![CDATA[<h2 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h2><ul>
<li><strong>Language</strong> 下拉菜单中选择 <strong>Java</strong> 或 <strong>Kotlin</strong>。</li>
<li><strong>app &gt; java &gt; com.example.myfirstapp &gt; MainActivity</strong></li>
</ul>
<p> 这是主 activity。它是应用的入口点。当您构建和运行应用时，系统会启动此 <a href="https://developer.android.google.cn/reference/android/app/Activity?hl=zh-cn">Activity</a> 的实例并加载其布局。  </p>
<ul>
<li><strong>app &gt; res &gt; layout &gt; activity_main.xml</strong></li>
</ul>
<p> 此 XML 文件定义了 activity 界面 (UI) 的布局。它包含一个 <a href="https://developer.android.google.cn/reference/android/widget/TextView?hl=zh-cn">TextView</a> 元素，其中具有“Hello, World!”文本  </p>
<ul>
<li><strong>app &gt; manifests &gt; AndroidManifest.xml</strong></li>
</ul>
<p><a href="https://developer.android.google.cn/guide/topics/manifest/manifest-intro?hl=zh-cn">清单文件</a>描述了应用的基本特性并定义了每个应用组件。  </p>
<ul>
<li><strong>Gradle Scripts &gt; build.gradle</strong></li>
</ul>
<p> 有两个使用此名称的文件：一个针对项目“Project: My First App”，另一个针对应用模块“Module: My_First_App.app”。每个模块均有自己的 build.gradle 文件，但此项目当前仅有一个模块。使用每个模块的 build.gradle 文件控制 <a href="https://developer.android.google.cn/studio/releases/gradle-plugin?hl=zh-cn">Gradle 插件</a>构建应用的方式。如需详细了解此文件，请参阅<a href="https://developer.android.google.cn/studio/build?hl=zh-cn#module-level">配置 build</a>。  </p>
<h2 id="2-构建界面"><a href="#2-构建界面" class="headerlink" title="2. 构建界面"></a>2. 构建界面</h2><ul>
<li>点击并按住边上的【锚点】，将其向【目标】拖动，然后将其释放。这是一个约束条件。即相对于【目标】的【距离】</li>
</ul>
<h2 id="3-字符串资源文件"><a href="#3-字符串资源文件" class="headerlink" title="3. 字符串资源文件"></a>3. 字符串资源文件</h2><ul>
<li><strong>app &gt; res &gt; values &gt; strings.xml</strong></li>
</ul>
<p> 这是一个<a href="https://developer.android.google.cn/guide/topics/resources/string-resource?hl=zh-cn">字符串资源</a>文件，您可在此文件中指定所有界面字符串。您可以利用该文件在一个位置管理所有界面字符串，使字符串的查找、更新和本地化变得更加容易。 </p>
<h1 id="4-启动另一个-activity"><a href="#4-启动另一个-activity" class="headerlink" title="4. 启动另一个 activity"></a>4. 启动另一个 activity</h1><h3 id="4-1-响应“Send”按钮"><a href="#4-1-响应“Send”按钮" class="headerlink" title="4.1 响应“Send”按钮"></a>4.1 响应“Send”按钮</h3><ol>
<li><p><strong>app &gt; java &gt; com.example.myfirstapp &gt; MainActivity</strong> 文件中，添加以下 sendMessage() 方法桩：  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Called when the user taps the Send button */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// Do something in response to button</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回【<strong>activity_main.xml】</strong>，给需要触发【sendMessage】的【按钮】，将其属性【<strong>onClick</strong>】设置为【**sendMessage [MainActivity]**】</p>
</li>
</ol>
<h3 id="4-2-构建一个-intent"><a href="#4-2-构建一个-intent" class="headerlink" title="4.2 构建一个 intent"></a>4.2 构建一个 intent</h3><ul>
<li><p><a href="https://developer.android.google.cn/reference/android/content/Intent?hl=zh-cn">Intent</a> 是在相互独立的组件（如两个 activity）之间提供运行时绑定功能的对象。<a href="https://developer.android.google.cn/reference/android/content/Intent?hl=zh-cn">Intent</a> 表示应用执行某项操作的意图。您可以使用 intent 执行多种任务，但在本课中，您的 intent 将用于启动另一个 activity。  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> EXTRA_MESSAGE = <span class="string">&quot;com.example.myfirstapp.MESSAGE&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Called when the user taps the Send button */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMessage</span><span class="params">(view: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> editText = findViewById&lt;EditText&gt;(R.id.editTextTextPersonName)</span><br><span class="line">        <span class="keyword">val</span> message = editText.text.toString()</span><br><span class="line">        <span class="keyword">val</span> intent = Intent(<span class="keyword">this</span>, DisplayMessageActivity::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">            putExtra(EXTRA_MESSAGE, message)</span><br><span class="line">        &#125;</span><br><span class="line">        startActivity(intent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Intent(<span class="keyword">this</span>, DisplayMessageActivity::<span class="keyword">class</span>.java).apply &#123;</span><br><span class="line">            putExtra(EXTRA_MESSAGE, message)</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//指定DisplayMessageActivity实例</span></span><br><span class="line"><span class="comment">//将message传递给putExtra方法，然后方法将值添加到intent中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> EXTRA_MESSAGE = <span class="string">&quot;com.example.myfirstapp.MESSAGE&quot;</span></span><br><span class="line"><span class="comment">//一个公共常量 EXTRA_MESSAGE，因为下一个 activity 将使用该键检索文本值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果出现了闪退我们需要检查注册表【AndroidManifest.xml】。 是否添加了要跳转到页面的相关【Activity 】</p>
</li>
</ul>
<h3 id="4-3-显示消息"><a href="#4-3-显示消息" class="headerlink" title="4.3 显示消息"></a>4.3 显示消息</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_display_message)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get the Intent that started this activity and extract the string</span></span><br><span class="line">    <span class="keyword">val</span> message = intent.getStringExtra(EXTRA_MESSAGE)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Capture the layout&#x27;s TextView and set the string as its text</span></span><br><span class="line">    <span class="keyword">val</span> textView = findViewById&lt;TextView&gt;(R.id.textView).apply &#123;</span><br><span class="line">        text = message</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-添加向上导航功能"><a href="#4-4-添加向上导航功能" class="headerlink" title="4.4 添加向上导航功能"></a>4.4 添加向上导航功能</h3><ul>
<li>若要添加<strong>向上</strong>按钮，您需要在 <a href="https://developer.android.google.cn/guide/topics/manifest/manifest-intro?hl=zh-cn">AndroidManifest.xml</a> 文件中声明哪个 activity 是逻辑父级。打开 <strong>app &gt; manifests &gt; AndroidManifest.xml</strong> 文件，找到 DisplayMessageActivity 的 <activity> 标记，然后将其替换为以下代码：  <figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;.DisplayMessageActivity&quot;</span></span><br><span class="line">          android:parentActivityName=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span><br><span class="line">    &lt;!-- The meta-<span class="keyword">data</span> tag <span class="keyword">is</span> required <span class="keyword">if</span> you support API level <span class="number">15</span> and lower --&gt;</span><br><span class="line">    &lt;meta-<span class="keyword">data</span></span><br><span class="line">        android:name=<span class="string">&quot;android.support.PARENT_ACTIVITY&quot;</span></span><br><span class="line">        android:value=<span class="string">&quot;.MainActivity&quot;</span> /&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Android studio</category>
      </categories>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>开源中国正则表达式测试工具：<a href="https://tool.oschina.net/regex/#">https://tool.oschina.net/regex/#</a></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>正则表达式</category>
      </categories>
  </entry>
  <entry>
    <title>C#</title>
    <url>/2022/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/C#/</url>
    <content><![CDATA[<h2 id="C-与-NET平台"><a href="#C-与-NET平台" class="headerlink" title="C#与 .NET平台"></a>C#与 .NET平台</h2><h3 id="1-NET之道"><a href="#1-NET之道" class="headerlink" title="1 .NET之道"></a>1 .NET之道</h3><h4 id="1-1-NET之前的世界"><a href="#1-1-NET之前的世界" class="headerlink" title="1.1 .NET之前的世界"></a>1.1 .NET之前的世界</h4><p>技术的每一次更新，都有将原先技术的复杂性、不可确定给隐藏起来，和消除的倾向</p>
<h4 id="1-2-NET的解决方案"><a href="#1-2-NET的解决方案" class="headerlink" title="1.2 .NET的解决方案"></a>1.2 .NET的解决方案</h4><p>核心功能：</p>
<ul>
<li>对已有代码具有完全的互操作性：已有的COM二进制组件可以和更新的.NET二进制组件共存，反之亦然。</li>
<li>支持多种编程语言：使用多种编程语言(C#Visual Basic、F#和S#等)创建.NET应用</li>
<li>所有支持NET的语言共享的公共运行时引擎：这个引擎的一个特点是具有一组明确定义的类型，而每一种支持NET的语言都能“明白”这些类型。</li>
<li>全面和彻底的语言集成：.NET支持跨语言的继承、异常处理和代码调试。</li>
<li>全面的基础类库：这个库除隐藏了原始API调用的复杂性外，还提供了被所有支持NET的语言所使用的一致的对象模型。</li>
<li>不关注COM底层操作：IClassFactory、IUnknown、IDispatch、lDL代码和讨时厌的与变量兼容的数据类型（如BSTR、SAFEARRAY等）不会出现在.NET二进制代码中</li>
<li>真正简化的部暑模型：在NET环境下，不需要将二进制单元注册到系统注册表了。</li>
</ul>
<h4 id="1-3-NET平台构造块-CLR、CTS和CLS-简介"><a href="#1-3-NET平台构造块-CLR、CTS和CLS-简介" class="headerlink" title="1.3 .NET平台构造块(CLR、CTS和CLS)简介"></a>1.3 .NET平台构造块(CLR、CTS和CLS)简介</h4><p>从程序员的角度，.NET可以理解为一个运行库环境和一个全面的基础类库。运行库的正式名称是CLR。其主要作用是为我们定位、加载和管理NET类型，同时也负责一些低层细节的工作，如内存管理、应用托管、处理线程、安全检查等.NET平台的另一个构造块是CTS(公共类型系统)。CTS规范完整描述了运行库所支持的所有可能的数据类型和编程结构，指定了这些实体间如何交互，也规定了它们在NET元数据格式中的表示。要注意的是，一种特定的支持.NET的语言可能不支持CTS所定义的所有特性。CLS(公共语言规范)是一个相关的规范，定义了一个让所有NET语言都支持的公共类型和编程结构的子集。这样，如果构造的NET类型仅公开与CLS兼容的特性，那么可以肯定其他所有支持.NET的语言都能使用它们。反之，如果使用了与CLS不兼容的数据类型或编程结构，就不能保证所有的NET语言能和你的NET代码库相交互。</p>
<h5 id="1-1-3-1-基础类库的作用"><a href="#1-1-3-1-基础类库的作用" class="headerlink" title="1.1.3.1 基础类库的作用"></a>1.1.3.1 基础类库的作用</h5><p>除了CLR和CTS&#x2F;CLS规范之外，.NET平台提供了一个适用于全部.NET程序语言的基础类库(BCL)。这个基础类库不仅封装了各种基本类型，如线程、文件输入&#x2F;输出(I&#x2F;O)、图形绘制以及与各种外部硬件设备的交互，还支持实际应用中用到的一些服务</p>
<h4 id="1-4-NET程序集概览"><a href="#1-4-NET程序集概览" class="headerlink" title="1.4 .NET程序集概览"></a>1.4 .NET程序集概览</h4><p>当使用支持NET的编译器生成*.dll或*.exe文件时，二进制大对象会被打包成一个程序集。不管选择了哪种.NET语言编程，需要明白的是，尽管NET二进制文件与COM服务器和非托管Windows二进制文件（*.dl或*.exe)具有相同的文件扩展名，但它们的内部却是完全不同的。例如，*.dI的.NET二进制文件不会导出与COM运行库进行通信的方法（因为NET不是COM)。</p>
<h5 id="1-1-4-1-单文件程序集和多文件程序集"><a href="#1-1-4-1-单文件程序集和多文件程序集" class="headerlink" title="1.1.4.1 单文件程序集和多文件程序集"></a>1.1.4.1 单文件程序集和多文件程序集</h5><p>大多数情况下，一个程序集只对应一个二进制文件（*.dll或*.exe)。因此，当生成一个.NET *.dll时，可以认为二进制文件和程序集完全一样。多文件程序集则由多个NET二进制文件组成，其中的每个二进制文件称作模块(module)。生成一个多文件程序集时，其中一个模块（称为主模块）一定包含程序集清单（还可能包含CIL指令和各种类型元数据)。其他相关的模块包含一个模块级的程序集清单、CIL和类型元数据。可以想到，主模块会记录程序集清单中所含的其他必要的辅助模块。</p>
<h5 id="1-1-4-2-CIL的作用"><a href="#1-1-4-2-CIL的作用" class="headerlink" title="1.1.4.2 CIL的作用"></a>1.1.4.2 CIL的作用</h5><p>通用中间语言。 目标为.NET 框架的语言被编译成CIL，然后汇编成字节码</p>
<ol>
<li>好处<ol>
<li>CIL是平台无关的。这意味着一个代码库可以在多种操作系统上运行</li>
<li>每种支持.NET的编译器生成的几乎完全相同的CIL指令</li>
</ol>
</li>
<li>将CIL编译成特定平台的指令<ol>
<li>当给定的Jitter编译器将CIL指令编译为相应的机器代码时，它会用适合目标操作系统的方式将结果缓存在内存中</li>
<li>将CIL代码编译成有意义的CPU指令的工具称为Jitter(即时)编译器，有时也称为JIT。。NET运行库环境将使用针对各种不同CPU的JIT编译器，每个编译器都会针对底层平台进行优化。</li>
</ol>
</li>
</ol>
<h5 id="1-1-4-3-NET类型元数据的作用"><a href="#1-1-4-3-NET类型元数据的作用" class="headerlink" title="1.1.4.3 .NET类型元数据的作用"></a>1.1.4.3 .NET类型元数据的作用</h5><p>除了CIL指令以外，.NET程序集还包括全部完整且准确的元数据，这些元数据描述了每一个二进制文件中定义的类型（如类、结构、枚举等）以及每个类型的成员（比如属性、方法和事件等）生成最新和最大的类型元数据总是编译器的工作而不是程序员的工作</p>
<h5 id="1-1-4-3-程序集清单的作用"><a href="#1-1-4-3-程序集清单的作用" class="headerlink" title="1.1.4.3 程序集清单的作用"></a>1.1.4.3 程序集清单的作用</h5><p>在许多细节中，清单记录了所有确保现有程序集正常工作的外部程序集、程序集的版本号、版权信息等。同类型元数据一样，生成程序集清单也是编译器的工作</p>
<h4 id="1-5-CTS"><a href="#1-5-CTS" class="headerlink" title="1.5 CTS"></a>1.5 CTS</h4><p>一个给定的程序集可能包含任意数量的不同“类型”。在.NET领域里，类型(type)是一个一般性的术语，它指的是集合{类，接口，结构，枚举，委托}里的任意一个成员。CTS（公共类型系统)是一个正式的规范，它规定了类型必须如何定义才能被CLR承载</p>
<h5 id="1-1-5-1-CTS类类型"><a href="#1-1-5-1-CTS类类型" class="headerlink" title="1.1.5.1 CTS类类型"></a>1.1.5.1 CTS类类型</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C#类类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Calc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + y&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-2-CTS接口类型"><a href="#1-1-5-2-CTS接口类型" class="headerlink" title="1.1.5.2 CTS接口类型"></a>1.1.5.2 CTS接口类型</h5><p>一般情况下，所有的.NET接口均已大写字母I开头</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C#接口通常被声明为公共的，这样其他程序集就可以实现其功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDraw</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-3-CTS结构类型"><a href="#1-1-5-3-CTS结构类型" class="headerlink" title="1.1.5.3 CTS结构类型"></a>1.1.5.3 CTS结构类型</h5><p>结构可以看做是有值语义的轻量级类类型</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C#结构类型</span></span><br><span class="line"><span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//结构可以包含字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> xPos, yPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构可以包含参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123; xPos = x; yPos = y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构可以定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPosition</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(&#123;0&#125;, &#123;1&#125;)&quot;</span>, xPos, yPos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-4-CTS枚举类型"><a href="#1-1-5-4-CTS枚举类型" class="headerlink" title="1.1.5.4 CTS枚举类型"></a>1.1.5.4 CTS枚举类型</h5><p>枚举是一种便利的编程结构，它可以用来组成名称&#x2F;值对</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C#枚举类型</span></span><br><span class="line"><span class="built_in">enum</span> CharacterType</span><br><span class="line">&#123;</span><br><span class="line">	Widzard = <span class="number">100</span>,</span><br><span class="line">	Fighter = <span class="number">200</span>,</span><br><span class="line">	Thief	= <span class="number">300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-5-CTS委托类型"><a href="#1-1-5-5-CTS委托类型" class="headerlink" title="1.1.5.5 CTS委托类型"></a>1.1.5.5 CTS委托类型</h5><p>委托在.NET中等效于类型安全的C风格的函数指针</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个C#委托类型可以“指向”任意带有两个整型参数且返回一个整型值的方法</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Binaryop</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-CLS"><a href="#1-6-CLS" class="headerlink" title="1.6 CLS"></a>1.6 CLS</h4><p>CLS是一套清晰地描述了支持，.NET的编译器必须支持的最小的和完全的特征集的规则，以生成可由CLR承载的代码，你不需要记忆所有的规则也能成为精通NET的程序员。总地来说，只有那些工具&#x2F;编译器的开发人员才会对CTS和CLS规范的具体细节感兴趣。</p>
<h4 id="1-7-CLR"><a href="#1-7-CLR" class="headerlink" title="1.7 CLR"></a>1.7 CLR</h4><p>从编程角度来说，运行库(runtime)可以理解为执行给定编译代码单元所需的外部服务的集合。.NET平台提供了另一种运行库系统。与其他系统不同在于.NET提供了一个定义明确的运行库层，可以被支持.NET的所有语言和平台所共享</p>
<h4 id="1-8-程序集-x2F-命名空间-x2F-类型的区别"><a href="#1-8-程序集-x2F-命名空间-x2F-类型的区别" class="headerlink" title="1.8 程序集&#x2F;命名空间&#x2F;类型的区别"></a>1.8 程序集&#x2F;命名空间&#x2F;类型的区别</h4><p>命名空间就是一个程序集内相关类型的一个分组。一个程序集（比如mscorlib.dll)可以包含任意个命名空间，每个命名空间又可以包含多种类型。</p>
<h5 id="1-1-8-1-以编程方式访问命名空间"><a href="#1-1-8-1-以编程方式访问命名空间" class="headerlink" title="1.1.8.1 以编程方式访问命名空间"></a>1.1.8.1 以编程方式访问命名空间</h5><p>命名空间只是一种方便我们从逻辑上理解和组织关联类型的方式，这一点应该反复强调。我们再来考虑System命名空间。从你的角度看，可以假设System.Console表示一个在System命名空间中名为Console的类，然而从.NET运行库的角度看，它却不是。运行时引擎只认识名为System.Console的独立实体。</p>
<h5 id="1-1-8-2-引用外部程序集"><a href="#1-1-8-2-引用外部程序集" class="headerlink" title="1.1.8.2 引用外部程序集"></a>1.1.8.2 引用外部程序集</h5><p>Framework程序集都位于称为全局程序集缓存(GAC)的特定目录下。在安装Windows的计算机上，全局程序集缓存默认状态下都位于C:\Windows\Assembly目录下根据构建NET应用程序所用的开发工具的不同，可以有多种不同的方法来告知编译器在编译期间要包括哪些程序集。下一章将会看到如何实现，在此就不再赘述。</p>
<h4 id="1-9-使用ildasm-exe探索程序集"><a href="#1-9-使用ildasm-exe探索程序集" class="headerlink" title="1.9 使用ildasm.exe探索程序集"></a>1.9 使用ildasm.exe探索程序集</h4><p>如果感到掌握NET平台中的每一个命名空间有些困难，那么只需要记住，各命名空间的区别在于，它们包含的语义上关联的类型不同。所以，如果只需要一个控制台程序而不需要用户界面，就可以不需要了解System.windows,Forms、System.Windows和System.web命名空间。中间语言反汇编工具（ildasm.exe）可以加载任意的.NET程序集并分析它的内容</p>
<p><strong>该程序详细使用部分略过</strong></p>
<h4 id="1-10-使用Reflector-exe来查看程序集"><a href="#1-10-使用Reflector-exe来查看程序集" class="headerlink" title="1.10 使用Reflector.exe来查看程序集"></a>1.10 使用Reflector.exe来查看程序集</h4><p>ildasm只能查看底层的CIL代码，而不是使用选择的托管代码查看程序集的实现Reflector提供了一个反汇编窗口和一个允许我们根据所选语言查看底层代码的下拉列表</p>
<p><strong>该程序详细使用部分略过</strong></p>
<h4 id="1-11-部署-NET运行库"><a href="#1-11-部署-NET运行库" class="headerlink" title="1.11 部署.NET运行库"></a>1.11 部署.NET运行库</h4><p>.NET程序集只能运行在安装了.NETFramework的计算机上。就是微软官网下载的NET3.5、4.5</p>
<h4 id="1-12-NET的平台无关性"><a href="#1-12-NET的平台无关性" class="headerlink" title="1.12 .NET的平台无关性"></a>1.12 .NET的平台无关性</h4><p>.NET程序集可以在非微软系统上开发和执行</p>
<h4 id="1-13-小结"><a href="#1-13-小结" class="headerlink" title="1.13 小结"></a>1.13 小结</h4><p>.NET本质上就是一个运行库执行引擎(mscoree.dll)和基础类库(mscorlib.dll等)。CLR可以承载任意符合托管代码规则的.NET二进制文件（又称程序集）。而程序集中有很多CIL指令（以及类型元数据和程序集清单)，这些指令通过即时编译器编译为特定平台的指令。另外，本章还讲述了CLS和CTS的作用。</p>
<h3 id="2-构建C-应用程序"><a href="#2-构建C-应用程序" class="headerlink" title="2 构建C#应用程序"></a>2 构建C#应用程序</h3><h4 id="2-1-NET-Framework-4-SDK的作用"><a href="#2-1-NET-Framework-4-SDK的作用" class="headerlink" title="2.1 .NET Framework 4 SDK的作用"></a>2.1 .NET Framework 4 SDK的作用</h4><p>如果你确实要使用Visual Studio20l0。就没有必要手动安装.NET Frame-work 4 SDK。当我们安装其中任一产品的时候，都会自动安装SDK,所有的东西都是现成的。</p>
<h4 id="2-2-用csc-exe构件-C-应用程序"><a href="#2-2-用csc-exe构件-C-应用程序" class="headerlink" title="2.2 用csc.exe构件 C#应用程序"></a>2.2 用csc.exe构件 C#应用程序</h4><p>略过</p>
<h4 id="2-3-开发环境搭建"><a href="#2-3-开发环境搭建" class="headerlink" title="2.3 开发环境搭建"></a>2.3 开发环境搭建</h4><p>略过</p>
<h2 id="C-核心编程结构"><a href="#C-核心编程结构" class="headerlink" title="C#核心编程结构"></a>C#核心编程结构</h2><h3 id="3-C-核心编程-I"><a href="#3-C-核心编程-I" class="headerlink" title="3 C#核心编程#I"></a>3 C#核心编程#I</h3><h4 id="3-1-一个简单的C-程序"><a href="#3-1-一个简单的C-程序" class="headerlink" title="3.1 一个简单的C#程序"></a>3.1 一个简单的C#程序</h4><p>正式地说，定义Main()方法的类叫做应用程序对象。虽然一个可执行程序可以有多个应用程序对象（在执行单元测试的时候可能有用），但是我们必须通过命令行编译器的&#x2F;main选项或通过位于Visual Studio20l0项目属性编辑器中Application选项卡内的Startup Object下拉列表框（参见第2章)来通知编译器将哪个Main()方法用作入口点。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study.CANDNET4PRO</span>	<span class="comment">//命名空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">simplecprogram</span>	<span class="comment">//类名</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static是静态成员是类级别的（不属于对象级别的），因此在调用之前不需要先创建新的类实例void：不需要在退出方法域之前使用return关键字来显式定义一个返回值</p>
<h5 id="3-1-1-指定应用程序错误代码"><a href="#3-1-1-指定应用程序错误代码" class="headerlink" title="3.1.1 指定应用程序错误代码"></a>3.1.1 指定应用程序错误代码</h5><p>虽然绝大多数Main()方法会以void作为返回值，但是C#和其他C系列的语言一样，都可以从Main()返回一个int。根据惯例，返回值0表示程序正常结束，而其他值（如-1)则表示有错误发生(要知道，值0是自动返回的，即使Main()方法的原型结构返回void）。</p>
<ol>
<li><p>将程序执行成功的返回值修改成-1</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study.CANDNET4PRO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">simplecprogram</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用bat脚本去获取返回值（应用的返回值保存在一个叫做%ERRORLEVEL%的系统环境变量中）。</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">@echo <span class="keyword">off</span></span><br><span class="line"></span><br><span class="line">study</span><br><span class="line">@<span class="keyword">if</span> <span class="string">&quot;%ERRORLEVEL%&quot;</span> == <span class="string">&quot;0&quot;</span> <span class="keyword">goto</span> success</span><br><span class="line"></span><br><span class="line">  :fail</span><br><span class="line">  echo this application has faild!</span><br><span class="line">  echo <span class="keyword">return</span> value = %ERRORLEVEL%</span><br><span class="line">  <span class="keyword">goto</span> <span class="keyword">end</span></span><br><span class="line">:success</span><br><span class="line">echo this application has succeeded!</span><br><span class="line">echo <span class="keyword">return</span> value = %ERRORLEVEL%</span><br><span class="line"><span class="keyword">goto</span> <span class="keyword">end</span></span><br><span class="line">:<span class="keyword">end</span></span><br><span class="line">echo all done.</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="3-1-2-处理命令行参数"><a href="#3-1-2-处理命令行参数" class="headerlink" title="3.1.2 处理命令行参数"></a>3.1.2 处理命令行参数</h5><p>将字符串数据传入数组，其中一个方法是使用C#的for循环</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study.CANDNET4PRO</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">simplecprogram</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; args.Length; i++)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Arg：&#123;0&#125;&quot;</span>, args[i]);</span><br><span class="line">            <span class="comment">//Console.WriteLine(&quot;hello world&quot;);</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cmd输入参数执行返回输出值</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">study.exe /arg1 -arg2 -arg3</span><br><span class="line">&gt;&gt; Arg：/arg1</span><br><span class="line">&gt;&gt; Arg：-arg2</span><br><span class="line">&gt;&gt; Arg：-arg3</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-使用Visual-studio指定命令行参数"><a href="#3-1-3-使用Visual-studio指定命令行参数" class="headerlink" title="3.1.3 使用Visual studio指定命令行参数"></a>3.1.3 使用Visual studio指定命令行参数</h5><p>调式——&gt;xxx调试参数——&gt;命令行参数</p>
<h4 id="3-2-System-nvironment类的其他成员"><a href="#3-2-System-nvironment类的其他成员" class="headerlink" title="3.2 System.nvironment类的其他成员"></a>3.2 System.nvironment类的其他成员</h4><p>这个类允许我们通过不同的静态成员获取大量有关运行.NET应用程序的操作系统的细节</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> c.biancheng.net;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study.CANDNET4PRO</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">ENVIRONMENT</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] theargs = Environment.GetCommandLineArgs();</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">string</span> arg <span class="keyword">in</span> theargs)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;arg：&#123;0&#125;&quot;</span>,arg);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>System.Environment的其他部分属性ExitCode，获取或设置应用程序中任何地方的退出代码Is64BitOperatingSystem，返回布尔值，代表主机是否运行64位操作系统MachineName，获取当前机器的名字NewLine，获得当前环境的换行符SystemDirectory，返回通向系统目录的完整路径UserName，返回启动这个应用程序的用户的名称参考链接：<a href="https://blog.csdn.net/fangchen12312/article/details/54907075">https://blog.csdn.net/fangchen12312/article/details/54907075</a></p>
<h4 id="3-3-System-Console类"><a href="#3-3-System-Console类" class="headerlink" title="3.3 System.Console类"></a>3.3 System.Console类</h4><p>Console类封装了基于控制台应用程序的输入、输出和错误流操作。</p>
<h5 id="3-3-1-使用console类进行基本的输入和输出"><a href="#3-3-1-使用console类进行基本的输入和输出" class="headerlink" title="3.3.1 使用console类进行基本的输入和输出"></a>3.3.1 使用console类进行基本的输入和输出</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;1&quot;</span>);     <span class="comment">//标准输出</span></span><br><span class="line">        getuserdata();      <span class="comment">//调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getuserdata</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;please enter your name&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> username = Console.ReadLine();       <span class="comment">//等待用户输入并赋值</span></span><br><span class="line">        Console.Write(<span class="string">&quot;please enter your age&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> userage = Console.ReadLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ConsoleColor prev = Console.ForegroundColor;  <span class="comment">//获取console当前的颜色</span></span><br><span class="line">        Console.ForegroundColor = ConsoleColor.Yellow;  <span class="comment">//设hiconsole的颜色为黄色</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, userage, username);  <span class="comment">//输出变量</span></span><br><span class="line"></span><br><span class="line">        Console.ForegroundColor = prev;  <span class="comment">//将颜色设置回去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-格式化控制台输出"><a href="#3-3-2-格式化控制台输出" class="headerlink" title="3.3.2 格式化控制台输出"></a>3.3.2 格式化控制台输出</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, userage, username);  <span class="comment">//输出变量</span></span><br><span class="line"><span class="comment">//该语句中的&#123;0&#125;是占位符，可以用来传递一些要等到运行时才能知道其值得数据片段</span></span><br><span class="line"><span class="comment">//也不受顺序限制</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;1&#125; &#123;0&#125;&quot;</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 输出：10 30</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-格式化数值类型"><a href="#3-3-3-格式化数值类型" class="headerlink" title="3.3.3 格式化数值类型"></a>3.3.3 格式化数值类型</h5><table>
<thead>
<tr>
<th>字符串格式字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>c或c</td>
<td>用于格式化货币。默认情况下，这个标志会以当地的货币符号为前缀（美国英语中是一个美元符号[S])</td>
</tr>
<tr>
<td>D或d</td>
<td>用于格式化十进制数。这个标志还可以用干指定填充值的最小个数</td>
</tr>
<tr>
<td>E或e</td>
<td>用于指数记数法。无论指数常数是大写()还是小写()，都进行转换控制</td>
</tr>
<tr>
<td>F或f</td>
<td>用于定点小数的格式化。这个标志也用于指定填充值的最小个数</td>
</tr>
<tr>
<td>G或g</td>
<td>代表general。.这个字符能用来将一个数格式化为定点或指数格式</td>
</tr>
<tr>
<td>N或n</td>
<td>用于基本的数值格式化（带逗号）</td>
</tr>
<tr>
<td>X或x</td>
<td>用于十六进制格式化。如果使用大写的X,十六进制格式也会包含大写的字符</td>
</tr>
</tbody></table>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0:c&#125;, 9999&quot;</span>); <span class="comment">//格式化数值语法</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-4在控制台应用程序外格式化数值数据"><a href="#3-3-4在控制台应用程序外格式化数值数据" class="headerlink" title="3.3.4在控制台应用程序外格式化数值数据"></a>3.3.4在控制台应用程序外格式化数值数据</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> usermessage = <span class="built_in">string</span>.Format(&#123;<span class="number">0</span>:x&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在其他语法中也可以使用格式化字符</p>
<h4 id="3-4-系统数据类型和C-简化符号"><a href="#3-4-系统数据类型和C-简化符号" class="headerlink" title="3.4 系统数据类型和C#简化符号"></a>3.4 系统数据类型和C#简化符号</h4><p>C#数据类型关键字其实是system命名空间中完整类型的简化符号例如：bool、int对应System.Boolean、System.Int32每一个数值类型（short、int等)都对应System命名空间中的一个结构。简单来说，结构是分配在栈上的值类型。而string和object是引用类型，也就是说变量是分配在托管堆上的。值类型可以在内存中快速分配，并且具有固定的可预测的生存周期。</p>
<h5 id="3-4-1-变量声明和初始化"><a href="#3-4-1-变量声明和初始化" class="headerlink" title="3.4.1 变量声明和初始化"></a>3.4.1 变量声明和初始化</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> myInt0; <span class="comment">//先声明后赋值</span></span><br><span class="line">    myInt0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> myInt1 = <span class="number">1</span>; <span class="comment">//声明同时初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> myInt2 = <span class="number">2</span>, myInt3 = <span class="number">3</span>; <span class="comment">//一行声明多个相同实际类型的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-内建数据类型的新操作符"><a href="#3-4-2-内建数据类型的新操作符" class="headerlink" title="3.4.2 内建数据类型的新操作符"></a>3.4.2 内建数据类型的新操作符</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> b = <span class="keyword">new</span> <span class="built_in">bool</span>();    <span class="comment">//设置为false</span></span><br><span class="line">    <span class="built_in">int</span> i = <span class="keyword">new</span> <span class="built_in">int</span>();  <span class="comment">//设置为0</span></span><br><span class="line">    DateTime dt = <span class="keyword">new</span> DateTime();   <span class="comment">//设置为1/1/0001 12:00:00 AM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>允许使用new关键字来创建变量，它姜变量自动设置为其默认值</p>
<h5 id="3-4-3-数据类型类的层次结构"><a href="#3-4-3-数据类型类的层次结构" class="headerlink" title="3.4.3 数据类型类的层次结构"></a>3.4.3 数据类型类的层次结构</h5><p>类层次结构顶端的类型会为派生类型提供一些默认行为</p>
<h5 id="3-4-4-数值数据类型的成员"><a href="#3-4-4-数值数据类型的成员" class="headerlink" title="3.4.4 数值数据类型的成员"></a>3.4.4 数值数据类型的成员</h5><p>.NET的数值类型支持MaxValue和MinValue属性，还有很多其它类型的属性，但在此不提及</p>
<h5 id="3-4-5-System-Boolean成员"><a href="#3-4-5-System-Boolean成员" class="headerlink" title="3.4.5 System.Boolean成员"></a>3.4.5 System.Boolean成员</h5><p>bool类型的值只能来自集合{true|false}</p>
<h5 id="3-4-6-System-Char成员"><a href="#3-4-6-System-Char成员" class="headerlink" title="3.4.6 System.Char成员"></a>3.4.6 System.Char成员</h5><p>char与string二者都是表示一组连续的字符串的，但string表示一组连续的字符串（hello），而char则表示听类型中的单个字符（h）</p>
<h5 id="3-4-7-从字符串中解析数值"><a href="#3-4-7-从字符串中解析数值" class="headerlink" title="3.4.7 从字符串中解析数值"></a>3.4.7 从字符串中解析数值</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bool</span> b = <span class="built_in">bool</span>.Parse(<span class="string">&quot;True&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>parse将字符true解析为bool类型</p>
<h5 id="3-4-8-System-DateTime-和-System-TimeSpan"><a href="#3-4-8-System-DateTime-和-System-TimeSpan" class="headerlink" title="3.4.8 System.DateTime 和 System.TimeSpan"></a>3.4.8 System.DateTime 和 System.TimeSpan</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取当前时间</span></span><br><span class="line">    DateTime dt0 = DateTime.Now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造年月日</span></span><br><span class="line">    DateTime dt1 = <span class="keyword">new</span> DateTime(<span class="number">2010</span>, <span class="number">10</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出格式化.月，日</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, dt1.Date, dt1.DayOfWeek);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建小时、分钟、秒的变量</span></span><br><span class="line">    TimeSpan ts = <span class="keyword">new</span> TimeSpan(<span class="number">4</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从当前timespan中减去15分钟并输出结果</span></span><br><span class="line">    Console.WriteLine(ts.Subtract(<span class="keyword">new</span> TimeSpan(<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-9-NET4-System-Mum-erics命名空间"><a href="#3-4-9-NET4-System-Mum-erics命名空间" class="headerlink" title="3.4.9 NET4 System.Mum.erics命名空间"></a>3.4.9 NET4 System.Mum.erics命名空间</h5><p>NET4引入了一个新的命名空间System.Numerics,它定义了BigInteger结构。顾名思义，BigInteger数据类型可用来表示较大的数值（例如，美国国债），它没有固定的上下限。大部分程序都不需要使用BigIneteger结构，但一旦需要定义较大的数值时，你就需要为项目添加System.Numerics.dll程序集的引用需要特殊设置，此处不提及</p>
<h4 id="3-5-使用字符串数据"><a href="#3-5-使用字符串数据" class="headerlink" title="3.5 使用字符串数据"></a>3.5 使用字符串数据</h4><p>具体字符串方法关键词：System.String成员</p>
<h5 id="3-5-1-基本的字符串操作"><a href="#3-5-1-基本的字符串操作" class="headerlink" title="3.5.1 基本的字符串操作"></a>3.5.1 基本的字符串操作</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> test = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, test);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, test.ToUpper());</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, test.ToLower());</span><br></pre></td></tr></table></figure>
<p>ToUpper()并不会改变变量</p>
<h5 id="3-5-2-字符串拼接"><a href="#3-5-2-字符串拼接" class="headerlink" title="3.5.2 字符串拼接"></a>3.5.2 字符串拼接</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> test0 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> test1 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> test2 = test0 + test1;</span><br><span class="line">    <span class="built_in">string</span> test2 = <span class="built_in">string</span>.concat(test0,test1);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, test2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test0 + test1调用的是string.concat()方法</p>
<h5 id="3-5-3-转义字符"><a href="#3-5-3-转义字符" class="headerlink" title="3.5.3 转义字符"></a>3.5.3 转义字符</h5><p>\a可以出发系统警报</p>
<h5 id="3-5-4-定义逐字字符串"><a href="#3-5-4-定义逐字字符串" class="headerlink" title="3.5.4 定义逐字字符串"></a>3.5.4 定义逐字字符串</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// @在表示路径时候很有用</span></span><br><span class="line">    Console.WriteLine(<span class="string">@&quot;C:\test\test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字字符串可以保存空格</span></span><br><span class="line">    <span class="built_in">string</span> test = <span class="string">@&quot;this is a vert&quot;</span>;</span><br><span class="line">    Console.WriteLine(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-5-字符串和相等性"><a href="#3-5-5-字符串和相等性" class="headerlink" title="3.5.5 字符串和相等性"></a>3.5.5 字符串和相等性</h5><p>进行对引用类型相等性测试时，如果引用类型指向内存中的相同对象，则返回true</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s1 = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, s1 == <span class="string">&quot;TEST&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, s1 == <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-6-字符串是不可变的"><a href="#3-5-6-字符串是不可变的" class="headerlink" title="3.5.6 字符串是不可变的"></a>3.5.6 字符串是不可变的</h5><p>一旦将初始值赋给字符串对象，字符数据就不能改变了。string类型的方法其实返回了一个按修改格式的新字符串对象</p>
<h5 id="3-5-7-System-Text-StringBuilder类型"><a href="#3-5-7-System-Text-StringBuilder类型" class="headerlink" title="3.5.7 System.Text.StringBuilder类型"></a>3.5.7 System.Text.StringBuilder类型</h5><p>StringBuilder的独特之处在于，当我们调用这个类型的成员时，都是直接修改对象内部的字符数据（因此更高效），而不是获取按修改后格式的数据副本。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引用</span></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.AppendLine(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        sb.AppendLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        sb.AppendLine(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Console.WriteLine(sb.ToString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下只能保存16个字符串以下的数据，可以通过构造函数来改变初始值</p>
<h4 id="3-6窄化和宽化数据类型转换"><a href="#3-6窄化和宽化数据类型转换" class="headerlink" title="3.6窄化和宽化数据类型转换"></a>3.6窄化和宽化数据类型转换</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">short</span> numb1 = <span class="number">9</span>, numb2 = <span class="number">10</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&quot;</span>, numb1, numb2, test(numb1, numb2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">test</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//方法test要求传入int，但Main传入了short，但程序造成执行。因为编译器把每一个short隐性宽化成int</span></span><br><span class="line"><span class="comment">//宽化用于定义隐式向上转换，并且不会导致数据丢失</span></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">short</span> numb1 = <span class="number">9</span>, numb2 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">short</span> numb3 = (<span class="built_in">short</span>)test(numb1, numb2);</span><br><span class="line">    <span class="comment">//显示强制转换int为short（并允许数据丢失）</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&quot;</span>, numb1, numb2, numb3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">test</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-1-捕捉窄化数据转换中的错误"><a href="#3-6-1-捕捉窄化数据转换中的错误" class="headerlink" title="3.6.1 捕捉窄化数据转换中的错误"></a>3.6.1 捕捉窄化数据转换中的错误</h5><p>显示强制转换允许我们强制编译器应用窄化转换（即使这样做可能导致数据丢失）。但有可能出现数据上溢，或数据下溢，并且没有报错。C#提供的checked和unchecked关键字将确保数据丢失肯定会被检测到</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span> b1 = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">byte</span> b2 = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//告诉编译器增加CIL代码，如果发生上溢或下溢就抛出异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span> sum = checked((<span class="built_in">byte</span>)Add(b1, b2));</span><br><span class="line">        Console.WriteLine(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (OverflowException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-2-设置项目级别的溢出检测"><a href="#3-6-2-设置项目级别的溢出检测" class="headerlink" title="3.6.2 设置项目级别的溢出检测"></a>3.6.2 设置项目级别的溢出检测</h5><p>C#编译器提供了&#x2F;checked标志。如果启用的话，所有运算都会被检测是否溢出。无需使用checked关键字具体设置到VS属性页中去设置</p>
<h5 id="3-6-3-unchecked关键字"><a href="#3-6-3-unchecked关键字" class="headerlink" title="3.6.3 unchecked关键字"></a>3.6.3 unchecked关键字</h5><p>该关键字是用来忽略溢出运算的</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unchecked</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">byte</span> sum = (<span class="built_in">byte</span>)(b1 + b2);</span><br><span class="line">    Console.WriteLine(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-4-System-Convert的作用"><a href="#3-6-4-System-Convert的作用" class="headerlink" title="3.6.4 System.Convert的作用"></a>3.6.4 System.Convert的作用</h5><p>同样可以用于宽化或窄化数据。是否采用是个人喜好问题</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span> myByte = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> myInt = <span class="number">200</span>;</span><br><span class="line">        myByte = Convert.ToByte(myInt);</span><br><span class="line">        Console.WriteLine(myByte);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-隐式类型本地变量"><a href="#3-7-隐式类型本地变量" class="headerlink" title="3.7 隐式类型本地变量"></a>3.7 隐式类型本地变量</h4><p>为每个变量显示地指定数据类型一直是很好的做法，但C#语言还可以使用var关键字来创造隐式类型的本地变量var关键字不必指定具体数据类型（int、 bool灯）。运行时，编译器将根据本地数据点的初始值来自动推断实际的数据类型</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myIntt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> myBool = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-7-1-隐式类型变量的限制"><a href="#3-7-1-隐式类型变量的限制" class="headerlink" title="3.7.1 隐式类型变量的限制"></a>3.7.1 隐式类型变量的限制</h5><p>隐式类型只能用于方法或属性范围内的本地变量。用var关键字定义返回值、参数或自定义类型的字段数据，都是不合法的。具体略</p>
<h5 id="3-7-2-隐式类型数据是强类型数据"><a href="#3-7-2-隐式类型数据是强类型数据" class="headerlink" title="3.7.2 隐式类型数据是强类型数据"></a>3.7.2 隐式类型数据是强类型数据</h5><p>该数据点将视为它声明的类型。为该变量分配不同类型将导致编译时错误</p>
<h5 id="3-7-3-隐式类型本地变量的用途"><a href="#3-7-3-隐式类型本地变量的用途" class="headerlink" title="3.7.3 隐式类型本地变量的用途"></a>3.7.3 隐式类型本地变量的用途</h5><p>使用var声明本地变量并不能带来什么好处。这样会给其他阅读代码的人带来困扰，由于你无法快速判断实际的数据类型在某些情况下无法显式定义查询的返回类型，这时隐式类型就很有用了在代码中滥用隐式类型是一种糟糕的设计</p>
<h4 id="3-8-C-迭代结构"><a href="#3-8-C-迭代结构" class="headerlink" title="3.8 C#迭代结构"></a>3.8 C#迭代结构</h4><p>C#提供了如下四种迭代结构</p>
<ul>
<li>for</li>
<li>foreach&#x2F;in</li>
<li>while</li>
<li>do&#x2F;while</li>
</ul>
<h5 id="3-8-1-for循环"><a href="#3-8-1-for循环" class="headerlink" title="3.8.1 for循环"></a>3.8.1 for循环</h5><p>如果需要迭代一段代码固定次数，for语句会提供很大的灵活性</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ForandForEachLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &quot;i&quot;仅在for循环域内可见</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number is: &#123;0&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-8-2-foreach循环"><a href="#3-8-2-foreach循环" class="headerlink" title="3.8.2 foreach循环"></a>3.8.2 foreach循环</h5><p>foreach关键字允许遍历数组中的所有项</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ForAndForEachLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] carTypes = &#123;<span class="string">&quot;Ford&quot;</span>, <span class="string">&quot;DMW&quot;</span>, <span class="string">&quot;Yugo&quot;</span>, <span class="string">&quot;Honda&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> c <span class="keyword">in</span> carTtpes)</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>[] myInts = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> myInts)</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-8-3-在foreach结构中使用var"><a href="#3-8-3-在foreach结构中使用var" class="headerlink" title="3.8.3 在foreach结构中使用var"></a>3.8.3 在foreach结构中使用var</h5><p>编译器可以准确地推断“类型的类型”</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">VarInForeachLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] myInts = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="comment">//在标准foreach中使用“var”</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> myInts)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Item value: &#123;0&#125;&quot;</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-8-4-while和do-x2F-while循环结构"><a href="#3-8-4-while和do-x2F-while循环结构" class="headerlink" title="3.8.4 while和do&#x2F;while循环结构"></a>3.8.4 while和do&#x2F;while循环结构</h5><p>当希望执行一段语句直到满足某个终止条件时，while循环结构很有用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExecuteWhileLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> userIsDone = <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对字符串的小写副本进行测试</span></span><br><span class="line">    <span class="keyword">while</span>(userIsDone.ToLower() != <span class="string">&quot;yes&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;Are you done? [yes] [no]: &quot;</span>);</span><br><span class="line">        userIsDone = Console.ReadLine();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In while loop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do&#x2F;while肯定会执行至少一次对应的代码块</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExecuteDowhileLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> userIsDone = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In do/while loop&quot;</span>);</span><br><span class="line">        Console.Write(<span class="string">&quot;Are you done? [yes] [no]: &quot;</span>);</span><br><span class="line">        userIsDone = Console.ReadLine();</span><br><span class="line">    &#125;<span class="keyword">while</span>(userIsDone.ToLower() != <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-条件结构和关系-x2F-相等操作符"><a href="#3-9-条件结构和关系-x2F-相等操作符" class="headerlink" title="3.9 条件结构和关系&#x2F;相等操作符"></a>3.9 条件结构和关系&#x2F;相等操作符</h4><p>C#定义了两个结构来根据各种情况改变程序的流程</p>
<ul>
<li>if&#x2F;else</li>
<li>switch</li>
</ul>
<h5 id="3-9-1-if-x2F-else语句"><a href="#3-9-1-if-x2F-else语句" class="headerlink" title="3.9.1 if&#x2F;else语句"></a>3.9.1 if&#x2F;else语句</h5><p>C#中的if&#x2F;else语句只能用于布尔表达式，不能用于-1和0这样的值<strong>逻辑操作符</strong>&amp;&amp;和||操作符在必要时会“短路”处理，条件只要达成后面就不继续判断</p>
<table>
<thead>
<tr>
<th>逻辑操作符</th>
<th>示例</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>if((age &#x3D;&#x3D; 30)  &amp;&amp; (name &#x3D;&#x3D;”Fred”))</td>
<td>与。所有为真则真</td>
</tr>
<tr>
<td>&amp;#124;&amp;#124;</td>
<td>if((age &#x3D;&#x3D; 30)  &amp;#124;&amp;#124; (name &#x3D;&#x3D;”Fred”))</td>
<td>或。一个为真则真</td>
</tr>
<tr>
<td>！</td>
<td>if(!myBool)</td>
<td>非。表达式为假则真</td>
</tr>
</tbody></table>
<h5 id="3-9-2-switch语句"><a href="#3-9-2-switch语句" class="headerlink" title="3.9.2 switch语句"></a>3.9.2 switch语句</h5><p>switch语句允许我们根据预定义的选择来处理程序流程</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExecuteSwitch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> langChoice = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> n = <span class="built_in">int</span>.Parse(langChoice);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is 1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is 2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;good luck&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-C-核心编程-II"><a href="#4-C-核心编程-II" class="headerlink" title="4 C#核心编程#II"></a>4 C#核心编程#II</h3><h4 id="4-1-方法和参数修饰符"><a href="#4-1-方法和参数修饰符" class="headerlink" title="4.1 方法和参数修饰符"></a>4.1 方法和参数修饰符</h4><p>方法可以在类或结构的范围内实现，并且可以被各种关键字修饰以限制其行为</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// static 返回值 方法名（参数）&#123;...&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-1-默认的参数传递行为"><a href="#4-1-1-默认的参数传递行为" class="headerlink" title="4.1.1 默认的参数传递行为"></a>4.1.1 默认的参数传递行为</h5><p>参数传入函数的默认行为是按照值传递。数据的副本会被传入函数，如果在成员的作用于内修改参数的值，改变的就是调用者数据值的副本，而原先的值不会改变</p>
<h5 id="4-1-2-out修饰符"><a href="#4-1-2-out修饰符" class="headerlink" title="4.1.2 out修饰符"></a>4.1.2 out修饰符</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="keyword">out</span> <span class="built_in">int</span> ans</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ans = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-3-ref修饰符"><a href="#4-1-3-ref修饰符" class="headerlink" title="4.1.3 ref修饰符"></a>4.1.3 ref修饰符</h5><p>如果希望方法可以对在调用者作用域中声明的不同数据进行操作（通常是改变它的值），例如，排序和交换例程，就必须使用引用参数。注意输出参数和引用参数之间的区别。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SwapStrings</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> s1, <span class="keyword">ref</span> <span class="built_in">string</span> s2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> tempStr = s1;</span><br><span class="line">    s1 = s2;</span><br><span class="line">    s2 = tempStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;Flip&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">&quot;Flop&quot;</span>;</span><br><span class="line">    Console.WriteLine(s1,s2);</span><br><span class="line">    SwapString(<span class="keyword">ref</span> s1, <span class="keyword">ref</span> s2);</span><br><span class="line">    Console.WriteLine(s1,s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">Flip, Flop</span><br><span class="line">Flop, Flip</span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-params修饰符"><a href="#4-1-4-params修饰符" class="headerlink" title="4.1.4 params修饰符"></a>4.1.4 params修饰符</h5><p>params关键字可以把可变数量的参数（相同类型）作为个逻辑参数传给方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">CalcuateAverage</span> (<span class="params"><span class="keyword">params</span> <span class="built_in">double</span>[] values</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(valuse.Length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; values.Length; i++)</span><br><span class="line">        sum += valuse[i];</span><br><span class="line">    <span class="keyword">return</span> ( sum / values.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-5-定义可选参数"><a href="#4-1-5-定义可选参数" class="headerlink" title="4.1.5 定义可选参数"></a>4.1.5 定义可选参数</h5><p>可以创建包含可选参数的方法。这允许调用者不指定不必要的参数，而是使用参数的默认值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnterLogData</span>(<span class="params"><span class="built_in">string</span> message, <span class="built_in">string</span> owner = <span class="string">&quot;Programmer&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Error: &#123;0&#125;&quot;</span>, message);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Owner of Error: &#123;0&#125;&quot;</span>, owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    EnterLogData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    EnterLogData(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-6-使用命名参数调用方式"><a href="#4-1-6-使用命名参数调用方式" class="headerlink" title="4.1.6 使用命名参数调用方式"></a>4.1.6 使用命名参数调用方式</h5><p>与可选参数一样，支持命名参数的主要原因也是为了简化与COM的互操作允许在调用方法时以任意顺序指定参数的值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span>(<span class="params"><span class="built_in">string</span> a, <span class="built_in">string</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">    Console.WriteLine(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print1(b: <span class="string">&quot;123&quot;</span>, a: <span class="string">&quot;321&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">321</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h5 id="4-1-7-成员重载"><a href="#4-1-7-成员重载" class="headerlink" title="4.1.7 成员重载"></a>4.1.7 成员重载</h5><p>当我们定义一组名字相同的成员时，如果它们的参数数量（或类型）不同，这样的成员就叫做被重载。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用int版本的Add</span></span><br><span class="line">    	Console.WriteLine(Add(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用double版本的Add</span></span><br><span class="line">        Console.WriteLine(Add(<span class="number">4.3</span>, <span class="number">4.4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">Add</span>(<span class="params"><span class="built_in">long</span> x, <span class="built_in">long</span> y</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-C-中的数组操作"><a href="#4-2-C-中的数组操作" class="headerlink" title="4.2 C#中的数组操作"></a>4.2 C#中的数组操作</h4><p>数组是一组通过数字索引来访问的数据项。更精确地说，数组是一组相同类型的数据点(int数组、string数组，SportsCars数组等)</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleArrays</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] myInts = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];	<span class="comment">//创建数组并设定边界</span></span><br><span class="line">        myInts[<span class="number">0</span>] = <span class="number">100</span>;	<span class="comment">//填充值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h5 id="4-2-1-C-数组初始化语法"><a href="#4-2-1-C-数组初始化语法" class="headerlink" title="4.2.1 C#数组初始化语法"></a>4.2.1 C#数组初始化语法</h5><p>需要创建一个已知大小的数组，并且希望快速指定初始值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ArrayInitialization</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用new关键字的数组初始化语法</span></span><br><span class="line">    <span class="built_in">string</span>[] stringArray = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">	<span class="comment">//不使用new关键字的数组初始化语法</span></span><br><span class="line">    <span class="built_in">bool</span>[] boolArray = &#123; flase, flase, <span class="literal">true</span>&#125;;</span><br><span class="line">	<span class="comment">//使用new关键字和大小的数组初始化</span></span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>] &#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-隐式类型本地数组"><a href="#4-2-2-隐式类型本地数组" class="headerlink" title="4.2.2 隐式类型本地数组"></a>4.2.2 隐式类型本地数组</h5><p>var同样可以用来定义数组。混合数组会报错</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeclarImplicaaitArrays</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//a为int[]</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="comment">//b为string[]</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span>[] &#123; <span class="string">&quot;t&quot;</span>, <span class="string">&quot;e&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-定义object数组"><a href="#4-2-3-定义object数组" class="headerlink" title="4.2.3 定义object数组"></a>4.2.3 定义object数组</h5><p>System.Object是.NET类型系统中所有类型（包括基本数据类型）的最终基类。所以Objent的子项可以是任意东西</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span>[] test = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">4</span>];</span><br><span class="line">    test[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    test[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    test[<span class="number">2</span>] = <span class="keyword">new</span> DateTime(<span class="number">1969</span>, <span class="number">3</span>, <span class="number">24</span>);</span><br><span class="line">    test[<span class="number">3</span>] = <span class="string">&quot;tet&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">object</span> obj <span class="keyword">in</span> test)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2-4-使用多维数组"><a href="#4-2-4-使用多维数组" class="headerlink" title="4.2.4 使用多维数组"></a>4.2.4 使用多维数组</h5><p>矩形数组，每一行长度都相同</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RectMultdimensionaArray</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[,] myMatrix;</span><br><span class="line">    myMatrix = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>, j++)</span><br><span class="line">            myMareix[i,j] = i * j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>交错数组，每一个都有各自的上界</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JaggeMuitidimensionaArray</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[][] myJagArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>][];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; myJagArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个具有5个不同数组的数组</span></span><br><span class="line">        myJagArray[i] = <span class="keyword">new</span> <span class="built_in">int</span>[i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; myJagArray[i].Length; j++)</span><br><span class="line">            Console.Write(myJagArray[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-数组作为参数（和返回值）"><a href="#4-2-5-数组作为参数（和返回值）" class="headerlink" title="4.2.5 数组作为参数（和返回值）"></a>4.2.5 数组作为参数（和返回值）</h5><p>将数组作为参数进行传递</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArray</span>(<span class="params"><span class="built_in">int</span>[] myInsts</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i =  <span class="number">0</span>; i &lt; myInts.Length; i++)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, i, myInsts[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PassAndReceiveArrays</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] args = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    PrintArray(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-6-System-Array基类"><a href="#4-2-6-System-Array基类" class="headerlink" title="4.2.6 System.Array基类"></a>4.2.6 System.Array基类</h5><p>每一个数组都从System.Array类获得了很多功能。使用这些公共成员，我们就能使用统一的对象模型来操作数组</p>
<h4 id="4-3-枚举类型"><a href="#4-3-枚举类型" class="headerlink" title="4.3 枚举类型"></a>4.3 枚举类型</h4><p>在构建系统的时候，创建一组符号名来对应已知的数字值会很方便。例如，如果创建一个工资系统，我们可能会希望使用诸如副总裁、经理、职员、实习生等常量来指代员工类型。C#支持自定义枚举的概念来满足这种需求。例如，下面是一个名为EmpType的枚举：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自定义枚举</span></span><br><span class="line"><span class="built_in">enum</span> EmpType</span><br><span class="line">&#123;</span><br><span class="line">	Manager,</span><br><span class="line">	Grunt,</span><br><span class="line">	Contractor,</span><br><span class="line">	VicePresident</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-控制枚举的底层存储"><a href="#4-3-1-控制枚举的底层存储" class="headerlink" title="4.3.1 控制枚举的底层存储"></a>4.3.1 控制枚举的底层存储</h5><p>默认情况下，用来保存枚举值的存储类型是System.Int32(C#int),当然也可以改成我们喜欢的类型。C#枚举可以以相似的方式定义为核心系统类型(byte、short、int或long)。如果我们构建的NET应用程序将会被部署在低内存的设备中（如支持.NET的手机或PDA),并且希望尽可能节省内存，那么改变枚举的实际类型可能会很有用</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">enum</span> EmpType : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">	manager =<span class="number">10</span>,</span><br><span class="line">	grunt = <span class="number">1</span>,</span><br><span class="line">	contractor = <span class="number">100</span>,</span><br><span class="line">	vicepresident = <span class="number">9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-声明枚举变量"><a href="#4-3-2-声明枚举变量" class="headerlink" title="4.3.2 声明枚举变量"></a>4.3.2 声明枚举变量</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AskForBonus接受EmpType作为唯一变量，根据传入参数的值，输出对应的请求响应</span></span><br><span class="line"><span class="built_in">enum</span> EmpType</span><br><span class="line">    &#123;</span><br><span class="line">        Manageer,</span><br><span class="line">        Grunt,</span><br><span class="line">        Contractor,</span><br><span class="line">        VicePresident</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EmpType emp = EmpType.Contractor;</span><br><span class="line">        AskForBonus(emp);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AskForBonus</span>(<span class="params">EmpType e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> EmpType.Manageer:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EmpType.Grunt:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EmpType.Contractor:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EmpType.VicePresident:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-3-System-Enum类型"><a href="#4-3-3-System-Enum类型" class="headerlink" title="4.3.3 System.Enum类型"></a>4.3.3 System.Enum类型</h5><p>略</p>
<h5 id="4-3-4-动态获取枚举的名称-x2F-值对"><a href="#4-3-4-动态获取枚举的名称-x2F-值对" class="headerlink" title="4.3.4 动态获取枚举的名称&#x2F;值对"></a>4.3.4 动态获取枚举的名称&#x2F;值对</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EmpType emp = EmpType.Contractor;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, emp.ToString());</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将输出Contractor</span></span><br></pre></td></tr></table></figure>


<h4 id="4-4-结构类型"><a href="#4-4-结构类型" class="headerlink" title="4.4 结构类型"></a>4.4 结构类型</h4><p>结构类型很适合在应用程序中对数学、几何以及其他“原子”实体建模。结构（和枚举相似）是用户自定义的类型，然而，结构不只是一组名称值对。结构是可以包含许多数据字段和操作这些字段的成员的类型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)	<span class="comment">//调用</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Point test;</span><br><span class="line">    test.x = <span class="number">349</span>;</span><br><span class="line">    test.y = <span class="number">76</span>;</span><br><span class="line">    test.Display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Point	<span class="comment">//设置结构</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//结构的字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        x++; y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Decrement</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        x--; y--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;X = &#123;0&#125;, Y = &#123;1&#125;&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-值类型和引用类型"><a href="#4-5-值类型和引用类型" class="headerlink" title="4.5 值类型和引用类型"></a>4.5 值类型和引用类型</h4><p>C#结构在.NET类库中是属于隐式派生自System.ValueType中。System.ValueType的作用是确保所有派生类型（如任何结构)都分配在栈上而不是垃圾回收堆上。创建和销毁分配在栈上的数据都很快，因为它的生命周期是由定义的作用域决定的</p>
<h5 id="4-5-1-值类型、引用类型和赋值操作符"><a href="#4-5-1-值类型、引用类型和赋值操作符" class="headerlink" title="4.5.1 值类型、引用类型和赋值操作符"></a>4.5.1 值类型、引用类型和赋值操作符</h5><p>当把一个值类型赋给另外一个时，就是对字段成员逐一进行复制。对于System.Int32这样的简单数据类型，唯一需要复制的成员就是数值。然而，对于我们的Point,X和Y值会被复制到新的结构变量中。</p>
<h5 id="4-5-2-包含引用类型的值类型"><a href="#4-5-2-包含引用类型的值类型" class="headerlink" title="4.5.2 包含引用类型的值类型"></a>4.5.2 包含引用类型的值类型</h5><p>当值类型包含其他引用类型时，赋值将生成一个引用的副本。这样就有两个独立的结构，每一个都包含指向内存中同一个对象的引用（也就是“浅复制”）。</p>
<h5 id="4-5-3-按值传递引用类型"><a href="#4-5-3-按值传递引用类型" class="headerlink" title="4.5.3 按值传递引用类型"></a>4.5.3 按值传递引用类型</h5><p>略</p>
<h5 id="4-5-4-按引用类型传递引用类型"><a href="#4-5-4-按引用类型传递引用类型" class="headerlink" title="4.5.4 按引用类型传递引用类型"></a>4.5.4 按引用类型传递引用类型</h5><p>按引用传递引用类型时需要记住的黄金规则如下：如果按引用传递引用类型，被调用者可能改变对象的状态数据的值和所引用的对象，如果按值传递引用类型，被调用者可能改变对象的状态数据的值，但不能改变所引用的对象。</p>
<h4 id="4-6-C-可空类型"><a href="#4-6-C-可空类型" class="headerlink" title="4.6 C#可空类型"></a>4.6 C#可空类型</h4><p>从.NET2.0发布后，我们就可以创建可控数据类型了</p>
<h5 id="4-6-1-使用可空类型"><a href="#4-6-1-使用可空类型" class="headerlink" title="4.6.1 使用可空类型"></a>4.6.1 使用可空类型</h5><p>所有数值类型都是值类型。值类型在声明之前是不允许被赋予null的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span>? t1 = <span class="number">10</span>;	<span class="comment">//【?】声明可空类型</span></span><br><span class="line">    <span class="built_in">double</span>? t2 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串是引用类型，不需要声明</span></span><br><span class="line">    <span class="comment">// string? s = &quot;oops&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-6-2-操作符"><a href="#4-6-2-操作符" class="headerlink" title="4.6.2 ??操作符"></a>4.6.2 ??操作符</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DatabaseReader dr = <span class="keyword">new</span> DatabaseReader();</span><br><span class="line">        <span class="built_in">int</span> myData = dr.GetIntFromDatabase() ?? <span class="number">100</span>;    <span class="comment">//如果返回值为空，则将本地变量赋值为100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可替代if语句，让整体代码量更加紧凑</p>
<h3 id="5-定义封装的类类型"><a href="#5-定义封装的类类型" class="headerlink" title="5 定义封装的类类型"></a>5 定义封装的类类型</h3><p>如何构建支持任意数量的构造函数的定义的定义明确的类类型</p>
<h4 id="5-1-C-类类型"><a href="#5-1-C-类类型" class="headerlink" title="5.1 C#类类型"></a>5.1 C#类类型</h4><p>就.NET平台而言，最基础的编程结构就是类类型类是由字段数据（通常叫做成员变量）以及操作这个数据的成员（如构造函数、属性、方法、事件等）所构成的自定义类型</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span>	<span class="comment">//定义类类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Car的“状态”</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> petName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> currSpeed;</span><br><span class="line">	<span class="comment">//为了保护状态数据的完整性，最好将数据定义为私有的（或者是受保护的），并且通过类型属性对数据提供受控制的访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Car的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; is goint &#123;1&#125; MPH&quot;</span>, petName, currSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeedUp</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currSpeed += delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">stringp[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car();	<span class="comment">//分配和设置Car对象</span></span><br><span class="line">        <span class="comment">//，第一句代码只是声明了指向尚未被创建的car对象的引用。在我们通过new关键字把引用赋给对象之后，这个引用才会指向内存中的有效类实例。</span></span><br><span class="line">        myCar.petName = <span class="string">&quot;Hnery&quot;</span>;</span><br><span class="line">        myCar.currSpeed = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myCar.SpeedUp(<span class="number">5</span>);</span><br><span class="line">            myCar.PrintState();</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用new关键字来分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">stringp[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Car test = <span class="keyword">new</span> Car();</span><br><span class="line">    test.petName = <span class="string">&quot;Fred&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-构造函数"><a href="#5-2-构造函数" class="headerlink" title="5.2 构造函数"></a>5.2 构造函数</h4><p>C#支持构造函数，它允许在创建对象时创建其状态。构造函数是类的特殊方法，在使用new关键字创建对象时被间接调用。然而，和“普通”方法不同，构造函数永远不会返回值（即使是void),并且它的名字总是和需要构造的类的名字相同。</p>
<h5 id="5-2-1-默认构造函数的作用"><a href="#5-2-1-默认构造函数的作用" class="headerlink" title="5.2.1 默认构造函数的作用"></a>5.2.1 默认构造函数的作用</h5><p>除了把新对象分配到内存中，默认构造函数确保所有字段数据都设置为正确的默认值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Car的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> petName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> currSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        petName = <span class="string">&quot;chuck&quot;</span>;</span><br><span class="line">        currSpeed = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car chuck = <span class="keyword">new</span> Car();</span><br><span class="line">        chuck.printState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-定义自定义的构造函数"><a href="#5-2-2-定义自定义的构造函数" class="headerlink" title="5.2.2 定义自定义的构造函数"></a>5.2.2 定义自定义的构造函数</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> petName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> currSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的默认构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        petName = <span class="string">&quot;Chuck&quot;</span>;</span><br><span class="line">        currSpeed = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> pn</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PetName = pn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> pn, <span class="built_in">int</span> cs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        petName = pn;</span><br><span class="line">        currSpeed = cs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据传递不同参数调用不同的初始值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Car chuck = <span class="keyword">new</span> Car();</span><br><span class="line">    chuck.printState();</span><br><span class="line"></span><br><span class="line">    Car mary = <span class="keyword">new</span> Car(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    mary.printState();</span><br><span class="line"></span><br><span class="line">    Car daisy = <span class="keyword">new</span> Car(<span class="string">&quot;Daisy&quot;</span>, <span class="number">75</span>);</span><br><span class="line">    daisy.printState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-3-定义自定义的构造函数"><a href="#5-2-3-定义自定义的构造函数" class="headerlink" title="5.2.3 定义自定义的构造函数"></a>5.2.3 定义自定义的构造函数</h5><p>略</p>
<h4 id="5-3-this关键字的作用"><a href="#5-3-this关键字的作用" class="headerlink" title="5.3 this关键字的作用"></a>5.3 this关键字的作用</h4><p>this关键字可能的用途就是，解决当传人参数的名字和类型数据字段的名字相同时产生的作用域歧义</p>
<h5 id="5-3-1-使用this进行串联构造函数调用"><a href="#5-3-1-使用this进行串联构造函数调用" class="headerlink" title="5.3.1 使用this进行串联构造函数调用"></a>5.3.1 使用this进行串联构造函数调用</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> t0;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> t1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span>(<span class="params"><span class="built_in">int</span> shuzi</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shuzi &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            shuzi = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t0 = shuzi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span>(<span class="params"><span class="built_in">int</span> shuzi, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shuzi &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            shuzi = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t0 = shuzi;</span><br><span class="line">        t1 = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要理解的是，使用this关键字串联构造函数不是强制的。但如果使用这项技术，类定义就会更容易维护、更简明。再说一次，使用这项技术可以简化编程任务，因为真正的工作都交给了一个构造函数（通常这个构造函数有大多数的参数）来做，而其他构造函数只是在推卸责任。</p>
<h5 id="5-3-2-观察构造函数流程"><a href="#5-3-2-观察构造函数流程" class="headerlink" title="5.3.2 观察构造函数流程"></a>5.3.2 观察构造函数流程</h5><p>略</p>
<h5 id="5-3-3-再谈可选参数"><a href="#5-3-3-再谈可选参数" class="headerlink" title="5.3.3 再谈可选参数"></a>5.3.3 再谈可选参数</h5><p>略</p>
<h4 id="5-4-static关键字"><a href="#5-4-static关键字" class="headerlink" title="5.4 static关键字"></a>5.4 static关键字</h4><p>C#类（或结构）可以通过static关键字来定义许多静态成员。如果这样的话，这些成员就只能直接从类级别而不是对象引用调用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误的方法——WriteLine不是实例级别的方法</span></span><br><span class="line">Console c = <span class="keyword">new</span> Console();</span><br><span class="line">c.WriteLine(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的方法</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="5-4-1-定义静态方法"><a href="#5-4-1-定义静态方法" class="headerlink" title="5.4.1 定义静态方法"></a>5.4.1 定义静态方法</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Teenager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetRandomNumber</span>(<span class="params"><span class="built_in">short</span> upperLimit</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r.Next(upperLimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Complain</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>[] messages = &#123;<span class="string">&quot;Do i have to?&quot;</span>, <span class="string">&quot;He started it!&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;I&#x27;m too tired...&quot;</span>, <span class="string">&quot;I hate chool!&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;You are sooooo wrong!&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> messages[GetRandomNumber(<span class="number">5</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        Console.WriteLine(Teenager.Complain());	<span class="comment">//类中静态方法调用方法</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-2-定义静态数据"><a href="#5-4-2-定义静态数据" class="headerlink" title="5.4.2 定义静态数据"></a>5.4.2 定义静态数据</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SavingsAccount</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> currBalance;</span><br><span class="line">    <span class="comment">//静态数据点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> currInterestRate = <span class="number">0.04</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavingsAccount</span> (<span class="params"><span class="built_in">double</span> balance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currBalance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当创建SavingsAccount类的新实例时，静态数据的值没有重置，因为CLR把数据分配到内存中只会进行一次。之后，所有SavingsAccount类型的对象会操作同一个值。在设计C#类时，哪一部分数据应该定义为静态成员，而哪一部分数据不应该定义为静态成员，这是一个难题。尽管没有硬性规定，但要记住静态数据字段是由所有对象共享的。因此，如果你要定义一个所有对象都可以分享的数据点，就可以使用静态成员。</p>
<h5 id="5-4-3-定义静态构造函数"><a href="#5-4-3-定义静态构造函数" class="headerlink" title="5.4.3 定义静态构造函数"></a>5.4.3 定义静态构造函数</h5><p>略</p>
<h5 id="5-4-4-定义静态类"><a href="#5-4-4-定义静态类" class="headerlink" title="5.4.4 定义静态类"></a>5.4.4 定义静态类</h5><p>可以在类级别应用static关键字。那样子不能使用new关键字来创建，并且只能包含用static关键字标记的成员或字段</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TimeUtilclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTime</span>()</span></span><br><span class="line">    &#123;Console.WriteLine(DateTime.Now.ToShortTimestring()); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintDate</span>()</span></span><br><span class="line">    &#123;Console.WriteLine(DateTime.Today.ToShortDatestring()); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-定义OOP的支柱"><a href="#5-5-定义OOP的支柱" class="headerlink" title="5.5 定义OOP的支柱"></a>5.5 定义OOP的支柱</h4><p>所有基于对象的语言必须满足OOP的3个核心原则</p>
<ul>
<li>封装：这种语言怎样隐藏一个对象的内部实现并且保护数据的完整性？</li>
<li>继承：这种语言时怎样促进代码重用的？</li>
<li>多态：这种语言怎样让你用同样的方式处理相关对象的？</li>
</ul>
<h5 id="5-5-1-封装的作用"><a href="#5-5-1-封装的作用" class="headerlink" title="5.5.1 封装的作用"></a>5.5.1 封装的作用</h5><p>这是将对象用户不必了解的实现细节隐藏起来的一种语言能力</p>
<h5 id="5-5-2-继承的作用"><a href="#5-5-2-继承的作用" class="headerlink" title="5.5.2 继承的作用"></a>5.5.2 继承的作用</h5><p>它是指基于已有类定义来创建新类定义的语言能力子类可以继承基类（或称父类）核心的功能，并扩展基类的行为</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Radio</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Power</span>(<span class="params"><span class="built_in">bool</span> turnOn</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Radio on:(0&#125;&quot;</span>,turnon);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//汽车“has-a”收音机</span></span><br><span class="line">	<span class="keyword">private</span> Radio myRadio = <span class="keyword">new</span> Radio();</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnonRadio</span>(<span class="params"><span class="built_in">bool</span> onoff</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">//到内部对象的委托调用</span></span><br><span class="line">		myRadio.Power (onoff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//调用在内部被转发到Radio</span></span><br><span class="line">    <span class="function">Car viper <span class="keyword">new</span> <span class="title">car</span>()</span>;</span><br><span class="line">    viper.TurnonRadio(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-3-多态的作用"><a href="#5-5-3-多态的作用" class="headerlink" title="5.5.3 多态的作用"></a>5.5.3 多态的作用</h5><p>它表示的是语言以同一种方式处理相关对象的能力</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Shape[] myShapes = <span class="keyword">new</span> Shape[<span class="number">3</span>];</span><br><span class="line">        myShapes[<span class="number">0</span>] = <span class="keyword">new</span> Hexagon();</span><br><span class="line">        myShapes[<span class="number">1</span>] = <span class="keyword">new</span> Circle();</span><br><span class="line">        myShapes[<span class="number">2</span>] = <span class="keyword">new</span> Hexagon();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Shape s <span class="keyword">in</span> myShapes)</span><br><span class="line">        &#123;</span><br><span class="line">            s.Draw();</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-6-C-访问修饰符"><a href="#5-6-C-访问修饰符" class="headerlink" title="5.6 C#访问修饰符"></a>5.6 C#访问修饰符</h4><p>在使用封装的时候，我们必须考虑类型的哪些方面对我们应用程序的哪些部分可见。准确地说，类型（类、接口、结构、枚举以及委托）以及它们的成员（属性、方法、构造函数、字段等）总是使用某个关键字来定义，这个关键字用来控制它们对应用程序其他部分如何“可见”。尽管C#定义了许多关键字来控制权限，但是它们会因为应用的地方不同.（类型或成员）而不同</p>
<h5 id="5-6-1-默认的访问修饰符"><a href="#5-6-1-默认的访问修饰符" class="headerlink" title="5.6.1 默认的访问修饰符"></a>5.6.1 默认的访问修饰符</h5><p>默认情况下，类型成员是隐式私有的。如果要从其他类型调用对象的成员，我们必须将它们标记为公共可访问的</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具有公共默认构造函数的公共类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Radio</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Radio</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-6-2-访问修饰符和嵌套类型"><a href="#5-6-2-访问修饰符和嵌套类型" class="headerlink" title="5.6.2 访问修饰符和嵌套类型"></a>5.6.2 访问修饰符和嵌套类型</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">\\嵌套类型是直接声明在类或结构作用域中的类型</span><br><span class="line"></span><br><span class="line">\\一个嵌套在公共类中的私有枚举</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SportsCar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">enum</span> CarColor</span><br><span class="line">    &#123;</span><br><span class="line">        Red, Green, Blue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-7-第一个支柱：C-的封装服务"><a href="#5-7-第一个支柱：C-的封装服务" class="headerlink" title="5.7 第一个支柱：C#的封装服务"></a>5.7 第一个支柱：C#的封装服务</h4><p>封装概念的核心是，对象的内部数据不应该从对象实例直接访问。如果调用者想改变对象的状态，就要使用访问方法（即getter)和修改方法（即setter)。在C#中，封装是通过public、private、protected和internal关键字在语法级别体现的封装提供了一种保护状态数据完整性的方法。与定义公共字段相比（很容易发生数据损坏)，应该更多地定义私有数据字段，这种字段可以由调用者间接地操作</p>
<h5 id="5-7-1-使用传统的访问方法和修改方法执行封装"><a href="#5-7-1-使用传统的访问方法和修改方法执行封装" class="headerlink" title="5.7.1 使用传统的访问方法和修改方法执行封装"></a>5.7.1 使用传统的访问方法和修改方法执行封装</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字段数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> empName;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> empID;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currPay;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> id,<span class="built_in">float</span> pay</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        empName name;</span><br><span class="line">        empID id;</span><br><span class="line">        currpay pay;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GiveBonus</span>(<span class="params"><span class="built_in">float</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	currPay += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Name:&#123;0)&quot;</span>,empName);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ID:(0)&quot;</span>,empID);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Pay:(0)&quot;</span>,currPay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-7-2-使用-NET属性进行封装"><a href="#5-7-2-使用-NET属性进行封装" class="headerlink" title="5.7.2 使用.NET属性进行封装"></a>5.7.2 使用.NET属性进行封装</h5><p>.NET语言还是提倡使用属性来强制数据封装状态数据。属性总是映射到“实际的”访问方法和修改方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> empName;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> empID;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currPay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> empName; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span>.Length &gt; <span class="number">15</span>)</span><br><span class="line">            	Console.WriteLine(<span class="string">&quot;Error!Name must be less than 16 characters!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                empName = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Employee emp = <span class="keyword">new</span> Employee(<span class="string">&quot;test&quot;</span>,<span class="number">456</span>,<span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置和获取Name属性</span></span><br><span class="line">    emp.Name = <span class="string">&quot;Mart&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性就等同于公共数据点，在背后会调用响应的get或set块来保持封装</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//int表示该属性所封装的数据类型</span></span><br><span class="line"><span class="comment">//数据类型必须与相关的字段(empID)相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> ID<span class="comment">//没有括号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> empID; &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; empID = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-7-3-使用类的属性"><a href="#5-7-3-使用类的属性" class="headerlink" title="5.7.3 使用类的属性"></a>5.7.3 使用类的属性</h5><p>通常类的构造函数会接受传入参数，检查有效数据，赋值给内部私有字段为了简化代码，并把所有的错误检查隔离到一个中心位置，可以一直再类中使用属性</p>
<h5 id="5-7-4-属性的内部表示"><a href="#5-7-4-属性的内部表示" class="headerlink" title="5.7.4 属性的内部表示"></a>5.7.4 属性的内部表示</h5><p>许多程序员往往使用get和set前缀来命名传统的访问方法和修改方法（例如，get_Name() 和et_Name())。这种命名约定本身没有问题。然而，在底层，C#属性也是使用同样的前缀用CL 代码来表示的，理解这一点非常重要。 例如，如果用ildasm.exe打开EmployeeApp.cxe程序集，将看到每一个属性实际上被映射到由CLR 内部调用的隐藏的get_x()&#x2F;set_Xx()方法</p>
<h5 id="5-7-5-控制属性get-x2F-set语句的可见性级别"><a href="#5-7-5-控制属性get-x2F-set语句的可见性级别" class="headerlink" title="5.7.5 控制属性get&#x2F;set语句的可见性级别"></a>5.7.5 控制属性get&#x2F;set语句的可见性级别</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对象用户只能获取值，然而Emloyee类和派生类型可以设置值</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span> &#123; <span class="keyword">return</span> empSSN; &#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">set</span> &#123; empSSN = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-7-6-只读和只写属性"><a href="#5-7-6-只读和只写属性" class="headerlink" title="5.7.6 只读和只写属性"></a>5.7.6 只读和只写属性</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//忽略set块，即只读。反之一样，忽略get块即只写</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span> &#123; <span class="keyword">return</span> empSSN； &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-7-7-静态属性"><a href="#5-7-7-静态属性" class="headerlink" title="5.7.7 静态属性"></a>5.7.7 静态属性</h5><p>静态成员是在类级别访问的，而不能从这个类的实例（对象）访问</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态属性必须在静态数据上操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> companyName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> Company</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> <span class="keyword">return</span> companyName;</span><br><span class="line">        <span class="keyword">set</span> companyName <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//与静态属性交互</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with Encapsulation *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置公司</span></span><br><span class="line">    Employee.Company = <span class="string">&quot;My Company&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;These folks work at (0).&quot;</span>,Employee.Company);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Employee emp <span class="keyword">new</span> <span class="title">Employee</span> (<span class="params"><span class="string">&quot;Marvin&quot;</span>,<span class="number">24</span>,<span class="number">456</span>,<span class="number">30000</span>,<span class="string">&quot;111-11-1111&quot;</span></span>)</span>;</span><br><span class="line">    emp.GiveBonus(<span class="number">1000</span>);</span><br><span class="line">    emp.Displaystats();</span><br><span class="line">        </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-8-自动属性"><a href="#5-8-自动属性" class="headerlink" title="5.8 自动属性"></a>5.8 自动属性</h4><p>C#语言提供了另外一种使用最少的代码定义简单的封装服务的方法，这种方法就是使用自动属性语法要简化封装字段数据的过程，可以使用自动属性语法。顾名思义，该特性使用一种新的语法，为编译器减轻了定义私有返回字段和相关C#属性成员的工作。考虑下面对于Car类的改造，我们使用这种语法快速创建了3个属性：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//原语句</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//使用标准属性语法的Car类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> carName = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> carName; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; carName <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//改造语句</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自动属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动属性也可以将get/set设置为私有和公共的</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> SomeotherProperty &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>在定义自动属性时，只指定访问修饰符、实际的数据类型、属性名称和空的get&#x2F;set作用域。在编译时，编译器为类型自动生成了私有返回字段和适当的get&#x2F;set实现逻辑。</p>
<h5 id="5-8-1-与自动属性交互"><a href="#5-8-1-与自动属性交互" class="headerlink" title="5.8.1 与自动属性交互"></a>5.8.1 与自动属性交互</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自动属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car Name: &#123;0&#125;&quot;</span>,PetName);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Speed: &#123;0&#125;&quot;</span>,Speed);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Color: &#123;0&#125;&quot;</span>,Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用定义了自动属性的对象时，可以用属性语法来设置和获取值：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Automatic Properties *****n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Car c = <span class="keyword">new</span> Car();</span><br><span class="line">    c.PetName = <span class="string">&quot;Frank&quot;</span>;</span><br><span class="line">    c.Speed = <span class="number">55</span>;</span><br><span class="line">    c.Color = <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Your car is named (0)?That&#x27;s odd...&quot;</span>, c.PetName):</span><br><span class="line">    c.Displaystats();</span><br><span class="line">                      </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-8-2-关于自动属性和默认值"><a href="#5-8-2-关于自动属性和默认值" class="headerlink" title="5.8.2 关于自动属性和默认值"></a>5.8.2 关于自动属性和默认值</h5><p>你可以直接在代码库中使用封装了数字或布尔数据的自动属性，因为隐藏的返回字段将设置一个可以直接使用的安全的默认值。但如果自动属性包装了另一个类变量，隐藏的私有引用类型的默认值也将设置为null。</p>
<h4 id="5-9-对象初始化器语法"><a href="#5-9-对象初始化器语法" class="headerlink" title="5.9 对象初始化器语法"></a>5.9 对象初始化器语法</h4><p>当你使用其他人设计的类时，包括使用NET基础类库中的类时，你往往会发现没有一个构造函数允许我们设置所有的状态数据。因此，程序员常常被迫去挑选最合适的构造函数，然后再使用所提供的一些属性赋值。为了简化新建对象的过程，C#提供了对象初始化器语法。使用这项技术，只用少量代码就可以创建对象并设置一些属性和公共字段。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xVal,<span class="built_in">int</span> yval</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xVal;</span><br><span class="line">        Y = yval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Console.writeLine(<span class="string">&quot;[&#123;0),(1)]&quot;</span>,X,Y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    现在，考虑下面的创建Point对象的方法：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过手动设置各个属性来创建Point</span></span><br><span class="line">    <span class="function">Point firstPoint <span class="keyword">new</span> <span class="title">Point</span>()</span>;</span><br><span class="line">    firstPoint.X = <span class="number">10</span>;</span><br><span class="line">    firstPoint.Y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或通过自定义构造函数创建Point</span></span><br><span class="line">    Point anotherPoint = <span class="keyword">new</span> Point(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">    anotherPoint.Displaystats();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//或使用对象初始化语法创建Point</span></span><br><span class="line">    Point finalPoint = <span class="keyword">new</span> Point &#123; X = <span class="number">30</span>, Y = <span class="number">30</span> &#125;;</span><br><span class="line">    finalPoint.Displaystats();</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个Point变量没有像以前那样使用自定义构造函数，但仍然可以对公共的X、Y属性赋值。在后台调用的是类型的默认构造函数，然后再给指定的属性赋值。因此，对象初始化语法只是使用默认构造函数创建类变量并设置各个属性状态数据的语法的简写形式。</p>
<h5 id="5-9-1-使用初始化语法调用自定义构造函数"><a href="#5-9-1-使用初始化语法调用自定义构造函数" class="headerlink" title="5.9.1 使用初始化语法调用自定义构造函数"></a>5.9.1 使用初始化语法调用自定义构造函数</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> PointColor</span><br><span class="line">&#123; LightBlue,BloodRed,Gold &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> PointColor Color&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span> (<span class="params"><span class="built_in">int</span> xVal,<span class="built_in">int</span> yval</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xVal;</span><br><span class="line">        y = yval;</span><br><span class="line">        Color = PointColor.Gold;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span> (<span class="params">PointColor ptColor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Color ptColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span></span><br><span class="line"><span class="function">    	: <span class="title">this</span>(<span class="params">PointColor.BloodRed</span>)</span> &#123;&#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;[&#123;0),&#123;1)]&quot;</span>,X,Y);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Point is &#123;0)&quot;</span>,Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用这个新的构造函数，可以创建一个金色的点（位置在(90,20)：</span></span><br><span class="line"><span class="comment">//使用初始化语法调用自定义构造函数</span></span><br><span class="line"><span class="function">Point goldPoint <span class="keyword">new</span> <span class="title">Point</span> (<span class="params">PointColor.Gold</span>)</span>&#123;X = <span class="number">90</span>,Y = <span class="number">20</span> &#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Value of Point is:&#123;0&#125;&quot;</span>,goldPoint.Displaystats());</span><br></pre></td></tr></table></figure>


<h5 id="5-9-2-初始化内部类型"><a href="#5-9-2-初始化内部类型" class="headerlink" title="5.9.2 初始化内部类型"></a>5.9.2 初始化内部类型</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Point topLeft <span class="keyword">new</span> <span class="title">Point</span> ()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Point bottomRight <span class="keyword">new</span> <span class="title">Point</span> ()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Point TopLeft</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> topLeft; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;topLeft=<span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Point BottomRight</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> bottomRight; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; bottomRight = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;[TopLeft:(0),(1),(2)BottomRight:(3),(4),(5)]&quot;</span>,</span><br><span class="line">            topLeft.X,topLeft.Y,topLeft.Color,</span><br><span class="line">            bottomRight.X,bottomRight.Y,bottomRight.Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用对象初始化语法，可以像下面这样新建Rectangle变量并设置内部Point:</span></span><br><span class="line"><span class="comment">//创建并初始化Rectangle</span></span><br><span class="line">Rectangle myRect = <span class="keyword">new</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line">    TopLeft = <span class="keyword">new</span> Point &#123; X = <span class="number">10</span>,Y = <span class="number">10</span> &#125;</span><br><span class="line">    BottomRight = <span class="keyword">new</span> Point &#123; X = <span class="number">200</span>,Y = <span class="number">200</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法从根本上减少了代码量，看起来更简洁</span></span><br></pre></td></tr></table></figure>


<h4 id="5-10-常量数据"><a href="#5-10-常量数据" class="headerlink" title="5.10 常量数据"></a>5.10 常量数据</h4><p>如果我们要为应用程序定义逻辑上和某个类或结构相关的一组已知值的话，就非常有用。const关键字来定义常量（赋初始值之后无法给改变）。定义常量时必须为常量指定初始值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<h5 id="5-10-1-只读字段"><a href="#5-10-1-只读字段" class="headerlink" title="5.10.1 只读字段"></a>5.10.1 只读字段</h5><p>和常量类似，在赋初始值后无法改变。但和常量不同的是，赋给只读字段的值可以在运行时决定</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">double</span> PI;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PI = <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-10-2-静态只读字段"><a href="#5-10-2-静态只读字段" class="headerlink" title="5.10.2 静态只读字段"></a>5.10.2 静态只读字段</h5><p>只读字段不是隐式静态的。如果要从类级别公开PI，就必须显式使用stactic关键字</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行前就知道值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在运行时才赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">double</span> PI;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">test</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PI = <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-11-分部类型"><a href="#5-11-分部类型" class="headerlink" title="5.11 分部类型"></a>5.11 分部类型</h4><p>在创建类时，多数代码在确立后基本可以忽略不记。例如，字段数据、属性和构造函数在生产过程中很少变动，而方法却需要经常修改如果愿意，你可以将一个类分布到多个C#文件中</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//单个文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字段数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//转换成多个文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//test.cs</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.Internal.cs</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字段数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译这个修改后的项目，你会发现一切都没有变化。分部类的整个理念都是在设计时实现的。</p>
<h3 id="6-继承和多态"><a href="#6-继承和多态" class="headerlink" title="6 继承和多态"></a>6 继承和多态</h3><p>使用继承永来构建一组相关类。我们会看到，这种形式的代码重用允许我们在父类中定义通用功能，并且这种功能可以披子类所使用（或者改变）。然后，我们会学习如何使用虚成员和抽象成员在类层次结构中创建多态接口。</p>
<h4 id="6-1-继承的基本机制"><a href="#6-1-继承的基本机制" class="headerlink" title="6.1 继承的基本机制"></a>6.1 继承的基本机制</h4><p>代码重用归为两类：经典继承（is-a关系）、包含\委托模型（has-a关系）经典继承的基本思想是新的类可以利用既有类的功能</p>
<h5 id="6-1-1-指定既有类的父类"><a href="#6-1-1-指定既有类的父类" class="headerlink" title="6.1.1 指定既有类的父类"></a>6.1.1 指定既有类的父类</h5><p>作为新类基础的既有类叫做基类或父类。基类的作用是为扩展它的类定义所有公共数据以及成员。扩展类叫做派生类或子类。在C#中，我们在类定义中利用冒号操作符在类之间创建“is-a”关系：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Minivan是一个car</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Minivan</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尽管Minivan中没有内容，但其从Car继承了每一个公共成员的访问权限，因此可以如下使用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Basic Inheritance *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//创建Minivan对象</span></span><br><span class="line">    Minivan myvan = <span class="keyword">new</span> Minivan();</span><br><span class="line">    myvan.Speed = <span class="number">10</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;My van is going (0)MPH&quot;</span>,</span><br><span class="line">    myvan.Speed);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能通过对象引用来访问私有成员</span></span><br><span class="line">    my.curSpeed = <span class="number">55</span>; <span class="comment">//该语句会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-2-多个基类"><a href="#6-1-2-多个基类" class="headerlink" title="6.1.2 多个基类"></a>6.1.2 多个基类</h5><p>.NET平台不允许类的多重继承。C#要求一个类只能有一个直接基类虽然一个类只能有一个直接基类，但是一个接口可以直接从多个接口派生。使用这个技巧，可以构建灵活的接口层次来建模复杂的行为</p>
<h5 id="6-1-3-sealed关键字"><a href="#6-1-3-sealed关键字" class="headerlink" title="6.1.3 sealed关键字"></a>6.1.3 sealed关键字</h5><p>C#提供了另外一个关键字sealed来防止发生继承。如果我们将类标记为sealed,编译器将不会允许我们从这个类型派生。例如，假设我们认为进一步扩展MiniVan类是无意义的：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MiniVan类不会被扩展</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Minivan</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果尝试从这个类派生的话，就会收到一个编译时错误：</span><br><span class="line"><span class="comment">//错误！不能扩展用sealed关键字标记的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">DeluxeMiniVan</span> : <span class="title">MiniVan</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-2-回顾Visual-Studio类关系图"><a href="#6-2-回顾Visual-Studio类关系图" class="headerlink" title="6.2 回顾Visual Studio类关系图"></a>6.2 回顾Visual Studio类关系图</h4><p>略</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="6-3-OOP的第二个支柱：继承"><a href="#6-3-OOP的第二个支柱：继承" class="headerlink" title="6.3 OOP的第二个支柱：继承"></a>6.3 OOP的第二个支柱：继承</h4><p>我们可以看到SalesPerson是一个mployee(Manager也一样)。在经典的继承模型中，基类（如ployee)用于定义所有派生类型共有的一般特征。子类（如SalesPerson和Manager)通过增加特定的行为来扩展这些一般功能。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//经理需要知道它们的股票期权数量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Manager</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> Stockoptions &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-使用base关键字控制基类的创建"><a href="#6-3-1-使用base关键字控制基类的创建" class="headerlink" title="6.3.1 使用base关键字控制基类的创建"></a>6.3.1 使用base关键字控制基类的创建</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span>(<span class="params"><span class="built_in">string</span> fullName,<span class="built_in">int</span> age,<span class="built_in">int</span> empID,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="built_in">float</span> currPay,<span class="built_in">string</span> ssn,<span class="built_in">int</span> numbofopts</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个属性由Manager类来定义</span></span><br><span class="line">    Stockoptions = numbofOpts;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用从父类继承的属性来为传入参数赋值</span></span><br><span class="line">    ID = empID;</span><br><span class="line">    Age = age;</span><br><span class="line">    Name = fullName;</span><br><span class="line">    Pay = currPay;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//嗅！这会导致编译器错误，因为SSN属性是只读的</span></span><br><span class="line">    SocialSecurityNumber = ssn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span>(<span class="params"><span class="built_in">string</span> fullName,<span class="built_in">int</span> age,<span class="built_in">int</span> empID,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="built_in">float</span> currpay,<span class="built_in">string</span> ssn,<span class="built_in">int</span> numbofOpts</span>)</span></span><br><span class="line"><span class="function">	: <span class="title">base</span>(<span class="params">fullName,age,empID,currpay,ssn</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个属性由Manager类定义</span></span><br><span class="line">    Stockoptions numbofopts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>base关键字挂接构造函数签名，这代表派生构造函数将数据传递到最近的父构造函数中。在这里，我们显式调用由Employee定义的5个参数的构造函数，从而节省子类创建过程中不必要的调用。</p>
<h5 id="6-3-2-家族的秘密：protected关键字"><a href="#6-3-2-家族的秘密：protected关键字" class="headerlink" title="6.3.2 家族的秘密：protected关键字"></a>6.3.2 家族的秘密：protected关键字</h5><p>当基类定义了受保护数据或受保护成员时，它就创建了一组可以直接被任何后代访问的项。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//受保护的状态数据</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//派生类现在可以直接访问这些信息了</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> empName;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> empID;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> currPay;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> empAge;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> empSSN;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="built_in">string</span> companyName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="6-3-3-增加密封类"><a href="#6-3-3-增加密封类" class="headerlink" title="6.3.3 增加密封类"></a>6.3.3 增加密封类</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为了防止其他人扩展类，可以使用sealed关键字：</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">PTSalesperson</span> : <span class="title">SalesPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PTSalesPerson</span>(<span class="params"><span class="built_in">string</span> fullName,<span class="built_in">int</span> age,<span class="built_in">int</span> empID,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="built_in">float</span> currPay,<span class="built_in">string</span> ssn,<span class="built_in">int</span> numbofSales</span>)</span></span><br><span class="line"><span class="function">     : <span class="title">base</span> (<span class="params">fullName,age,empID,currpay,ssn,numbofSales</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//假设其他成员…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们希望构建新类来使用密封类的功能，唯一的办法就是使用包含委托模型（也叫“has-a”关系)。</p>
<h4 id="6-4-包含-x2F-委托编程"><a href="#6-4-包含-x2F-委托编程" class="headerlink" title="6.4 包含&#x2F;委托编程"></a>6.4 包含&#x2F;委托编程</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个类型会作为包含类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">BenfitPackage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">ComputePayDeduction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">125.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//包含BenfitPackage对象的类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> BenfitPackage test = <span class="keyword">new</span> BenfitPackage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//已经成功地包含了另外要给对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要公开被包含对象的功能给外部世界，就需要委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//包含一个BenefitPackage对象</span></span><br><span class="line">    <span class="keyword">protected</span> BenefitPackage empBenefits = <span class="keyword">new</span> BenefitPackage();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公开对象的保险金行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetBenefitCost</span> ()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> empBenefits.ComputePayDeduction(); &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//通过自定义属性公开对象</span></span><br><span class="line">    <span class="keyword">public</span> BenefitPackage Benefits</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> empBenefits; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; empBenefits <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套类型的概念就是”has-a”关系的另一种说法</p>
<h4 id="6-5-OOP的第三个支柱：C-的多态支持"><a href="#6-5-OOP的第三个支柱：C-的多态支持" class="headerlink" title="6.5 OOP的第三个支柱：C#的多态支持"></a>6.5 OOP的第三个支柱：C#的多态支持</h4><p>相关类型如何对相同的请求做出不同的相应</p>
<h5 id="6-5-1-virtual和override关键字"><a href="#6-5-1-virtual和override关键字" class="headerlink" title="6.5.1 virtual和override关键字"></a>6.5.1 virtual和override关键字</h5><p>如果基类希望定义可以由子类重写的方法，就必须用virtual关键字标志方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个方法现在可以由派生类“重写”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GiveBonus</span>(<span class="params"><span class="built_in">float</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	currPay += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用override关键字重写方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Salesperson</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//销售人员的奖金受销售量的影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">GiveBonus</span>(<span class="params"><span class="built_in">float</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> salesBonus = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (numberofSales &gt;<span class="number">0</span> &amp;numberofSales &lt;<span class="number">100</span>)</span><br><span class="line">            salesBonus <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numberofSales &gt;<span class="number">101</span> &amp;numberofSales &lt;<span class="number">200</span>)</span><br><span class="line">                salesBonus = <span class="number">15</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            	salesBonus = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-2-使用Visual-Studio2010重写虚方法"><a href="#6-5-2-使用Visual-Studio2010重写虚方法" class="headerlink" title="6.5.2 使用Visual Studio2010重写虚方法"></a>6.5.2 使用Visual Studio2010重写虚方法</h5><p>Visual Studio20l0有一个非常有用的、可以在重写虚成员时使用的特性。如果在类类型中输入“override”单词（然后按空格键），智能感知会自动显示定义在父类中的所有可重写成员的列表</p>
<h5 id="6-5-3-密封虚成员"><a href="#6-5-3-密封虚成员" class="headerlink" title="6.5.3 密封虚成员"></a>6.5.3 密封虚成员</h5><p>有时我们不希望密封整个类，而只希望防止派生类型来重写某个虚方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//SalesPerson密封了GiveBonus()方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">SalesPerson</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">sealed</span> <span class="keyword">void</span> <span class="title">GiveBonus</span>(<span class="params"><span class="built_in">float</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-4-抽象类"><a href="#6-5-4-抽象类" class="headerlink" title="6.5.4 抽象类"></a>6.5.4 抽象类</h5><p>由于很多基类都是比较模糊的实体，好的设计师会防止在代码中直接创建新的ployee对象。在C#中，我们可以使用abstract关键字来强制这种编程方式，因此创建一个抽象基类：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将Employee类更新为抽象类来防止直接实例化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-5-构建多态接口"><a href="#6-5-5-构建多态接口" class="headerlink" title="6.5.5 构建多态接口"></a>6.5.5 构建多态接口</h5><p>抽象基类的多态接口只是指一组虚的或者抽象的方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层次结构中的抽象基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>(<span class="params"><span class="built_in">string</span> name =<span class="string">&quot;NoName&quot;</span></span>)</span></span><br><span class="line">    &#123; PetName = name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个虚方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Console.WriteLine(<span class="string">&quot;Inside Shape.Draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//circle没有重写Draw()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">circle</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hexagon重写了Draw()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Hexagon</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hexagon</span> ()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hexagon</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Drawing (0)the Hexagon&quot;</span>,PetName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要强制每一个子类重写Draw()方法，我们可以把Draw()定义为Shape类的一个抽象方法，也就是说我们没有提供默认的实现。在C#中可以使用abstract关键字将方法标记为抽象的。注意，abstract成员没有提供任何实现：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//强制所有子类来定义如何被呈现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//即使不实现抽象的Draw()方法，Circle也必须是抽象的，我们必须标记abstract</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">circle</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">circle</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing (0&#125;the circle&quot;</span>,PetName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优美的代码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个图形对象数组</span></span><br><span class="line">    Shape[] myShapes = (<span class="keyword">new</span> Hexagon(),<span class="keyword">new</span> circle(),<span class="keyword">new</span> Hexagon(<span class="string">&quot;Mick&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> circle(<span class="string">&quot;Beth&quot;</span>),<span class="keyword">new</span> Hexagon (<span class="string">&quot;Linda&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环每一个项来和多态接口进行交互</span></span><br><span class="line">    <span class="keyword">foreach</span> (Shape s <span class="keyword">in</span> myShapes)</span><br><span class="line">    &#123;</span><br><span class="line">        s.Draw ();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-6-成员投影"><a href="#6-5-6-成员投影" class="headerlink" title="6.5.6 成员投影"></a>6.5.6 成员投影</h5><p>C#提供了逻辑上和方法重写相对的功能，叫做投影（shadowing)。正式地说，如果派生类定义的成员和定义在基类中的成员一致，派生类就投影了父类的版本。在真实情况下，如果我们（或者我们的团队)从一个不是自己创建的类来创建子类就很可能会发生这样的情况</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个类扩展了circle并隐藏了继承的Draw()方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ThreeDcircle</span> : <span class="title">circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//隐藏任何在我之上的Draw()实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a 3D circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用new关键字显式生命派生类型的实现故意设计为隐藏父类的版本</span></span><br></pre></td></tr></table></figure>


<h4 id="6-6-基类-x2F-派生类的转换规则"><a href="#6-6-基类-x2F-派生类的转换规则" class="headerlink" title="6.6 基类&#x2F;派生类的转换规则"></a>6.6 基类&#x2F;派生类的转换规则</h4><p>类类型强制转换操作的规则.NET平台下，系统中的最高基类是System.Object。因此，所有东西都是(“is-a”)object,并且可以照此进行处理。因此，在对象变量中保存任何类型的实例都是合法的：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用object保存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CastingExamples</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Manager是(is-a)System.Object,因此我们刚好可以在对象变量中存储Manager引用</span></span><br><span class="line">    <span class="comment">//用object变量保存Manager引用也是可以的</span></span><br><span class="line">    <span class="function"><span class="built_in">object</span> frank <span class="keyword">new</span> <span class="title">Manager</span>(<span class="params"><span class="string">&quot;Frank Zappa&quot;</span>,<span class="number">9</span>,<span class="number">3000</span>,<span class="number">40000</span>,<span class="string">&quot;111-11-1111&quot;</span>,<span class="number">5</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接受单个employee类型的参数，因为是&quot;is-a&quot;关系，所以可以直接将任何Employee类的后代直接传递到这个方法中</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GivePromotion</span>(<span class="params">Employee emp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//增加工资</span></span><br><span class="line">    <span class="comment">//在公司车库新增停车位</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0)was promoted!&quot;</span>emp.Name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CastingExamples</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Manager是(is-a)System.object,因此我们刚好可以在对象变量中存储Manger引用</span></span><br><span class="line">    <span class="function"><span class="built_in">object</span> frank <span class="keyword">new</span> <span class="title">Manager</span>(<span class="params"><span class="string">&quot;Frank Zappa&quot;</span>,<span class="number">9</span>,<span class="number">3000</span>,<span class="number">40000</span>,<span class="string">&quot;111-11-1111&quot;</span>,<span class="number">5</span></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Manager同样是Employee</span></span><br><span class="line">    <span class="function">Employee moonUnit <span class="keyword">new</span> <span class="title">Manager</span> (<span class="params"><span class="string">&quot;MoonUnit Zappa&quot;</span>,<span class="number">2</span>,<span class="number">3001</span>,<span class="number">20000</span>,<span class="string">&quot;101-11-1321&quot;</span>,<span class="number">1</span></span>)</span>;</span><br><span class="line">    GivePromotion(moonUnit);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PTSalesPerson SalesPerson</span></span><br><span class="line">    Sa1 esPerson ji11=<span class="keyword">new</span> <span class="function">PTSa1 <span class="title">esPerson</span>(<span class="params"><span class="string">&quot;Ji11&quot;</span>,<span class="number">834</span>,<span class="number">3002</span>,<span class="number">100000</span>,<span class="string">&quot;111-12-1119&quot;</span>,<span class="number">90</span></span>):</span></span><br><span class="line"><span class="function">    <span class="title">GivePromotion</span>(<span class="params">ji1l</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从基类类型隐式转换为派生类型</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误。因为传递的不是一个Employee，而是一个object。继承链位置比前者高，不支持隐式转换</span></span><br><span class="line"><span class="function"><span class="built_in">object</span> frank <span class="keyword">new</span> <span class="title">Manager</span>(<span class="params"><span class="string">&quot;Frank Zappa&quot;</span>,<span class="number">9</span>,<span class="number">3000</span>,<span class="number">40000</span>,<span class="string">&quot;111-11-1111&quot;</span>,<span class="number">5</span></span>)</span>;</span><br><span class="line">GivePromotion(frank);</span><br><span class="line"></span><br><span class="line"><span class="comment">//要将object变量传递给GivePromotion()方法，必须使用如下的代码：</span></span><br><span class="line">GivePromotion ((Manager)frank);</span><br></pre></td></tr></table></figure>

<h5 id="6-6-1-C-的as关键字"><a href="#6-6-1-C-的as关键字" class="headerlink" title="6.6.1 C#的as关键字"></a>6.6.1 C#的as关键字</h5><p>但是C#提供了s关键字在运行时快速检测某个类型是否和另外一个兼容。如果我们使用as关键字，就可以通过检查nul1返回值来检测兼容性。考虑如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用“as”来测试兼容性</span></span><br><span class="line">Hexagon hex2 = frank <span class="keyword">as</span> Hexagon;</span><br><span class="line"><span class="keyword">if</span> (hex2 == <span class="literal">null</span>)</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Sorry,frank is not a Hexagon...&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="6-6-2-C-的is关键字"><a href="#6-6-2-C-的is关键字" class="headerlink" title="6.6.2 C#的is关键字"></a>6.6.2 C#的is关键字</h5><p>除了as关键字，C#语言还提供了is关键字来检测两个项是否兼容。然而，和as关键字不同的是，如果类型不兼容，is关键字就返回false而不是null引用。考虑如下GivePromotion()方法的实现：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GivePromotion</span> (<span class="params">Employee emp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;(0)was promoted!&quot;</span>emp.Name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (emp <span class="keyword">is</span> SalesPerson)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)made (1&#125;sale(s)!&quot;</span>emp.Name,</span><br><span class="line">            ((SalesPerson)emp).SalesNumber);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (emp <span class="keyword">is</span> Manager)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)had (1)stock options...&quot;</span>,emp.Name,</span><br><span class="line">            ((Manager)emp).Stockoptions);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-7-超级父类：System-object"><a href="#6-7-超级父类：System-object" class="headerlink" title="6.7 超级父类：System.object"></a>6.7 超级父类：System.object</h4><p>在.NET世界中，每一个类型最终都会从一个叫System.Object(可以用C#关键字Object表示)的基类派生。Object类定义了一组框架中所有类型公共的成员。System.object定义了一组成员。某些项被声明为Virtual。可以被重写</p>
<h5 id="6-7-1-重写System-Object-Tostring"><a href="#6-7-1-重写System-Object-Tostring" class="headerlink" title="6.7.1 重写System.Object.Tostring()"></a>6.7.1 重写System.Object.Tostring()</h5><p>这对于调试（由于其他原因)来说很有用。至于如何构建这个字符串，就看个人喜好了，然而，推荐的方式是使用分号来分割每一个名称&#x2F;值对并且在方括号中包装整个字符串(.NET基础类库中的很多类型都遵循这个方式)。下面是Person类重写ToString()的代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> myState;</span><br><span class="line">    myState = <span class="built_in">string</span>.Format (<span class="string">&quot;[First Name:(0);Last Name:(1);Age:(2)]&quot;</span>,</span><br><span class="line">        FirstName,LastName,Age);</span><br><span class="line">    <span class="keyword">return</span> mystate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-7-2-重写System-Object-Equals"><a href="#6-7-2-重写System-Object-Equals" class="headerlink" title="6.7.2 重写System.Object.Equals()"></a>6.7.2 重写System.Object.Equals()</h5><p>略</p>
<h5 id="6-7-3-重写System-Object-GetHashCode"><a href="#6-7-3-重写System-Object-GetHashCode" class="headerlink" title="6.7.3 重写System.Object.GetHashCode()"></a>6.7.3 重写System.Object.GetHashCode()</h5><p>略</p>
<h5 id="6-7-4-测试修改后的Person类"><a href="#6-7-4-测试修改后的Person类" class="headerlink" title="6.7.4 测试修改后的Person类"></a>6.7.4 测试修改后的Person类</h5><p>跟前两个相关联的测试。略</p>
<h5 id="6-7-5-System-Object的静态成员"><a href="#6-7-5-System-Object的静态成员" class="headerlink" title="6.7.5 System.Object的静态成员"></a>6.7.5 System.Object的静态成员</h5><p>System.Object还定义了两个（非常有用的）静态成员来测试基于值或基于引用的相等性。考虑如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMembersofobject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//System.Object的静态成员</span></span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;Sally&quot;</span>,<span class="string">&quot;Jones&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;Sally&quot;</span>,<span class="string">&quot;Jones&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;P3 and P4 have same state:(0)&quot;</span>,<span class="built_in">object</span>.Equals(p3,p4));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;P3 and P4 are pointing to same object:(0)&quot;</span>,</span><br><span class="line">        <span class="built_in">object</span>.ReferenceEquals(p3,p4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要传入两个对象（任何类型)并允许System.Object类自动检测细节。如果为自定义类型重新定义了相等性，或者需要检测两个引用变量是否指向内存中相同区域（通过静态的ReferenceEquals()方法)，这些方法就会很有用。</p>
<h3 id="7-结构化异常处理"><a href="#7-结构化异常处理" class="headerlink" title="7 结构化异常处理"></a>7 结构化异常处理</h3><p>诸如try、catch、throw、finally之类处理异常的C#关键字，还要了解应用程序级异常与系统级异常的区别以及System.Exception基类，其中还将介绍创建自定义异常和如何利用Visual Studio2010异常调试工具等主题。</p>
<h4 id="7-1-错误、bug与异常"><a href="#7-1-错误、bug与异常" class="headerlink" title="7.1 错误、bug与异常"></a>7.1 错误、bug与异常</h4><p>即便是最好的软件也经常伴随着各种各样的问题</p>
<ul>
<li>bug：由程序员一方引起的错误</li>
<li>用户错误：运行程序用户引起的。例如：输入非法字符串时</li>
<li>异常：编程时很难被估摸到。例如：试图链接一个已经不存在的数据库</li>
</ul>
<h4 id="7-2-NET异常处理的作用"><a href="#7-2-NET异常处理的作用" class="headerlink" title="7.2 .NET异常处理的作用"></a>7.2 .NET异常处理的作用</h4><p>结构化异常处理方案的优点在于，开发人员现在有了统一的而且对.NET领域内各种语言都通用的方式来处理错误。因此，一个C#程序员处理错误的方法和VB程序员、使用C+&#x2F;CLI的C++程序员处理错误的方法在语法上相似。更棒的是，用以引发和捕获异常的语法在不同程序集间或计算机间都是一致的。例如，如果使用C#构建WC℉服务，可以向远程调用者抛出一个SOAP错误，而使用的关键字与在同一个应用中的方法之间抛出异常的关键字完全相同。.NET异常的另一好处是，我们不再是通过接收意义模糊的数字常量来确定问题，而是可以通过异常，它们包含容易读懂的问题描述信息和首次触发异常时调用栈的详细快照。此外，我们还能够为最终用户提供相应的帮助链接信息，将他们引向一个URL,其中包含相应错误的详细信息和程序员自定义的数据。</p>
<h5 id="7-2-1-NET异常处理的四要素"><a href="#7-2-1-NET异常处理的四要素" class="headerlink" title="7.2.1 NET异常处理的四要素"></a>7.2.1 NET异常处理的四要素</h5><p>结构化异常处理编程要使用4个互相关联的实体：</p>
<ul>
<li>一个表示异常详细信息的类类型：</li>
<li>一个向调用者引发异常类实例的成员，</li>
<li>调用者的一段调用异常成员的代码块：</li>
<li>调用者的一段处理（或捕获）将要发生异常的代码块。</li>
</ul>
<h5 id="7-2-2-System-Exception基类"><a href="#7-2-2-System-Exception基类" class="headerlink" title="7.2.2 System.Exception基类"></a>7.2.2 System.Exception基类</h5><p>所有用户定义和系统定义的异常最终都继承自System.Exception基类（它继承自System.Object基类)。这个类的代码如下（请注意其中有些成员是虚的，这样就可能被派生类型重写）</p>
<h4 id="7-3-最简单的例子"><a href="#7-3-最简单的例子" class="headerlink" title="7.3 最简单的例子"></a>7.3 最简单的例子</h4><p>略</p>
<h5 id="7-3-1-引发普通的异常"><a href="#7-3-1-引发普通的异常" class="headerlink" title="7.3.1 引发普通的异常"></a>7.3.1 引发普通的异常</h5><p>我们将创建并设定一个新的System.Exception类的实例，并通过类的构造函数为只读属性Message赋值。如果将异常对象返回被调用者，可以使用C#中的throw关键字。下面是新Accelerate()方法的相关代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这次如果用户加速到超过最大速度，就会引发异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (carIsDead)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)is out of order...&quot;</span>,PetName);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentSpeed +delta;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSpeed &gt;MaxSpeed)</span><br><span class="line">        &#123;</span><br><span class="line">            carIsDead <span class="literal">true</span>;</span><br><span class="line">            CurrentSpeed =<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用throw关键字引发异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format (<span class="string">&quot;(0)has overheated!&quot;</span>,PetName));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=&gt;CurrentSpeed (0&#125;&quot;</span>,CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，异常应当仅仅在一个较为致命的条件满足后引发（比如未发现必要的文件，连接数据库失败等等)。</p>
<h5 id="7-3-2-捕获异常"><a href="#7-3-2-捕获异常" class="headerlink" title="7.3.2 捕获异常"></a>7.3.2 捕获异常</h5><p>当调用一个可能引发异常的方法时，应当使用ty&#x2F;catch块。一旦捕获到异常对象，将能够调用异常对象成员来释放问题的详细信息。如何处理这份数据取决于我们自己。你可能希望将其记录到报告文件里，写进Windows事件日志里，发电子邮件给系统管理员或者将问题显示给最终用户</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理引发的异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Car mycar = <span class="keyword">new</span> car(<span class="string">&quot;Zippy&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    myCar.CrankTunes (<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加速车到超过最大速度以触发异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        myCar.Accelerate(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Method:(0)&quot;</span>,e.Targetsite);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message:(0)&quot;</span>,e.Message);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Source:(0&#125;&quot;</span>,e.Source);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异常被处理了，转到下一个语句</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-配置异常的状态"><a href="#7-4-配置异常的状态" class="headerlink" title="7.4 配置异常的状态"></a>7.4 配置异常的状态</h4><p>Exception类还会提供其他成员(Targetsite、StackTrace、HelpLink和Data),这些成员在需要进一步界定问题本质时很有用。</p>
<h5 id="7-4-1-TargetSite属性"><a href="#7-4-1-TargetSite属性" class="headerlink" title="7.4.1 TargetSite属性"></a>7.4.1 TargetSite属性</h5><p>System.Exception,Targetsite属性帮助我们了解引发某个异常的方法的各种信息。输出Targetsite的值将显示返回值、名称、引发异常方法的参数。可是，Targetsite不是只返回华而不实的字符串，而是返回一个强类型的ystem.Reflection.MethodBase对象。这种类型可用于收集引发异常的方法以及定义引发异常的方法的类的许多信息。假定我们的上一个catch逻辑更新为如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>(]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Targetsite实际上返回一个MethodBase对象</span></span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">***Error!***&quot;</span>)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Member name:(0)&quot;</span>,e.Targetsite);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Class defining member:(0&#125;&quot;</span>,</span><br><span class="line">            e.Targetsite.DeclaringType);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Member type:(0&#125;&quot;</span>,e.Targetsite.MemberType);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message:(0&#125;&quot;</span>,e.Message);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Source:(0)&quot;</span>,e.Source);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">*****Out of exception logic *****&quot;</span>)</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-2-StackTrace属性"><a href="#7-4-2-StackTrace属性" class="headerlink" title="7.4.2 StackTrace属性"></a>7.4.2 StackTrace属性</h5><p>System.Exception.StackTrace属性帮助我们标识引发异常的一系列调用。需要注意的是，StackTrace的值是异常创建时自动产生的，无法为其赋值。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Stack:(0)&quot;</span>, e.StackTrace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-HelpLink属性"><a href="#7-4-3-HelpLink属性" class="headerlink" title="7.4.3 HelpLink属性"></a>7.4.3 HelpLink属性</h5><p>Targetsite属性和StackTrace属性能够帮助程序员了解指定的异常，它们对最终用户而言却基本上没什么用。你已经看到System.Exception.Message属性可用来获取呈现给当前用户的可以阅读的信息。默认情况下，HelpLink属性的值是一个空字符串。如果读者需要用一个有意义的值填充该属性，就要在引发System.Exception类型异常之前赋值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (carIsDead)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)is out of order...&quot;</span>,PetName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentSpeed +=delta;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSpeed &gt;MaxSpeed)</span><br><span class="line">        &#123;</span><br><span class="line">        carIsDead <span class="literal">true</span>;</span><br><span class="line">        CurrentSpeed <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//我们儒要调用H1 pLink属性，因此需要在异常对象引发之前先创建一个本地变量</span></span><br><span class="line">        Exception ex =</span><br><span class="line">        	<span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format (<span class="string">&quot;(0&#125;has overheated!&quot;</span>,PetName));</span><br><span class="line">        ex.HelpLink = <span class="string">&quot;http://www.CarsRUs.com&quot;</span>；</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;=&gt;CurrentSpeed (0)&quot;</span>,CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>逻辑块将被更新，以输出如下的帮助链接信息：</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Help Link:&#123;0)&quot;</span>,e.HelpLink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-4-Data属性"><a href="#7-4-4-Data属性" class="headerlink" title="7.4.4 Data属性"></a>7.4.4 Data属性</h5><p>System.Exception中的Data属性允许我们使用用户提供的相应信息（如时间戳）来填充异常对象。Data属性返回一个实现了定义在System.Collections命名空间下的IDictionary接口的对象</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (carIsDead)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)is out of order...&quot;</span>,PetName);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentSpeed += delta;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSpeed &gt;=MaxSpeed)</span><br><span class="line">        &#123;</span><br><span class="line">            carIsDead <span class="literal">true</span>;</span><br><span class="line">            Currentspeed <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//我们需要调用He1 pLink属性，因此需要在异常对象引发之前先创建一个本地变量</span></span><br><span class="line">            Exception ex =</span><br><span class="line">                <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format (<span class="string">&quot;(0)has overheated!&quot;</span>,PetName));</span><br><span class="line">            ex.HelpLink <span class="string">&quot;http://www.CarsRUs.com&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//填充关于错误的自定义数据</span></span><br><span class="line">            ex.Data.Add(<span class="string">&quot;TimeStamp&quot;</span>,</span><br><span class="line">                <span class="built_in">string</span>.Format (<span class="string">&quot;The car exploded at (0)&quot;</span>,DateTime.Now));</span><br><span class="line">            ex.Data.Add(<span class="string">&quot;Cause&quot;</span>,<span class="string">&quot;You have a lead foot.&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;=&gt;CurrentSpeed (0)&quot;</span>,CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-5-系统级异常（System-SystemException"><a href="#7-5-系统级异常（System-SystemException" class="headerlink" title="7.5 系统级异常（System.SystemException)"></a>7.5 系统级异常（System.SystemException)</h4><p>.NET平台引发的异常应被称为系统异常。这些异常被认为是无法修复的致命错误。系统异常直接派生自名为System.SystemException的基类</p>
<p>当一个异常类型派生自System.SystemException时，能够判断引发该异常的实体是.NET运行库而不是正在执行的应用程序代码库</p>
<h4 id="7-6-应用程序级异常-Sytem-ApplicationException"><a href="#7-6-应用程序级异常-Sytem-ApplicationException" class="headerlink" title="7.6 应用程序级异常(Sytem.ApplicationException)"></a>7.6 应用程序级异常(Sytem.ApplicationException)</h4><p>就像系统异常一样，应用程序异常并不在一组构造函数外再定义其他任何成员。从功能上来讲，System.ApplicationException的唯一目的就是标识出错误的来源。当读者处理一个派生自System.ApplicationException的异常时，可以设想异常是由正在执行的应用程序代码库引发的，而不是由.NET基础类库或NET运行时引擎引发的。</p>
<h5 id="7-6-1-构建自定义异常，第一部分"><a href="#7-6-1-构建自定义异常，第一部分" class="headerlink" title="7.6.1 构建自定义异常，第一部分"></a>7.6.1 构建自定义异常，第一部分</h5><p>假定要构建一个自定义异常，第一步就是要创建于给派生自System.Exception&#x2F;System.ApplicationException的新类</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个自定义异常描述了car-is-dead条件下的详细信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarIsDeadException</span> <span class="title">ApplicationException</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，可以重写Exception中的方法，和自定义构造</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarIsDeadException</span> : <span class="title">ApplicationException</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> messageDetails String.Empty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTime <span class="title">ErrorTimeStamp</span> (<span class="params"><span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> <span class="built_in">string</span> CauseofError (<span class="keyword">get</span>;<span class="keyword">set</span>;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="title">CarIsDeadException</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarIsDeadException</span>(<span class="params"><span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> cause,DateTime time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        messageDetails message;</span><br><span class="line">        CauseofError cause;</span><br><span class="line">        ErrorTimeStamp time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Exception.Message属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Message</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">string</span>.Format (<span class="string">&quot;Car Error Message:(0)&quot;</span>,messageDetails);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-6-2-构建自定义异常，第二部分"><a href="#7-6-2-构建自定义异常，第二部分" class="headerlink" title="7.6.2 构建自定义异常，第二部分"></a>7.6.2 构建自定义异常，第二部分</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarIsDeadException</span> <span class="title">ApplicationException</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime ErrorTimestamp &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CauseofError &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarIsDeadException</span>()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将信息传递给父对象构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarIsDeadException</span>(<span class="params"><span class="built_in">string</span> message,<span class="built_in">string</span> cause,DateTime time</span>)</span></span><br><span class="line"><span class="function">        :<span class="title">base</span>(<span class="params">message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            CauseofError cause;</span><br><span class="line">            ErrorTimestamp time;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，这次我们并没有定义一个字符串变量来呈现信息，也没有重写Message属性，仅是将参数传递到基类构造函数而已。通过这样的设计，一个自定义异常类就没有任何基类重写，和一个派生自System.ApplicationException的特定命名的类没有任何差别了。自定义异常类的作用并不是提供继承基类之外附加的功能，而是提供明确标识错误种类的强命名类型，因此客户会为不同类型的异常提供不同的处理程序逻辑。</p>
<h5 id="7-6-3-构建自定义异常，第三部分"><a href="#7-6-3-构建自定义异常，第三部分" class="headerlink" title="7.6.3 构建自定义异常，第三部分"></a>7.6.3 构建自定义异常，第三部分</h5><p>如果读者想构造一个真正意义上严谨规范的自定义异常类，需要确保类遵守ET异常处理的最佳实践。具体来讲，自定义异常需要：</p>
<ul>
<li>继承自ApplicationException类，</li>
<li>有[System..Serializable]特性标记，</li>
<li>定义一个默认的构造函数；</li>
<li>定义一个设定继承的Message属性的构造函数；</li>
<li>定义一个处理“内部异常”的构造函数：</li>
<li>定义一个处理类型序列化的构造函数。</li>
</ul>
<h4 id="7-7-处理多个异常"><a href="#7-7-处理多个异常" class="headerlink" title="7.7 处理多个异常"></a>7.7 处理多个异常</h4><p>要牢记的一条首要原则就是，要保证将catch块按照下面的原则结构化：最前面的catch捕获最特定的异常（也就是一个异常类型派生关系链中排在最上面的派生类型），最后面的catch捕获最普通的异常（也就是指定异常继承关系链中的基类，在本例中是System.Exception)。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这段代码编译正常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Handling Multiple Exceptions *****n&quot;</span>);</span><br><span class="line">    <span class="function">Car mycar <span class="keyword">new</span> <span class="title">Car</span>(<span class="params"><span class="string">&quot;Rusty&quot;</span>,<span class="number">90</span></span>)</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//触发超出范围的异常</span></span><br><span class="line">        mycar.Accelerate(<span class="number">-10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CarIsDeadException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ArgumentOutofRangeException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捕获CarIaDeadException和ArgumentoutofRangeException之后的所有异常</span></span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-7-1-通用的catch语句"><a href="#7-7-1-通用的catch语句" class="headerlink" title="7.7.1 通用的catch语句"></a>7.7.1 通用的catch语句</h5><p>C#也支持通用catch块，它不显式接收由指定成员引发的异常对象：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通用的catch</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Handling Multiple Exceptions *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="function">Car mycar <span class="keyword">new</span> <span class="title">car</span>(<span class="params"><span class="string">&quot;Rusty&quot;</span>,<span class="number">90</span></span>)</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        myCar.Accelerate(<span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Something bad happened...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种处理方法获取不到有用的信息，但他是被允许的，可以通用处理所有错误</p>
<h5 id="7-7-2-再次引发异常"><a href="#7-7-2-再次引发异常" class="headerlink" title="7.7.2 再次引发异常"></a>7.7.2 再次引发异常</h5><p>可以在try块逻辑中向之前的调用者再次引发一个调用栈异常。要想这样，仅仅在catch块中使用throw关键字就行了，它通过调用逻辑链传递异常。在catch块只能处理即将发生的部分错误时这样做很有用：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//传递异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给汽车加速的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(CarIsDeadException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行一些处理此错误的操作并传递异常</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终用户将看到一个系统提供的错误对话框。通常情况下，只需要向调用者再次引发部分处理过的异常，使之能够恰当地处理即将发生的异常。</p>
<h5 id="7-7-3-内部异常"><a href="#7-7-3-内部异常" class="headerlink" title="7.7.3 内部异常"></a>7.7.3 内部异常</h5><p>在处理一个异常的时候遇到另一个异常，最好的习惯是将这个新异常对象标识为与第一个异常类型相同的新对象中的“内部错误”，这个建议比较拗口。我们之所以需要创建一个异常的新对象来等待处理，是因为声明一个内部错误的唯一途径就是将其作为一个构造函数参数。考虑以下代吗：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (CarIsDeadException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Filestream fs File.Open(<span class="string">@&quot;C:\carErrors.txt&quot;</span>,FileMode.Open);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//引发记录新异常的异常，还有第一个异常的相关信息</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CarIsDeadException(e.Message,e2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-7-4-finally块"><a href="#7-7-4-finally块" class="headerlink" title="7.7.4 finally块"></a>7.7.4 finally块</h5><p>一个try&#x2F;catch块后面可能接着会定义一个finally块。finally块并不是必须要有的，它是为了保证不管是否有异常（或其他任何类型)，一组代码语句始终都能被执行。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Handling Multiple Exceptions *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="function">Car mycar <span class="keyword">new</span> <span class="title">Car</span>(<span class="params"><span class="string">&quot;Rusty&quot;</span>,<span class="number">90</span></span>)</span>;</span><br><span class="line">    myCar.CrankTunes(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//车的加速逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(CarIsDeadException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理CarIsDeadException</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(ArgumentOutofRangeException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理ArgumentoutofRangeException</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理其他任何异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不论异常发生与否，以下语句总是被执行</span></span><br><span class="line">        myCar.CrankTunes (<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console,ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-8-谁在引发什么异常"><a href="#7-8-谁在引发什么异常" class="headerlink" title="7.8 谁在引发什么异常"></a>7.8 谁在引发什么异常</h4><p>“我怎么知道指定的基础类库中的方法可能引发哪个异常呢？”最终的答案就是：参阅.NET Framework4SDK文档。帮助系统文档中的每个方法都有指定成员可能引发的异常。另外一个可供选择的办法是：在Visual Studio2010中可以通过悬停鼠标光标在代码窗口的成员名称上，来浏览该基础类库成员可能引发的所有异常（如果有的话)的列表</p>
<h4 id="7-9-未处理异常的后果"><a href="#7-9-未处理异常的后果" class="headerlink" title="7.9 未处理异常的后果"></a>7.9 未处理异常的后果</h4><p>其实就是一个演示弹窗。略</p>
<h4 id="7-10-使用Visual-Studio调试未处理的异常"><a href="#7-10-使用Visual-Studio调试未处理的异常" class="headerlink" title="7.10 使用Visual Studio调试未处理的异常"></a>7.10 使用Visual Studio调试未处理的异常</h4><p>请注意，为了解决这些问题，Visual Studio2010提供了大量工具来帮助我们调试未处理自定义异常。再次假定将Car对象加速超过了速度上限。如果启动了调试会话（选择Debug→StartDebugging菜单)，Visual Studio会在未处理异常引发时自动中断。利用好调试功能，来测试出异常</p>
<h4 id="7-11-损坏状态异常简介"><a href="#7-11-损坏状态异常简介" class="headerlink" title="7.11 损坏状态异常简介"></a>7.11 损坏状态异常简介</h4><p>在Windows API中，常常会陷入一些低级别的表示“状态损坏”的错误中。简而言之，如果Windows操作系统发出了一个状态损坏的错误，你的程序就会面临崩遗。正因如此，就不要指望恢复应用了，唯一正确的做法是终止程序。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">HandledProcessCorruptedstateExceptions)</span></span><br><span class="line"><span class="meta">static int Main(string[</span>]args)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设Main()调用的方法可以运行整个程序</span></span><br><span class="line">        RunMyApplication();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果到达这里，说明发生了一些很精糕的事情</span></span><br><span class="line">        <span class="comment">//打印消息并退出程序吧…这就是我们的命运</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Ack!Huge problem:(0)&quot;</span>,ex.Message);</span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="8-对象的生命周期"><a href="#8-对象的生命周期" class="headerlink" title="8 对象的生命周期"></a>8 对象的生命周期</h3><p>C#程序员从来不直接从内存中删别除一个托管对象（回忆一下，在C#语言中没有delete关键字）。相反，NET对象被分配到一块叫做托管堆(managed heap)的内存区域上，在那里它们会在“将来的某一时刻”被垃圾回收器自动销毁。</p>
<h4 id="8-1-类、对象和引用"><a href="#8-1-类、对象和引用" class="headerlink" title="8.1 类、对象和引用"></a>8.1 类、对象和引用</h4><p>类只是一个蓝图，它描述了这个类型的实例在内存中看起来是什么样子定义类后，可以使用new关键字分配任意数量的对象new关键字返回的是一个指向堆上对象的引用，而不是真正对象本身</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">printhello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">print1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在托管堆上创建一个新的printhello对象，返回一个对这个对象的引用（&#x27;t(栈)&#x27;）</span></span><br><span class="line">        printhello t = <span class="keyword">new</span> printhello;</span><br><span class="line">        Console.WriteLine(t.print1().Tostring());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-对象生命周期的基础"><a href="#8-2-对象生命周期的基础" class="headerlink" title="8.2 对象生命周期的基础"></a>8.2 对象生命周期的基础</h4><p>你无需对托管堆进行直接操作，它将自动管理。当一个对象从代码库的任何部分都不可访问时，垃圾回收器就会从堆中删除它</p>
<h5 id="8-2-1-CIL的new指令"><a href="#8-2-1-CIL的new指令" class="headerlink" title="8.2.1 CIL的new指令"></a>8.2.1 CIL的new指令</h5><p>要理解托管堆不只是一个由CLR访问的随机内存块。.NET垃圾回收器是堆的“清洁工”，它会压缩空的内存块来实现优化（必要的时候）。为了辅助这一行为，托管堆保存着一个指针(常称为下一个对象的指针或新对象指针)，它精确地指示下一个对象将被分配的位置。此外，newobj指令通知CLR执行下面的核心任务。</p>
<ul>
<li>计算分配对象所需要的总内存数（包含数据成员和基类所需的内存)。</li>
<li>检查托管堆，确保有足够的空间来放置要分配的对象。如果空间足够，调用类型的构造函数，最终将内存中新对象的引用返回给调用者，它的地址恰好是下一个对象的指针的上一个位置。</li>
<li>最后，在将引用返回给调用者之前，移动下一个对象的指针，指向托管堆上的下一个可用的</li>
</ul>
<p>位置。因为我们经常需要在应用程序中频繁地分配对象，托管堆上的空间最终会用完。当处理newobj指令时，如果CLR判定托管堆没有足够的空间来分配所请求的类型，它会执行一次垃圾回收来尝试释放内存</p>
<h5 id="8-2-2-将对象引用设置为空"><a href="#8-2-2-将对象引用设置为空" class="headerlink" title="8.2.2 将对象引用设置为空"></a>8.2.2 将对象引用设置为空</h5><p>C&#x2F;C++程序员通常将指针变量设置为NULL来确保不再引用非托管内存。将引用赋值为NULL并不意味着强制垃圾回收器立即启动并把对象从堆上移除。我们完成的唯一事情就是显式取消引用和之前引用所指向对象之间的连接。因此，和其他C系列的语言（或VB6.0)相比，在C#中将引用设置为NULL意义就不大了，不管怎么样，这样做也不会有什么害处。</p>
<h4 id="8-3-应用程序根的作用"><a href="#8-3-应用程序根的作用" class="headerlink" title="8.3 应用程序根的作用"></a>8.3 应用程序根的作用</h4><p>根(root)就是一个存储位置，其中保存着对托管堆上一个对象的引用。严格地说，根可以属于下面任何一个类别：</p>
<ul>
<li>全局对象的引用（虽然在C#中不允许，但是CIL代码的确允许分配全局对象)</li>
<li>静态对象&#x2F;静态字段的引用</li>
<li>应用程序代码库中局部对象的引用</li>
<li>传递进一个方法的对象参数的引用</li>
<li>等待被终结的对象的引用</li>
<li>任何引用对象的CPU寄存器</li>
</ul>
<h4 id="8-4-对象的代"><a href="#8-4-对象的代" class="headerlink" title="8.4 对象的代"></a>8.4 对象的代</h4><p>当CLR试图寻找不可访问的对象时，它不会逐个检查托管堆上的每一个对象。为了帮助优化这个过程，堆上的每一个对象被指定为属于某“代”(generation)。代的设计思路很简单：对象在堆上存在的时间越长，它就更可能应该保留。例如，定义桌面应用程序主窗口的类将一直停留在内存中直到程序结束。相反，最近才放在堆上的对象可能很快就不可访问了（例如在一个方法作用域中创建的对象)。基于这些假设，堆上的每一个对象都属于下列某代。会依次向高代进行访问，看是否能拿到更多内存</p>
<ul>
<li>第0代：从没有被标记为回收的新分配的对象。</li>
<li>第1代：在上一次垃圾回收中没有被回收的对象（也就是，它被标记为回收，但因为已经获取了足够的堆空间而没有被删除)。</li>
<li>第2代：在一次以上的垃圾回收后仍然没有被回收的对象。</li>
</ul>
<h4 id="8-5-NET1-0至-NET3-5的并发垃圾回收"><a href="#8-5-NET1-0至-NET3-5的并发垃圾回收" class="headerlink" title="8.5 .NET1.0至.NET3.5的并发垃圾回收"></a>8.5 .NET1.0至.NET3.5的并发垃圾回收</h4><p>在.NET4之前，运行时使用并发垃圾回收技术来清理不再使用的对象。在这个模型下，当对第0代或第1代对象执行回收时，垃圾收集器会暂时挂起当前进程中的所有活动线程，以确保应用程序在回收过程中不会访问托管堆。</p>
<h4 id="8-6-NET4下的后台垃圾回收"><a href="#8-6-NET4下的后台垃圾回收" class="headerlink" title="8.6 .NET4下的后台垃圾回收"></a>8.6 .NET4下的后台垃圾回收</h4><p>.NET4改变了垃圾回收器处理线程挂起的方式，它在清理托管堆上的对象时，使用后台垃圾回收。尽管它叫这个名称，但并不意味着所有的垃圾回收都发生在额外的后台执行线程。后台垃圾回收用于非暂时代上的对象，而对于暂时代上的对象，.NET运行时将使用一个专用后台线程进行回收。</p>
<h4 id="8-7-System-GC类型"><a href="#8-7-System-GC类型" class="headerlink" title="8.7 System.GC类型"></a>8.7 System.GC类型</h4><p>极少需要在代码中直接使用这个类一般情况下，只有在创建那些使用非托管资源的类时，才需要使用System.Gc的成员。例如，使用.NET平台调用协议调用基于C的Windows API,或一些非常低级且复杂的COM互操作逻辑。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 强制一次垃圾回收，并等待每一个对象都被终结</span></span><br><span class="line">    GC.Collect();</span><br><span class="line">    GC.waitForPendingFinalizers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-8-构建可终结对象"><a href="#8-8-构建可终结对象" class="headerlink" title="8.8 构建可终结对象"></a>8.8 构建可终结对象</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// System.object</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Finalize</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当为自定义的类重写Fina1ize()时，就建立了一个地方，来为类型执行必要的清理逻辑。因为这个成员被定义为受保护的，所以不可能通过点操作符从类实例中直接调用一个对象的Finalize()方法。相反，在从内存删除这个对象之前，垃圾回收器会调用对象的Finalize()方法（如果支持的话)。大多数C#类都不需要显式地清理逻辑，也不需要自定义终结器。原因很简单：如果类使用了其他托管对象，一切都最终会被回收。只是在你使用非托管资源时（例如原始的操作系统文件句柄、原始的非托管数据库连接、非托管内存或其他非托管资源)，才可能需要设计一个在用完后清理自身的类。在.NET平台上，非托管资源是通过使用PInvoke(平台调用)服务直接调用操作系统的API,或通过一些复杂的COM交互获得的。</p>
<h5 id="8-8-1-重写System-object-Finalize"><a href="#8-8-1-重写System-object-Finalize" class="headerlink" title="8.8.1 重写System.object.Finalize()"></a>8.8.1 重写System.object.Finalize()</h5><p>在极其个别的情况下，确实需要创建一个使用非托管资源的类，你显然希望保证底层内存以一种可预测的方式被释放。C#终结器和构造函数很相似，因为它们和定义它们的类具有相同的名字。此外，终结器具有波浪号(~)前缀。然而，和构造方法不同的是，终结器不接受访问修饰符（它们是受隐式保护的），不接受参数，也不能被重载（一个类只能有一个终结器）。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用终结器语法重写System.object.Finalize()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyResourceWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    ~MyResourceWrapper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//清除这里非托管的资源</span></span><br><span class="line">        <span class="comment">//当被销毁时蜂鸣（仅为测试目的）</span></span><br><span class="line">        Conso1e.Beep（）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-8-2-终结过程的细节"><a href="#8-8-2-终结过程的细节" class="headerlink" title="8.8.2 终结过程的细节"></a>8.8.2 终结过程的细节</h5><p>尽管对象的终结能够保证对象可以清除非托管的资源，但它本质上仍然是非确定的，而且由于额外的幕后处理，速度会变得相当慢。</p>
<h4 id="8-9-构建可处置对象"><a href="#8-9-构建可处置对象" class="headerlink" title="8.9 构建可处置对象"></a>8.9 构建可处置对象</h4><p>很多非托管资源都非常宝贵(如数据库和文件句柄)，所以它们应该尽可能快地被清除，而不能依靠垃圾回收的发生如果提供IDisposable接口，就是假设当对象用户不再使用这个对象时，会在这个对象引用离开作用域之前手工调用Dispose()。这样，对象可以执行任何必要的非托管资源的清除工作，而且不会再有将对象放在终结队列上导致的性能损失，也不必等待垃圾回收器触发类的终结逻辑。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现IDisposable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyResourcewrapper</span> <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对象用户应该在完成使用这个对象时调用这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这里清除非托管资源</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//抛弃包含的其他可处置对象</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//出于测试目的</span></span><br><span class="line">        Console.WriteLine (<span class="string">&quot;****In Dispose!*****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设我们已经导入了System.Io命名空间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisposeFilestream</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">FileStream fs <span class="keyword">new</span> <span class="title">Filestream</span>(<span class="params"><span class="string">&quot;myFile.txt&quot;</span>,FileMode.OpenorCreate</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//确实有点混淆，这两个方法调用完成相同的事情</span></span><br><span class="line">    fs.close();</span><br><span class="line">    fs.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类型实现了IDisposable,调用Dispose()总是正确的。<strong>重用C#的using关键字</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当退出using作用域时，自动调用Dispose()</span></span><br><span class="line">    <span class="keyword">using</span>(<span class="function">MyResourceWrapper rw <span class="keyword">new</span> <span class="title">MyResourceWrapper</span> ())</span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="comment">//使用xw对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-10-构建可终结类型和可处置类型"><a href="#8-10-构建可终结类型和可处置类型" class="headerlink" title="8.10 构建可终结类型和可处置类型"></a>8.10 构建可终结类型和可处置类型</h4><p>将两个技术混合进同一个类定义是可行的。这样做可以获得两种模型的好处。如果对象用户记住了调用Dispose(),可以通过调用cC.SuppressFinalize()通知垃圾回收器跳过终结过程，如果对象用户忘记了调用Dispose(),对象最终也将被终结并有机会释放内部资源。对象的内部非托管资源会用其中一种方式释放掉。下面是修改后的yResourceWrapper,它现在既是可终结的，也是可处置的，它定义在C#控制台应用程序FinalizableDisposableClass中：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高级的资源包装器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyResourceWrapper</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果对象用户忘记调用Dispose(),垃圾回收器会调用这个方法</span></span><br><span class="line">    ~MyResourcewrapper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//清除所有内部的非托管资源</span></span><br><span class="line">        <span class="comment">//不要调用任何托管对象的Dispose()</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//对象用户将调用这个方法来尽快清除资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这里清除非托管资源</span></span><br><span class="line">        <span class="comment">//在其他包含的可处置对象上调用Dispose()</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//如果用户调用了Dispose()就不需要终结，因此跳过终结</span></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正式的处置模式</strong>首先，Finalize()和Dispose()方法都要清除相同的非托管资源。这当然导致了重复的代码，它很容易使维护复杂化。理想情况下，应该定义一个私有的辅助函数供两个方法调用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyResourceWrapper</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用来判断Dispose()是否已经被调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposed <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用辅助方法</span></span><br><span class="line">        <span class="comment">//指定true表示对象用户触发了清理过程</span></span><br><span class="line">        CleanUp(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在跳过终结</span></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUp</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//保证我们还没有被处置</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>,disposed)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//如果disposing等于true,释放所有托管的资源</span></span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//释放托管的资源</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在这里清理非托管的资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        disposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ~MyResourcewrapper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用辅助方法</span></span><br><span class="line">        <span class="comment">//指定false表示Gc触发了清理过程</span></span><br><span class="line">        CleanUp(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-11-延迟对象实例化"><a href="#8-11-延迟对象实例化" class="headerlink" title="8.11 延迟对象实例化"></a>8.11 延迟对象实例化</h4><p>在创建类时，可能偶尔会在代码中添加一个永远不会被使用的特殊成员变量，因为用户不会调用使用了它们的方法（或属性）。这很正常。但是，如果成员变量的初始化需要很大的内存空间，问题就来了。.NET4基础类库提供了一个非常有趣的泛型类Lazy&lt;&gt;,它定义在mscorlib.d11内的System命名空间下。该类所定义的数据在代码库实际使用它之前是不会被创建的。由于它是一个泛型类，因此第一次使用时必须指定要创建的项的类型，可以是任意ET基础类库中的类型或自定义类型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MediaPlayer包含Lazy&lt;AllTracks&gt;对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MediaPlayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Lazy&lt;AllTracks&gt; allSongs = <span class="keyword">new</span> Lazy&lt;AllTracks&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AllTracks <span class="title">GetAllTracks</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回所有歌曲</span></span><br><span class="line">        <span class="keyword">return</span> allSongs.Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里没有分配AllTracks对象</span></span><br><span class="line">    <span class="function">Mediaplayer myPlayer <span class="keyword">new</span> <span class="title">Mediaplayer</span>()</span>;</span><br><span class="line">    myPlayer.play();</span><br><span class="line">                  </span><br><span class="line">    <span class="comment">//在调用GetA11 Tracks()时分配AllTracks</span></span><br><span class="line">    MediaPlayer yourplayer = <span class="keyword">new</span> Mediaplayer();</span><br><span class="line">    AllTracks yourMusic = yourPlayer.GetAllTracks();</span><br><span class="line">    </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定制延迟数据的创建</strong>但如果AllTracks类包含其他的构造函数，并且你想调用它们会如何呢？Lazy&lt;&gt;类允许指定一个泛型委托作为可选参数。在创建其包装的类型时，它将调用指定的方法。该泛型委托的类型为System.Punc&lt;&gt;,它所指向的方法的返回值类型与相关的Lazy&lt;&gt;变量所创建的类型是相同的，并且可以包含16个参数（用泛型类型参数表示)。在大多数情况下，都不需要向Func&lt;&gt;所指向的方法传入任何参数</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Mediaplayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在创建AllTracks对象时使用Lambda表达式添加额外的代码</span></span><br><span class="line">    <span class="keyword">private</span> Lazy&lt;AllTracks&gt; allSongs = <span class="keyword">new</span> Lazy&lt;AllTracks&gt;( () =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Creating AllTracks object!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AllTracks();</span><br><span class="line">         &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AllTracks <span class="title">GetAllTracks</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回所有的歌曲</span></span><br><span class="line">        <span class="keyword">return</span> allSongs.Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="高级C-编程结构"><a href="#高级C-编程结构" class="headerlink" title="高级C#编程结构"></a>高级C#编程结构</h2><h3 id="9-接口"><a href="#9-接口" class="headerlink" title="9 接口"></a>9 接口</h3><p>本章剩余的部分会研究许多定义在.NET基础类库中的标准接口。我们会看到，自定义类和结构完全可以实现这些预定义的接口，以支持对象克隆、对象枚举和对象排序等的高级行为。</p>
<h4 id="9-1-接口类型"><a href="#9-1-接口类型" class="headerlink" title="9.1 接口类型"></a>9.1 接口类型</h4><pre><code> 首先给出接口类型的正式定义。接口就是一组抽象成员的集合。抽象方法是纯粹的协议，在其中没有提供默认的实现。由接口定义的某个特定成员依赖于它所模拟的确切行为。一个类（或者一个结构）可以支持任意数量的接口，因此也就支持了多种行为。
</code></pre>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//IDbConnection接口定义了一组所有连接对象都支持的公共成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDbConnection</span> : <span class="title">IDisposable</span>	<span class="comment">//interface是接口定义关键字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function">IDbTransaction <span class="title">BeginTransaction</span>()</span>;</span><br><span class="line">    <span class="function">IDbTransaction <span class="title">BeginTransaction</span>(<span class="params">IsolationLevel il</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChangeDatabase</span>(<span class="params"><span class="built_in">string</span> databaseName</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span>()</span>;</span><br><span class="line">    <span class="function">IDbCommand <span class="title">CreateCommand</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="built_in">string</span> Connectionstring <span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="built_in">int</span> ConnectionTimeout <span class="keyword">get</span>;</span><br><span class="line">    <span class="built_in">string</span> Database <span class="keyword">get</span>;</span><br><span class="line">    Connectionstate State <span class="keyword">get</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对比接口类型和抽象基类</strong>虽然类定义了一组抽象成员，它完全可以再定义许多构造函数、字段数据、非抽象成员（具有实现）等。而接口，只能包含抽象成员。由抽象父类创建的多态接口有一个主要的限制，那就是只有派生类型才支持由抽象父类定义的成员。定义了接口之后，它就可以被任何层次结构、任何命名空间或任何程序集（由任何NET编程语言写的)中的任何类型来实现。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">object</span> <span class="title">clone</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-定义自定义接口"><a href="#9-2-定义自定义接口" class="headerlink" title="9.2 定义自定义接口"></a>9.2 定义自定义接口</h4><p>接口新建：prohect—&gt;add new  item——&gt;interface接口使用interface关键字来定义；接口不指定基类；接口成员也不指定访问修饰符</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个pointy表现为一个只读属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPointy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口中的读写属性为以下形式</span></span><br><span class="line">    <span class="comment">//retType PropName &#123; get;set; &#125;</span></span><br><span class="line">    <span class="comment">//而接口中的只写属性是</span></span><br><span class="line">    <span class="comment">//retType PropName &#123; set; &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">byte</span> Points &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口类型就其本身而言没什么用，因为它们只是抽象成员的集合，除非被类或接口实现</p>
<h4 id="9-3-实现接口"><a href="#9-3-实现接口" class="headerlink" title="9.3 实现接口"></a>9.3 实现接口</h4><p>如果类（或结构）选择通过支持接口来扩展功能，就需要在其类型定义中使用逗号分隔的列表。要知道要知道直接基类必须是冒号操作符后的第一个项。如果类类型从System.Object直接继承，我们完全可以只在列表中提供类支持的接口，因为如果没有特别指明，C#编译器会从System.Object扩展我们的类型</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个类派生自System.Object并且实现一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pencil</span> : <span class="title">IPointy</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//这个类也派生自System.Object并且实现一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SwitchBlade</span> : <span class="title">object</span>,<span class="title">IPointy</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//这个类派生自一个自定义基类并且实现一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fork</span> : <span class="title">Utensil</span>,<span class="title">IPointy</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这个结构隐式派生自System.ValueType并且实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Arrow : ICloneable,IPointy</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//名为Triangle(三角形)的新的Shape派生类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="title">Shape</span>,<span class="title">IPointy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;Drawing &#123;0&#125;the Triangle&quot;</span>,PetName);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IPointy实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span> Points</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-在对象级别调用接口成员"><a href="#9-4-在对象级别调用接口成员" class="headerlink" title="9.4 在对象级别调用接口成员"></a>9.4 在对象级别调用接口成员</h4><p>如何才能动态判断一个类型支持哪些接口呢？</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Interfaces *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用IPointy定义的Points属性</span></span><br><span class="line">    Hexagon hex = <span class="keyword">new</span> Hexagon();	<span class="comment">//</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Points:(0)&quot;</span>,hex.Points);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行时判断一个类型是否支持一个指定接口的一种方式是使用显式强制转换。如果这个类型不支持被请求的接口，将收到一个无效转换异常（InvalidCastException)。使用结构化异常处理妥善处置这种可能的异常，例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//捕获可能发生的InvalidCastException异常</span></span><br><span class="line">    Circle c = <span class="keyword">new</span> Circle(<span class="string">&quot;Lisa&quot;</span>);</span><br><span class="line">    IPointy itfpt = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        itfpt = (IPointy)c;</span><br><span class="line">        Console.WriteLine(itfPt.Points);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvalidCastException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用try&#x2F;catch逻辑并非是最好的解决方法，在首次调用该接口成员之前判断其支持哪个接口更加理想</p>
<h5 id="9-4-1-获取接口引用：as关键字"><a href="#9-4-1-获取接口引用：as关键字" class="headerlink" title="9.4.1 获取接口引用：as关键字"></a>9.4.1 获取接口引用：as关键字</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//我们能将六角形hex2视为实现了IPointy接口吗</span></span><br><span class="line">    Hexagon hex2 = <span class="keyword">new</span> Hexagon(<span class="string">&quot;Peter&quot;</span>);</span><br><span class="line">    IPointy itfpt2 = hex2 <span class="keyword">as</span> IPointy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(itfpt2 != nu11)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Points:(0)&quot;</span>,itfpt2.Points);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;OoPS!Not pointy、.·&quot;</span>):</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用as关键字的时候，无需使用try&#x2F;catch逻辑。如果引用非空，说明调用的是一个正确的接口引用。</p>
<h5 id="9-4-2-获取接口引用：is关键字"><a href="#9-4-2-获取接口引用：is关键字" class="headerlink" title="9.4.2 获取接口引用：is关键字"></a>9.4.2 获取接口引用：is关键字</h5><p>如果要考察的对象与指定接口不符，将返回false值</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with Interfaces ****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成Shape数组</span></span><br><span class="line">    Shape[]myshapes = &#123; <span class="keyword">new</span> Hexagon(),<span class="keyword">new</span> circle(),<span class="keyword">new</span> Triangle(<span class="string">&quot;Joe&quot;</span>),<span class="keyword">new</span> circle(<span class="string">&quot;JoJo&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;myShapes.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Shape基类定义一个抽象的Draw()成员，由此所有Shape都知道如何绘制自己</span></span><br><span class="line">        myShapes [i].Draw();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//哪些是有棱角的</span></span><br><span class="line">        <span class="keyword">if</span>(myshapes[i] <span class="keyword">is</span> IPointy)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-&gt;Points:(0&#125;&quot;</span>,((IPointy)myShapes[i]).Points);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-&gt;(0)\&#x27;s not pointy!&quot;</span>myShapes fi].PetName);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-5-接口作为参数"><a href="#9-5-接口作为参数" class="headerlink" title="9.5 接口作为参数"></a>9.5 接口作为参数</h4><p>读者可以构造将接口作为参数的方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义了一个名为IDraw3D的接口</span></span><br><span class="line"><span class="comment">//模拟能以绝佳3D效果呈现一个类型的能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDraw3D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw3D</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Circle支持IDraw3D接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ThreeDCircle</span>:<span class="title">Circle</span>,<span class="title">IDraw3D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw3D</span>()</span></span><br><span class="line"><span class="function">    Console.<span class="title">WriteLine</span>(<span class="params"><span class="string">&quot;Drawing circle in 3D!&quot;</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hexagon支持IPointy与IDraw3D接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Hexagon</span> : <span class="title">Shape</span>,<span class="title">IPointy</span>,<span class="title">IDraw3D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw3D</span>()</span></span><br><span class="line"><span class="function">    Console.<span class="title">WriteLine</span>(<span class="params"><span class="string">&quot;Drawing Hexagon in 3D!&quot;</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绘制任何支持IDraw3D接口的类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawIn3D</span>(<span class="params">IDraw3D itf3d</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;-&gt;Drawing IDraw3D compatible type&quot;</span>);</span><br><span class="line">    itf3d.Draw3D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制任何支持IDraw3D接口的类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawIn3D</span>(<span class="params">IDraw3D itf3d</span>)</span></span><br><span class="line"><span class="function">Console.<span class="title">WriteLine</span>(<span class="params"><span class="string">&quot;-&gt;Drawing IDraw3D compatible type&quot;</span></span>)</span>;</span><br><span class="line">itf3d.Draw3D();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以测试Shape数组中的项是否支持接口，如果支持，就将其传入DrawIn3D()方法：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Interfaces *****</span></span><br><span class="line"><span class="string">&quot;</span>)</span><br><span class="line">    Shape[]<span class="function">myshapes <span class="keyword">new</span> <span class="title">Hexagon</span>(),<span class="keyword">new</span> <span class="title">circle</span>(),<span class="keyword">new</span> <span class="title">Triangle</span>(),<span class="keyword">new</span> <span class="title">circle</span>(<span class="params"><span class="string">&quot;JoJo&quot;</span></span>))</span></span><br><span class="line"><span class="function">    <span class="title">for</span>(<span class="params"><span class="built_in">int</span> i=<span class="number">0</span>;i&lt;myShapes.Length;i++</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//支持绘制为3D吗</span></span><br><span class="line">        <span class="keyword">if</span>(myShapes[i]<span class="keyword">is</span> IDraw3D)</span><br><span class="line">            DrawIn3D((IDraw3D)myShapes [i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-6-接口作为返回值"><a href="#9-6-接口作为返回值" class="headerlink" title="9.6 接口作为返回值"></a>9.6 接口作为返回值</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个方法返回数组中第一个实现了IPointy的对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> IPointy <span class="title">FindFirstPointyshape</span>(<span class="params">Shape[]shapes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Shape s <span class="keyword">in</span> shapes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">is</span> IPointy)</span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">as</span> IPointy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Interfaces&#x27;*****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//构建Shape数组</span></span><br><span class="line">    Shape[]<span class="function">myShapes <span class="keyword">new</span> <span class="title">Hexagon</span> ()<span class="keyword">new</span> <span class="title">circle</span>(),<span class="keyword">new</span> <span class="title">Triangle</span>(<span class="params"><span class="string">&quot;Joe&quot;</span></span>),<span class="keyword">new</span> <span class="title">circle</span>(<span class="params"><span class="string">&quot;JoJo&quot;</span></span>)&#125;</span>;</span><br><span class="line">    <span class="comment">//获取第一个pointy项</span></span><br><span class="line">    <span class="comment">//为安全起见，在使用前最好检查firstPointyItem是否为nul1</span></span><br><span class="line">    <span class="function">IPointy firstPointyItem <span class="title">FindFirstPointyshape</span>(<span class="params">myShapes</span>)</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;The item has (0&#125;points&quot;</span>,firstpointyItem.Points);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-7-接口类型数组"><a href="#9-7-接口类型数组" class="headerlink" title="9.7 接口类型数组"></a>9.7 接口类型数组</h4><p>同样的接口可以由多个类型实现，即使这些类型不处于相同的类层次结构中如果已经定义了PitchFork、Fork和Knife类型，那么现在可以定义一个支持IPointy接口的对象数组。既然这些成员都支持同样的接口，因此可以抛开类层次结构的全部差异性，通过数组进行迭代并将每个对象视为支持IPointy接口的对象：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个数组只能包含实现了IPo1nty接口的类型</span></span><br><span class="line">    IPointy[] myPointyobjects = (<span class="keyword">new</span> Hexagon(),<span class="keyword">new</span> Knife(),<span class="keyword">new</span> Triangle(),<span class="keyword">new</span> Fork(),<span class="keyword">new</span> PitchFork());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span>(IPointy i <span class="keyword">in</span> myPointyobjects)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Object has (0&#125;points.&quot;</span>,i.Points);</span><br><span class="line">    Console.ReadLine();‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-8-使用Visual-Studio2010实现接口"><a href="#9-8-使用Visual-Studio2010实现接口" class="headerlink" title="9.8 使用Visual Studio2010实现接口"></a>9.8 使用Visual Studio2010实现接口</h4><p>略</p>
<h4 id="9-9-通过显式接口实现解决命名冲突"><a href="#9-9-通过显式接口实现解决命名冲突" class="headerlink" title="9.9 通过显式接口实现解决命名冲突"></a>9.9 通过显式接口实现解决命名冲突</h4><p>一个类或结构可以实现许多接口。因此，我们很有可能会实现包含同名成员的接口，所以就熏要处理命名冲突。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//绘制到表单上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawToForm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制到内存中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawToMemory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//呈现到打印机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawToPrinter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Octagon</span> <span class="title">IDrawToForm</span>,<span class="title">IDrawToMemory</span>,<span class="title">IDrawToPrinter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对某个接口显式绑定Draw()</span></span><br><span class="line">    <span class="keyword">void</span> IDrawToForm.Draw()</span><br><span class="line">	&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing to form...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> IDrawToMemory.Draw (</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing to memory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> IDrawToPrinter.Draw()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing to a printer...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在使用这种语法时，不能提供访问修饰符，显式实现的成员总是自动为私有的。也就是在对象级别就不可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Interface Name clashes *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    Octagon oct = <span class="keyword">new</span> octagon();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在必须使用转换来访问draw()成员</span></span><br><span class="line">    IDrawToForm itfForm = (IDrawToForm)oct;</span><br><span class="line">    itfForm.Draw ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果以后不需要接口变量，可以简化成这个形式</span></span><br><span class="line">    ((IDrawToPrinter)oct).Draw();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以使用“as”关键字</span></span><br><span class="line">    <span class="keyword">if</span> (oct <span class="keyword">is</span> IDrawToMemory)</span><br><span class="line">        ((IDrawToMemory)oct).Draw ()</span><br><span class="line"></span><br><span class="line">    Console,ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-10-设计接口层次结构"><a href="#9-10-设计接口层次结构" class="headerlink" title="9.10 设计接口层次结构"></a>9.10 设计接口层次结构</h4><p>接口可以组织成接口层次结构。和类层次结构相似，如果接口扩展了既有接口，它就继承了父接口定义的抽象成员。如果希望扩展既有接口功能又不变动既有代码，接口层次结构就会很有用</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAdvancedDraw</span> : <span class="title">IDrawable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawInBoundingBox</span>(<span class="params"><span class="built_in">int</span> top,<span class="built_in">int</span> left,<span class="built_in">int</span> bottom,<span class="built_in">int</span> right</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawUpsideDown</span>()</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口类型的多重继承</strong>一个接口可以扩展多个基接口</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接口可以是多重继承的</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDrawable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IPrintable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;<span class="comment">//&lt;--注意，可能导致命名冲突</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多重接口继承。没有问题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IShape</span> : <span class="title">IDrawable</span>,<span class="title">IPrintable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetNumberofsides</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-11-构建可枚举类型（IEnumerable和IEnumerator"><a href="#9-11-构建可枚举类型（IEnumerable和IEnumerator" class="headerlink" title="9.11 构建可枚举类型（IEnumerable和IEnumerator)"></a>9.11 构建可枚举类型（IEnumerable和IEnumerator)</h4><p>任何支持GetEnumerator()方法的类型都可以通过foreach结构进行运算</p>
<p>编译器通知我们Garage类没有实现名为GetEnumerator()的方法。这个方法是由隐藏在System.Collections命名空间中的IEnumerable接口定义的。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//显示定义方法</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Garage包含一组car对象</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Garage</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> car[] = carArray <span class="keyword">new</span> Car[<span class="number">4</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//启动时填充一些car对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Garage</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        carArray[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Rusty&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        carArray[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Clunker&quot;</span>,<span class="number">55</span>);</span><br><span class="line">        carArray[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Zippy&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        carArray[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Fred&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnuerator</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">//返回数组对象的IEnumberator</span></span><br><span class="line">    	<span class="keyword">return</span> carArray.GetEnumerator();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//定义完成后则此代码可以执行</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Carage carLot = <span class="keyword">new</span> Garage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carLot)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(c.PetName, c.CurrentSpeed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并且手动与IEnuerator交互也是可行的</span></span><br><span class="line">IEnumerator i = carLot.Getnumerator();</span><br><span class="line">i.MoveNext();</span><br><span class="line">Car myCar = (Car)i.Current;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不想让用户直接交互，可以在对象级隐藏此功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IEnumerator.GetEnmerator()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> carArray.GetEnumerator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样的话，对象用户就不能找到Garage的GetEnumerator()方法，而foreach结构会在必要的候在后台获得接口。</span></span><br></pre></td></tr></table></figure>

<h5 id="9-11-1-用yield关键字构建迭代器方法"><a href="#9-11-1-用yield关键字构建迭代器方法" class="headerlink" title="9.11.1 用yield关键字构建迭代器方法"></a>9.11.1 用yield关键字构建迭代器方法</h5><p>迭代器就是这样一个成员方法，它指定了容器内部项被foreach处理时该如何返回。yield关键字用来向调用方的foreach结构指定返回值。当到达yield return语句后，当前位置被存储下来，下次调用迭代器时会从这个位置开始执行</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Garage</span></span><br><span class="line"><span class="title">private</span> <span class="title">car</span>[]<span class="title">carArray</span> = <span class="keyword">new</span> Car[<span class="number">4</span>];</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//迭代器方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carArray)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-11-2-构建命名迭代器"><a href="#9-11-2-构建命名迭代器" class="headerlink" title="9.11.2 构建命名迭代器"></a>9.11.2 构建命名迭代器</h5><p>yield关键字从技术上说可以结合任何方法一起使用，无论方法名是什么。这些方法（技术上称为命名选代器）独特之处在于可以接受许多参数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerable <span class="title">GetTheCars</span>(<span class="params"><span class="built_in">bool</span> ReturnRevesed</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//逆序返回项</span></span><br><span class="line">    <span class="keyword">if</span>(ReturnRevesed)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = carArray.Length;i != <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> carArray[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按顺序返回数组中的项</span></span><br><span class="line">        <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carArray)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with the yield Keyword *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="function">Garage carLot <span class="keyword">new</span> <span class="title">Garage</span>()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用GetEnumerator()获取项</span></span><br><span class="line">    <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carLot)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0&#125;is going (1&#125;MPH&quot;</span>,c.PetName,c.CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用命名迭代器来获取项（逆序）</span></span><br><span class="line">    <span class="comment">//新方法允许调用者以正序和逆序（如果传入的参数值为tue)来获取子项</span></span><br><span class="line">    <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carLot.GetThecars(<span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0&#125;is going (1&#125;MPH&quot;</span>,c.PetName,c.CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名迭代器是很有用的结构，因为一个自定义容器可以定义多重方式来请求返回的集。</p>
<h5 id="9-11-3-迭代器方法的内部表示"><a href="#9-11-3-迭代器方法的内部表示" class="headerlink" title="9.11.3 迭代器方法的内部表示"></a>9.11.3 迭代器方法的内部表示</h5><p>那么，总结一下可枚举对象的构建吧。记住，如果自定义类型要和C#的foreach关键字一起使用的话，容器就需要定义一个名为GetEnumerator()的方法，它由IEnumerable接口类型来定制。通常，这个方法的实现只是交给保存子对象的内部成员，然而，我们也可以使用yield return语法来提供多个“命名迭代器”方法。</p>
<h4 id="9-12-构建可克隆的对象-ICloneable"><a href="#9-12-构建可克隆的对象-ICloneable" class="headerlink" title="9.12 构建可克隆的对象(ICloneable)"></a>9.12 构建可克隆的对象(ICloneable)</h4><p>如果想使自己的自定义类型支持向调用方返回自身同样副本的能力，需要实现标准ICloneable接口。如在本章开头提到的，这个类型定义了一个简单的方法Clone():</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Point现在支持克隆能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span> : <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xPos,<span class="built_in">int</span> yPos</span>)</span>&#123;X xPos;Y yPos;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//重写Object.Tostring()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Tostring</span>()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;X (0);Y (1)&quot;</span>,X,Y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个当前对象的副本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">clone</span>()</span></span><br><span class="line">    &#123;<span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="keyword">this</span>.X,<span class="keyword">this</span>.Y);&#125;</span><br><span class="line">&#125;</span><br><span class="line">                                    </span><br><span class="line">这样我们就可以创建完全独立的Poit类型的副本了，如下所示：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with object cloning *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//请注意Clone()返回了一个普通object类型</span></span><br><span class="line">    <span class="comment">//需要显式转换来获取派生类型</span></span><br><span class="line">    Point p3 = <span class="keyword">new</span> Point(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    Point p4 = (Point)p3.Clone();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变p4.x将不影响P3,x</span></span><br><span class="line">    P4.X=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出每个对象</span></span><br><span class="line">    Console.WriteLine(p3);</span><br><span class="line">    Console.WriteLine(p4);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用此代码简化Clone()方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">clone</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>更复杂的克隆示例</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个类定义了一个点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointDescription</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Guid PointID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PetName = <span class="string">&quot;No-name&quot;</span>;</span><br><span class="line">        PointID = Guid.NewGuid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> PointDescription desc = <span class="keyword">new</span> PointDescription();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xPos, <span class="built_in">int</span> yPos, <span class="built_in">string</span> petName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xPos; Y = yPos;</span><br><span class="line">        desc.PetName = petName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xPos, <span class="built_in">int</span> yPos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xPos; Y = yPos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写Object.ToString()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;X &#123;0&#125;;Y &#123;1&#125;;Name &#123;2&#125;;</span></span><br><span class="line"><span class="string">ID &#123;3&#125;</span></span><br><span class="line"><span class="string">&quot;</span>,</span><br><span class="line">        X, Y, desc.PetName, desc.PointID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前对象的副本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Clone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取浅复制</span></span><br><span class="line">        Point newPoint = (Point)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充间距</span></span><br><span class="line">        PointDescription currentDesc = <span class="keyword">new</span> PointDescription();</span><br><span class="line">        currentDesc.PetName = <span class="keyword">this</span>.desc.PetName;</span><br><span class="line">        newPoint.desc = currentDesc;</span><br><span class="line">        <span class="keyword">return</span> newPoint;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;*****Fun with object cloning *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cloned p3 and stored new Point in p4&quot;</span>);</span><br><span class="line">        Point p3 = <span class="keyword">new</span> Point(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">        Point p4 = (Point)p3.Clone();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Before modification:&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p3:&#123;0&#125;&quot;</span>, p3);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p4:&#123;0&#125;&quot;</span>, p4);</span><br><span class="line">        p4.desc.PetName = <span class="string">&quot;My new Point&quot;</span>;</span><br><span class="line">        p4.X = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">Changed p4.desc.petName and p4.X&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;After modification:&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p3:&#123;0&#125;&quot;</span>, p3);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p4:&#123;0&#125;&quot;</span>, p4);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>概括一下克隆过程：如果有一个仅包含值类型的类或结构，使用Memberwiseclone()实现Clone()方法。如果有一个保存其他引用类型的自定义类型，需要建立一个考虑了每个引用类型成员变量的新对象。</p>
<h4 id="9-13-构建可比较的对象-IComparable"><a href="#9-13-构建可比较的对象-IComparable" class="headerlink" title="9.13 构建可比较的对象(IComparable)"></a>9.13 构建可比较的对象(IComparable)</h4><p>System.IComparable接口指定了一种允许一个对象可基于某些特定键值进行排序的行为。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Car类的迭代可以基于CarID进行排序</span></span><br><span class="line"><span class="keyword">using</span> study;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Currentspeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> CarID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> currsp, <span class="built_in">int</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Currentspeed = currsp;</span><br><span class="line">            PetName = name;</span><br><span class="line">            CarID = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于C#int数据类型（只是CLR System.Int32的简写形式)实现了IComparable,我们就可以按如下所示的方法实现car的CompareTo()方法：</span></span><br><span class="line">        <span class="built_in">int</span> IComparable.CompareTo(<span class="built_in">object</span> obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Car temp = obj <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.CarID.CompareTo(temp.CarID);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Parameter is not a Car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Car[] myAutos = <span class="keyword">new</span> Car[<span class="number">5</span>];</span><br><span class="line">            myAutos[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Rusty&quot;</span>, <span class="number">80</span>, <span class="number">1</span>);</span><br><span class="line">            myAutos[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mary&quot;</span>, <span class="number">40</span>, <span class="number">234</span>);</span><br><span class="line">            myAutos[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;viper&quot;</span>, <span class="number">40</span>, <span class="number">34</span>);</span><br><span class="line">            myAutos[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mel&quot;</span>, <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line">            myAutos[<span class="number">4</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Chucky&quot;</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//建立一个Car对象数组</span></span><br><span class="line">            <span class="comment">//显示当前数组</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Here is the unordered set of cars:&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> myAutos)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, c.CarID, c.PetName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//现在，使用IComparable为它们排序</span></span><br><span class="line">            Array.Sort(myAutos);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//显示排序后的数组</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Here is the ordered set of cars:&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> myAutos)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, c.CarID, c.PetName);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-13-1-指定多个排序顺序-IComparer"><a href="#9-13-1-指定多个排序顺序-IComparer" class="headerlink" title="9.13.1 指定多个排序顺序(IComparer)"></a>9.13.1 指定多个排序顺序(IComparer)</h5><p>那如果要构建一个既可通过D排序又可通过昵称排序的Cr类型，该怎么办呢？如果读者对这种行为感兴趣，就需要与另一个标准接口IComparer打交道。它按如下代码所示定义在</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Car类的迭代可以基于CarID进行排序</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Currentspeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> CarID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> currsp, <span class="built_in">int</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Currentspeed = currsp;</span><br><span class="line">            PetName = name;</span><br><span class="line">            CarID = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于C#int数据类型（只是CLR System.Int32的简写形式)实现了IComparable,我们就可以按如下所示的方法实现car的CompareTo()方法：</span></span><br><span class="line">        <span class="built_in">int</span> IComparable.CompareTo(<span class="built_in">object</span> obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Car temp = obj <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.CarID.CompareTo(temp.CarID);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Parameter is not a Car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PetNameComparer</span> : <span class="title">IComparer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> IComparer.Compare(<span class="built_in">object</span> o1, <span class="built_in">object</span> o2)</span><br><span class="line">        &#123;</span><br><span class="line">            Car t1 = o1 <span class="keyword">as</span> Car;</span><br><span class="line">            Car t2 = o2 <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span>(t1 != <span class="literal">null</span> &amp;&amp; t2 != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> String.Compare(t1.PetName, t2.PetName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;parameter is not a car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">start</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Car[] myAutos = <span class="keyword">new</span> Car[<span class="number">5</span>];</span><br><span class="line">            myAutos[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Rusty&quot;</span>, <span class="number">80</span>, <span class="number">1</span>);</span><br><span class="line">            myAutos[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mary&quot;</span>, <span class="number">40</span>, <span class="number">234</span>);</span><br><span class="line">            myAutos[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;viper&quot;</span>, <span class="number">40</span>, <span class="number">34</span>);</span><br><span class="line">            myAutos[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mel&quot;</span>, <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line">            myAutos[<span class="number">4</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Chucky&quot;</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照名称进行排序</span></span><br><span class="line">            Array.Sort(myAutos, <span class="keyword">new</span> PetNameComparer());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//转储排序后的数组</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Ordering by pet name:&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> myAutos)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, c.CarID, c.PetName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-13-2-自定义属性、自定义排序类型"><a href="#9-13-2-自定义属性、自定义排序类型" class="headerlink" title="9.13.2 自定义属性、自定义排序类型"></a>9.13.2 自定义属性、自定义排序类型</h5><p>使用强关联属性按照名称排序，而不是使用独立的类型进行排序</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Car类的迭代可以基于CarID进行排序</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Currentspeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> CarID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> currsp, <span class="built_in">int</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Currentspeed = currsp;</span><br><span class="line">            PetName = name;</span><br><span class="line">            CarID = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于C#int数据类型（只是CLR System.Int32的简写形式)实现了IComparable,我们就可以按如下所示的方法实现car的CompareTo()方法：</span></span><br><span class="line">        <span class="built_in">int</span> IComparable.CompareTo(<span class="built_in">object</span> obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Car temp = obj <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.CarID.CompareTo(temp.CarID);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Parameter is not a Car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> IComparer SortByPetName</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (IComparer)<span class="keyword">new</span> PetNameComparer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PetNameComparer</span> : <span class="title">IComparer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> IComparer.Compare(<span class="built_in">object</span> o1, <span class="built_in">object</span> o2)</span><br><span class="line">        &#123;</span><br><span class="line">            Car t1 = o1 <span class="keyword">as</span> Car;</span><br><span class="line">            Car t2 = o2 <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span>(t1 != <span class="literal">null</span> &amp;&amp; t2 != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> String.Compare(t1.PetName, t2.PetName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;parameter is not a car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">start</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Car[] myAutos = <span class="keyword">new</span> Car[<span class="number">5</span>];</span><br><span class="line">            myAutos[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Rusty&quot;</span>, <span class="number">80</span>, <span class="number">1</span>);</span><br><span class="line">            myAutos[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mary&quot;</span>, <span class="number">40</span>, <span class="number">234</span>);</span><br><span class="line">            myAutos[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;viper&quot;</span>, <span class="number">40</span>, <span class="number">34</span>);</span><br><span class="line">            myAutos[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mel&quot;</span>, <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line">            myAutos[<span class="number">4</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Chucky&quot;</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            Array.Sort(myAutos, Car.SortByPetName);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Ordering by pet name:&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> myAutos)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, c.CarID, c.PetName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-泛型"><a href="#10-泛型" class="headerlink" title="10 泛型"></a>10 泛型</h3><p>C#数组允许我们定义一组固定上限的同-一类型的项（包括System.Object的数组，它本质上表示任何类型的数组)。虽然通常这可以满足我们的要求，但是在很多时候我们需要更灵活的数据结构，比如动态增长和收缩的容器或者容器只可以保存符合某个条件的对象（比如，只能从给定基类派生的对象，实现某个特殊接口的项等)。础类库中引入了一个以集合为中心的新命名空间：System.Collections.Generic命名空间。本章会介绍，泛型容器和它们的非泛型版本相比，在很多方面要优越得多，因为它们提供了更多类型安全和性能优势</p>
<h4 id="10-1-非泛型集合"><a href="#10-1-非泛型集合" class="headerlink" title="10.1 非泛型集合"></a>10.1 非泛型集合</h4><p>在学习如何在程序中使用泛型之前，研究一下非泛型集合类的问题会非常有用。这将有助于你更好地理解泛型要解决的首要问题。引入System.Collections命名空间：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br></pre></td></tr></table></figure>

<h5 id="10-1-1-性能问题"><a href="#10-1-1-性能问题" class="headerlink" title="10.1.1 性能问题"></a>10.1.1 性能问题</h5><p>我们有时需要用一个类别的变量来表示另一个类别的变量。为此，C#提供了称为装箱的简单机制来实现A类——&gt;打包——&gt;B类重定引用，类型</p>
<p>尽管装箱和拆箱对程序员来说很方便，但是这种方式带来的堆&#x2F;栈内存转移会导致性能问题（执行速度和代码多少)，并且也缺乏类型安全(1)必须在托管堆上分配一个新对象。(2)基于栈数据的值必须被转移到新分配的内存位置。(3)在拆箱时，保存在堆对象中的值必须转移回栈。(4)堆上无用的对象（最后）会被回收。</p>
<h5 id="10-1-2-类型安全问题"><a href="#10-1-2-类型安全问题" class="headerlink" title="10.1.2 类型安全问题"></a>10.1.2 类型安全问题</h5><p>非泛型世界中的另一个类型安全问题：由于System.Collections中的大多数类所操作的都是System.Object,因此它们可以容纳任何类型</p>
<p>与非泛型容器相比，泛型容器的一些优势如下所示。</p>
<ul>
<li>泛型提供了更好的性能，因为它们不会导致装箱或拆箱的损耗。</li>
<li>泛型更类型安全，因为它们只包含我们指定的类型。</li>
<li>泛型大幅减少了构建自定义集合类型的需要，因为基础类库提供了几个预制的容器。</li>
</ul>
<h4 id="10-2-泛型类型参数的作用"><a href="#10-2-泛型类型参数的作用" class="headerlink" title="10.2 泛型类型参数的作用"></a>10.2 泛型类型参数的作用</h4><p>当你在，NET Framework4SDK文档或Visual Studio20l0对象浏览器中看到泛型项时，你会发现其表现形式为一对尖括号及其内部的字母或其他标记尖括号中标记的正式名称为类型参数，但你也可以通俗地将其称为占位符。<T>符号读作of T。因此IEnumerable<T>读作IEnumerable ofT,或者也可以称其为类型T的枚举。</p>
<h5 id="10-2-1-为泛型类-x2F-结构指定类型参数"><a href="#10-2-1-为泛型类-x2F-结构指定类型参数" class="headerlink" title="10.2.1 为泛型类&#x2F;结构指定类型参数"></a>10.2.1 为泛型类&#x2F;结构指定类型参数</h5><p>在创建泛型类或泛型结构的实例时，需要在声明变量和调用构造函数时指定类型参数。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该List&lt;&gt;只能容纳Person对象·</span></span><br><span class="line">List&lt;Person&gt; morePeople = <span class="keyword">new</span> List&lt;Person&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="10-2-2-为泛型成员指定类型参数"><a href="#10-2-2-为泛型成员指定类型参数" class="headerlink" title="10.2.2 为泛型成员指定类型参数"></a>10.2.2 为泛型成员指定类型参数</h5><p>非泛型类或结构都支持泛型成员（如方法和属性)。因此在调用这种方法时，你仍然需要指定占位符的值。例如，System.Array支持一些泛型方法（.NET2.0中添加的)。如现在的Sort()静态方法包含一个相应的泛型方法Sort<T>()。考虑下面的代码段，其中T为int类型：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span>[] myInts=(<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">93</span>&#125;:</span><br><span class="line"><span class="comment">//为sort&lt;&gt;()泛型方法指定占位符</span></span><br><span class="line">Array.Sort&lt;<span class="built_in">int</span>&gt;(myInts);</span><br><span class="line">              </span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> myInts)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-2-3-为泛型接口指定类型参数"><a href="#10-2-3-为泛型接口指定类型参数" class="headerlink" title="10.2.3 为泛型接口指定类型参数"></a>10.2.3 为泛型接口指定类型参数</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span>&lt;<span class="title">Car</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//IComparable&lt;T&gt;的实现</span></span><br><span class="line">    <span class="built_in">int</span> IComparable&lt;car&gt;.CompareTo(Car obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CarID &gt; obj.CarID)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CarID &lt; obj.CarID)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里你不用判断传入的参数是否为Car,因为它只能为car。如果传入的数据类型不兼容，将得到编译时错误。</p>
<h4 id="10-3-System-Collectiong-Generic命名空间"><a href="#10-3-System-Collectiong-Generic命名空间" class="headerlink" title="10.3 System.Collectiong.Generic命名空间"></a>10.3 System.Collectiong.Generic命名空间</h4><p>System.Collectiong.Generic命名空间中为大多数非泛型接口都定义了泛型版本。略</p>
<h5 id="10-3-1-集合初始化语法"><a href="#10-3-1-集合初始化语法" class="headerlink" title="10.3.1 集合初始化语法"></a>10.3.1 集合初始化语法</h5><p>这个C#语言特性让你可以用与填充基础数组类似的语法，来填充ArrayList或List<T>等容器。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化标准的数组</span></span><br><span class="line"><span class="built_in">int</span>[] myArrayOfInts=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//初始化整数的泛型List&lt;&gt;</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt;myGenericList = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用数字数据初始化ArrayList</span></span><br><span class="line">ArrayList myList = <span class="keyword">new</span> ArrayList &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="10-3-2-使用List类"><a href="#10-3-2-使用List类" class="headerlink" title="10.3.2 使用List类"></a>10.3.2 使用List<T>类</h5><p>List<T>类是System.Collections.Generic命名空间中最常用的类型，因为它可以动态调整内容</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里我们使用初始化语法将对象填人List&lt;T&gt;,将其作为调用n次add()方法的简写形式。打印集合的项数和枚举各个项之后，</span></span><br><span class="line"><span class="comment">//调用了Insert()方法。如你所见，Insert()可以向List&lt;T&gt;中的指定索引位置插入一个新项。</span></span><br><span class="line"><span class="comment">//最后调用了ToArray()方法，它基于原始的List&lt;T&gt;,返回一个Person对象数组。我们使用数组索引器语法，对该数组再次执行循环。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseGenericList</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用集合/对象初始化语法，构建一个Person对象的列表</span></span><br><span class="line">    List&lt;Person&gt;<span class="function">people <span class="keyword">new</span> <span class="title">List</span>&lt;<span class="title">Person</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Person &#123;FirstName=<span class="string">&quot;Homer&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">47</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> Person &#123;FirstName=<span class="string">&quot;Marge&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">45</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> Person &#123;FirstName=<span class="string">&quot;Lisa&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">9</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> Person &#123;FirstName=<span class="string">&quot;Bart&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">8</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">                    </span><br><span class="line">    <span class="comment">//打印列表中项的个数</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Items in list:(0&#125;&quot;</span>,people.Count);</span><br><span class="line">    <span class="comment">//枚举列表</span></span><br><span class="line">    <span class="keyword">foreach</span> (Person p <span class="keyword">in</span> people)</span><br><span class="line">        Console.WriteLine(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入一个新Person</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">-&gt;Inserting new person.&quot;</span>);</span><br><span class="line">    people.Insert(<span class="number">2</span>,<span class="keyword">new</span> Person FirstName <span class="string">&quot;Maggie&quot;</span>,LastName <span class="string">&quot;Simpson&quot;</span>,Age <span class="number">2</span> ))</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Items in list:(0)&quot;</span>,people.Count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数据复制到新的数组中</span></span><br><span class="line">    Person[] arrayofPeople = people.ToArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;arrayofPeople.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;First Names:(0)&quot;</span>,arrayofPeople[i].FirstName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-3-3-使用Stack类"><a href="#10-3-3-使用Stack类" class="headerlink" title="10.3.3 使用Stack类"></a>10.3.3 使用Stack<T>类</h5><p>Stack<T>类表示以后进先出的方式维护数据的集合。它包含Push()和Pop()方法，可以向栈压入数据或从栈移除数据。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里，我们构建了包含3个Persen的栈，按名字的顺序添加：Homer、Marge和Lisa。在观察</span></span><br><span class="line"><span class="comment">//栈时，得到的永远是栈顶对象，因此，我们先调用Peek()来显示第三个Person对象。在一系列的Pop()</span></span><br><span class="line"><span class="comment">//和Peek()调用之后，栈最终为空，这时再调用Peek()和Pop()将触发系统异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseGenericstack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack&lt;Person&gt;stackofPeople = <span class="keyword">new</span> Stack&lt;Person&gt;();</span><br><span class="line">    stackofPeople.Push(<span class="keyword">new</span> Person &#123;FirstName <span class="string">&quot;Homer&quot;</span>,LastName <span class="string">&quot;Simpson&quot;</span>,Age <span class="number">47</span> &#125;)</span><br><span class="line">    stackofPeople.Push(<span class="keyword">new</span> Person &#123;FirstName <span class="string">&quot;Marge&quot;</span>,LastName <span class="string">&quot;Simpson&quot;</span>,Age <span class="number">45</span> &#125;)</span><br><span class="line">    stackofPeople.Push(<span class="keyword">new</span> Person &#123;FirstName =<span class="string">&quot;Lisa&quot;</span>,LastName <span class="string">&quot;Simpson&quot;</span>,Age <span class="number">9</span> &#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//观察栈顶的项，取出，再次观察</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;First person is:(0)&quot;</span>,stackofPeople.Peek());</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;Popped off (0)&quot;</span>,stackofPeople.Pop());</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">First person is:(0&#125;&quot;</span>,stackofPeople.Peek());</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Popped off (0)&quot;</span>,stackofPeople.Pop());</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">First person item is:(0)&quot;</span>,stackofPeople.Peek());</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Popped off &#123;0&#125;&quot;</span>,stackofPeople.Pop());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">nFirst person is:(0)&quot;</span>,stackofPeople.Peek());</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Popped off (0)&quot;</span>,stackofPeople.Pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvalidoperationException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">Error!&#123;0&#125;&quot;</span>,ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-3-4-使用Queue类"><a href="#10-3-4-使用Queue类" class="headerlink" title="10.3.4 使用Queue类"></a>10.3.4 使用Queue<T>类</h5><p>如果你需要对一个以先到先得方式处理数据的场景进行建模，Queue<T>类是很适合的</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetCoffee</span>(<span class="params">Person p</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;(0)got coffee!&quot;</span>,p.FirstName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在假设你有另一个辅助方法，在其内部调用GetCoffee():</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseGenericQueue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个包含3个人的队列</span></span><br><span class="line">    Queue&lt;Person&gt;peopleQ = <span class="keyword">new</span> Queue&lt;Person&gt;();</span><br><span class="line">    peopleQ.Enqueue(<span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Homer&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">47</span>));</span><br><span class="line">    peopleQ.Enqueue(<span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Marge&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">45</span>));</span><br><span class="line">    peopleQ.Enqueue(<span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Lisa&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">9</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//观察队列中的第一个人</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0)is first in line!&quot;</span>,peopleQ.Peek().FirstName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除队列中的人</span></span><br><span class="line">    GetCoffee(peopleQ.Dequeue());</span><br><span class="line">    Getcoffee(peopleQ.Dequeue());</span><br><span class="line">    GetCoffee(peopleQ.Dequeue());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再次从队列中获取数据</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetCoffee(peopleQ.Dequeue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InvalidoperationException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Error!(0)&quot;</span>,e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//Homer is first in line!</span></span><br><span class="line"><span class="comment">//Homer got coffee!</span></span><br><span class="line"><span class="comment">//Marge got coffee!</span></span><br><span class="line"><span class="comment">//Lisa got coffee!</span></span><br><span class="line"><span class="comment">//Error！Queue empty,</span></span><br><span class="line"><span class="comment">//————————————————————————</span></span><br></pre></td></tr></table></figure>

<h5 id="10-3-5-使用Sortedset类"><a href="#10-3-5-使用Sortedset类" class="headerlink" title="10.3.5 使用Sortedset类"></a>10.3.5 使用Sortedset<T>类</h5><p>SortedSet<T>类中的项是排序的，在插入和移除项之后，也能自动确保排序正确，因此该类十分有用。不过，你必须通知SortedSet<T>按何种方式进行排序</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SortPeopleByAge</span> : <span class="title">IComparer</span>&lt;<span class="title">Person</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Compare</span>(<span class="params">Person firstPerson,Person secondPerson</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstPerson.Age &gt; secondPerson.Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (firstPerson.Age &lt; secondPerson.Age)</span><br><span class="line">            <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//运行应用程序，列表中的对象将永远按Ag属性的值排序，而与插入和移除对象的顺序无关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在在Program类中添加下面的新方法，我们假设在Main()中调用该方法：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseSortedset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加一些不同年龄的人</span></span><br><span class="line">    SortedSet&lt;Person&gt;setofPeople - <span class="keyword">new</span> Sortedset&lt;Person&gt;(<span class="keyword">new</span> SortPeopleByAge())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Homer&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">47</span>),</span><br><span class="line">        <span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Marge&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">45</span>),</span><br><span class="line">        <span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Lisa&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">9</span>),</span><br><span class="line">        <span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Bart&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">8</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//各项是按照年龄排序的</span></span><br><span class="line">    <span class="keyword">foreach</span> (Person p <span class="keyword">in</span> setofPeople)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(p);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加一些具有不同年龄的人</span></span><br><span class="line">    setofPeople.Add(<span class="keyword">new</span> Person FirstName =<span class="string">&quot;Saku&quot;</span>,LastName <span class="string">&quot;Jones&quot;</span>,Age <span class="number">1</span> &#125;)</span><br><span class="line">    setofPeople.Add(<span class="keyword">new</span> Person FirstName <span class="string">&quot;Mikko&quot;</span>,LastName <span class="string">&quot;Jones&quot;</span>,Age <span class="number">32</span> ))</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//仍然按照年龄排序</span></span><br><span class="line">    <span class="keyword">foreach</span> (Person p <span class="keyword">in</span> setofPeople)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-4-创建自定义泛型方法"><a href="#10-4-创建自定义泛型方法" class="headerlink" title="10.4 创建自定义泛型方法"></a>10.4 创建自定义泛型方法</h4><p>尽管大多数开发者通常使用基础类库中已知的泛型类型，不过你也可以构建自己的泛型成员和自定义泛型类型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该方法最大的优势在于，只需要维护一个Swap&lt;T&gt;()版本，而且它能以类型安全的方式操作任意</span></span><br><span class="line"><span class="comment">//两个给定参数类型的项。更重要的是，栈数据保留在栈上，堆数据保留在堆上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法可以交换任意两个由类型参数&lt;T&gt;指定的项</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T a,<span class="keyword">ref</span> T b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;You sent the Swap()method a (0)&quot;</span>,<span class="keyword">typeof</span>(T)）;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a =b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with Custom Generic Methods *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两个整数</span></span><br><span class="line">    inta=<span class="number">10</span>,b=<span class="number">90</span>:</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Before swap:(0),(1]&quot;</span>,a,b);</span><br><span class="line">    Swap&lt;<span class="built_in">int</span>&gt;(<span class="keyword">ref</span> a,<span class="keyword">ref</span> b);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After swap:(0),(1)&quot;</span>,a,b);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两个字符串</span></span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;Hello&quot;</span>,s2 = <span class="string">&quot;There&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Before swap:(0&#125;&#123;1)!&quot;</span>,s1,s2);</span><br><span class="line">    Swap&lt;<span class="built_in">string</span>&gt;(<span class="keyword">ref</span> s1,<span class="keyword">ref</span> s2);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After swap:(0)(1)!&quot;</span>,s1,s2);</span><br><span class="line">    </span><br><span class="line">    Console.ReadLine(）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类型参数的推断</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用诸如Swa&lt;T&gt;之类的泛型方法时，当（且仅当)泛型方法需要参数时，我们可以选择省略类型参数，因为编译器会基于成员参数推断类型参数.</span></span><br><span class="line"><span class="comment">//举个例子，我们可以通过将以下代码添加到Main()中来交换两个ystem.Boolean类型的值：</span></span><br><span class="line"><span class="built_in">bool</span> bl = <span class="literal">true</span>,b2 = <span class="literal">false</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Before swap:(0),(1)&quot;</span>,bl,b2);</span><br><span class="line">Swap(<span class="keyword">ref</span> bl,<span class="keyword">ref</span> b2);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;After swap:(0),(1)&quot;</span>,b1,b2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尽管编译器可以根据声明61和b2的类型发现正确的类型参数，但你还是应该养成显式指定类型参数的习惯：</span></span><br><span class="line">Swap&lt;<span class="built_in">bool</span>&gt;(<span class="keyword">ref</span> b1,<span class="keyword">ref</span> b2);</span><br></pre></td></tr></table></figure>

<h4 id="10-5-创建自定义泛型结构和类"><a href="#10-5-创建自定义泛型结构和类" class="headerlink" title="10.5 创建自定义泛型结构和类"></a>10.5 创建自定义泛型结构和类</h4><p>新建一个Console Application项目GenericPoint略</p>
<h5 id="10-5-1-泛型代码中的default关键字"><a href="#10-5-1-泛型代码中的default关键字" class="headerlink" title="10.5.1 泛型代码中的default关键字"></a>10.5.1 泛型代码中的default关键字</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在C#中，default关键字被重载</span></span><br><span class="line"><span class="comment">//和泛型一起使用时，它表示一个类型参数的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetPoint</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    x =<span class="literal">default</span>(T);</span><br><span class="line">    Y =<span class="literal">default</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在引人泛型时，default关键字被赋予了双重身份。除了在switch结构内部使用外，还可用于设置类型参数的默认值。这是非常有用的，因为一个泛型类型预先并不知道实际的占位符，因此无法安全地假设默认值是什么。类型参数的默认值如下：</p>
<ul>
<li>数值的默认值为0；</li>
<li>引用类型的默认值为nul1,</li>
<li>一个结构的字段被设为0（值类型）或null（引用类型)。</li>
</ul>
<h5 id="10-5-2-泛型基类"><a href="#10-5-2-泛型基类" class="headerlink" title="10.5.2 泛型基类"></a>10.5.2 泛型基类</h5><p>泛型类可以作为其他类的基类，它可以定义许多虚方法和抽象方法。但需要遵守如下规则：</p>
<ol>
<li>首先，如果一个非泛型类扩展了一个泛型类，派生类必须指定一个类型参数：</li>
<li>第二，如果泛型基类定义了泛型虚方法或抽象方法，派生类型必须使用指定类型参数重写泛型方法：</li>
<li>第三，如果派生类型也是泛型，则它能够（可选地）重用类型占位符。</li>
</ol>
<h4 id="10-6-类型参数的约束"><a href="#10-6-类型参数的约束" class="headerlink" title="10.6 类型参数的约束"></a>10.6 类型参数的约束</h4><p>而NET平台使用were关键字可以得到更加具体的类型参数信息。使用这个关键字，可以对给定的类型参数添加一组约束，C#编译器将在编译时检查这些约束除非要创建类型安全的自定义集合，否则你很少会在C#项目中使用where关键字。</p>
<h5 id="10-6-1-使用where关键字的示例"><a href="#10-6-1-使用where关键字的示例" class="headerlink" title="10.6.1 使用where关键字的示例"></a>10.6.1 使用where关键字的示例</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MyGenericclass派生自object,并且包含项为实现了IDrawable的类，并且必须支持默认构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericclass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>,<span class="title">IDrawable</span>,<span class="title">new</span>()&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new()约束必须总是在列为的末尾new()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你创建的自定义泛型集合指定了多个类型参数，可以为每个类型参数指定约束集，各约束集之间用where子句分隔：</span></span><br><span class="line"><span class="comment">//&lt;K&gt;必须扩展SomeBaseclass,并且必须包含默认构造函数</span></span><br><span class="line"><span class="comment">//&lt;T&gt;必须为结构，并且实现泛型IComparab1e接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericclass</span>&lt;<span class="title">K</span>,<span class="title">T</span>&gt;<span class="keyword">where</span> <span class="title">K</span> <span class="title">SomeBaseclass</span>,<span class="title">new</span>()</span><br><span class="line">                                <span class="keyword">where</span> <span class="title">T</span> <span class="title">struct</span>,<span class="title">IComparable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-6-2-操作符约束的不足"><a href="#10-6-2-操作符约束的不足" class="headerlink" title="10.6.2 操作符约束的不足"></a>10.6.2 操作符约束的不足</h5><p>在创建泛型方法时，如果对类型参数应用任何C#操作符(+、一、*、&#x3D;等)，都将产生令人惊奇的编译器错误。泛型并不是万能的，不能对类型参数进行操作符操作看上去就是它的主要限制之一。</p>
<h3 id="11-委托、事件和lambda"><a href="#11-委托、事件和lambda" class="headerlink" title="11 委托、事件和lambda"></a>11 委托、事件和lambda</h3><p>回调机制可用于各种应用程序，但它们对于图形用户界面来说尤其重要，因为控件（如按钮)需要在正确的环境下调用外部方法（如单击按钮时、鼠标滑过按钮表面时等）。在NET平台下，委托类型用来定义和响应应用程序中的回调。事实上，NET委托类型是一个类型安全的对象，指向可以以后调用的其他方法。和传统的C++函数指针不同，NET委托是内置支持多路广播和异步方法调用的对象。</p>
<h4 id="11-1-NET委托类型"><a href="#11-1-NET委托类型" class="headerlink" title="11.1 .NET委托类型"></a>11.1 .NET委托类型</h4><p>使用回调，程序员可以使一个函数返回报告给（即回调）程序中的另一个函数。在NET Framework里，回调仍是可能的，它们的功能是由使用更为安全和面向对象的委托(delegate)来完成的。本质上来讲，委托是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或多个方法）。委托类型包含3个重要的信息：</p>
<ul>
<li>它所调用的方法的名称；</li>
<li>该方法的参数（可选)：</li>
<li>该方法的返回值（可选)。</li>
</ul>
<p>NET Framework中每个委托（包括自定义委托)都被自动赋予同步或异步访问方法的能力，可以不用手工创建与管理一个hread对象而直接调用另一个辅助执行线程上的方法</p>
<h4 id="11-2-在C-中定义委托类型"><a href="#11-2-在C-中定义委托类型" class="headerlink" title="11.2 在C#中定义委托类型"></a>11.2 在C#中定义委托类型</h4><p>在C#中创建一个委托类型时，需要使用delegate关键字。委托的名称可以自由选择。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个委托可以指向任何传入两个整数返回一个整数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Binaryop</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="11-3-System-MulticastDelegate与System-Delegate基类"><a href="#11-3-System-MulticastDelegate与System-Delegate基类" class="headerlink" title="11.3 System.MulticastDelegate与System.Delegate基类"></a>11.3 System.MulticastDelegate与System.Delegate基类</h4><p>使用C#中delegate关键字创建委托的时候，也就间接声明了一个派生自System.Multicast-Delegate的类。这个类使其继承类可以访问包含由委托对象维护的方法地址的列表以及一些处理调用列表的附加方法（与少数重载的操作符)。</p>
<h4 id="11-4-最简单的委托示例"><a href="#11-4-最简单的委托示例" class="headerlink" title="11.4 最简单的委托示例"></a>11.4 最简单的委托示例</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleDelegate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个委托可以指向任何传入两个整数并返回一个整数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Binaryop</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个类包含了BinaryOp将指向的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleMath</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;<span class="keyword">return</span> x - y;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine (<span class="string">&quot;****Simple Delegate Example *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建一个指向mpleMath,dd()方法的Binaryop对象</span></span><br><span class="line">            Binaryop b = <span class="keyword">new</span> Binaryop(SimpleMath.Add);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用委托对象间接调用dd()方法</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;10 + 10 is &#123;0&#125;&quot;</span>,b(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>委托对象</strong></p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Simple Delegate Example *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NET委托也可以指向实例方法</span></span><br><span class="line">    SimpleMath m =<span class="keyword">new</span> SimpleMath();</span><br><span class="line">    Binaryop b =<span class="keyword">new</span> Binaryop(m.Add);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示这个对象的信息</span></span><br><span class="line">    DisplayDelegateInfo(b);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;10 + 10 is (0)&quot;</span>,b(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-5-使用委托发送对象状态通知"><a href="#11-5-使用委托发送对象状态通知" class="headerlink" title="11.5 使用委托发送对象状态通知"></a>11.5 使用委托发送对象状态通知</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//内部状态数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Currentspeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxSpeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汽车能用还是不能用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> carIsDead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>()</span> &#123; MaxSpeed = <span class="number">100</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> maxSp, <span class="built_in">int</span> currSp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Currentspeed = currSp;</span><br><span class="line">        MaxSpeed = maxSp;</span><br><span class="line">        PetName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1)定义委托类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CarEngineHandler</span>(<span class="params"><span class="built_in">string</span> msgForCaller</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2)定义每个委托类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> CarEngineHandler listofHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3)向调用者添加注册函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterwithCarEngine</span>(<span class="params">CarEngineHandler methodToCall</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listofHandlers = methodToCall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果汽车不能用了，触发引爆事件</span></span><br><span class="line">        <span class="keyword">if</span> (carIsDead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (listofHandlers != <span class="literal">null</span>)</span><br><span class="line">                listofHandlers(<span class="string">&quot;Sorry,this car is dead...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Currentspeed += delta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//快不能用了吗</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span> == (MaxSpeed - Currentspeed) &amp;&amp; listofHandlers != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                listofHandlers(<span class="string">&quot;Careful buddy!Gonna blow!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Currentspeed &gt;= MaxSpeed)</span><br><span class="line">                carIsDead = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;CurrentSpeed (0)&quot;</span>, Currentspeed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;****Delegates as event enablers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        <span class="comment">//首先，创建一个Car对象</span></span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在，告诉汽车，它想要向我们发送信息时调用哪个方法</span></span><br><span class="line">        c1.RegisterwithCarEngine(<span class="keyword">new</span> Car.CarEngineHandler(OnCarEngineEvent));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加速（这将触发事件）</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;****Speeding up ****&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要传入事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnCarEngineEvent</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">*****Message From Car object *****&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=&gt;&#123;0&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-5-1-支持多路广播"><a href="#11-5-1-支持多路广播" class="headerlink" title="11.5.1 支持多路广播"></a>11.5.1 支持多路广播</h5><p>NET委托内置支持多路广播。换句话说，一个委托对象可以维护一个可调用方法的列表而不只是单独一个方法。给一个委托对象添加多个方法时，不用直接分配，重载+&#x3D;操作符即可。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//现在支持多路广播</span></span><br><span class="line">    <span class="comment">//注意现在我们正在使用+一操作符，而不是量值操作符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterwithCarEngine</span>(<span class="params">CarEngineHandler methodToCall</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listofHandlers += methodTocall;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;****Delegates as event enablers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        <span class="comment">//首先，创建一个Car对象</span></span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在，告诉汽车，它想要向我们发送信息时调用哪个方法</span></span><br><span class="line">        c1.RegisterwithCarEngine(<span class="keyword">new</span> Car.CarEngineHandler(OnCarEngineEvent));</span><br><span class="line">        c1.RegisterwithCarEngine(<span class="keyword">new</span> Car.CarEngineHandler(OnCarEngineEvent2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加速（这将触发事件）</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;****Speeding up ****&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要传入事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnCarEngineEvent</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">*****Message From Car object *****&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=&gt;&#123;0&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnCarEngineEvent2</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=&gt;&#123;0&#125;&quot;</span>, msg.ToUpper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-5-2-从委托的调用列表中移除成员"><a href="#11-5-2-从委托的调用列表中移除成员" class="headerlink" title="11.5.2 从委托的调用列表中移除成员"></a>11.5.2 从委托的调用列表中移除成员</h5><p>Delegate类还定义了一个静态Remove()方法，允许调用者动态地从委托对象的调用列表中移除方法。这样，调用者就可以在运行时简单地“退订”某个已知的通知。你可以直接在代码中调用Delegate.Remove(),不过C#开发者可以使用-&#x3D;操作符作为简写方式。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterwithCarEngine</span>(<span class="params">CarEngineHandler methodToCall</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listofHandlers -= methodToCall;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Delegates as event enablers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//首先，创建一个Car对象</span></span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定对象，稍后注销</span></span><br><span class="line">    Car.CarEngineHandler handler2 = <span class="keyword">new</span> Car.CarEngineHandler(OnCarEngineEvent2);</span><br><span class="line">    c1.RegisterwithCarEngine(handler2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加速（这将触发事件）</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Speeding up ****&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注销handler2程序</span></span><br><span class="line">    c1.UnRegisterwithCarEngine(handler2);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-6-方法组转换语法"><a href="#11-6-方法组转换语法" class="headerlink" title="11.6 方法组转换语法"></a>11.6 方法组转换语法</h4><p>当然，如果要调用ulticastDelegate或Delegate中继承的任何成员，手工创建一个委托变量是最直接的方式。但大多数情况下，我们并不需要依靠委托对象。我们常常使用委托对象只是为了传递作为构造函数参数的方法名称。为了简化操作，C#提供了一种叫做方法组转换的简便方法。该特性允许我们在调用以委托作为参数的方法时直接提供方法的名称，而不用创建委托对象。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Delegates as event enablers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//首先，创建一个Car对象</span></span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在，告诉汽车，它想要向我们发送信息时调用哪个方法</span></span><br><span class="line">    c1.RegisterwithCarEngine(CallMeHere);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加速（这将触发事件）】</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Speeding up ****&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    c1.UnRegisterwithCarEngine(CallMeHere);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallMeHere</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;=&gt;Message from Car:&#123;0&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-7-委托协变"><a href="#11-7-委托协变" class="headerlink" title="11.7 委托协变"></a>11.7 委托协变</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">DelegateCovariance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义委托类型，它指向返回Car对象的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> Car <span class="title">ObtaincarDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">GetBasiccar</span>()</span></span><br><span class="line">        &#123;  <span class="keyword">return</span> <span class="keyword">new</span> car();&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sportscar <span class="title">Getsportscar</span>()</span></span><br><span class="line">        &#123;  <span class="keyword">return</span> <span class="keyword">new</span> Sportscar();&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;*****Delegate Covariance *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        </span><br><span class="line">            ObtaincarDelegate targetA = <span class="keyword">new</span> obtaincarDelegate(GetBasiccar);</span><br><span class="line">            Car c = targetA();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Obtained a &#123;0&#125;&quot;</span>,c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//协变允许这种目标对象赋值</span></span><br><span class="line">            UbtainVehicleDelegate targetB = <span class="keyword">new</span> ObtainvehicleDelegate(GetSportscar);</span><br><span class="line">            Sportscar sc = (SportsCar)targetB();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Obtained a (0)&quot;</span>,sc);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-8-泛型委托"><a href="#11-8-泛型委托" class="headerlink" title="11.8 泛型委托"></a>11.8 泛型委托</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">GenericDelegate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个泛型委托可以调用任何返回void并接受单个参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyGenericDelegate</span>&lt;<span class="title">T</span>&gt;(<span class="params">T arg</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine (<span class="string">&quot;****Generic Delegates *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注册目标</span></span><br><span class="line">            MyGenericDelegate&lt;<span class="built_in">string</span>&gt;<span class="function">strTarget</span></span><br><span class="line"><span class="function">            <span class="keyword">new</span> <span class="title">MyGenericDelegate</span>&lt;<span class="title">string</span>&gt;(<span class="params">StringTarget</span>)</span>;</span><br><span class="line">            strTarget(<span class="string">&quot;Some string data&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            MyGenericDelegate&lt;<span class="built_in">int</span>&gt;<span class="function">intTarget</span></span><br><span class="line"><span class="function">            <span class="keyword">new</span> <span class="title">MyGenericDelegate</span>&lt;<span class="title">int</span>&gt;(<span class="params">IntTarget</span>)</span>;</span><br><span class="line">            intTarget(<span class="number">9</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StringTarget</span>(<span class="params"><span class="built_in">string</span> arg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arg in uppercase is:(0&#125;&quot;</span>,arg.ToUpper());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IntTarget</span>(<span class="params"><span class="built_in">int</span> arg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;++arg is:(0)&quot;</span>,++arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-9-C-事件"><a href="#11-9-C-事件" class="headerlink" title="11.9 C#事件"></a>11.9 C#事件</h4><p>委托存在一些问题。例如：重复代码、如果没将委托的成员变量定义为私有的，调用者就可以直接访问委托对象公共的委托成员打破了封装，不仅会导致代码难以维护和调试，还会导致应用程序的安全风险！我们不希望给其他应用程序改变委托指向的权力以及没有我们的许可直接调用成员的权力。</p>
<h5 id="11-9-1-event关键字"><a href="#11-9-1-event关键字" class="headerlink" title="11.9.1 event关键字"></a>11.9.1 event关键字</h5><p>为了简化自定义方法的构建来为委托调用列表增加和删除方法，C#提供了event关键字。会自动提供注册和注销方法以及委托类型任何必要的成员变量。这些委托成员变量总是声明为私有的，因此不能直接从触发事件的对象访问它们</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个委托用来与Car的事件协作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CarEngineHandler</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这种汽车可以发送这些事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CarEngineHandler Exploded;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CarEngineHandler AboutToBlow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果汽车不能用了，触发引爆事件</span></span><br><span class="line">    <span class="keyword">if</span> (carIsDead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Exploded != <span class="literal">null</span>)</span><br><span class="line">            Exploded(<span class="string">&quot;Sorry,this car is dead...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Currentspeed += delta;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//快不能用了吗</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">10</span> == (MaxSpeed - Currentspeed) &amp;&amp; AboutToBlow != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AboutToBlow(<span class="string">&quot;Careful buddy!Gonna blow!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Currentspeed &gt;= MaxSpeed)</span><br><span class="line">            carIsDead = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;CurrentSpeed &#123;0&#125;&quot;</span>, Currentspeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经设定了cr对象发送两个自定义事件，这不再需要定义自定义注册函数，也不需要声明委托成员变量</p>
<h5 id="11-9-2-揭开事件的神秘面纱"><a href="#11-9-2-揭开事件的神秘面纱" class="headerlink" title="11.9.2 揭开事件的神秘面纱"></a>11.9.2 揭开事件的神秘面纱</h5><p>C#事件事实上会扩展为两个隐藏的公共方法，一个带add_前缀，另一个带remove_前缀。前缀后面是C#事件的名称。</p>
<h5 id="11-9-3-监听传入的事件"><a href="#11-9-3-监听传入的事件" class="headerlink" title="11.9.3 监听传入的事件"></a>11.9.3 监听传入的事件</h5><p>C#事件也简化了注册调用者事件处理程序的操作。现在无需指定自定义辅助方法，调用者仅需使用+&#x3D;和-&#x3D;操作符即可（操作符将在后台触发正确的addx()或remove_XXX()方法）。注册一个事件要遵循以下模式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//注册一个事件要遵循以下模式</span></span><br><span class="line"><span class="comment">//Nameofobject.NameofEvent +new RelatedDelegate(functionToCall);</span></span><br><span class="line">Car.EngineHandler d = <span class="keyword">new</span> Car.CarEventHandler(CarExplodedEventHandler)</span><br><span class="line">myCar.Exploded += d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要与事件源断开时，使用-=操作符：</span></span><br><span class="line"><span class="comment">// Nameofobject.NameofEvent -new RelatedDelegate(functionToCall);</span></span><br><span class="line">mycar.Exploded -= d;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with Events *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>,<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册事件处理程序</span></span><br><span class="line">    c1.AboutToBlow+=CarIsAlmostDoomed;</span><br><span class="line">    c1.AboutToBlow +=CarAboutToBlow;</span><br><span class="line">    c1.Exploded +=CarExploded;</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Speeding up *****&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    c1.Exploded -= CarExploded;</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">*****Speeding up *****&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>（<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="11-9-4-使用Visual-Studio2010简化事件注册"><a href="#11-9-4-使用Visual-Studio2010简化事件注册" class="headerlink" title="11.9.4 使用Visual Studio2010简化事件注册"></a>11.9.4 使用Visual Studio2010简化事件注册</h5><p>略</p>
<h5 id="11-9-5-创建自定义的事件参数"><a href="#11-9-5-创建自定义的事件参数" class="headerlink" title="11.9.5 创建自定义的事件参数"></a>11.9.5 创建自定义的事件参数</h5><p>略</p>
<h5 id="11-9-6-泛型EvenHandler委托"><a href="#11-9-6-泛型EvenHandler委托" class="headerlink" title="11.9.6 泛型EvenHandler委托"></a>11.9.6 泛型EvenHandler<T>委托</h5><p>由于很多自定义委托接受object作为第一个参数，EvenArgs派生类型作为第二个参数，我们可以通过使用泛型EvenHandler<T>类型来进一步简化之前的示例，其中T就是自定义的EventArgs</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;CarEventArgs&gt;Exploded;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;CarEventArgs&gt;AboutToBlow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Prim and Proper Events *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//像平常一样创建一个Car</span></span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>,<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册事件处理程序</span></span><br><span class="line">    c1.AboutToBlow += CarIsAlmostDoomed;</span><br><span class="line">    c1.AboutToBlow += CarAboutToBlow;</span><br><span class="line">    </span><br><span class="line">    EventHandler&lt;CarEventArgs&gt; d = <span class="keyword">new</span> EventHandler&lt;CarEventArgs&gt;(CarExploded);</span><br><span class="line">    c1.Exploded += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-10-C-匿名方法"><a href="#11-10-C-匿名方法" class="headerlink" title="11.10 C#匿名方法"></a>11.10 C#匿名方法</h4><p>当一个调用者想监听传进来的事件时，它必须定义一个唯一的与相关联委托签名匹配的方法方法很少会被调用委托之外的任何程序所调用。从生产效率的角度来说，手工定义一个由委托对象调用的方法显得有点烦琐，不会很受欢迎。为了解决这一情况，现在可以在事件注册时直接将一个委托与一段代码相关联。这种代码的正式名称为匿名方法。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Anonymous Methods *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>,<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//注册事件处理程序作为匿名方法</span></span><br><span class="line">    c1.AboutToBlow += <span class="built_in">delegate</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Eek!Going too fast!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">    c1.AboutToBlow += <span class="built_in">delegate</span>(<span class="built_in">object</span> sender,CarEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message from Car:(0)&quot;</span>,e.msg);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    c1.Exploded += <span class="built_in">delegate</span>(<span class="built_in">object</span> sender,CarEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fatal Message from car:(0)&quot;</span>,e.msg);</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//这最终会触发事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问本地变量</strong>匿名方法它使我们能访问定义它们的方法（称为定义方法）的本地变量。这些变量称为匿名方法的外部变量。有关匿名方法作用域与定义方法的作用域之间的交互，有几个重要的知识点，如下所示。</p>
<ul>
<li>匿名方法不能访问定义方法中的ref或out参数。</li>
<li>匿名方法中的本地变量不能与外部方法中的本地变量重名。</li>
<li>匿名方法可以访问外部类作用域中的实例变量（或静态变量）。</li>
<li>匿名方法内的本地变量可以与外部类的成员变量同名（本地变量的作用域不同，可以隐藏外部类的成员变量)。</li>
</ul>
<h4 id="11-11-Lambda表达式"><a href="#11-11-Lambda表达式" class="headerlink" title="11.11 Lambda表达式"></a>11.11 Lambda表达式</h4><p>Lambda表达式只是用更简单的方式来写匿名方法，彻底简化了对.NET委托类型的使用。考虑泛型List<T>类的FidA11()方法。当你需要从一个集合中提取子集时，可以使用该方法，其原型如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//System,Collections.Generic,List&lt;T&gt;类中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">FindAll</span>(<span class="params">Predicate&lt;T&gt; match</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AnonymousMethodsyntax</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立整数列表</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt;list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    list.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">20</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">44</span> &#125;);</span><br><span class="line">                           </span><br><span class="line">    <span class="comment">//现在使用匿名方法</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; evenNumbers = list.FindAll(<span class="built_in">delegate</span>(<span class="built_in">int</span> i)</span><br><span class="line">    	&#123; <span class="keyword">return</span> ( i % <span class="number">2</span> ) == <span class="number">0</span>; &#125; );</span><br><span class="line">                             </span><br><span class="line">    Console.WriteLine (<span class="string">&quot;Here are your even numbers:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> evenNumber <span class="keyword">in</span> evenNumbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;(0)\t&quot;</span>, evenNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用Lambda表达式进一步简化对FindA11()方法的调用。使用新的语法时，底层的委托对象将会消失得无影无踪。请看下面的Program类的新方法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LambdaExpressionSyntax</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立一个整数列表</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    list.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">20</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">44</span> &#125;);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//现在使用Lambda表达式</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt;evenNumbers = list.FindAll(i =&gt; (i % <span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Here are your even numbers:&quot;</span>)</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> evenNumber <span class="keyword">in</span> evenNumbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;&#123;0&#125;\t&quot;</span>,evenNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-11-1-剖析Lambda表达式"><a href="#11-11-1-剖析Lambda表达式" class="headerlink" title="11.11.1 剖析Lambda表达式"></a>11.11.1 剖析Lambda表达式</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ”i&quot;就是我们的参数列表</span></span><br><span class="line"><span class="comment">// (i % 2) == 0 就是处理&quot;i&quot;的表达式</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt;evenNumbers = list.FindAll(i =&gt; (i % <span class="number">2</span>) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h5 id="11-11-2-使用多个语句处理参数"><a href="#11-11-2-使用多个语句处理参数" class="headerlink" title="11.11.2 使用多个语句处理参数"></a>11.11.2 使用多个语句处理参数</h5><p>C#允许使用一系列代码语句来定义Lambda表达式。当表达式必须使用多行代码处理参数时，你可以使用一对花括号确定这些语句的范围</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LambdaExpressionsyntax</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建整型列表</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt;list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    list.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">20</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">44</span> &#125; );</span><br><span class="line">                           </span><br><span class="line">    <span class="comment">//现在使用语句块编写Lambda表达式</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; evenNumbers = list.FindAll( (i)=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;value of i is currently:(0)&quot;</span>,i);</span><br><span class="line">        <span class="built_in">bool</span> isEven = ( ( i %<span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> isEven;</span><br><span class="line">    &#125;):</span><br><span class="line">                           </span><br><span class="line">    Console.WriteLine (<span class="string">&quot;Here are your even numbers:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> evenNumber <span class="keyword">in</span> evenNumbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;(0)\t&quot;</span>,evenNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-11-3-含有多个（或零个）参数的Lambda表达式"><a href="#11-11-3-含有多个（或零个）参数的Lambda表达式" class="headerlink" title="11.11.3 含有多个（或零个）参数的Lambda表达式"></a>11.11.3 含有多个（或零个）参数的Lambda表达式</h5><p>Lambda表达式可以处理多个参数或者不提供任何参数</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleMath</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MathMessage</span>(<span class="params"><span class="built_in">string</span> msg, <span class="built_in">int</span> result</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> MathMessage mmDelegate;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMathHandler</span>(<span class="params">MathMessage target</span>)</span></span><br><span class="line">    &#123;mmDelegate = target;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mmDelegate != <span class="literal">null</span>)</span><br><span class="line">            mmDelegate.Invoke (<span class="string">&quot;Adding has completed!&quot;</span>,x +y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式注册w/委托</span></span><br><span class="line">    SimpleMath m = <span class="keyword">new</span> SimpleMath();</span><br><span class="line">    m.SetMathHandler((msg, result)=&gt;</span><br><span class="line">         &#123;Console.WriteLine(<span class="string">&quot;Message:(0),Result:(1)&quot;</span>,msg,result);&#125;);</span><br><span class="line">                     </span><br><span class="line">    <span class="comment">//执行Lambda表达式</span></span><br><span class="line">    m.Add(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-11-4-使用Lambda表达式重新编写CarEvents示例"><a href="#11-11-4-使用Lambda表达式重新编写CarEvents示例" class="headerlink" title="11.11.4 使用Lambda表达式重新编写CarEvents示例"></a>11.11.4 使用Lambda表达式重新编写CarEvents示例</h5><p>略</p>
<h3 id="12-高级C-语言特征"><a href="#12-高级C-语言特征" class="headerlink" title="12 高级C#语言特征"></a>12 高级C#语言特征</h3><p>高级的语法构造</p>
<h4 id="12-1-索引器方法"><a href="#12-1-索引器方法" class="headerlink" title="12.1 索引器方法"></a>12.1 索引器方法</h4><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用索引操作符遍历传入的命令行参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; args.Length; i++)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Args:&#123;0&#125;&quot;</span>,args[i]);</span><br><span class="line">                                          </span><br><span class="line">    <span class="comment">//声明一个局部整数数组</span></span><br><span class="line">    <span class="built_in">int</span>[] myInts = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">100</span>,<span class="number">432</span>,<span class="number">9874</span>&#125;:</span><br><span class="line">                                          </span><br><span class="line">    <span class="comment">//使用素引操作符访问每个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span> ; j &lt; myInts.Length ; j++)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Index &#123;0&#125;&#123;1&#125;&quot;</span>j,myInts[j]);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C#允许构建按照标准数组方式索引的自定义类和结构。顺理成章地能以这种方式访问子项的方法称为索引器方法(indexer method)。构建自定义集合类（泛型或非泛型)时，这个特殊的语言功能特别有用。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseGenericListofPeople</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Person&gt;myPeople = <span class="keyword">new</span> List&lt;Person&gt;();</span><br><span class="line">    myPeople.Add(<span class="keyword">new</span> Person(<span class="string">&quot;Lisa&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">9</span>));</span><br><span class="line">    myPeople.Add(<span class="keyword">new</span> Person(<span class="string">&quot;Bart&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">7</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变第一个人的索引器</span></span><br><span class="line">    myPeople[<span class="number">0</span>] = <span class="keyword">new</span> Person (<span class="string">&quot;Maggie&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过索引器获取和显示每一项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; myPeople.Count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Person number:&#123;0&#125;&quot;</span>,i);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Name:&#123;0&#125;&#123;1&#125;&quot;</span>,myPeople[i].FirstName,</span><br><span class="line">            myPeople[i].LastName);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Age:&#123;0&#125;&quot;</span>,myPeople[i].Age);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-1-使用字符串值索引对象"><a href="#12-1-1-使用字符串值索引对象" class="headerlink" title="12.1.1 使用字符串值索引对象"></a>12.1.1 使用字符串值索引对象</h5><p>由于ListDictionary类型允许使用字符串标记（例如一个人名）来访问其中包含的类型，我们可以设定新的索引器如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PeopleCollection</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, Person&gt;listPeople = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,Person&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个索引器基于一个字符串索引返回一个Car</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">this</span>(<span class="params"><span class="built_in">string</span> name]</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (Person</span>)listPeople[name]</span>; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; listPeople[name] = <span class="keyword">value</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearPeople</span>()</span></span><br><span class="line">	&#123; listPeople.clear();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count</span><br><span class="line">	&#123;<span class="keyword">get</span> &#123;<span class="keyword">return</span> listPeople.Count;&#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator (</span><br><span class="line">    &#123;<span class="keyword">return</span> listPeople.GetEnumerator();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Indexers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PeopleCollection myPeople = <span class="keyword">new</span> PeopleCollection();</span><br><span class="line"></span><br><span class="line">    myPeople[<span class="string">&quot;Homer&quot;</span>] = <span class="keyword">new</span> Person (<span class="string">&quot;Homer&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">40</span>);</span><br><span class="line">    myPeople[<span class="string">&quot;Marge&quot;</span>] = <span class="keyword">new</span> Person (<span class="string">&quot;Marge&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取&quot;Homer&quot;并输出数据</span></span><br><span class="line">    Person homer = myPeople[<span class="string">&quot;Homer&quot;</span>];</span><br><span class="line">    Console.WriteLine (homer.Tostring ());</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-2-重载索引器方法"><a href="#12-1-2-重载索引器方法" class="headerlink" title="12.1.2 重载索引器方法"></a>12.1.2 重载索引器方法</h5><p>索引器方法可以在单个类或结构上被重载</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DataTableCollection</span> : <span class="title">InternalDataCollectionBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重载的索引器</span></span><br><span class="line">    <span class="keyword">public</span> DataTable <span class="keyword">this</span>[<span class="built_in">string</span> name] &#123;<span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DataTable <span class="keyword">this</span>[<span class="built_in">string</span> name,<span class="built_in">string</span> tableNamespace] &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> DataTable <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-3-多维的索引器"><a href="#12-1-3-多维的索引器" class="headerlink" title="12.1.3 多维的索引器"></a>12.1.3 多维的索引器</h5><p>如果真想特立独行，也可以创建一个传入多个参数的索引器。假定有一个以二维数组方式存储子项的自定义集合，可以设定索引器方法如下：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeContainer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[,] my2DintArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>,<span class="number">10</span>];</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> row,<span class="built_in">int</span> column]</span><br><span class="line">    &#123;<span class="comment">/*从二维数组中取值或赋值*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-4-在接口类型上定义索引器"><a href="#12-1-4-在接口类型上定义索引器" class="headerlink" title="12.1.4 在接口类型上定义索引器"></a>12.1.4 在接口类型上定义索引器</h5><p>最后，要知道索引器可以在指定NET接口上定义，这样实现类型就可以提供自定义实现。以下是一个接口的简单示例，它定义了使用数字索引器获取字符串对象的协议：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStringContainer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//该接口定义了一个索引器，该素引器基于数字索引返回字符串</span></span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-2-操作符重载"><a href="#12-2-操作符重载" class="headerlink" title="12.2 操作符重载"></a>12.2 操作符重载</h4><p>+操作符本身可以根据所提供的数据类型（本例中是字符串和整数）不同而有不同的功能。当+操作符被用于数字类型时，结果就是操作数之和；而当+操作符用于字符串类型时，结果就是字符串的串联。C#语言允许我们构建自定义类型和结构，它们也能对同一组基本操作符（如+)做出不同的反应。一定要注意不能重载每个内建C#操作符。</p>
<h5 id="12-2-1-重载二元操作符"><a href="#12-2-1-重载二元操作符" class="headerlink" title="12.2.1 重载二元操作符"></a>12.2.1 重载二元操作符</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//仅是一个简单的C#类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xPos, <span class="built_in">int</span> yPos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xPos;</span><br><span class="line">        Y = yPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载+操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> + (Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(p1.X + p2.X, p1.Y + p2.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载-操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> - (Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(p1.X - p2.X, p1.Y - p2.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;[(0),(1)]&quot;</span>, <span class="keyword">this</span>.X, <span class="keyword">this</span>.Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Fun with overloaded Operators *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//创建两个点</span></span><br><span class="line">    Point ptone = <span class="keyword">new</span> Point(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    Point ptTwo = <span class="keyword">new</span> Point(<span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone &#123;0&#125;&quot;</span>, ptone);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptTwo &#123;0&#125;&quot;</span>, ptTwo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个点相加得到一个更大的点</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone ptTwo:(0)&quot;</span>, ptone + ptTwo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个点相减得到一个更小的点</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone ptTwo:(0]&quot;</span>, ptone - ptTwo);</span><br><span class="line">    Console.ReadLine():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-2-x3D-与-操作符"><a href="#12-2-2-x3D-与-操作符" class="headerlink" title="12.2.2 +&#x3D;与-+操作符"></a>12.2.2 +&#x3D;与-+操作符</h5><p>如果一个类型重载了相关的二元操作符，这些简写赋值操作符会自动具有相应的新功能</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重载二元操作符时，能产生新的简写赋值操作符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自动改变功能的+=</span></span><br><span class="line">    Point ptThree = <span class="keyword">new</span> Point(<span class="number">90</span>,<span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptThree (0)&quot;</span>,ptThree);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptThree += ptTwo:&#123;0&#125;&quot;</span>,ptThree +ptTwo);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动改变功能的-=</span></span><br><span class="line">    Point ptFour = <span class="keyword">new</span> Point (<span class="number">0</span>,<span class="number">500</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptFour &#123;0&#125;&quot;</span>,ptFour);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptFour -ptThree:&#123;0&#125;&quot;</span>,ptFour -ptThree);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-3-重载一元操作符"><a href="#12-2-3-重载一元操作符" class="headerlink" title="12.2.3 重载一元操作符"></a>12.2.3 重载一元操作符</h5><p>C#也允许我们重载各种-一元操作符，例如++与-。在重载一元操作符时，也要通过operator关键字定义一个静态方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将传人的Point的X/Y值加1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> ++(Point pl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(pl.X + <span class="number">1</span>, pl.Y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将传人的Point的X/Y值减1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> --(Point pl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(p1.X - <span class="number">1</span>, p1.Y - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//也可以按如下代码增减Point的X和Y值：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//向Point应用++和--元操作符</span></span><br><span class="line">    Point ptFive = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;++ptFive = &#123;0&#125;&quot;</span>, ++ptFive); <span class="comment">//[2, 2]</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;--ptFive = &#123;0&#125;&quot;</span>, --ptFive); <span class="comment">//[1, 1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用相同的操作符进行后递增和后递减</span></span><br><span class="line">    Point ptSix = <span class="keyword">new</span> Point(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptsix ++ = &#123;0&#125;&quot;</span>, ptSix++); <span class="comment">//[20, 20]</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptsix -- = &#123;0&#125;&quot;</span>, ptSix--); <span class="comment">//[21, 21]</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-4-重载相等操作符"><a href="#12-2-4-重载相等操作符" class="headerlink" title="12.2.4 重载相等操作符"></a>12.2.4 重载相等操作符</h5><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Point的变体也重载了==和！=操作符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o.ToString() = <span class="keyword">this</span>.ToString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ToString().GetHashCode();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在，让我们来重载==和！=操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> ==(Point p1, Point p2)</span><br><span class="line">    &#123; <span class="keyword">return</span> p1.Equals(p2); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> !=(Point p1, Point p2)</span><br><span class="line">    &#123; <span class="keyword">return</span> !p1.Equals(p2); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-5-重载比较操作符"><a href="#12-2-5-重载比较操作符" class="headerlink" title="12.2.5 重载比较操作符"></a>12.2.5 重载比较操作符</h5><p>如果重载&lt;也必须重载&gt;</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用重载的&lt;与&gt;操作符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone &lt; ptTwo &#123;0&#125;&quot;</span>,ptone &lt; ptTwo);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone &gt; ptTwo &#123;0&#125;&quot;</span>,ptone &gt; ptTwo);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">略</span><br></pre></td></tr></table></figure>

<h4 id="12-3-自定义类型转换"><a href="#12-3-自定义类型转换" class="headerlink" title="12.3 自定义类型转换"></a>12.3 自定义类型转换</h4><p>C#提供两个关键字explicit和implicit,可用来控制发生转换时类型的响应方式</p>
<h3 id="13-LINQ-to-Object"><a href="#13-LINQ-to-Object" class="headerlink" title="13 LINQ to Object"></a>13 LINQ to Object</h3><p>创建何种类型的应用程序，都需要在执行时访定的是，数据随处可见，如L文件、关系数据库、内存中的集合、基元数组等。在过去，根据数据位置的不同，程序员需要使用不同且不相关的API。,NET3.5引人了语言集成查询(LNQ),它提供了一种简明的、对称的、强类型的方式访向各种各样的数据存储。本章将开始研究LNQ,首先关注的是LINQ to Object。</p>
<h2 id="用-NET程序集编程"><a href="#用-NET程序集编程" class="headerlink" title="用.NET程序集编程"></a>用.NET程序集编程</h2><h3 id="14-NET程序集入门"><a href="#14-NET程序集入门" class="headerlink" title="14 .NET程序集入门"></a>14 .NET程序集入门</h3><p>书前13章中的每一个应用程序都是传统的、“独立”的应用程序，这里的“独立”是指所本有程字逻辑都封装在一个可执行文件中（.使cxc),然而，二进制重用(binary reuse)的t是NET平台的一个主要特点，它使得应用程序可以使用多个外部程序集（又称代码库）里面的类型。本章将对创建、部署和配置NET程序集的核心细节进行重点分析。本章首先介绍NET命名空间的构造，接着阐述单文件程序集和多文件程序集之间、“私有”程序集和“共享”程序集之间的区别，然后分析NET运行库如何解析一个程序集的位置，并进而理解全局程序集缓存(GAC)、应用程序配置文件(*.config文件)、发行者策略程序集以及ystem.Confi-guration命名空间。</p>
<h3 id="15-类型反射、晚期绑定和基于特性的编程"><a href="#15-类型反射、晚期绑定和基于特性的编程" class="headerlink" title="15 类型反射、晚期绑定和基于特性的编程"></a>15 类型反射、晚期绑定和基于特性的编程</h3><p>如第14章讲到的，在NET中，程序集是基本的部署单元。使用集成在Visual Studio2010中的象浏览器（和其他DE),可以查看项目所引用程序集的类型。此外，对于一个NET二进制文件，使用外部工具（如ildasm.exe和reflector..exe)可以查看底层的CIL代码、类型元数据和程序集清单。除了在设计时对NET程序集进行研究外，也可以使用System.Reflection命名空间通过编程获取相同的信息。本章的第一个任务就是明确反射的作用以及理解NET元数据的必要性。</p>
<h3 id="16-进程、应用程序域和对象上下文"><a href="#16-进程、应用程序域和对象上下文" class="headerlink" title="16 进程、应用程序域和对象上下文"></a>16 进程、应用程序域和对象上下文</h3><p>前章研究了CLR解析外部引用程序集位置的步骤以及.NET元数据的作用。本章将深入探讨序集由CLR承载的细节，并阐述进程、应用程序域和对象上下文（context)之间的关系。简单地说，进程可以承载一组相关的.NET程序集，而应用程序域（简称AppDomain)是对该进程的逻辑细分。你将看到，一个应用程序域进一步被细分成多个上下文边界，这些边界用来分组目的相似的NET对象。使用上下文的概念，CLR便能够确保恰当地控制那些带特殊运行时要求的对象。尽管大多数的日常编程任务可能不会直接使用进程、应用程序域或对象上下文，但在使用很多.NET API时，理解这些话题是非常重要的，如WCF、多线程和并行处理以及对象序列化。</p>
<h3 id="17-CIL和动态程序集的作用"><a href="#17-CIL和动态程序集的作用" class="headerlink" title="17 CIL和动态程序集的作用"></a>17 CIL和动态程序集的作用</h3><p>在热痛楼价用包硅受倍技他在英京中分招一托深有的作将*.cs代码文件翻译为CL代码、类型元数据和程序集清单。事实上，CL是一个成熟的.NET编程语言，包含自已的语法、语义和编译器(ilasm.exe)。本章将介绍这个NET平台的母语。你将理解CL指令、CL特性和CIL操作码之间的区别，还将学习各种CL编程工具以及.NET程序集正反向工程的作用，然后介绍了使用CL语法定义命名空间，类型和成员的基础知识，最后研究了System.Ref1 ection.Bmit命名空间的作用以及如何在运行时动态构造程序集（使用CL指令）。当然，很少有程序员会在日常工作中使用原始的CL代码。因此，我将在本章开头介绍为什么了解这个底层NET语言的语法和语义是很重要的。</p>
<h3 id="18-动态类型和动态语言运行时"><a href="#18-动态类型和动态语言运行时" class="headerlink" title="18 动态类型和动态语言运行时"></a>18 动态类型和动态语言运行时</h3><p>ET4为C#引人了一个新的关键字dynamic。该关键字允许我们在强类型的分号和花括号之间使用脚本化的行为，使用这种松散的类型，可以极大地简化一些复杂的细还可以获得与大量基于NET的动态语言（如IronRuby、IronPython)交互的能力。本章，我们将学习dynamic关键字的方方面面，理解如何使用DLR”(Dynamic Language Runtime,动态语言运行时)将松散的类型映射到正确的内存对象。理解了DLR提供的诸多服务之后，你将看到一些示例，它们使用动态类型来简化后期绑定方法的调用（通过反射服务）并且可以方便地与遗留的COM库进行通信。</p>
<h2 id="NET基础类库"><a href="#NET基础类库" class="headerlink" title=".NET基础类库"></a>.NET基础类库</h2><h3 id="19-构件多线程应用程序"><a href="#19-构件多线程应用程序" class="headerlink" title="19 构件多线程应用程序"></a>19 构件多线程应用程序</h3><p>人喜欢运行缓慢迟钝的应用程序。而且，也没人喜欢在影响程序其他部分响应速度的应用袋如单击工具条中的其项。在NET发布之前，构的应用程序需要编写极其复杂的C++代码和Windows线程API。幸好.NET平台提供了许多简单的方法来构建在特殊的执行路径执行复杂操作的软件。首先，回顾ET的委托类型，并理解它对异步方法调用的内在支持。你将看到，这项技术允许用户自动地在次线程中调用某个方法，而不需要手工创建或配置线程。</p>
<h3 id="20-文件输入输出和对象序列化"><a href="#20-文件输入输出和对象序列化" class="headerlink" title="20 文件输入输出和对象序列化"></a>20 文件输入输出和对象序列化</h3><p>如果要创建成熟的桌面应用程序，那么在用户会话之间保存信息的功能是必不可少的。本章将从.NET Framework的视角来研究一系列与I&#x2F;O相关的主题。首先研究System.Io命名空间定义的一些重要类型，进而理解怎样以编程方式修改计算机的目录和文件结构。掌握了这些后，接下来的任务就是研究读写基于字符、二进制、字符串、内存的各种数据存储内容的方法。</p>
<h3 id="21-ADO-NET之一：连接层"><a href="#21-ADO-NET之一：连接层" class="headerlink" title="21 ADO.NET之一：连接层"></a>21 ADO.NET之一：连接层</h3><p>如你所愿，NET平台定义了许多命名空间，允许同本地&#x2F;远程的数据库进行交互，我们把这些命名空间统称为ADO.NET。本章首先会总体介绍ADO.NET的作用，然后会重点讨论ADO.NET的数据提供程序。，NET平台支持许多数据提供程序，每一个都为和特定的数据库管理系统(微软SQL Server、Oracle、MySQL等)进行通信做了优化。</p>
<h3 id="22-ADO-NET之二：断开连接层"><a href="#22-ADO-NET之二：断开连接层" class="headerlink" title="22 ADO.NET之二：断开连接层"></a>22 ADO.NET之二：断开连接层</h3><hr>
<p>title: C#<br>date: 2022-8-22 10:39:26<br>tags:</p>
<p>- </p>
<p>categories: </p>
<ul>
<li>计算机</li>
<li>计算机语言</li>
<li>C#</li>
</ul>
<hr>
<h2 id="1-C-最小程序结构"><a href="#1-C-最小程序结构" class="headerlink" title="1. C#最小程序结构"></a>1. C#最小程序结构</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;	<span class="meta">#在程序中包含system命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorldApplication</span>	#<span class="title">name</span>空间申请，下级可包含多个类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HelloWorld</span> #类声明，下级可包含多个方法</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)	#mian方法，所有C#程序的入口点，说明执行类时将做的动作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 我的第一个 C# 程序*/</span>	<span class="meta">#注释</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World&quot;</span>);	<span class="meta">#writeline是console的方法</span></span><br><span class="line">            Console.ReadKey();	<span class="meta">#同上，当这个是等待按键动作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-C-基本语法"><a href="#2-C-基本语法" class="headerlink" title="2. C#基本语法"></a>2. C#基本语法</h2><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;	<span class="meta">#在任何 C# 程序中的第一条语句都是using System</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span>	#类声明</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 成员变量</span></span><br><span class="line">        <span class="built_in">double</span> length;	<span class="meta">#变量创建</span></span><br><span class="line">        <span class="built_in">double</span> width;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Acceptdetails</span>()	#函数体，Acceptdetails为Rectangle【成员函数】</span></span><br><span class="line">        &#123;</span><br><span class="line">            length = <span class="number">4.5</span>;    </span><br><span class="line">            width = <span class="number">3.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Length: &#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Width: &#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Area: &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExecuteRectangle</span>	#<span class="title">main</span>方法及启动实例化<span class="title">Rectangle</span>类的类</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = <span class="keyword">new</span> Rectangle();	实例化并重命名r</span><br><span class="line">            r.Acceptdetails();	<span class="meta">#使用方法</span></span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-C-数据类型值类型"><a href="#3-C-数据类型值类型" class="headerlink" title="3. C#数据类型值类型"></a>3. C#数据类型<a href="https://www.runoob.com/csharp/csharp-data-types.html">值类型</a></h2><h3 id="3-1-值类型"><a href="#3-1-值类型" class="headerlink" title="3.1 值类型"></a>3.1 <a href="https://www.runoob.com/csharp/csharp-data-types.html">值类型</a></h3><figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataTypeApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Size of int: &#123;0&#125;&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">int</span>));	<span class="meta">#sizeof实际上是获取了数据在内存中所占用的存储空间，以字节为单位来计数。</span></span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###引用类型引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p>
<p>####对象：对象可以分配任何其他类型的值，但在分类之前，需要类型转换####动态类型：####字符串类型####对象</p>
<p>###指针类型</p>
<p>##C#类型转换</p>
<ul>
<li><strong>隐式类型转换</strong> - 这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。</li>
<li><strong>显式类型转换</strong> - 显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失。<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">TypeConversionApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExplicitConversion</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> d = <span class="number">5673.74</span>;</span><br><span class="line">            <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 强制转换 double 为 int</span></span><br><span class="line">            i = (<span class="built_in">int</span>)d;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a href="https://www.runoob.com/csharp/csharp-type-conversion.html">C# 类型转换方法</a>##C#变量 一个变量只不过是一个供程序操作的存储区的名字。在 C# 中，每个变量都有一个特定的类型，类型决定了变量的内存大小和布局。范围内的值可以存储在内存中，可以对变量进行一系列操作</li>
</ul>
<p>##C#常量常量是固定值，程序执行期间不会改变。常量可以是任何基本数据类型，比如整数常量、浮点常量、字符常量或者字符串常量，还有枚举常量。常量可以被当作常规的变量，只是它们的值在定义后不能被修改。</p>
<p>##C#运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：</p>
<ul>
<li><p>算术运算符</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>&#x2F;</p>
</li>
<li><p>%（取模）</p>
</li>
<li><p>++（自增1）</p>
</li>
<li><p>–（自减1）</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OperatorsAppl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> a = <span class="number">21</span>;</span><br><span class="line">            <span class="built_in">int</span> b = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">int</span> c;</span><br><span class="line"></span><br><span class="line">            c = a + b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 1 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            c = a - b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 2 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            c = a * b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 3 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            c = a / b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 4 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            c = a % b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 5 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ++a 先进行自增运算再赋值</span></span><br><span class="line">            c = ++a;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 6 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 a 的值为 22</span></span><br><span class="line">            <span class="comment">// --a 先进行自减运算再赋值</span></span><br><span class="line">            c = --a;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 7 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>c &#x3D; a++</strong>: 先将 a 赋值给 c，再对 a 进行自增运算。</p>
</li>
<li><p><strong>c &#x3D; ++a</strong>: 先将 a 进行自增运算，再将 a 赋值给 c 。</p>
</li>
<li><p><strong>c &#x3D; a–</strong>: 先将 a 赋值给 c，再对 a 进行自减运算。</p>
</li>
<li><p><strong>c &#x3D; –a</strong>: 先将 a 进行自减运算，再将 a 赋值给 c 。</p>
</li>
</ul>
</li>
<li><p>关系运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td>(A &#x3D;&#x3D; B) 不为真。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td>(A !&#x3D; B) 为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td>(A &gt; B) 不为真。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td>(A &lt; B) 为真。</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &gt;&#x3D; B) 不为真。</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &lt;&#x3D; B) 为真。</td>
</tr>
</tbody></table>
</li>
<li><p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td>(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td>&amp;#124;&amp;#124;</td>
<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td>(A &amp;#124;&amp;#124; B) 为真。</td>
</tr>
<tr>
<td>!</td>
<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td>!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
</li>
<li><p>位运算符（用于二进制移动，即60的二进制为00111100）</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
<td>(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td>&amp;#124;</td>
<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
<td>(A &amp;#124; B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
<td>(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td>
<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
</li>
</ul>
<p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：A &#x3D; 0011 1100B &#x3D; 0000 1101—————–A&amp;B &#x3D; 0000 1100A|B &#x3D; 0011 1101A^B &#x3D; 0011 0001~A  &#x3D; 1100 0011</p>
<ul>
<li><p>赋值运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td>C &#x3D; A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td>C +&#x3D; A 相当于 C &#x3D; C + A</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td>C -&#x3D; A 相当于 C &#x3D; C - A</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td>C *&#x3D; A 相当于 C &#x3D; C * A</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td>C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td>C %&#x3D; A 相当于 C &#x3D; C % A</td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移且赋值运算符</td>
<td>C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移且赋值运算符</td>
<td>C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与且赋值运算符</td>
<td>C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或且赋值运算符</td>
<td>C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>
</tr>
<tr>
<td>&amp;#124;&#x3D;</td>
<td>按位或且赋值运算符</td>
<td>C &amp;#124;&#x3D; 2 等同于 C &#x3D; C &amp;#124; 2</td>
</tr>
</tbody></table>
</li>
<li><p>其他运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>sizeof()</td>
<td>返回数据类型的大小。</td>
<td>sizeof(int)，将返回 4.</td>
</tr>
<tr>
<td>typeof()</td>
<td>返回 class 的类型。</td>
<td>typeof(StreamReader);</td>
</tr>
<tr>
<td>&amp;</td>
<td>返回变量的地址。</td>
<td>&amp;a; 将得到变量的实际地址。</td>
</tr>
<tr>
<td>*</td>
<td>变量的指针。</td>
<td>*a; 将指向一个变量。</td>
</tr>
<tr>
<td>? :</td>
<td>条件表达式</td>
<td>如果条件为真 ? 则为 X : 否则为 Y</td>
</tr>
<tr>
<td>is</td>
<td>判断对象是否为某一类型。</td>
<td>If( Ford is Car) &#x2F;&#x2F; 检查 Ford 是否是 Car 类的一个对象。</td>
</tr>
<tr>
<td>as</td>
<td>强制转换，即使转换失败也不会抛出异常。</td>
<td>Object obj &#x3D; new StringReader(“Hello”);StringReader r &#x3D; obj as StringReader;</td>
</tr>
</tbody></table>
</li>
</ul>
<p>##C@#判断</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/csharp/csharp-if.html">if 语句</a></td>
<td>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/csharp/csharp-if-else.html">if…else 语句</a></td>
<td>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/csharp/csharp-nested-if.html">嵌套 if 语句</a></td>
<td>您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/csharp/csharp-switch.html">switch 语句</a></td>
<td>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/csharp/csharp-nested-switch.html">嵌套 switch 语句</a></td>
<td>您可以在一个 <strong>switch</strong> 语句内使用另一个 **switch ** 语句。</td>
</tr>
</tbody></table>
<p>##C#循环</p>
<table>
<thead>
<tr>
<th>循环类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a href="https://www.runoob.com/csharp/csharp-while-loop.html">while 循环</a></td>
<td>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/csharp/csharp-for-loop.html">for&#x2F;foreach 循环</a></td>
<td>多次执行一个语句序列，简化管理循环变量的代码。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/csharp/csharp-do-while-loop.html">do…while 循环</a></td>
<td>除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>
</tr>
<tr>
<td><a href="https://www.runoob.com/csharp/csharp-nested-loops.html">嵌套循环</a></td>
<td>您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>
</tr>
</tbody></table>
<p>##C#封装<strong>封装</strong> 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者_实现所需级别的抽象_。C# 封装根据具体的需要，设置使用者的访问权限，并通过 <strong>访问修饰符</strong> 来实现。一个 <strong>访问修饰符</strong> 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：</p>
<ul>
<li><p>public：所有对象都可以访问；</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">double</span> length;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">double</span> width;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> length * width;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;长度：&#123;0&#125;&quot;</span>,length);</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;宽度：&#123;0&#125;&quot;</span>,width);</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;面积：&#123;0&#125;&quot;</span>,GetArea());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">			r.length = <span class="number">4.5</span>;</span><br><span class="line">			r.width = <span class="number">3.5</span>;</span><br><span class="line">			r.Display();</span><br><span class="line">			Console.ReadLine();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在上面的实例中，成员变量 length 和 width 被声明为 public，所以它们可以被函数 Main() 使用 Rectangle 类的实例 r 访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员函数 Display() 和 GetArea() 可以直接访问这些变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员函数 Display() 也被声明为 public，所以它也能被 Main() 使用 Rectangle 类的实例 r 访问</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>private：对象本身在对象内部可以访问；</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//成员变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> length;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> width;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Acceptdetails</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入长度：&quot;</span>);</span><br><span class="line">            length = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入宽度：&quot;</span>);</span><br><span class="line">            width = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;长度： &#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;宽度： &#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//end class Rectangle    </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">            r.Acceptdetails();</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成员变量 length 和 width 被声明为 private，所以它们不能被函数 Main() 访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员函数 AcceptDetails() 和 Display() 可以访问这些变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于成员函数 AcceptDetails() 和 Display() 被声明为 public，所以它们可以被 Main() 使用 Rectangle 类的实例 r 访问。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>protected：只有该类对象及其子类对象可以访问</p>
</li>
<li><p>internal：同一个程序集的对象可以访问；</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//成员变量</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="built_in">double</span> length;</span><br><span class="line">        <span class="keyword">internal</span> <span class="built_in">double</span> width;</span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;长度： &#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;宽度： &#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//end class Rectangle    </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">            r.length = <span class="number">4.5</span>;</span><br><span class="line">            r.width = <span class="number">3.5</span>;</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>protected internal：访问限于当前程序集或派生自包含类的类型。</p>
</li>
</ul>
<p>##C#方法一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类。要使用一个方法，您需要：</p>
<ul>
<li><p>定义方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span><br><span class="line">&#123;</span><br><span class="line">   Method Body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</span><br><span class="line">    Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <span class="keyword">void</span>。</span><br><span class="line">    Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</span><br><span class="line">    Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</span><br><span class="line">    Method body：方法主体，包含了完成任务所需的指令集。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindMax</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">      <span class="built_in">int</span> result;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">         result = num1;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         result = num2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindMax</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">         <span class="built_in">int</span> result;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">            result = num1;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            result = num2;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         <span class="built_in">int</span> b = <span class="number">200</span>;</span><br><span class="line">         <span class="built_in">int</span> ret;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//调用 FindMax 方法</span></span><br><span class="line">         ret = n.FindMax(a, b);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;最大值是： &#123;0&#125;&quot;</span>, ret );</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>###参数传递</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>值参数</td>
<td>这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</td>
</tr>
<tr>
<td>引用参数</td>
<td>这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。</td>
</tr>
<tr>
<td>输出参数</td>
<td>这种方式可以返回多个值。</td>
</tr>
</tbody></table>
<p>##C#可控类型###单问号 ? 与 双问号 ?? <a href="https://www.runoob.com/csharp/csharp-nullable.html">https://www.runoob.com/csharp/csharp-nullable.html</a>##C#数组 数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。  ###声明数组</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">datatype[] arrayName;</span><br><span class="line">    datatype 用于指定被存储在数组中的元素的类型。</span><br><span class="line">    [ ] 指定数组的秩（维度）。秩指定数组的大小。</span><br><span class="line">    arrayName 指定数组的名称。</span><br><span class="line">例：</span><br><span class="line"><span class="built_in">double</span>[] balance;</span><br></pre></td></tr></table></figure>
<p>###初始化数组</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line">声明一个数组不会在内存中初始化数组。当初始化数组变量时，您可以赋值给数组。</span><br><span class="line"></span><br><span class="line">数组是一个引用类型，所以您需要使用 <span class="keyword">new</span> 关键字来创建数组的实例</span><br></pre></td></tr></table></figure>
<p>###赋值给数组</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line">balance[<span class="number">0</span>] = <span class="number">4500.0</span>;</span><br><span class="line"></span><br><span class="line">您可以在声明数组的同时给数组赋值，比如：</span><br><span class="line"><span class="built_in">double</span>[] balance = &#123; <span class="number">2340.0</span>, <span class="number">4523.69</span>, <span class="number">3421.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">您也可以创建并初始化一个数组，比如：</span><br><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br><span class="line">在上述情况下，你也可以省略数组的大小，比如：</span><br><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>###访问数组元素</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> salary = balance[<span class="number">9</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ArrayApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">MyArray</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> []  n = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]; <span class="comment">/* n 是一个带有 10 个整数的数组 */</span></span><br><span class="line">         <span class="built_in">int</span> i,j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 初始化数组 n 中的元素 */</span>        </span><br><span class="line">         <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">         &#123;</span><br><span class="line">            n[ i ] = i + <span class="number">100</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;</span>, j, n[j]);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##C#字符串</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StringApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">//字符串，字符串连接</span></span><br><span class="line">            <span class="built_in">string</span> fname, lname;</span><br><span class="line">            fname = <span class="string">&quot;Rowan&quot;</span>;</span><br><span class="line">            lname = <span class="string">&quot;Atkinson&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> fullname = fname + lname;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Full Name: &#123;0&#125;&quot;</span>, fullname);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过使用 string 构造函数</span></span><br><span class="line">            <span class="built_in">char</span>[] letters = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span> &#125;;</span><br><span class="line">            <span class="built_in">string</span> greetings = <span class="keyword">new</span> <span class="built_in">string</span>(letters);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Greetings: &#123;0&#125;&quot;</span>, greetings);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法返回字符串</span></span><br><span class="line">            <span class="built_in">string</span>[] sarray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;From&quot;</span>, <span class="string">&quot;Tutorials&quot;</span>, <span class="string">&quot;Point&quot;</span> &#125;;</span><br><span class="line">            <span class="built_in">string</span> message = String.Join(<span class="string">&quot; &quot;</span>, sarray);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于转化值的格式化方法</span></span><br><span class="line">            DateTime waiting = <span class="keyword">new</span> DateTime(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">58</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> chat = String.Format(<span class="string">&quot;Message sent at &#123;0:t&#125; on &#123;0:D&#125;&quot;</span>,</span><br><span class="line">            waiting);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, chat);</span><br><span class="line">            Console.ReadKey() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##C#结构体 结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。<strong>struct</strong> 关键字用于创建结构体。  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">struct</span> Books</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> title;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> author;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> subject;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> book_id;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testStructure</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      Books Book1;        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">      Books Book2;        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* book 1 详述 */</span></span><br><span class="line">      Book1.title = <span class="string">&quot;C Programming&quot;</span>;</span><br><span class="line">      Book1.author = <span class="string">&quot;Nuha Ali&quot;</span>;</span><br><span class="line">      Book1.subject = <span class="string">&quot;C Programming Tutorial&quot;</span>;</span><br><span class="line">      Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* book 2 详述 */</span></span><br><span class="line">      Book2.title = <span class="string">&quot;Telecom Billing&quot;</span>;</span><br><span class="line">      Book2.author = <span class="string">&quot;Zara Ali&quot;</span>;</span><br><span class="line">      Book2.subject =  <span class="string">&quot;Telecom Billing Tutorial&quot;</span>;</span><br><span class="line">      Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">      Console.WriteLine( <span class="string">&quot;Book 1 title : &#123;0&#125;&quot;</span>, Book1.title);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 1 author : &#123;0&#125;&quot;</span>, Book1.author);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 1 subject : &#123;0&#125;&quot;</span>, Book1.subject);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 1 book_id :&#123;0&#125;&quot;</span>, Book1.book_id);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 2 title : &#123;0&#125;&quot;</span>, Book2.title);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 2 author : &#123;0&#125;&quot;</span>, Book2.author);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 2 subject : &#123;0&#125;&quot;</span>, Book2.subject);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 2 book_id : &#123;0&#125;&quot;</span>, Book2.book_id);      </span><br><span class="line"></span><br><span class="line">      Console.ReadKey();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有点类似于数据库中每一条记录的记录方式</p>
<p>##C#枚举枚举是一组命名整型常量。枚举类型是使用 <strong>enum</strong> 关键字声明的。C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。</p>
<p>枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0.例如：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> Day &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = (<span class="built_in">int</span>)Day.Sun;</span><br><span class="line">        <span class="built_in">int</span> y = (<span class="built_in">int</span>)Day.Fri;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sun = &#123;0&#125;&quot;</span>, x);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fri = &#123;0&#125;&quot;</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sun = 0</span></span><br><span class="line"><span class="comment">Fri = 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>##C#类 当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量称为类的成员。  </p>
<p>###类的定义类的定义是以关键字 <strong>class</strong> 开始，后跟类的名称。类的主体，包含在一对花括号内。下面是类定义的一般形式：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">&lt;access specifier&gt; <span class="keyword">class</span>  <span class="title">class_name</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// member variables</span></span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">    <span class="comment">// member methods</span></span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method1(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method2(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; methodN(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>访问标识符 <access specifier> 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</li>
<li>数据类型 <data type> 指定了变量的类型，返回类型 <return type> 指定了返回的方法返回的数据类型。</li>
<li>如果要访问类的成员，你要使用点（.）运算符。</li>
<li>点运算符链接了对象的名称和成员的名称。</li>
</ul>
<p>###成员函数的封装</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BoxApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span>(<span class="params"> <span class="built_in">double</span> len </span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">            length = len;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBreadth</span>(<span class="params"> <span class="built_in">double</span> bre </span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">            breadth = bre;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"> <span class="built_in">double</span> hei </span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">            height = hei;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getVolume</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Boxtester</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Box Box1 = <span class="keyword">new</span> Box();        <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">            Box Box2 = <span class="keyword">new</span> Box();        <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">            <span class="built_in">double</span> volume;               <span class="comment">// 体积</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box1 详述</span></span><br><span class="line">            Box1.setLength(<span class="number">6.0</span>);</span><br><span class="line">            Box1.setBreadth(<span class="number">7.0</span>);</span><br><span class="line">            Box1.setHeight(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box2 详述</span></span><br><span class="line">            Box2.setLength(<span class="number">12.0</span>);</span><br><span class="line">            Box2.setBreadth(<span class="number">13.0</span>);</span><br><span class="line">            Box2.setHeight(<span class="number">10.0</span>);</span><br><span class="line">       </span><br><span class="line">            <span class="comment">// Box1 的体积</span></span><br><span class="line">            volume = Box1.getVolume();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box1 的体积： &#123;0&#125;&quot;</span> ,volume);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box2 的体积</span></span><br><span class="line">            volume = Box2.getVolume();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box2 的体积： &#123;0&#125;&quot;</span>, volume);</span><br><span class="line">           </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 成员变量是对象的属性（从设计角度），且它们保持私有来实现封装。这些变量只能使用公共成员函数来访问。  ###C#中的构造函数类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。构造函数的名称与类的名称完全相同，它没有任何返回类型。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LineApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Line</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">double</span> length;   <span class="comment">// 线条的长度</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Line</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span>(<span class="params"> <span class="built_in">double</span> len </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getLength</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Line line = <span class="keyword">new</span> Line();    </span><br><span class="line">         <span class="comment">// 设置线条长度</span></span><br><span class="line">         line.setLength(<span class="number">6.0</span>);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;线条的长度： &#123;0&#125;&quot;</span>, line.getLength());</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<a href="https://www.runoob.com/csharp/csharp-class.html"><strong>参数化构造函数</strong></a>###C#中的析构函数类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LineApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Line</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">double</span> length;   <span class="comment">// 线条的长度</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Line</span>()  <span class="comment">// 构造函数</span></span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ~Line() <span class="comment">//析构函数</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;对象已删除&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span>(<span class="params"> <span class="built_in">double</span> len </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getLength</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Line line = <span class="keyword">new</span> Line();</span><br><span class="line">         <span class="comment">// 设置线条长度</span></span><br><span class="line">         line.setLength(<span class="number">6.0</span>);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;线条的长度： &#123;0&#125;&quot;</span>, line.getLength());          </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对象已创建</span></span><br><span class="line"><span class="comment">线条的长度： 6</span></span><br><span class="line"><span class="comment">对象已删除</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>##C#继承继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的<strong>基类</strong>，这个新的类被称为<strong>派生类</strong>。继承的思想实现了 <strong>属于（IS-A）</strong> 关系。###基类的初始化 派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。  </p>
<p>###C#多重继承多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。<strong>C# 不支持多重继承</strong>。但是，您可以使用接口来实现多重继承。</p>
<p>##C#多态性多态是同一个行为具有多个不同表现形式或形态的能力。<strong>多态性</strong>意味着有多重形式。在面向对象编程范式中，多态性往往表现为”一个接口，多个功能”。多态性可以是静态的或动态的。在<strong>静态多态性</strong>中，函数的响应是在编译时发生的。在<strong>动态多态性</strong>中，函数的响应是在运行时发生的。</p>
<p>###静态多态性在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：</p>
<ul>
<li>函数重载</li>
<li>运算符重载</li>
</ul>
<p>###函数重载 您可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不能重载只有返回类型不同的函数声明  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PolymorphismApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestData</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c</span>)</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> a + b + c;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> a + b;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            TestData dataClass = <span class="keyword">new</span> TestData();</span><br><span class="line">            <span class="built_in">int</span> add1 = dataClass.Add(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">            <span class="built_in">int</span> add2 = dataClass.Add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;add1 :&quot;</span> + add1);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;add2 :&quot;</span> + add2);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###动态多态性C# 允许您使用关键字 <strong>abstract</strong> 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。请注意，下面是有关抽象类的一些规则：</p>
<ul>
<li>您不能创建一个抽象类的实例。</li>
<li>您不能在一个抽象类外部声明一个抽象方法。</li>
<li>通过在类定义前面放置关键字 <strong>sealed</strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong>sealed</strong> 时，它不能被继承。抽象类不能被声明为 sealed。<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PolymorphismApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="built_in">int</span> <span class="title">area</span>()</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Rectangle</span>:  <span class="title">Shape</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> length;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> width;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"> <span class="built_in">int</span> a=<span class="number">0</span>, <span class="built_in">int</span> b=<span class="number">0</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         length = a;</span><br><span class="line">         width = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">area</span> ()</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Rectangle 类的面积：&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> (width * length);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title">RectangleTester</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Rectangle r = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">         <span class="built_in">double</span> a = r.area();</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>,a);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>##C#运算符重载 您可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 <strong>operator</strong> 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。  </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Box <span class="keyword">operator</span>+ (Box b, Box c)</span><br><span class="line">&#123;</span><br><span class="line">   Box box = <span class="keyword">new</span> Box();</span><br><span class="line">   box.length = b.length + c.length;</span><br><span class="line">   box.breadth = b.breadth + c.breadth;</span><br><span class="line">   box.height = b.height + c.height;</span><br><span class="line">   <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.runoob.com/csharp/csharp-operator-overloading.html">https://www.runoob.com/csharp/csharp-operator-overloading.html</a></p>
<p>##C#接口接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 <strong>“是什么”</strong> 部分，派生类定义了语法合同 <strong>“怎么做”</strong> 部分。接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。接口使得实现接口的类或结构在形式上保持一致。抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。<a href="https://www.runoob.com/csharp/csharp-interface.html">https://www.runoob.com/csharp/csharp-interface.html</a></p>
<p>##C#命名空间<strong>命名空间</strong>的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_name</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##C#预处理器指令预处理器指令指导编译器在实际编译开始之前对信息进行预处理。所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。<a href="https://www.runoob.com/csharp/csharp-preprocessor-directives.html">https://www.runoob.com/csharp/csharp-preprocessor-directives.html</a></p>
<p>##C#正则表达式<a href="https://www.runoob.com/csharp/csharp-regular-expressions.html">https://www.runoob.com/csharp/csharp-regular-expressions.html</a></p>
<p>##C#异常处理<a href="https://www.runoob.com/csharp/csharp-exception-handling.html">https://www.runoob.com/csharp/csharp-exception-handling.html</a></p>
<p>##C#文件的输入与输出<a href="https://www.runoob.com/csharp/csharp-file-io.html">https://www.runoob.com/csharp/csharp-file-io.html</a></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>C#</category>
      </categories>
  </entry>
  <entry>
    <title>Ajax数据爬取</title>
    <url>/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/Ajax%E6%95%B0%E6%8D%AE%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<p>利用JavaScript在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部门网页的技术。非编程语言。</p>
<p><a href="https://www.w3school.com.cn/">w3school 在线教程</a></p>
<h2 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1 基本原理"></a>1 基本原理</h2><ol>
<li>发送请求</li>
</ol>
<p>ajax也是由JavaScript实现的</p>
<ol start="2">
<li>解析内容</li>
</ol>
<p>获取响应内容，再通过JavaScript进一步处理</p>
<ol start="3">
<li>渲染内容</li>
</ol>
<p>再通过JavaScript对网页进行改变渲染。也就是DOM操作</p>
<h2 id="2-Ajax分析方法"><a href="#2-Ajax分析方法" class="headerlink" title="2 Ajax分析方法"></a>2 Ajax分析方法</h2><p>环境：Chrome</p>
<table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>查看请求Ajax有其特殊的请求类型【xhr】</td>
<td>1.F12(打开开发者工具)。2.打开network选项卡，并且重新刷新页面。(重新获取请求)。1.找到类型为’xhr’的请求2.【预览】中可以查看返回结果(该界面谷歌做了解析，点击箭头即可对应展开)。即解析后的真实返回数据3.【响应】菜单对应真实的返回数据</td>
</tr>
<tr>
<td>2</td>
<td>过滤请求</td>
<td>1.谷歌自带筛选功能，直接选择【XHR】筛选出所有Ajax请求2.重复多几次动作，激活多几次数据。方便分析</td>
</tr>
</tbody></table>
<h2 id="3-Ajax结果提取"><a href="#3-Ajax结果提取" class="headerlink" title="3 Ajax结果提取"></a>3 Ajax结果提取</h2><table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
<th>动作</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>分析请求</td>
<td>1.对链接地址所传递的参数分析</td>
</tr>
<tr>
<td>2</td>
<td>分析响应</td>
<td>1.打开【预览】查看响应内容。该内容是【JSON】格式的2.查看【cardlistinfo】和【cards】</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlencode</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">base_url =<span class="string">&#x27;https://m.weibo.cn/api/container/getIndex?&#x27;</span></span><br><span class="line">headers = &#123;</span><br><span class="line"><span class="string">&#x27;Host&#x27;</span>:<span class="string">&#x27;m.weibo.cn&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;Referer&#x27;</span>:<span class="string">&#x27;https://m.weibo.cn/u/2830678474&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Macintosh;Intel Mac OS X 10 12 3)AppleWebKit/537.36 (KHTML,like Gecko)Chrome/58.0.3029.110 Safari/537.36&#x27;</span>,</span><br><span class="line"><span class="string">&#x27;X-Requested-With&#x27;</span>:<span class="string">&#x27;XMLHttpRequest&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_page</span>(<span class="params">page</span>):</span><br><span class="line">    params = &#123;</span><br><span class="line">    <span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;uid&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;value&#x27;</span>:<span class="string">&#x27;2830678474&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;containerid&#x27;</span>:<span class="string">&#x27;1076032830678474&#x27;</span>,</span><br><span class="line">    page:page</span><br><span class="line">    &#125;</span><br><span class="line">    url = base_url + urlencode(params)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response = requests.get(url, headers=headers)</span><br><span class="line">        <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> response.json()</span><br><span class="line">    <span class="keyword">except</span> requests.ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Error&#x27;</span>, e.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">parse_page</span>(<span class="params">json</span>):</span><br><span class="line">    <span class="keyword">if</span> json:</span><br><span class="line">        items = json.get(<span class="string">&#x27;data&#x27;</span>).get(<span class="string">&#x27;cards&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">            item = item.get(<span class="string">&#x27;mblog&#x27;</span>)</span><br><span class="line">            weibo =&#123;&#125;</span><br><span class="line">            weibo[<span class="string">&#x27;id&#x27;</span>]=item.get(<span class="string">&#x27;id&#x27;</span>)</span><br><span class="line">            weibo[<span class="string">&#x27;text&#x27;</span>]=pq(item.get(<span class="string">&#x27;text&#x27;</span>)).text()</span><br><span class="line">            weibo[<span class="string">&#x27;attitudes&#x27;</span>]=item.get(<span class="string">&#x27;attitudes count&#x27;</span>)</span><br><span class="line">            weibo[<span class="string">&#x27;comments&#x27;</span>]=item.get(<span class="string">&#x27;comments count&#x27;</span>)</span><br><span class="line">            weibo[<span class="string">&#x27;reposts&#x27;</span>]=item.get(<span class="string">&#x27;reposts_count&#x27;</span>)</span><br><span class="line">            <span class="keyword">yield</span> weibo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">11</span>):</span><br><span class="line">        json = get_page(page)</span><br><span class="line">        results = parse_page(json)</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            <span class="built_in">print</span>(result)</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="comment">#爬取微博</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>代理的使用</title>
    <url>/2022/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E4%BB%A3%E7%90%86%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<ol>
<li>获取代理</li>
</ol>
<p>网络上有很多免费代理。也可以在本地搭建代理服务器</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>动态渲染页面爬取</title>
    <url>/2022/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E5%8A%A8%E6%80%81%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2%E7%88%AC%E5%8F%96/</url>
    <content><![CDATA[<p>通过对ajax的分析和抓取是一种常规手段。但是如果遇上一些使用其他渲染技术的网站，或者接口包含很多的加密参数，很难直接找出规律。这种时候可以直接模拟使用浏览器运行的方式来实现，可见即可爬。不需要理解网页内部用了什么渲染方法、不需要理会后台的接口参数</p>
<h2 id="Selenium的使用"><a href="#Selenium的使用" class="headerlink" title="Selenium的使用"></a>Selenium的使用</h2><p>Selenium是一个自动化测试工作。可以驱动浏览器实现很多模拟动作，也可以获取当前页面源代码</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>打开网站，模拟操作，读取渲染结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.keys <span class="keyword">import</span> Keys</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.wait <span class="keyword">import</span> WebDriverWait</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    browser = webdriver.Chrome()</span><br><span class="line">    browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line">    <span class="built_in">input</span> = browser.find_element(by=By.ID, value=<span class="string">&#x27;kw&#x27;</span>)</span><br><span class="line">    <span class="built_in">input</span>.send_keys(<span class="string">&#x27;Python&#x27;</span>)</span><br><span class="line">    <span class="built_in">input</span>.send_keys(Keys.ENTER)</span><br><span class="line">    wait = WebDriverWait(browser,<span class="number">10</span>)</span><br><span class="line">    wait.until(EC.presence_of_element_located((By.ID,<span class="string">&#x27;content_left&#x27;</span>)))</span><br><span class="line">    <span class="built_in">print</span>(browser.current_url)</span><br><span class="line">    <span class="built_in">print</span>(browser.get_cookies())</span><br><span class="line">    <span class="built_in">print</span>(browser.page_source)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    browser.close()</span><br></pre></td></tr></table></figure>

<h3 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.PhantomjS()</span><br><span class="line">browser = webdriver.Safari()</span><br></pre></td></tr></table></figure>

<h3 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h3><p>get方法访问百度</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">&#x27;https://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(browser.page_source)	<span class="comment">#打印网站源码</span></span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><p>获取单个节点方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element_by_id</span><br><span class="line">find_element_by_name</span><br><span class="line">find_element_by_xpath</span><br><span class="line">find_element_by_link_text</span><br><span class="line">find_element_by_partial_link_text</span><br><span class="line">find element_by_tag_name</span><br><span class="line">find_element_by_class_name</span><br><span class="line">find_element_by_css_selector</span><br></pre></td></tr></table></figure>
<p>通用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element(By.ID,<span class="built_in">id</span>) 等价 find_element_by_id(<span class="built_in">id</span>) <span class="comment">#功能一致，但参数更灵活</span></span><br></pre></td></tr></table></figure>
<p>多个节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_elements(By.ID,<span class="built_in">id</span>)	<span class="comment">#比起通用方法多一个‘s’</span></span><br><span class="line"></span><br><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">&#x27;.service-bd li&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#方法函数</span></span><br><span class="line">find_elements_by_id</span><br><span class="line">find elements_by_name</span><br><span class="line">find elements_by_xpath</span><br><span class="line">find_elements_by_link_text</span><br><span class="line">find_elements_by_partial_link_text</span><br><span class="line">find_elements_by_tag_name</span><br><span class="line">find_elements_by_class_name</span><br><span class="line">find_elements_by_css_selector</span><br></pre></td></tr></table></figure>

<h3 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">send_keys()	<span class="comment">#输入文字</span></span><br><span class="line">clear()	<span class="comment">#清空文字</span></span><br><span class="line">click()	<span class="comment">#点击按</span></span><br></pre></td></tr></table></figure>

<h3 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h3><p>例如：鼠标拖拽、键盘按钮等</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url =<span class="string">&#x27;http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">a = browser.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>) <span class="comment">#切换进frame中</span></span><br><span class="line">source =browser.find_element(by=By.CSS_SELECTOR, value=<span class="string">&#x27;#draggable&#x27;</span>)</span><br><span class="line">target =browser.find_element(by=By.CSS_SELECTOR, value=<span class="string">&#x27;#droppable&#x27;</span>)</span><br><span class="line">actions =ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source,target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure>
<p><a href="https://python-selenium-zh.readthedocs.io/zh_CN/latest/">selenium + python 中文文档</a></p>
<h3 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h3><p>当我们获取文档源码，我们可以通过解析库（如正则表达），但如果返回的是webelement类型，我们可以直接调用其信息</p>
<ul>
<li><p>获取属性</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url =<span class="string">&#x27;网站&#x27;</span></span><br><span class="line">browser.get(url)</span><br><span class="line">logo = browser.find_element(by=By.ID,value=<span class="string">&#x27;目标ID&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(logo)</span><br><span class="line"><span class="built_in">print</span>(logo.get_attributu(<span class="string">&#x27;class&#x27;</span>))	<span class="comment">#使用get_attributu获取目标属性</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取文本值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">(logo.test)	<span class="comment">#续上文，假设logo含有文本，如此即可</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="切换frame"><a href="#切换frame" class="headerlink" title="切换frame"></a>切换frame</h3><p>相当于页面的子页面。结构与外部网页结构完全一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">xxx（你的webdriver对象）.switch_to.frame(<span class="string">&#x27;iframeResult&#x27;</span>)	<span class="comment">#使用switch_to.frame方法切换frame</span></span><br></pre></td></tr></table></figure>

<h3 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h3><ul>
<li>隐式等待</li>
</ul>
<p>如果没有在DOM则继续等待，超出设定时间后抛出找不到节点异常</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)	<span class="comment">#隐式等待10秒</span></span><br><span class="line">browser.get(<span class="string">&#x27;https://www.zhihu.com/explore&#x27;</span>)</span><br><span class="line"><span class="built_in">input</span> browser.find_element_by_class_name(<span class="string">&#x27;zu-top-add-question&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">input</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>显式等待</li>
</ul>
<p>隐式等待只设定了一个固定时间，而显式等待可以指定要查找的节点[待补全]</p>
<h3 id="前进和后退"><a href="#前进和后退" class="headerlink" title="前进和后退"></a>前进和后退</h3><p>back()方法后退，forward()方法前进[待补全]</p>
<h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>selenium可以对cookies进行操作，例如获取、添加、删除等[待补全]</p>
<h3 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h3><p>selenium可以对浏览器的选项卡进行操作[待补全]</p>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>try…except常用来捕获各种异常。可以保证程序不会中断[待补全]</p>
<h2 id="Splash"><a href="#Splash" class="headerlink" title="Splash"></a>Splash</h2><p>splash是一个JavaScript渲染服务。同样可以实现对动态渲染页面的抓取</p>
<p>功能介绍</p>
<ul>
<li>异步方式处理多个网页渲染过程；</li>
<li>获取渲染后的页面的源代码或截图：</li>
<li>通过关闭图片渲染或者使用Adblock规则来加快页面渲染速度：</li>
<li>可执行特定的JavaScript脚本；</li>
<li>可通过Lua脚本来控制页面渲染过程；</li>
<li>获取渲染的详细过程并通过HAR(HTTP Archive)格式呈现。</li>
</ul>
<h2 id="Splash-负载均衡配置"><a href="#Splash-负载均衡配置" class="headerlink" title="Splash 负载均衡配置"></a>Splash 负载均衡配置</h2><p>可以搭建已给负载均衡器将压力分散到各个服务器上</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>基本库的使用</title>
    <url>/2022/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E5%9F%BA%E6%9C%AC%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>并不需要了解各种HTTP、TCP等等原理。Python拥有强大的库支持</p>
<h2 id="1-使用urllib"><a href="#1-使用urllib" class="headerlink" title="1 使用urllib"></a>1 使用urllib</h2><p>Python3中库名统一为【urllib】官方文档地址：<a href="https://docs.python.org/3/library/urllib.html">https://docs.python.org/3/library/urllib.html</a></p>
<ul>
<li>四个主要模块</li>
</ul>
<ol>
<li>request:它是最基本的HTTP请求模块，可以用来模拟发送请求。就像在浏览器里输入网址然后回车一样，只需要给库方法传入URL以及额外的参数，就可以模拟实现这个过程了</li>
<li>error：异常处理模块，如果出现请求错误，我们可以捕获这些异常，然后进行重试或其他操作以保证程序不会意外终止。</li>
<li>parse:一个工具模块，提供了许多URL处理方法，比如拆分、解析、合并</li>
<li>robotparser:主要是用来识别网站的robots.txt文件，然后判断哪些网站可以爬，哪些网站不可以爬，它其实用得比较少。</li>
</ol>
<h3 id="1-1-发送请求"><a href="#1-1-发送请求" class="headerlink" title="1.1 发送请求"></a>1.1 发送请求</h3><h4 id="1-1-1-URLopen"><a href="#1-1-1-URLopen" class="headerlink" title="1.1.1 URLopen()"></a>1.1.1 URLopen()</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&#x27;https://www.python.org&#x27;)</span><br><span class="line">print(response.read())	#抓取并输出文本</span><br><span class="line"></span><br><span class="line">print(type(response))</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&lt;class <span class="string">&#x27;http.client.HTTPResponse&#x27;</span>&gt;</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">抓取的网页是一个HTTPResposne类型的对象，主要包含<span class="built_in">read</span>()、readinto()、getheader(name)getheaders()、fileno()等方法，以及msg、version、status、reason、debuglevel、closed等属性。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&#x27;https://www.python.org&#x27;)</span><br><span class="line">print(response.status)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;200</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">状态值</span></span><br><span class="line"></span><br><span class="line">print(response.getheaders())</span><br><span class="line"></span><br><span class="line">print(response.getheader(&#x27;Server&#x27;))</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; nginx</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">服务器使用Nginx搭建</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import urllib.parse</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">data = bytes(urllib.parse.urlencode(&#123;&#x27;word&#x27;:&#x27;hello&#x27;&#125;),encoding=&#x27;utf-8&#x27;)</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">创建一个word参数，值为hello。使用urlencode:将参数字典转化为字符串，指定为utf8格式</span></span><br><span class="line">response = urllib.request.urlopen(&#x27;http://httpbin.org/post&#x27;,data=data)</span><br><span class="line">print(response.read())</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">response = urllib.request.urlopen(&#x27;http://httpbin.org/get&#x27;,timeout=1)</span><br><span class="line">print(response.read())</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">###################以上代码功能再实现_超时跳过抓取##################</span></span></span><br><span class="line">import socket</span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    response = urllib.request.urlopen(&#x27;http://httpbin.org/get&#x27;,timeout=0.1)</span><br><span class="line">except urllib.error.URLError as e:</span><br><span class="line">    if isinstance(e.reason,socket.timeout):</span><br><span class="line">        print(&#x27;TIME OUT&#x27;)</span><br></pre></td></tr></table></figure>
<p>其他参数：<a href="https://docs.python.org/3/library/urllib.request.html">https://docs.python.org/3/library/urllib.request.html</a></p>
<h4 id="1-1-2-request"><a href="#1-1-2-request" class="headerlink" title="1.1.2 request"></a>1.1.2 request</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用对象发送请求</span></span><br><span class="line"></span><br><span class="line">import urllib.request</span><br><span class="line"></span><br><span class="line">request = urllib.request.Request(&#x27;https://python.org&#x27;)</span><br><span class="line">response = urllib.request.urlopen(request)</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">request是一个对象。</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">参数结构：class urllib. request. Request ( ur 1, data=None, headers=&#123;&#125;, origin_req_host=None, unverifiable=False, method=None)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">带参数请求</span></span><br><span class="line"></span><br><span class="line">from urllib import request,parse</span><br><span class="line"></span><br><span class="line">url = &#x27;http://httpbin.org/post&#x27;</span><br><span class="line">headers = &#123;</span><br><span class="line">    &#x27;User-Agent&#x27;:&#x27;Mozilla/4.0 (compatible;MSIE 5.5; Windows NT&#x27;,</span><br><span class="line">    &#x27;Host&#x27;:&#x27;httpbin.org&#x27;</span><br><span class="line">&#125;</span><br><span class="line">dict = &#123;</span><br><span class="line">    &#x27;name&#x27;:&#x27;Germey&#x27;</span><br><span class="line">&#125;</span><br><span class="line">data = bytes(parse.urlencode(dict),encoding=&#x27;utf8&#x27;)</span><br><span class="line">req = request.Request(url=url,data=data,headers=headers,method=&#x27;POST&#x27;)</span><br><span class="line">response = request.urlopen(req)</span><br><span class="line">print(response.read().decode(&#x27;utf-8&#x27;))</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数URL用于请求URL,这是必传参数，其他都是可选参数。</li>
<li>第二个参数data如果要传，必须传bytes(字节流)类型的。如果它是字典，可以先用urllib.parse模块里的urlencode()编码。</li>
<li>第三个参数headers是一个字典，它就是请求头，我们可以在构造请求时通过headers参数直接构造，也可以通过调用请求实例的add header()方法添加。</li>
<li>添加请求头最常用的用法就是通过修改User-Agent来伪装浏览器，默认的User-Agent是</li>
<li>Python-urllib,我们可以通过修改它来伪装浏览器。比如要伪装火狐浏览器，你可以把它设置为：</li>
<li>Mozilla&#x2F;5.0 (X11;U;Linux i686)Gecko&#x2F;20071127 Firefox&#x2F;2.0.0.11</li>
<li>第四个参数origin_req_host指的是请求方的host名称或者IP地址。</li>
<li>第五个参数unverifiable表示这个请求是否是无法验证的，默认是False,意思就是说用户没有足够权限来选择接收这个请求的结果。例如，我们请求一个HTML文档中的图片，但是我们没有自动抓取图像的权限，这时unverifiable的值就是True。</li>
<li>第六个参数method是一个字符串，用来指示请求使用的方法，比如GET、POST和PUT等。</li>
</ul>
<h4 id="1-1-3-高级用法"><a href="#1-1-3-高级用法" class="headerlink" title="1.1.3 高级用法"></a>1.1.3 高级用法</h4><p>handler可以处理登陆验证、代理、cookies</p>
<ul>
<li>HTTPdefaulterrorhandler：用于处理HTTP响应错误</li>
</ul>
<p>HTTPredirecthandler：用于处理重定向</p>
<ul>
<li><p>HTTPcookieprocessor：用于处理cookies</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import http.cookiejar,urllib.request</span><br><span class="line">cookie = http.cookiejar.CookieJar()</span><br><span class="line">handler = urllib.request.HTTPCookieProcessor(cookie)</span><br><span class="line">opener = urllib.request.build_opener(handler)</span><br><span class="line">response = opener.open(&#x27;http://www.baidu.com&#x27;)</span><br><span class="line">for item in cookie:</span><br><span class="line">    print(item.name+&quot;=&quot;+item.value)</span><br><span class="line">cooker.save(</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取网页的cookies</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>proxyhandler：用于设置代理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">from urllib.error import URLError</span><br><span class="line">from urllib.request import ProxyHandler,build_opener</span><br><span class="line"></span><br><span class="line">proxy_handler = ProxyHandler(&#123;</span><br><span class="line">    &#x27;http&#x27;:&#x27;http:/127.0.0.1:9743&#x27;,</span><br><span class="line">    &#x27;https&#x27;:&#x27;https://127.0.0.1:9743&#x27;</span><br><span class="line">&#125;)</span><br><span class="line">opener = build_opener(proxy_handler)</span><br><span class="line">try:</span><br><span class="line">    response = opener.open(&#x27;https://www.baidu.com&#x27;)</span><br><span class="line">    print(response.read().decode(&#x27;utf-8&#x27;))</span><br><span class="line">except URLError as e:</span><br><span class="line">    print(e.reason)</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用本地的9743端口的代理</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">proxy_handler字典对应的是协议及协议对应使用的代理</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>HTTPpasswordmgr：用于管理密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">from urllib.request import HTTPPasswordMgrWithDefaultRealm,HTTPBasicAuthHandler,build_opener</span><br><span class="line">from urllib.error import URLError</span><br><span class="line">username = &#x27;username&#x27;</span><br><span class="line">password =&#x27;password&#x27;</span><br><span class="line">url = &#x27;http://localhost:5000/&#x27;</span><br><span class="line">p = HTTPPasswordMgrWithDefaultRealm()</span><br><span class="line">p.add_password(None,url,username,password)</span><br><span class="line">auth_handler = HTTPBasicAuthHandler(p)</span><br><span class="line">opener = build_opener(auth_handler)</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    result = opener.open(url)</span><br><span class="line">    html = result.read().decode(&#x27;utf-8&#x27;)</span><br><span class="line">    print(html)</span><br><span class="line">except URLError as e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure>
<p>HTTPbasicauthhandler：用于管理认证</p>
</li>
</ul>
<p>官方文档：<a href="https://docs.python.org/3/library/urllib.request.html">https://docs.python.org/3/library/urllib.request.html</a></p>
<h3 id="1-2-处理异常"><a href="#1-2-处理异常" class="headerlink" title="1.2 处理异常"></a>1.2 处理异常</h3><h4 id="1-2-1-URLerror"><a href="#1-2-1-URLerror" class="headerlink" title="1.2.1 URLerror"></a>1.2.1 URLerror</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">from urllib import request,error</span><br><span class="line">try:</span><br><span class="line">    response = request.urlopen(&#x27;https://cuiqingcai.com/index.htm&#x27;)</span><br><span class="line">except error.URLError as e:</span><br><span class="line">    print(e.reason)</span><br></pre></td></tr></table></figure>
<p>程序对本该发生错误中止的内容进行了“not found”输入。然后继续执行下一步，而非原先中止程序</p>
<h4 id="1-2-2-HTTPerror"><a href="#1-2-2-HTTPerror" class="headerlink" title="1.2.2 HTTPerror"></a>1.2.2 HTTPerror</h4><p>专门处理HTTP请求错误</p>
<h3 id="1-3-解析链接"><a href="#1-3-解析链接" class="headerlink" title="1.3 解析链接"></a>1.3 解析链接</h3><h4 id="主要是对链接的进行处理，可以重构请求，可以解析请求"><a href="#主要是对链接的进行处理，可以重构请求，可以解析请求" class="headerlink" title="主要是对链接的进行处理，可以重构请求，可以解析请求"></a>主要是对链接的进行处理，可以重构请求，可以解析请求</h4><h3 id="1-4-分析Robots协议"><a href="#1-4-分析Robots协议" class="headerlink" title="1.4 分析Robots协议"></a>1.4 分析Robots协议</h3><p>robots即机器人协议、爬虫协议。用于规定爬虫许可爬取的范围</p>
<p>可用robotparser进行解析</p>
<h2 id="2-使用requests"><a href="#2-使用requests" class="headerlink" title="2 使用requests"></a>2 使用requests</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">r = requests.get(&#x27;https://www.baidu.com/&#x27;)</span><br><span class="line">print(type(r))</span><br><span class="line">print(r.status_code)</span><br><span class="line">print(r.text)</span><br><span class="line">print(r.cookies)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;class <span class="string">&#x27;requests.models.Response&#x27;</span>&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">200</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;<span class="built_in">head</span>&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-equiv=X-UA-Compatible content=IE=Edge&gt;&lt;meta content=always name=referrer&gt;&lt;<span class="built_in">link</span> rel=stylesheet <span class="built_in">type</span>=text/css href=https://ss1.bdstatic.com/5eN1bjq8AAUYm2zgoY3K/r/www/cache/bdorz/baidu.min.css&gt;&lt;title&gt;ç¾åº¦ä¸ä¸ï¼ä½ å°±ç¥é&lt;/title&gt;&lt;/head&gt; &lt;body <span class="built_in">link</span>=<span class="comment">#0000cc&gt; &lt;div id=wrapper&gt; &lt;div id=head&gt; &lt;div class=head_wrapper&gt; &lt;div class=s_form&gt; &lt;div class=s_form_wrapper&gt; &lt;div id=lg&gt; &lt;img hidefocus=true src=//www.baidu.com/img/bd_logo1.png width=270 height=129&gt; &lt;/div&gt; &lt;form id=form name=f action=//www.baidu.com/s class=fm&gt; &lt;input type=hidden name=bdorz_come value=1&gt; &lt;input type=hidden name=ie value=utf-8&gt; &lt;input type=hidden name=f value=8&gt; &lt;input type=hidden name=rsv_bp value=1&gt; &lt;input type=hidden name=rsv_idx value=1&gt; &lt;input type=hidden name=tn value=baidu&gt;&lt;span class=&quot;bg s_ipt_wr&quot;&gt;&lt;input id=kw name=wd class=s_ipt value maxlength=255 autocomplete=off autofocus=autofocus&gt;&lt;/span&gt;&lt;span class=&quot;bg s_btn_wr&quot;&gt;&lt;input type=submit id=su value=ç¾åº¦ä¸ä¸ class=&quot;bg s_btn&quot; autofocus&gt;&lt;/span&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div id=u1&gt; &lt;a href=http://news.baidu.com name=tj_trnews class=mnav&gt;æ°é»&lt;/a&gt; &lt;a href=https://www.hao123.com name=tj_trhao123 class=mnav&gt;hao123&lt;/a&gt; &lt;a href=http://map.baidu.com name=tj_trmap class=mnav&gt;å°å¾&lt;/a&gt; &lt;a href=http://v.baidu.com name=tj_trvideo class=mnav&gt;è§é¢&lt;/a&gt; &lt;a href=http://tieba.baidu.com name=tj_trtieba class=mnav&gt;è´´å§&lt;/a&gt; &lt;noscript&gt; &lt;a href=http://www.baidu.com/bdorz/login.gif?login&amp;amp;tpl=mn&amp;amp;u=http%3A%2F%2Fwww.baidu.com%2f%3fbdorz_come%3d1 name=tj_login class=lb&gt;ç»å½&lt;/a&gt; &lt;/noscript&gt; &lt;script&gt;document.write(&#x27;&lt;a href=&quot;http://www.baidu.com/bdorz/login.gif?login&amp;tpl=mn&amp;u=&#x27;+ encodeURIComponent(window.location.href+ (window.location.search === &quot;&quot; ? &quot;?&quot; : &quot;&amp;&quot;)+ &quot;bdorz_come=1&quot;)+ &#x27;&quot; name=&quot;tj_login&quot; class=&quot;lb&quot;&gt;ç»å½&lt;/a&gt;&#x27;);</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">                &lt;/script&gt; &lt;a href=//www.baidu.com/more/ name=tj_briicon class=bri style=<span class="string">&quot;display: block;&quot;</span>&gt;æ´å¤äº§å&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div <span class="built_in">id</span>=ftCon&gt; &lt;div <span class="built_in">id</span>=ftConw&gt; &lt;p <span class="built_in">id</span>=lh&gt; &lt;a href=http://home.baidu.com&gt;å³äºç¾åº¦&lt;/a&gt; &lt;a href=http://ir.baidu.com&gt;About Baidu&lt;/a&gt; &lt;/p&gt; &lt;p <span class="built_in">id</span>=<span class="built_in">cp</span>&gt;&amp;copy;2017&amp;nbsp;Baidu&amp;nbsp;&lt;a href=http://www.baidu.com/duty/&gt;ä½¿ç¨ç¾åº¦åå¿è¯»&lt;/a&gt;&amp;nbsp; &lt;a href=http://jianyi.baidu.com/ class=cp-feedback&gt;æè§åé¦&lt;/a&gt;&amp;nbsp;äº¬ICPè¯030173å·&amp;nbsp; &lt;img src=//www.baidu.com/img/gs.gif&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># &lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;</span></span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-1-get请求"><a href="#2-2-1-get请求" class="headerlink" title="2.2.1 get请求"></a>2.2.1 get请求</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">data = &#123;</span><br><span class="line">    &#x27;name&#x27;:&#x27;germey&#x27;,</span><br><span class="line">    &#x27;age&#x27;:22</span><br><span class="line">&#125;</span><br><span class="line">r = requests.get(&#x27;http://www.httpbin.org/get&#x27;,params=data)</span><br><span class="line">print(r.text)</span><br><span class="line">print(r.json())	#该语句可以将网页返回的&#x27;str&#x27;类型直接转换成&#x27;字典&#x27;格式</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以上语句 等价 http://www.httpbin.org/get?age=22&amp;name=germey</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>抓取网页</p>
</li>
<li><p>抓取二进制数据</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">r = requests.get(&quot;https://github.com/favicon.ico&quot;)</span><br><span class="line">with open(&#x27;favicon.ico&#x27;,&#x27;wb&#x27;) as f:</span><br><span class="line">    f.write(r.content)</span><br><span class="line">    </span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">图片、音频、视频本质都是由二进制组成。所以要用<span class="string">&#x27;wb&#x27;</span>以二进制写的形式打开</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-2-2-POST请求"><a href="#2-2-2-POST请求" class="headerlink" title="2.2.2 POST请求"></a>2.2.2 POST请求</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">data = &#123;&#x27;name&#x27;:&#x27;germey&#x27;,&#x27;age&#x27;:&#x27;22&#x27;&#125;</span><br><span class="line">r = requests.post(&quot;http://httpbin.org/post&quot;,data=data)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-高级用法"><a href="#2-2-高级用法" class="headerlink" title="2.2 高级用法"></a>2.2 高级用法</h3><h4 id="2-2-1-文件上传"><a href="#2-2-1-文件上传" class="headerlink" title="2.2.1 文件上传"></a>2.2.1 文件上传</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">files =&#123;&#x27;file&#x27;:open(&#x27;favicon.ico&#x27;,&#x27;rb&#x27;)&#125;</span><br><span class="line">r=requests.post(&quot;http://httpbin.org/post&quot;,files=files)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<h4 id="2-2-2-cookies"><a href="#2-2-2-cookies" class="headerlink" title="2.2.2 cookies"></a>2.2.2 cookies</h4><h4 id="2-2-3-会话维持"><a href="#2-2-3-会话维持" class="headerlink" title="2.2.3 会话维持"></a>2.2.3 会话维持</h4><p>利用session</p>
<h4 id="2-2-4-SSL证书验证"><a href="#2-2-4-SSL证书验证" class="headerlink" title="2.2.4 SSL证书验证"></a>2.2.4 SSL证书验证</h4><h4 id="2-2-5-代理设置"><a href="#2-2-5-代理设置" class="headerlink" title="2.2.5 代理设置"></a>2.2.5 代理设置</h4><h4 id="2-2-6-超时设置"><a href="#2-2-6-超时设置" class="headerlink" title="2.2.6 超时设置"></a>2.2.6 超时设置</h4><h4 id="2-2-7-身份认证"><a href="#2-2-7-身份认证" class="headerlink" title="2.2.7 身份认证"></a>2.2.7 身份认证</h4><h2 id="3-正则表达式"><a href="#3-正则表达式" class="headerlink" title="3 正则表达式"></a>3 正则表达式</h2><h3 id="3-1-match"><a href="#3-1-match" class="headerlink" title="3.1 match()"></a>3.1 match()</h3><p>match()方法会尝试从字符串的起始位置匹配正则表达式，如果匹配，就返回匹配成功的结果；如果不匹配，就返回None。示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">content = <span class="string">&#x27;Hello 123 4567 World_This is a Regex Demo&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(content))</span><br><span class="line">result = re.<span class="keyword">match</span>(<span class="string">&#x27;^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;&#x27;</span>,content)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result.group())</span><br><span class="line"><span class="built_in">print</span>(result.span())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 41</span></span><br><span class="line"><span class="comment"># &lt;re.Match object; span=(0, 25), match=&#x27;Hello 123 4567 World_This&#x27;&gt;</span></span><br><span class="line"><span class="comment"># Hello 123 4567 World_This</span></span><br><span class="line"><span class="comment"># (0, 25)</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>数据存储</title>
    <url>/2022/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><p>txtjsoncsv</p>
<h2 id="关系型数据库存储"><a href="#关系型数据库存储" class="headerlink" title="关系型数据库存储"></a>关系型数据库存储</h2><p>MySQL</p>
<h2 id="非关系型数据库存储"><a href="#非关系型数据库存储" class="headerlink" title="非关系型数据库存储"></a>非关系型数据库存储</h2><p>MongoDBRedis</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫基本原理</title>
    <url>/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="1-爬虫概述"><a href="#1-爬虫概述" class="headerlink" title="1 爬虫概述"></a>1 爬虫概述</h1><p>爬虫：获取玩个并提取和保存信息的自动化程序</p>
<ol>
<li>获取网页</li>
<li>提取信息</li>
</ol>
<p>最通用的方法即【正则表达式】，也是一个万能的方法</p>
<ol start="3">
<li>保存数据</li>
<li>自动化程序</li>
</ol>
<p>重要的是自动处理运行过程中的各种异常处理、错误重试等</p>
<h1 id="2-能抓怎样的数据"><a href="#2-能抓怎样的数据" class="headerlink" title="2 能抓怎样的数据"></a>2 能抓怎样的数据</h1><p>最常规的即HTML源代码，有些网站使用json字符串（API接口常用）二进制图片等</p>
<h1 id="3-JavaScript渲染页面"><a href="#3-JavaScript渲染页面" class="headerlink" title="3 JavaScript渲染页面"></a>3 JavaScript渲染页面</h1><p>现在很多网站都是Javascript渲染出来的，原始网站仅仅是一个空壳</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">&lt;title&gt;This is a Demo&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id=&quot;container&quot;&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;script src=&quot;app.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>这个网站会请求app.js文件，然后运行JavaScript代码，代码会改变HTML节点，添加内容，得到完整的网站</p>
<h1 id="4-会话和cookies"><a href="#4-会话和cookies" class="headerlink" title="4 会话和cookies"></a>4 会话和cookies</h1><p>在浏览网站的过程中，我们经常会遇到需要登录的情况，有些页面只有登录之后才可以访问，而且登录之后可以连续访问很多次网站，但是有时候过一段时间就需要重新登。有一些网站，在打开浏览器时就自动登录了，而且很长时间都不会失效，这种情况又是什么？其实这里面涉及会话Session)和Cookies的相关知识，</p>
<ol>
<li>静态网页和动态网页</li>
</ol>
<p>静态网页速度快，编写简单。但是不利于维护，也不能程序例如使用Python等开发的动态网站，灵活的变动内容</p>
<ol start="2">
<li>无状态HTTP</li>
</ol>
<p>无状态也就是HTTP对客户端发送完状态后，不会自行记录。导致后续要继续使用到这个状态里的信息又要重新传送</p>
<p>会话和cookies就是为了解决这个问题。会话（服务器端）：保存用户的会话信息cookies（客户端）：下次访问网页会带上它发给服务器</p>
<p>cookies属性结构浏览器开发工具【Application】左侧storage最后一项就是cookies</p>
<p>关闭浏览器不会清空cookies，这个是服务器设置的失效时间。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫基础</title>
    <url>/2022/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<ol>
<li>HTTP基本原理</li>
</ol>
<p>从浏览框敲入URL到获取网页内容发生了什么</p>
<p>1.1 URI和URLURI（统一资源标志符）URL（统一资源定位符）URN（统一资源名称）：仅命名资源而不定位 | 用的很少</p>
<p>URI包含URL和URN但又因为URN用的少，所以几乎所有的URI&#x3D;&#x3D;URL</p>
<p>1.2 超文本即HTML代码。包含标签信息</p>
<p>1.3 HTTP和HTTPSHTTPS即HTTP的安全办，增加了SSL层</p>
<p>如要爬取HTTPS，需要设置忽略证书的选项，否则会提示SSL链接错误</p>
<p>1.4 HTTP请求过程请求——&gt;响应</p>
<p>浏览器的network可以查看第一列 Name ：请求的名称，一般会将 URL 最后一部分内容当作名称 第二列 Status ：响应的状态码，这里显示为 200 代表响应是正常的 通过状态码，我们可 以判断发送了请求之后是杏得到了正常的响应 第三列 Type： 请求的文梢类型 这里为 document ，代表我们这次请求的是 HTML 文档， 内容就是一些 HTML 代码 第四列 Initiator： 请求源 用来标记请求是由哪个对象或进程发起的 第五列 Size： 从服务器下载的文件和请求的资源大小 如果是从缓存中取得的资源，则该列会显示from cache 第六列 Time：发起请求到获取响应所用的总时间 第七列 Waterfall：网络请求的可视化瀑布流</p>
<p>1.5 请求</p>
<ol>
<li>请求方法</li>
</ol>
<p>常见请求方法：GET和POSTGET和POST请求方法有如下区别。</p>
<ol>
<li><p>GET请求中的参数包含在URL里面，数据可以在URL中看到，而POST请求的URL不会包含这些数据，数据都是通过表单形式传输的，会包含在请求体中。</p>
</li>
<li><p>GET请求提交的数据最多只有1024字节，而POST方式没有限制。</p>
</li>
<li><p>POST以表单形式发送数据</p>
</li>
<li><p>请求的网址</p>
</li>
</ol>
<p>即URL</p>
<ol start="3">
<li>请求头</li>
</ol>
<p>用于说明服务器要使用的附加信息，cookie、referer、user-agent</p>
<ol start="4">
<li>请求体</li>
</ol>
<p>请求体一般承载的内容是POST请求中的表单数据，而对于GET请求，请求体则为空。</p>
<p>1.6 响应响应，由服务端返回给客户端，可以分为三部分：响应状态码(Response Status Code)、响应头(Response Headers)和响应体(Response Body)。</p>
<ol>
<li>响应状态码</li>
</ol>
<p>即200代表正常，404未找到这一类</p>
<ol start="2">
<li>响应头</li>
</ol>
<p>响应头包含了服务器对请求的应答信息，如Content–Type、Server、Set-Cookie等。下面简要说明一些常用的头信息。</p>
<ol start="3">
<li>响应体</li>
</ol>
<p>最重要的当属响应体的内容了。响应的正文数据都在响应体中，比如请求网页时，它的响应体就是网页的HTML码：请求一张图片时，它的响应体就是图片的二进制数据。我们做爬虫请求网页后，要解析的内容就是响应体</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>解析库的使用</title>
    <url>/2022/07/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E8%A7%A3%E6%9E%90%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>用于定位网页的各个节点</p>
<h2 id="1-使用XPath"><a href="#1-使用XPath" class="headerlink" title="1 使用XPath"></a>1 使用XPath</h2><p>即XML路径语言。也是一类编程语言</p>
<h2 id="2-使用beadutiful-soup"><a href="#2-使用beadutiful-soup" class="headerlink" title="2 使用beadutiful soup"></a>2 使用beadutiful soup</h2><p>借助网页的结构和属性等特征来解析网页</p>
<ul>
<li>基本用法<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html =<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line"><span class="string">&lt;body&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;title&quot;name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters;and their names were</span></span><br><span class="line"><span class="string">&lt;a href-&quot;http://example.com/elsie&quot;class=&quot;sister&quot;id-&quot;link1&quot;&gt;&lt;!--Elsie --&gt;&lt;/a&gt;,</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/lacie&quot;class=&quot;sister&quot;id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;and</span></span><br><span class="line"><span class="string">&lt;a href=&quot;http://example.com/tillie&quot;class=&quot;sister&quot;id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;</span></span><br><span class="line"><span class="string">and they lived at the bottom of a well.&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">soup = BeautifulSoup(html,<span class="string">&#x27;lxml&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(soup.prettify())</span><br><span class="line"><span class="built_in">print</span>(soup.title.string)</span><br><span class="line"></span><br><span class="line"><span class="comment">#prettify()对要解析的字符串以标准的缩进格式进行了输出</span></span><br><span class="line"><span class="comment">#这段代码对html字符串进行了重构成标准HTML语言</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.title)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(soup.title))</span><br><span class="line"><span class="built_in">print</span>(soup.title.string)</span><br><span class="line"><span class="built_in">print</span>(soup.head)</span><br><span class="line"><span class="built_in">print</span>(soup.p)</span><br><span class="line"><span class="comment">#这段是节点选择器</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.title.name)	<span class="comment">#获取名称</span></span><br><span class="line"><span class="built_in">print</span>(soup.p.attrs)	<span class="comment">#多属性的获取</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(soup.p[<span class="string">&#x27;name&#x27;</span>])	<span class="comment">#属性的获取</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-使用pyquery"><a href="#3-使用pyquery" class="headerlink" title="3 使用pyquery"></a>3 使用pyquery</h2><p>倾向于CSS选择器的解析库</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫开发环境配置</title>
    <url>/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E7%88%AC%E8%99%AB%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-Python3"><a href="#1-Python3" class="headerlink" title="1 Python3"></a>1 Python3</h2><p><a href="https://www.python.org/downloads/">https://www.python.org/downloads/</a></p>
<h3 id="1-2-Anaconda"><a href="#1-2-Anaconda" class="headerlink" title="1.2 Anaconda"></a>1.2 Anaconda</h3><p><a href="https://www.anaconda.com/products/distribution">https://www.anaconda.com/products/distribution</a></p>
<h2 id="2-请求库的安装"><a href="#2-请求库的安装" class="headerlink" title="2 请求库的安装"></a>2 请求库的安装</h2><p>爬虫可以简单分为几步：抓取页面、分析页面和存储数据。在抓取页面的过程中，我们需要模拟浏览器向服务器发出请求，所以需要用到一些Pythor库来实现HTTP请求操作。</p>
<h2 id="2-1-requests的安装"><a href="#2-1-requests的安装" class="headerlink" title="2.1 requests的安装"></a>2.1 requests的安装</h2><h2 id="2-2-selenium的安装"><a href="#2-2-selenium的安装" class="headerlink" title="2.2 selenium的安装"></a>2.2 selenium的安装</h2><p>Selenium是一个自动化测试工具，利用它我们可以驱动浏览器执行特定的动作，如点击、下拉等操作。对于一些JavaScript渲染的页面来说，这种抓取方式非常有效。</p>
<h2 id="2-3-Chromedriver的安装"><a href="#2-3-Chromedriver的安装" class="headerlink" title="2.3 Chromedriver的安装"></a>2.3 Chromedriver的安装</h2><p>前面我们成功安装好了Selenium库，但是它是一个自动化测试工具，需要浏览器来配合使用，本节中我们就介绍一下Chrome浏览器及ChromeDriver驱动的配置。</p>
<h2 id="2-4-geckodriver的安装"><a href="#2-4-geckodriver的安装" class="headerlink" title="2.4 geckodriver的安装"></a>2.4 geckodriver的安装</h2><p>上一节中，我们了解了ChromeDriver的配置方法，配置完成之后便可以用Selenium驱动Chrome浏览器来做相应网页的抓取。那么对于Firefox来说，也可以使用同样的方式完成Selenium的对接，这时需要安装另一个驱动GeckoDriver.</p>
<h2 id="2-4-phantomjs的安装"><a href="#2-4-phantomjs的安装" class="headerlink" title="2.4 phantomjs的安装"></a>2.4 phantomjs的安装</h2><p>PhantomJS是一个无界面的、可脚本编程的WebKit浏览器引擎，它原生支持多种Web标准：DOM操作、CSS选择器、JSON、Canvas以及SVG。Selenium支持PhantomJS,这样在运行的时候就不会再弹出一个浏览器了。而且hantomJS的运行效率也很高，还支持各种参数配置，使用非常方便。</p>
<h2 id="3-解析库的安装"><a href="#3-解析库的安装" class="headerlink" title="3 解析库的安装"></a>3 解析库的安装</h2><h2 id="4-数据库安装"><a href="#4-数据库安装" class="headerlink" title="4 数据库安装"></a>4 数据库安装</h2><h2 id="5-存储库安装"><a href="#5-存储库安装" class="headerlink" title="5 存储库安装"></a>5 存储库安装</h2><h2 id="6-web库安装"><a href="#6-web库安装" class="headerlink" title="6 web库安装"></a>6 web库安装</h2><h2 id="7-App爬取相关库安装"><a href="#7-App爬取相关库安装" class="headerlink" title="7 App爬取相关库安装"></a>7 App爬取相关库安装</h2><h2 id="8-爬虫框架安装"><a href="#8-爬虫框架安装" class="headerlink" title="8 爬虫框架安装"></a>8 爬虫框架安装</h2><h2 id="9-部署相关库的安装"><a href="#9-部署相关库的安装" class="headerlink" title="9 部署相关库的安装"></a>9 部署相关库的安装</h2>]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>验证码的识别</title>
    <url>/2022/07/26/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E9%AA%8C%E8%AF%81%E7%A0%81%E7%9A%84%E8%AF%86%E5%88%AB/</url>
    <content><![CDATA[<h2 id="图形验证码识别"><a href="#图形验证码识别" class="headerlink" title="图形验证码识别"></a>图形验证码识别</h2><p>[待补充]</p>
<h2 id="急验滑动验证码识别"><a href="#急验滑动验证码识别" class="headerlink" title="急验滑动验证码识别"></a>急验滑动验证码识别</h2><p>[待补充]</p>
<h2 id="点触验证码识别"><a href="#点触验证码识别" class="headerlink" title="点触验证码识别"></a>点触验证码识别</h2><p>[待补充]</p>
<h2 id="微博宫格验证码识别"><a href="#微博宫格验证码识别" class="headerlink" title="微博宫格验证码识别"></a>微博宫格验证码识别</h2><p>[待补充]</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
      </categories>
  </entry>
  <entry>
    <title>PVE服务器安装</title>
    <url>/2022/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/PVE/PVE%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h1><p><a href="https://www.proxmox.com/en/downloads">PVE镜像</a><a href="https://cn.ultraiso.net/">软碟通</a></p>
<h1 id="2-写入U盘"><a href="#2-写入U盘" class="headerlink" title="2. 写入U盘"></a>2. 写入U盘</h1><p> 插入U盘，使用UltralISO打开下载的ISO镜像，点击启动 &gt; 写入硬盘映像… &gt; 选择U盘 &gt; 选择写入方式为“<strong>RAW</strong>” &gt; 写入（<strong>UltralISO 打开时选用管理员账户</strong>）</p>
<h1 id="3-安装PVE"><a href="#3-安装PVE" class="headerlink" title="3. 安装PVE"></a>3. 安装PVE</h1><ol>
<li><p>插入PVE安装U盘，打开电脑从PVE安装U盘引导启动，选择“Install Proxmox VE”，按回车开始安装。</p>
</li>
<li><p>选择要安装的硬盘，单击“Options”可以选择硬盘格式或者安装到zfs RAID硬盘阵列，要提前准备好多块硬盘，完成后单击“Next”进入下一步。</p>
</li>
<li><p>输入root密码和电子邮件地址，单击“Next”。</p>
</li>
<li><p>选择管理接口，输入PVE节点的服务器域名、IP地址、子网掩码、网关和DNS服务器，如果电脑连到网络，后面的这些信息会自动获取，也可以自己改（<strong>如果后期需要远程管理或开启HTTPS，域名最好填写正确，否则后期还要修改</strong>）。</p>
<blockquote>
<p><strong>注意</strong>：PVE只有通过管理接口连接的网卡才能登录到PVE的管理界面，这跟EXSi不一样，EXSi配置好默认任何一个网卡都能访问管理界面，<strong>且管理口务必不要直通</strong>。<br>7.确认安装信息，点击“Install”开始安装，如果有不对的就点“Previous”回去修改。</p>
</blockquote>
</li>
<li><p>安装完成，单击“Reboot”，记得拔掉PVE安装U盘并更改启动项。</p>
</li>
<li><p>启动完成，界面上https开头的地址就是PVE的管理地址。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>系统服务</category>
        <category>PVE</category>
      </categories>
  </entry>
  <entry>
    <title>DzzOffice+onlyoffice安装</title>
    <url>/2022/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/Dzzoffice/DzzOffice+onlyoffice%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="1-安装docker"><a href="#1-安装docker" class="headerlink" title="1. 安装docker"></a>1. 安装docker</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install apt-transport-https ca-certificates  curl  gnupg-agent software-properties-common</span><br></pre></td></tr></table></figure>

<h1 id="2-docker部署dzzoffice-onlyoffice-mysql"><a href="#2-docker部署dzzoffice-onlyoffice-mysql" class="headerlink" title="2. docker部署dzzoffice+onlyoffice+mysql"></a>2. docker部署dzzoffice+onlyoffice+mysql</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull mysql:5.7.27 # 拉取数据库镜像 </span><br><span class="line">sudo docker run -d --name mysql -p 3308:3306 -e MYSQL_ROOT_PASSWORD=数据库密码 mysql:5.7.27 # 启动mysql数据库，由于该服务器还有其他数据库应用所有端口做了调整</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull imdevops/dzzoffice # 拉取dxxoffice镜像 </span><br><span class="line">sudo docker run -d --name dzzoffice -p 88:80 imdevops/dzzoffice:latest # 启动应用设置端口</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo docker pull onlyoffice/documentserver # 拉取onlyoffice镜像</span><br><span class="line">sudo docker run -i -t -d -p 9000:80 onlyoffice/documentserver # 启动应用设置端口</span><br></pre></td></tr></table></figure>

<h1 id="3-安装dzzoffice"><a href="#3-安装dzzoffice" class="headerlink" title="3. 安装dzzoffice"></a>3. 安装dzzoffice</h1><p>访问 http:&#x2F;&#x2F;你的IP地址:80&#x2F;dzzoffice 进行安装<img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204101939902.png#id=Cyb9v&originHeight=960&originWidth=1820&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="4-删除安装dzzoffice安装文件"><a href="#4-删除安装dzzoffice安装文件" class="headerlink" title="4. 删除安装dzzoffice安装文件"></a>4. 删除安装dzzoffice安装文件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf  /var/www/html/dzzoffice/install/index.php</span><br></pre></td></tr></table></figure>

<h1 id="5-连接onlyoffice"><a href="#5-连接onlyoffice" class="headerlink" title="5. 连接onlyoffice"></a>5. 连接onlyoffice</h1><p><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204101943157.png#id=dipur&originHeight=656&originWidth=1223&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>系统服务</category>
        <category>Dzziffice</category>
      </categories>
  </entry>
  <entry>
    <title>hexo</title>
    <url>/2022/02/18/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/hexo/hexo/</url>
    <content><![CDATA[<ol>
<li><p>install  nodejs  npm  Git yay</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S yay</span><br><span class="line">yay -S nodejs npm</span><br><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>station construction</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo init</span><br><span class="line">git clone https://github.com/zthxxx/hexo-theme-Wikitten.git themes/Wikitten</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#overwrite default page</span></span></span><br><span class="line">cp -rf themes/Wikitten/_source/* source/</span><br><span class="line">cp -rf themes/Wikitten/_scaffolds/* scaffolds/</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">#set profile</span></span></span><br><span class="line">cp -f themes/Wikitten/_config.yml.example themes/Wikitten/_config.yml</span><br><span class="line">vim themes/Wikitten/_config.yml</span><br></pre></td></tr></table></figure>
</li>
<li><p>yuque</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">YUQUE_TOKEN=&quot;$YUQUE_TOKEN&quot; yuque-hexo sync</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>系统服务</category>
        <category>hexo</category>
      </categories>
  </entry>
  <entry>
    <title>AMS云服务</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/%E4%BA%91%E6%9C%8D%E5%8A%A1/AMS%E4%BA%91%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p> 如果您希望使用命令行，请参阅 _AWS Command Line Interface 用户指南_中的以下教程：<a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-using-ec2.html">通过 AWS CLI 使用 Amazon EC2</a>。  </p>
<h3 id="密钥对"><a href="#密钥对" class="headerlink" title="密钥对"></a>密钥对</h3><p> AWS 使用公有密钥密码术来保护实例的登录信息。Linux 实例没有密码；您可以使用密钥对安全地登录您的实例。使用 SSH 登录时，您在启动实例时指定密钥对的名称，然后提供私有密钥。  </p>
<h2 id="连接到您的实例"><a href="#连接到您的实例" class="headerlink" title="连接到您的实例"></a>连接到您的实例</h2><p><strong>如果您的本地计算机操作系统是 Linux 或 macOS X</strong></p>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html">SSH 客户端</a> 				</li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/Connect-using-EC2-Instance-Connect.html">EC2 Instance Connect</a> 				</li>
<li><a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager.html">AWS Systems Manager 会话管理器</a></li>
</ul>
<p> 				</p>
<p><strong>如果您的本地计算机操作系统是 Windows</strong> 			 				 			</p>
<ul>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/putty.html">PuTTY</a> <ul>
<li><strong>转换你的私有密钥</strong></li>
</ul>
</li>
</ul>
<p> PuTTY 自身并不支持适用于 SSH 密钥的私有密钥格式。PuTTY 提供一种名为 PuTTYgen 的工具，该工具可以将密钥转换为 PuTTY 所需的格式。您必须如下所示将私有密钥（.pem 文件）转换为此格式（.ppk 文件），以便使用 PuTTY 连接到您的实例。  </p>
<ol>
<li>从 <strong>Start (开始)</strong> 菜单中，依次选择 <strong>All Programs (所有程序)<strong>、</strong>PuTTY</strong>、<strong>PuTTYgen</strong>。 		</li>
<li>在 <strong>Type of key to generate</strong> 下，选择 ** RSA**。如果您的 PuTTYgen 版本不包含此选项，请选择 <strong>SSH-2 RSA</strong>。</li>
<li>Load-选择.ppk密钥文件打开。</li>
<li>如要保存，选择<strong>Save private key进行保存</strong></li>
</ol>
<ul>
<li><strong>连接到您的 Linux 实例</strong><ul>
<li>选项（必选）<ul>
<li>连接方式：ssh</li>
<li>端口：22</li>
<li>选择密钥：Connection–&gt;SSH–&gt;Auth–&gt;Browse–&gt;选择并打开–&gt;OPEN（打开连接）</li>
</ul>
</li>
<li>选项（可选）<ul>
<li>保持连接：Connection–&gt;Seconds between keepadlives(0 to tum off)输入间隔多久发送一次保持活动数据。</li>
</ul>
</li>
<li>在<strong>主机名</strong>框中，执行以下操作之一：<ol>
<li>（公有 DNS）要使用实例的公有 DNS 名称进行连接，请输入 my-instance-user-name@my-instance-public-dns-name。 </li>
<li>(IPv6) 或者，如果实例具有 IPv6 地址，要使用实例的 IPv6 地址进行连接，请输入 my-instance-user-name@my-instance-IPv6-address</li>
</ol>
</li>
</ul>
</li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/AccessingInstancesLinux.html">SSH 客户端</a> 				</li>
<li><a href="https://docs.aws.amazon.com/systems-manager/latest/userguide/session-manager.html">AWS Systems Manager 会话管理器</a> 				</li>
<li><a href="https://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/WSL.html">适用于 Linux 的 Windows 子系统</a></li>
</ul>
<p> 				</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>系统服务</category>
        <category>云服务</category>
      </categories>
      <tags>
        <tag>服务</tag>
        <tag>计算机</tag>
        <tag>AMS云服务</tag>
      </tags>
  </entry>
  <entry>
    <title>布谷鸟MySQL操作</title>
    <url>/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/%E5%B8%83%E8%B0%B7%E9%B8%9F/%E5%B8%83%E8%B0%B7%E9%B8%9FMySQL%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>config.xml内含mysql密码</p>
<p>insert into userlist (UserID,UserNo,UserTName,UserZW,UserMobile,UserEmail) value (‘dg001’,’dg001’,’dongguan’,’dianpu’,’10086’,‘<a href="mailto:&#100;&#x67;&#48;&#x30;&#49;&#x40;&#x73;&#x61;&#x6e;&#115;&#101;&#46;&#99;&#111;&#x6d;">&#100;&#x67;&#48;&#x30;&#49;&#x40;&#x73;&#x61;&#x6e;&#115;&#101;&#46;&#99;&#111;&#x6d;</a>‘);</p>
<p>insert into workgroupuserlist (WId,WorkGroupID,UserNO) value (‘t’,’workgroup001’,’sz01’);</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> pypinyin</span><br><span class="line"></span><br><span class="line"><span class="comment">#######################################################</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pinyin</span>(<span class="params">word</span>):</span><br><span class="line">    s = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pypinyin.pinyin(word, style=pypinyin.NORMAL):</span><br><span class="line">        s += <span class="string">&#x27;&#x27;</span>.join(i)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"><span class="comment">#######################################################</span></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">    host=<span class="string">&#x27;192.168.100.145&#x27;</span>,</span><br><span class="line">    port=<span class="number">9171</span>,</span><br><span class="line">    user=<span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    password=<span class="string">&#x27;123&#x27;</span>,</span><br><span class="line">    db=<span class="string">&#x27;sisenmess-user-database&#x27;</span>,</span><br><span class="line">    charset=<span class="string">&#x27;utf8&#x27;</span></span><br><span class="line">)</span><br><span class="line">cur = conn.cursor()</span><br><span class="line"><span class="comment">#######################################################</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cuckoo_class</span>:</span><br><span class="line">    <span class="comment">#####################字符存储############################</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, username=<span class="string">&#x27;廖宗隆&#x27;</span>, userZW=<span class="string">&#x27;店铺&#x27;</span>, usergroup=<span class="string">&#x27;测试&#x27;</span>,UserMobile=<span class="string">&#x27;10086&#x27;</span> </span>):</span><br><span class="line">        self.username = username</span><br><span class="line">        self.userZW = userZW</span><br><span class="line">        self.usergroup = usergroup</span><br><span class="line">        self.UserMobile = UserMobile</span><br><span class="line">        self.userid = pinyin(username)</span><br><span class="line">        self.usergroupid = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">###########人员##################</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">People</span>(<span class="params">self</span>):</span><br><span class="line">        sql=<span class="string">&quot;insert into userlist (UserID,UserNo,UserPass,UserTName,UserZW,UserMobile,UserEmail) values(%s,%s,%s,%s,%s,%s,%s)&quot;</span></span><br><span class="line">        param=(self.userid, self.userid, <span class="string">&#x27;d41d8cd98f00b204e9800998ecf8427e&#x27;</span>, self.username, self.userZW, self.UserMobile, self.userid + <span class="built_in">str</span>(<span class="string">&#x27;@sanse.com&#x27;</span>))</span><br><span class="line">        cur.execute(sql,param)</span><br><span class="line">        conn.commit()</span><br><span class="line">    <span class="comment">#########部门定位ID#####################</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">department</span>(<span class="params">self</span>):</span><br><span class="line">        sql = (<span class="string">&#x27;SELECT * FROM workgroup where WorkGroupName=&quot;&#x27;</span>+self.usergroup+<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">        cur.execute(sql)</span><br><span class="line">        a = cur.fetchall()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">            usergroupid = (a[<span class="number">0</span>])</span><br><span class="line">        <span class="comment">###################################</span></span><br><span class="line">        sql=<span class="string">&quot;insert into workgroupuserlist (WId,WorkGroupID,UserNO) values(%s,%s,%s)&quot;</span></span><br><span class="line">        param=(self.userid,usergroupid[<span class="number">0</span>],self.userid)</span><br><span class="line">        cur.execute(sql,param)</span><br><span class="line">        conn.commit()</span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">cuckoo = Cuckoo_class(<span class="string">&#x27;李四&#x27;</span>,<span class="string">&#x27;买手&#x27;</span>,<span class="string">&#x27;adidas商品部&#x27;</span>,<span class="string">&#x27;110&#x27;</span>)     <span class="comment">#用户名字，职位，属于哪个组，电话</span></span><br><span class="line">cuckoo.People()</span><br><span class="line">cuckoo.department()</span><br><span class="line"><span class="comment">#######################################</span></span><br><span class="line">cur.close() <span class="comment"># 关闭游标</span></span><br><span class="line">conn.close() <span class="comment"># 关闭连接</span></span><br><span class="line"><span class="comment">#######################################</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>系统服务</category>
        <category>布谷鸟</category>
      </categories>
  </entry>
  <entry>
    <title>布谷鸟服务端</title>
    <url>/2022/05/05/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/%E5%B8%83%E8%B0%B7%E9%B8%9F/%E5%B8%83%E8%B0%B7%E9%B8%9F%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="布谷鸟基础安装"><a href="#布谷鸟基础安装" class="headerlink" title="布谷鸟基础安装"></a>布谷鸟基础安装</h2><p><img src="https://s2.loli.net/2022/05/03/3VG9wqoT4djJzDB.png#id=EEQcn&originHeight=322&originWidth=659&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol>
<li>把文件夹中的【Client】和【Server】这两个安装。</li>
<li>server首次启动选择需要的数据库。跟以前一样。然后将数据导入进去即可。</li>
</ol>
<p>需要开放端口为：【9660-9662,9665,9666,9670】，【TCP】&amp;【UDP】混合</p>
<h2 id="布谷鸟客户端自动更新"><a href="#布谷鸟客户端自动更新" class="headerlink" title="布谷鸟客户端自动更新"></a>布谷鸟客户端自动更新</h2><ol>
<li>将最新的【client客户端】子目录即【SisenMESS-Client】下的所有文件复制到【SisenMESS-Server\SisenMESSUpdate\】中</li>
<li>服务器安装【IIS服务】<ol>
<li>添加虚拟目录【别名：SisenMESSUpdate；物理路径：SisenMESS-Server\SisenMESSUpdate\】</li>
<li>身份验证【匿名&amp;Windows身份验证】</li>
<li>测试【<a href="http://localhost/SisenMESSUpdate/SisenMESSUpdate.xml%E6%89%93%E5%BC%80%E5%8D%B3%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%95%8C%E9%9D%A2%E3%80%91">http://localhost/SisenMESSUpdate/SisenMESSUpdate.xml打开即会出现一个界面】</a></li>
</ol>
</li>
</ol>
<p>PS:强制更新，提示用户更新的选项在【布谷鸟后台管理软件】的【系统设置】中</p>
<h2 id="布谷鸟手机客户端"><a href="#布谷鸟手机客户端" class="headerlink" title="布谷鸟手机客户端"></a>布谷鸟手机客户端</h2><p>端口：9662，TCP&amp;IIS</p>
<ol>
<li>【C:\SisnMESS_Documents】设置为【所有人完全控制】——对应【系统设置\文档服务设置\文档存放路径】。</li>
<li><del>将【SisenMESS-Mobile-WebService】设置为【所有人完全控制】。若无此文件夹：从【安装包】内复制过去。并且将【文档Web服务】的文件也复制进去——这一段有问题的。不要操作</del></li>
<li>IIS添加应用<ol>
<li>添加应用程序池【名称：SisenMESSMobile；NET版本：NET Framework v2.0.50727；托管管道模式：经典】</li>
<li>网站添加应用程序【别名：SisenMESS-Mobile-WebService;应用程序池：SisenMESSMobile；物理路径：Server\SisenMESS-Mobile-WebService】<ol>
<li>身份验证【ASP.NET &amp; Windows身份验证 &amp; 匿名身份验证】</li>
</ol>
</li>
<li>同上创建【SisenMESSDocuments】</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>系统服务</category>
        <category>布谷鸟</category>
      </categories>
  </entry>
  <entry>
    <title>Proxmox VE（PVE）安装黑群晖DS918-7.01</title>
    <url>/2022/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/%E9%BB%91%E7%BE%A4%E6%99%96/Proxmox%20VE%EF%BC%88PVE%EF%BC%89%E5%AE%89%E8%A3%85%E9%BB%91%E7%BE%A4%E6%99%96DS918-7.01/</url>
    <content><![CDATA[<h1 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h1><ul>
<li>必备项：<ul>
<li>DS918+_7.01-42214（系统安装包）.pat</li>
<li>redpill-DS918+_7.0.1-42214（引导文件）.img</li>
</ul>
</li>
<li>参考下载地址<ul>
<li><a href="https://pan.gxnas.com:1443/">https://pan.gxnas.com:1443/</a></li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102004791.jpg#id=Tiii4&originHeight=278&originWidth=389&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="2-PVE创建虚拟机"><a href="#2-PVE创建虚拟机" class="headerlink" title="2. PVE创建虚拟机"></a>2. PVE创建虚拟机</h1><table>
<thead>
<tr>
<th>【创建：虚拟机】步骤</th>
<th>方法</th>
<th>描述</th>
<th>图片</th>
</tr>
</thead>
<tbody><tr>
<td>1 一般</td>
<td>创建虚拟机</td>
<td>记住【VM ID】的号码</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102009098.jpg#id=V4GxE&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>2 操作系统</td>
<td>不不使用用任何介质</td>
<td></td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102009399.jpg#id=DKiRT&originHeight=513&originWidth=704&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>3 系统</td>
<td>系统使用【默认】</td>
<td>直接下一步</td>
<td></td>
</tr>
<tr>
<td>4 硬盘</td>
<td>1【总线&#x2F;设备】选择【SATA】2 【磁盘大小】输入【1】</td>
<td>这个磁盘会被删除，所以大小无关紧要</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102011037.jpg#id=I9QeF&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>5 【CPU】 and 【内存】</td>
<td>略</td>
<td>自己设置</td>
<td></td>
</tr>
<tr>
<td>6 网络</td>
<td>【模型】选择【Intel E1000e】</td>
<td></td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102012131.jpg#id=HU4JM&originHeight=511&originWidth=699&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
</tbody></table>
<h1 id="3-进一步对虚拟机设置"><a href="#3-进一步对虚拟机设置" class="headerlink" title="3. 进一步对虚拟机设置"></a>3. 进一步对虚拟机设置</h1><table>
<thead>
<tr>
<th>【PVE】步骤</th>
<th>方法</th>
<th>描述</th>
<th>图片</th>
</tr>
</thead>
<tbody><tr>
<td>1 硬件</td>
<td>删除硬盘</td>
<td>自行删除不需要的设备。例如：【CD&#x2F;DVD驱动器】</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102014132.jpg#id=JwaPw&originHeight=476&originWidth=999&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>2 硬件</td>
<td>【BIOS】设置为【OVMF(UEFI)】</td>
<td></td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102016929.jpg#id=CUomy&originHeight=407&originWidth=732&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>3 硬件</td>
<td>【机器】修改为【q35】</td>
<td></td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102017039.jpg#id=gAFiN&originHeight=402&originWidth=711&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>4 Winscp</td>
<td>将DS918_7.0.1.img文件上传至【pve】服务器</td>
<td>反正将镜像上传上去就行了</td>
<td></td>
</tr>
<tr>
<td>5 PVE Shell</td>
<td>qm importdisk 【VM ID】 【img镜像名称】local-lvm</td>
<td>输入指令将【群晖img镜像】转换为引导盘</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102020865.jpg#id=IXiSA&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>6 PVE</td>
<td></td>
<td>将刚刚转换的【引导盘】改成SATA模式必须是【SATA 0】</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102020419.jpg#id=vYkfo&originHeight=635&originWidth=979&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>7 硬件</td>
<td></td>
<td>自行添加硬盘如果是SSD记得开启【SSD仿真】</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102022784.jpg#id=Sqi7j&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>8 选项</td>
<td>选项–&gt;引导顺序–&gt;编辑–&gt;【选择目标对象并去掉其他的】</td>
<td>修改引导顺序</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102022530.jpg#id=eiz6S&originHeight=570&originWidth=966&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>9 synology</td>
<td>输入【<a href="http://find.synology.com/">http://find.synology.com/</a>】扫描当前synology设备</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10 synology</td>
<td></td>
<td>上传【.pat】文件</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102025044.jpg#id=gB5Sj&originHeight=601&originWidth=1049&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>11 synology</td>
<td>选Basic</td>
<td>配置存储池属性RAID类型根据实际选择（如果有多个硬盘需要组阵列的选SHR，如果需要把多个硬盘组成一个大容量的选JBOD）</td>
<td><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/zhongzhuan/202204102025414.jpg#id=yqgT7&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></td>
</tr>
<tr>
<td>12 synology</td>
<td>Btrfs</td>
<td>选择文件系统</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机</category>
        <category>系统服务</category>
        <category>PVE</category>
      </categories>
  </entry>
  <entry>
    <title>群辉网盘同步</title>
    <url>/2021/12/16/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/%E9%BB%91%E7%BE%A4%E6%99%96/%E7%BE%A4%E8%BE%89%E7%BD%91%E7%9B%98%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<ol>
<li>安装套件“Cloud Sync”</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/qCVgsYItzynMLwT.png#id=DU7ox&originHeight=238&originWidth=175&originalType=binary&ratio=1&status=done&style=none#id=jvBaR&originHeight=238&originWidth=175&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="百度网盘的实现"><a href="#百度网盘的实现" class="headerlink" title="百度网盘的实现"></a>百度网盘的实现</h2><ol>
<li>选择目标网盘</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/JKnfUjemW5TZo9p.png#id=oyEwt&originHeight=374&originWidth=640&originalType=binary&ratio=1&status=done&style=none#id=T8Xu1&originHeight=374&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol start="2">
<li>根据需要进行填写</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/DXvHGg71C8QpEFz.png#id=BNlzf&originHeight=377&originWidth=640&originalType=binary&ratio=1&status=done&style=none#id=FxVJM&originHeight=377&originWidth=640&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<blockquote>
<p>本地路径指的是群晖的本地文件夹，选择需要同步的文件夹，这里一次只能设置一个文件夹，如果需要设置多个，重复多次绑定操作即可！</p>
</blockquote>
<p>参考：<a href="https://baijiahao.baidu.com/s?id=1668236324533068417&wfr=spider&for=pc"> 群晖NAS如何同步百度云网盘  </a></p>
<h2 id="阿里网盘的实现："><a href="#阿里网盘的实现：" class="headerlink" title="阿里网盘的实现："></a>阿里网盘的实现：</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol>
<li>安装Docker套件，正常运行后打开Docker，在注册表搜索zx5253，找到zx5253&#x2F;webdav-aliyundriver这个项目双击开始下载。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/rZkx36NjvunKWmw.png#id=xNB9V&originHeight=237&originWidth=827&originalType=binary&ratio=1&status=done&style=none#id=NQKWq&originHeight=237&originWidth=827&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol start="2">
<li>登录成功后，按F12打开开发者工具，点击Application，点击Local Storage，点击 Local Storage下的 <a href="https://www.aliyundrive.com/">https://www.aliyundrive.com/</a>，点击右边的token，此时可以看到里面的数据，其中就有refresh_token，把其值复制出来即可。（格式为小写字母和数字，不要复制双引号。例子：ca6bf2175d73as2188efg81f87e55f11）</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/bHlGUFX4DrRsmNv.png#id=mX4mr&originHeight=881&originWidth=1056&originalType=binary&ratio=1&status=done&style=none#id=bxPQM&originHeight=881&originWidth=1056&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol start="3">
<li>打开群晖file station ，找到docker文件夹（文件夹随意，放docker里面好管理），创建一个文件夹，名称随意。</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/LcZl7HtAQTpMz3g.png#id=BHQ6X&originHeight=519&originWidth=1080&originalType=binary&ratio=1&status=done&style=none#id=GmjpL&originHeight=519&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol start="4">
<li>打开docker，选择注册表，搜索webdav-aliyundriver</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/6Hoh1VUMtwbcJCu.png#id=pdNyx&originHeight=519&originWidth=1080&originalType=binary&ratio=1&status=done&style=none#id=MqF22&originHeight=519&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="容器设置"><a href="#容器设置" class="headerlink" title="容器设置"></a>容器设置</h3><ol start="5">
<li>双击下载好的镜像运行，并进行设置，容器名称随意修改，然后选高级设置</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/K8GEA7a5QzLlv9P.png#id=GFJhX&originHeight=535&originWidth=1080&originalType=binary&ratio=1&status=done&style=none#id=uf19E&originHeight=535&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol start="6">
<li>高级设置内，勾选启动自动重新启动，然后进入存储空间设置； 选择存储空间，添加文件夹，左边为宿主机路径，点击找到我们刚刚创建的文件夹即可；右边是容器内路径，填入&#x2F;etc&#x2F;aliyun-driver&#x2F; 然后设置端口；</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/qRdVv6n85EeaMLt.png#id=tvqD3&originHeight=288&originWidth=600&originalType=binary&ratio=1&status=done&style=none#id=XGs0f&originHeight=288&originWidth=600&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol start="7">
<li>进入端口设置，本地端口随意输入，默认为8080，容器端口不要修改，使用默认值8080；进入环境设置</li>
<li>环境设置，然后添加如下内容</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改时区为上海 ↓</span><br><span class="line"></span><br><span class="line">可变：TZ 值：Asia/Shanghai</span><br><span class="line"></span><br><span class="line"># 添加token ↓</span><br><span class="line"></span><br><span class="line">可变：ALIYUNDRIVE_REFRESH_TOKEN 值：refresh_token 填入第1步查询到的refresh_token的值</span><br><span class="line"></span><br><span class="line"># 设置webdav密码 ↓</span><br><span class="line"></span><br><span class="line">可变：ALIYUNDRIVE_AUTH_PASSWORD 值：输入你要设置的密码(默认为admin)</span><br><span class="line"></span><br><span class="line"># 设置webdav用户名 ↓</span><br><span class="line"></span><br><span class="line">可变：ALIYUNDRIVE_AUTH_USER-NAME 值：输入你要设置的用户名(默认为admin)</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>应用保存。此时可从IP+端口号对阿里网盘进行访问</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/FkzKqxQdWGaLPi7.png#id=bRT9i&originHeight=138&originWidth=684&originalType=binary&ratio=1&status=done&style=none#id=NnWn7&originHeight=138&originWidth=684&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="cloud-sync设置"><a href="#cloud-sync设置" class="headerlink" title="cloud sync设置"></a>cloud sync设置</h3><ol start="10">
<li>设置cloud sync</li>
</ol>
<p>群晖打开cloud sync，选择webdav，然后下一步<img src="https://s2.loli.net/2021/12/16/hFgil1PT9oqwuC4.png#id=udcny&originHeight=519&originWidth=1080&originalType=binary&ratio=1&status=done&style=none#id=Fwjoo&originHeight=519&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">填入webdav地址+端口号，填入webdav用户名 密码，然后下一步</p>
<blockquote>
<p>数据加密，如果勾选的话，上次到阿里云盘的内容会被加密，通过普通方式不能打开，可以通过cloud sync下载的时候输入密码打开，或者win可以下载SynologyCloudSyncDecryptionTool 这个工具，然后输入密码打开，所以一定要保管好密码或者证书。</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/16/K8VvOLGaj3sUZR9.png#id=YQHuw&originHeight=519&originWidth=1080&originalType=binary&ratio=1&status=done&style=none#id=hwaC5&originHeight=519&originWidth=1080&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>参考：<a href="https://post.smzdm.com/p/a7dg9n8d/">群晖通过cloud sync创建阿里云盘同步 </a></p>
<h2 id="天翼网盘"><a href="#天翼网盘" class="headerlink" title="天翼网盘"></a>天翼网盘</h2><h3 id="WEBDAV-server"><a href="#WEBDAV-server" class="headerlink" title="WEBDAV server"></a>WEBDAV server</h3><ol>
<li>群辉安装“WebDAV server”套件</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/tkHVLzbojEx1gnO.png#id=PUPtc&originHeight=215&originWidth=149&originalType=binary&ratio=1&status=done&style=none#id=VhYVm&originHeight=215&originWidth=149&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<ol start="2">
<li>打开“HTTP”和“HTTPS”</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/UTZF8eodnglux9B.png#id=lc73F&originHeight=165&originWidth=396&originalType=binary&ratio=1&status=done&style=none#id=HzIz6&originHeight=165&originWidth=396&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="天翼网盘映射至群辉"><a href="#天翼网盘映射至群辉" class="headerlink" title="天翼网盘映射至群辉"></a>天翼网盘映射至群辉</h3><ol start="3">
<li>使用<a href="https://www.52pojie.cn/thread-1490131-1-1.html">【阿里云盘变本地硬盘】</a>将天翼网盘生成至本地</li>
<li>将天翼网盘需要同步的目录使用Windows的共享文件夹进行共享</li>
<li>在群辉中挂在Windows的共享文件夹（输入IP地址+标准尾缀；事先设定的账号密码；打开开机自动挂载）</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/16/V4KgBHcADnW5i1j.png#id=PWJGy&originHeight=368&originWidth=1424&originalType=binary&ratio=1&status=done&style=none#id=AoD87&originHeight=368&originWidth=1424&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="使用Cloud-Sync-添加WebDAV进行与Windows共享文件夹同步"><a href="#使用Cloud-Sync-添加WebDAV进行与Windows共享文件夹同步" class="headerlink" title="使用Cloud Sync 添加WebDAV进行与Windows共享文件夹同步"></a>使用Cloud Sync 添加WebDAV进行与Windows共享文件夹同步</h3><p><img src="https://s2.loli.net/2021/12/16/tEHRYGfjahLVWUb.png#id=End1e&originHeight=655&originWidth=781&originalType=binary&ratio=1&status=done&style=none#id=YXNP4&originHeight=655&originWidth=781&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><img src="https://s2.loli.net/2021/12/16/FsSxiUl9AL6OKZb.png#id=LHmjk&originHeight=801&originWidth=976&originalType=binary&ratio=1&status=done&style=none#id=Xoj77&originHeight=801&originWidth=976&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>参考：<a href="https://blog.csdn.net/xiaochenXIHUA/article/details/113744394">群晖NAS与Windows系统实现共享文件夹同步方案</a><a href="https://www.52pojie.cn/thread-1490131-1-1.html">【阿里云盘变本地硬盘】CloudDrive1.1.44 (阿里云盘新增refresh_token登录)</a></p>
]]></content>
      <tags>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>群辉</tag>
        <tag>网盘</tag>
        <tag>系统服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Xmind破解</title>
    <url>/2022/05/17/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/Xmind/Xmind%E7%A0%B4%E8%A7%A3/</url>
    <content><![CDATA[<p><a href="https://www.xmind.net/">Xmind下载地址</a>下载破解补丁</p>
<p><strong>激活xmind</strong></p>
<ol>
<li><p>将破解补丁复制至xmind主目录</p>
</li>
<li><p>打开xmind.ini</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">-javaagent:X:\XXX\XMindCrack.jar	<span class="comment">#:X:\XXX\为你的软件主目录</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>打开xmind。帮助——&gt;序列号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">XAka34A2rVRYJ4XBIU35UZMUEEF64CMMIYZCK2FZZUQNODEKUHGJLFMSLIQMQUCUBXRENLK6NZL37JXP4PZXQFILMQ2RG5R7G4QNDO3PSOEUBOCDRYSSXZGRARV6MGA33TN2AMUBHEL4FXMWYTTJDEINJXUAV4BAYKBDCZQWVF3LWYXSDCXY546U3NBGOI3ZPAP2SO3CSQFNB7VVIY123456789012345</span><br><span class="line">邮箱随意</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>Xmind</category>
      </categories>
  </entry>
  <entry>
    <title>foxmail-保存不断密码错误</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/foxmail/foxmail-%E4%BF%9D%E5%AD%98%E4%B8%8D%E6%96%AD%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673799213-f5a61653-f5eb-4f48-862a-f4cbc150f29d.png#clientId=u9baa2fa3-67c7-4&from=paste&height=149&id=uad6dc1ce&name=%E5%9B%BE%E7%89%87.png&originHeight=149&originWidth=309&originalType=binary&ratio=1&rotation=0&showTitle=false&size=35137&status=done&style=none&taskId=uc7da5b91-cee9-4069-956d-47426819235&title=&width=309" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633673801790-d82706f7-20ea-4c20-9cb8-f96daab2bfeb.png#clientId=u9baa2fa3-67c7-4&from=paste&height=539&id=u4b43f745&name=%E5%9B%BE%E7%89%87.png&originHeight=539&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59687&status=done&style=none&taskId=uad512afb-4432-4569-9f27-c4d200c7e99&title=&width=554" alt="图片.png">禁用</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>foxmail</category>
      </categories>
  </entry>
  <entry>
    <title>Office问题</title>
    <url>/2022/02/24/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/office/Office%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="excel表格显示系统资源不足"><a href="#excel表格显示系统资源不足" class="headerlink" title="excel表格显示系统资源不足"></a>excel表格显示系统资源不足</h2><h2 id="内存或磁盘空间不足"><a href="#内存或磁盘空间不足" class="headerlink" title="内存或磁盘空间不足"></a>内存或磁盘空间不足</h2><p>选择–&gt;信任中心–&gt;信任的位置–&gt;添加所有盘符（选中“同时信任该位置的子文件夹”）–&gt;重启office<img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633672776209-795c9e43-524f-4a48-a3f3-243ec000975f.png#clientId=udca30463-d1a3-4&from=paste&height=278&id=ucf29d622&name=%E5%9B%BE%E7%89%87.png&originHeight=278&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=42984&status=done&style=none&taskId=u4aad27c4-8c86-428e-b1ac-98d0f0afe94&title=&width=554" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633672782289-186e10d0-475f-485a-bae9-9d633e85acdc.png#clientId=udca30463-d1a3-4&from=paste&height=443&id=ubd039635&name=%E5%9B%BE%E7%89%87.png&originHeight=443&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=68943&status=done&style=none&taskId=u08aea8a9-a1bb-47cb-85a9-ee206085a5e&title=&width=554" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633672788396-4e95156a-2746-46fd-a496-17f16f5ad3c9.png#clientId=udca30463-d1a3-4&from=paste&height=416&id=u0d53a1c5&name=%E5%9B%BE%E7%89%87.png&originHeight=416&originWidth=536&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26217&status=done&style=none&taskId=u069df96c-f3a7-4e8f-8570-93e0a7c101f&title=&width=536" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633672793360-b85e7a84-1ee6-4c74-bb1c-8a0e7974d415.png#clientId=udca30463-d1a3-4&from=paste&height=446&id=ucc592979&name=%E5%9B%BE%E7%89%87.png&originHeight=446&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=69299&status=done&style=none&taskId=ub15100ef-32d6-42bf-9186-0352b5a24c9&title=&width=554" alt="图片.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1633672798327-11131e3b-9075-4d3a-a038-89a448623325.png#clientId=udca30463-d1a3-4&from=paste&height=476&id=ueab9b8bb&name=%E5%9B%BE%E7%89%87.png&originHeight=476&originWidth=554&originalType=binary&ratio=1&rotation=0&showTitle=false&size=51895&status=done&style=none&taskId=ueb4b04a7-8a81-4c3a-9d02-922badd53d4&title=&width=554" alt="图片.png"></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>Office</category>
      </categories>
  </entry>
  <entry>
    <title>office静默安装设置</title>
    <url>/2022/03/03/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/office/office%E9%9D%99%E9%BB%98%E5%AE%89%E8%A3%85%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>步骤</th>
<th>描述</th>
<th>方法</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>启动office自定义工具</td>
<td>1. win+r2. cmd3. cd &lt;office文件目录&gt;4. setup.exe &#x2F;admin</td>
</tr>
<tr>
<td>2</td>
<td>修改默认安装的软件</td>
<td>1. 使用【设置功能安装状态】进行修改</td>
</tr>
<tr>
<td>3</td>
<td>保存配置文件</td>
<td>1. 【文件】–&gt;【保存】–&gt;设置路径后保存</td>
</tr>
<tr>
<td>4</td>
<td>调用【msp】文件进行安装</td>
<td>1. setup &#x2F;adminfile ***(你的配置文件).msp</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>Office</category>
      </categories>
  </entry>
  <entry>
    <title>优启通一些其他操作</title>
    <url>/2022/03/10/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/%E5%90%AF%E5%8A%A8%E7%9B%98/%E4%BC%98%E5%90%AF%E9%80%9A%E4%B8%80%E4%BA%9B%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="EasyU-自定义内置软件"><a href="#EasyU-自定义内置软件" class="headerlink" title="EasyU 自定义内置软件"></a>EasyU 自定义内置软件</h2><table>
<thead>
<tr>
<th>1</th>
<th>进入【tools】目录下，找到【PETOOLS_Other】</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>在7z中创建新的文件夹</td>
</tr>
<tr>
<td>3</td>
<td>编辑【EXLOAD.cfg】。例子： SGImini.exe&#x3D;SGI映像总裁, Desktop</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>启动盘</category>
      </categories>
  </entry>
  <entry>
    <title>布谷鸟问题</title>
    <url>/2022/02/17/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/%E5%B8%83%E8%B0%B7%E9%B8%9F/%E5%B8%83%E8%B0%B7%E9%B8%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="无法截图"><a href="#无法截图" class="headerlink" title="无法截图"></a>无法截图</h2><ol>
<li>检查计算机名。</li>
</ol>
<p>例：用户名为f’f。即系统环境变量为：C:\Users\f’f.…..解决方法：修改回不带特殊符号的用户名</p>
<pre><code>     1. 重命名用户文件夹
     2. 修改注册表HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Profilelist中的ProfileImagePath的路径地址
</code></pre>
<p>补充布谷鸟临时截图路径C:\Users\计算机用户名\Documents\SisenMESS\用户名\TempFiles\年+月例：C:\Users\Administrator\Documents\SisenMESS\zhangsan\TempFiles\202202</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>布谷鸟</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>布谷鸟</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title>使用谷歌浏览器出现插件未就绪以及CLodop云打印服务</title>
    <url>/2022/03/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/%E6%B5%8F%E8%A7%88%E5%99%A8/%E4%BD%BF%E7%94%A8%E8%B0%B7%E6%AD%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%87%BA%E7%8E%B0%E6%8F%92%E4%BB%B6%E6%9C%AA%E5%B0%B1%E7%BB%AA%E4%BB%A5%E5%8F%8ACLodop%E4%BA%91%E6%89%93%E5%8D%B0%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<p> 复制此地址到地址栏回车键进入：【chrome:&#x2F;&#x2F;flags&#x2F;#block-insecure-<a href="https://so.csdn.net/so/search?q=private&spm=1001.2101.3001.7020">private</a>-network-requests  】设置为【Relaunch】重启浏览器即可  </p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器备份</title>
    <url>/2022/03/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6/%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<p>Chrome：C:\Users\Administrator\AppData\Local\Google\Chrome\User Data\Default火狐：C:\Users\Administrator\AppData\Roaming\Mozilla\Firefox\Profiles\17q0dwmg.default-release\bookmarkbackups360：C:\Documents and Settings\Administrator\Application Data\360SE\data\bookmarks.dat</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>软件</category>
        <category>浏览器</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 下建立 Git 与 GitHub 的连接</title>
    <url>/2022/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%9C%8D%E5%8A%A1/Linux/GitHub/Linux%20%E4%B8%8B%E5%BB%BA%E7%AB%8B%20Git%20%E4%B8%8E%20GitHub%20%E7%9A%84%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<ol>
<li><p>安装git</p>
</li>
<li><p>配置 Git 用户信息： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;woider&quot;</span><br><span class="line">git config --global user.email &quot;woider@gmail.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>生成 SSH KEY</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;woider@gmail.com&quot; </span><br></pre></td></tr></table></figure>
<p>如果报错找不到安装openssh</p>
</li>
<li><p>查看 SSH KEY</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@localhost:~# cd /root/.ssh</span><br><span class="line">root@localhost:~/.ssh# ls -a</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制 SSH KEY至GitHub</p>
</li>
</ol>
<p> 打开 id_rsa.pub 文件并复制-&gt; 登录 GitHub-&gt;打开 Personal settings 页面-&gt;选择 SSH and GPG keys 选项-&gt;创建并粘贴进去</p>
<ol start="6">
<li><p>测试git连接</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com                                                    ✔ </span><br><span class="line">The authenticity of host &#x27;github.com (20.205.243.166)&#x27; can&#x27;t be established.</span><br><span class="line">This key is not known by any other names</span><br><span class="line">Are you sure you want to continue connecting (yes/no/[fingerprint])? yes</span><br><span class="line"></span><br><span class="line">出现这个提示输入yes</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装hexo </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo npm install hexo-cli -g</span><br><span class="line">sudo npm install --save hexo-deployer-git</span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装语雀（可选）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm -g install yuque-hexo</span><br></pre></td></tr></table></figure>
</li>
<li><p>克隆或创建项目</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone repo  #复制远程仓库</span><br><span class="line">git init   #初始化本地仓库</span><br></pre></td></tr></table></figure>
</li>
<li><p>上传更改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add .  #增加修改内容</span><br><span class="line">git commit -m &quot;&lt;description&gt;&quot;  #对提交的说明</span><br><span class="line">git push origin master   #上传改动</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>服务</category>
        <category>Linux</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>github</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>archlinux系统层面基本操作</title>
    <url>/2022/03/31/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Linux/archlinux/archlinux%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="系统服务的操作与介绍"><a href="#系统服务的操作与介绍" class="headerlink" title="系统服务的操作与介绍"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/advanced/beAdmin?id=%e7%b3%bb%e7%bb%9f%e6%9c%8d%e5%8a%a1%e7%9a%84%e6%93%8d%e4%bd%9c%e4%b8%8e%e4%bb%8b%e7%bb%8d">系统服务的操作与介绍</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start dhcpcd          # 启动服务</span><br><span class="line">systemctl stop dhcpcd           # 停止服务</span><br><span class="line">systemctl restart dhcpcd        # 重启服务</span><br><span class="line">systemctl reload dhcpcd         # 重新加载服务以及它的配置文件</span><br><span class="line">systemctl status dhcpcd         # 查看服务状态</span><br><span class="line">systemctl enable dhcpcd         # 设置开机启动服务</span><br><span class="line">systemctl enable --now dhcpcd   # 设置服务为开机启动并立即启动这个单元:</span><br><span class="line">systemctl disable dhcpcd        # 取消开机自动启动</span><br><span class="line">systemctl daemon-reload dhcpcd  # 重新载入 systemd 配置 扫描新增或变更的服务单元 不会重新加载变更的配置 加载变更的配置用 reload</span><br></pre></td></tr></table></figure>

<h2 id="Pacman-包管理"><a href="#Pacman-包管理" class="headerlink" title="Pacman 包管理"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/advanced/beAdmin?id=pacman-%e5%8c%85%e7%ae%a1%e7%90%86">Pacman 包管理</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S package_name     # 安装软件包</span><br><span class="line">sudo pacman -Syu package_name   # 升级系统并安装软件包，Arch Linux 不支持部分升级，建议用此命令先升级再安装</span><br><span class="line">sudo pacman -Syu                # 升级系统</span><br><span class="line">sudo pacman -Syyu               # 升级系统 yy标记强制刷新 u标记升级动作</span><br><span class="line">sudo pacman -R package_name     # 删除软件包</span><br><span class="line">sudo pacman -Rs package_name    # 删除软件包，及其所有没有被其他已安装软件包使用的依赖包</span><br><span class="line">sudo pacman -Qdt                # 找出孤立包 Q为查询本地软件包数据库 d标记依赖包 t标记不需要的包 dt合并标记孤立包</span><br><span class="line">sudo pacman -Rs $(pacman -Qtdq) # 删除孤立软件包</span><br><span class="line">sudo pacman -Fy                 # 更新命令查询文件列表数据库</span><br><span class="line">sudo pacman -F xxx              # 当不知道某个命令属于哪个包时，用来查询某个xxx命令属于哪个包</span><br></pre></td></tr></table></figure>

<h2 id="编辑系统配置文件"><a href="#编辑系统配置文件" class="headerlink" title="编辑系统配置文件"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/advanced/beAdmin?id=%e7%bc%96%e8%be%91%e7%b3%bb%e7%bb%9f%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">编辑系统配置文件</a></h2><h3 id="用-sudoedit-编辑配置文件"><a href="#用-sudoedit-编辑配置文件" class="headerlink" title="用 sudoedit 编辑配置文件"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/advanced/beAdmin?id=%e7%94%a8-sudoedit-%e7%bc%96%e8%be%91%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">用 sudoedit 编辑配置文件</a></h3><p> 当我们用 sudo 执行一个命令时，整个进程都会获得 root 权限。只是编辑一个文件不需要那么强大的权限，我们只需要拥有对这一个配置文件的读写权限就足够了。而 sudoedit（或 sudo -e，二者是完全等效的）是编辑一个系统配置文件的最佳实践。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EDITOR=vim sudoedit 要编辑的文件</span><br></pre></td></tr></table></figure>
<p> sudoedit 命令大致是这样工作的：它会先创建一份普通用户有权编辑的临时文件，把要编辑的文件以 root 权限复制到这个临时文件中，接着根据 EDITOR 等环境变量，<strong>以普通用户的权限</strong>运行文本编辑器。在文本编辑器编辑完成并退出后，它会再次以 root 权限用这个编辑好的临时文件去覆盖掉原先的配置文件。  </p>
<h3 id="编辑-sudoers-配置文件"><a href="#编辑-sudoers-配置文件" class="headerlink" title="编辑 sudoers 配置文件"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/advanced/beAdmin?id=%e7%bc%96%e8%be%91-sudoers-%e9%85%8d%e7%bd%ae%e6%96%87%e4%bb%b6">编辑 sudoers 配置文件</a></h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo visudo  # visudo 需要使用 root 权限运行。默认编辑 /etc/sudoers</span><br><span class="line">sudo visudo -f 要编辑的sudoers文件的路径  # 也可以指定文件路径</span><br></pre></td></tr></table></figure>
<p> visudo 与 sudoedit 类似的是，它也会把要编辑的配置文件先复制到一个临时文件，再调用文本编辑器编辑，而不同的是，在开始编辑之前 visudo 还会锁定正在编辑的 sudoers 文件，以此避免两个人同时对它编辑；并且会在编辑完成之后检查 sudoers 的语法，如果发现错误则会拒绝这次编辑的结果。  </p>
<p> 如果普通用户不慎改坏了 sudoers 文件，则有可能失去使用 sudo 命令的权限，就好像“关上了大门并把自己关在了外面”，这时候就需要直接用 root 用户登录甚至需要 live USB 急救才行  </p>
<h2 id="文件传输与系统备份"><a href="#文件传输与系统备份" class="headerlink" title="文件传输与系统备份"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/advanced/beAdmin?id=%e6%96%87%e4%bb%b6%e4%bc%a0%e8%be%93%e4%b8%8e%e7%b3%bb%e7%bb%9f%e5%a4%87%e4%bb%bd">文件传输与系统备份</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S rsync</span><br><span class="line"></span><br><span class="line">rsync foo.txt me@server:/home/me/   # 最基础的复制文件 与scp的操作完全相同</span><br><span class="line">rsync -a bar/ me@server:/home/me/   # -a 标记实现目录复制等 比scp -r 能更好的处理符号链接等情况</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>archlinux</category>
      </categories>
  </entry>
  <entry>
    <title>archlinux一些软件安装</title>
    <url>/2022/07/18/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Linux/archlinux/archlinux%E4%B8%80%E4%BA%9B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="办公日常"><a href="#办公日常" class="headerlink" title="办公日常"></a>办公日常</h2><h3 id="即时通讯"><a href="#即时通讯" class="headerlink" title="即时通讯"></a>即时通讯</h3><h4 id="屏幕分享"><a href="#屏幕分享" class="headerlink" title="屏幕分享"></a>屏幕分享</h4><p> 对于另外一些手机通讯软件在电脑上的投屏可以尝试使<a href="https://archlinux.org/packages/community/x86_64/scrcpy/">scrcpy</a>。 也可以使用 <a href="https://archlinux.org/packages/extra/x86_64/kdeconnect/">KDE Connect</a> 在电脑上获取 Android 通知。  </p>
<h3 id="办公套件"><a href="#办公套件" class="headerlink" title="办公套件"></a>办公套件</h3><p> 主要两个选择是 <a href="https://wiki.archlinux.org/index.php/LibreOffice">LibreOffice</a>以及<a href="https://aur.archlinux.org/packages/onlyoffice-bin/">onlyoffice</a>)AUR。 我们建议你使用开源的 LibreOffice 以及 onlyoffice，而不是专有软件 WPS,前两者其目前的安装已经非常简单。  </p>
<p>其实可以部署线上onlyoffice本地使用libreoffice。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S libreoffice-still   #稳定版</span><br></pre></td></tr></table></figure>

<h3 id="打印机"><a href="#打印机" class="headerlink" title="打印机"></a>打印机</h3><p> 我们建议使用惠普打印机。其对于 Linux 的支持非常全面，可以去其<a href="https://hplipopensource.com/">网站</a>查看所支持的设备等详情。在 Arch Linux 上，安装包 hplip 以及 cups ，启动服务后即可使用。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S hplip</span><br><span class="line">sudo pacman -S cups</span><br><span class="line">sudo systemctl enable --now cups.service</span><br></pre></td></tr></table></figure>

<h3 id="电子书"><a href="#电子书" class="headerlink" title="电子书"></a>电子书</h3><p><a href="https://archlinux.org/packages/community/x86_64/foliate/">Foliate</a> 是阅读 epub 的更佳选择  </p>
<h3 id="文献管理"><a href="#文献管理" class="headerlink" title="文献管理"></a>文献管理</h3><p> JabRef 是 java 编写的并且与 LaTeX 协作较好的开源文献管理软件，可以与 vim, Emacs 协作，并通过 bib 格式管理文献。  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S jabref</span><br></pre></td></tr></table></figure>

<h2 id="视频影音"><a href="#视频影音" class="headerlink" title="视频影音"></a>视频影音</h2><h3 id="在线听歌与音频播放器"><a href="#在线听歌与音频播放器" class="headerlink" title="在线听歌与音频播放器"></a>在线听歌与音频播放器</h3><p><a href="https://github.com/qier222/YesPlayMusic">yesplaymusic</a> 是一款全平台的开源听歌软件，颜值高、无社交功能，并且是全网资源整合，推荐使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yay -S yesplaymusic</span><br></pre></td></tr></table></figure>

<h3 id="视频播放器"><a href="#视频播放器" class="headerlink" title="视频播放器"></a>视频播放器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S vlc #VLC 播放器</span><br><span class="line">sudo pacman -S mpv #MPV 播放器</span><br></pre></td></tr></table></figure>

<p>来源：<a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/exclusive/code">https://archlinuxstudio.github.io/ArchLinuxTutorial/#/exclusive/code</a></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>archlinux</category>
      </categories>
  </entry>
  <entry>
    <title>arch安装</title>
    <url>/2022/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Linux/archlinux/arch%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="arch安装"><a href="#arch安装" class="headerlink" title="arch安装"></a>arch安装</h2><h3 id="下载镜像及校验"><a href="#下载镜像及校验" class="headerlink" title="下载镜像及校验"></a>下载镜像及校验</h3><p><a href="www.gnupg.org">gpg</a><a href="https://archlinux.org/download/">archlinux下载页面</a>签名校验代码</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">gpg --keyserver-options auto-key-retrieve --verify archlinux-202x.0x<span class="number">.01</span>-x86_64.iso.sig</span><br></pre></td></tr></table></figure>

<h3 id="关闭主板设置中的-Secure-Boot"><a href="#关闭主板设置中的-Secure-Boot" class="headerlink" title="关闭主板设置中的 Secure Boot"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/archlinux_pre_install?id=_4%e5%85%b3%e9%97%ad%e4%b8%bb%e6%9d%bf%e8%ae%be%e7%bd%ae%e4%b8%ad%e7%9a%84-secure-boot">关闭主板设置中的 Secure Boot</a></h3><p> 需要调整启动模式为 UEFI,而非传统的 BIOS&#x2F;CSM。在类似名为 boot 的选项卡中，找到类似名为 Boot Mode 的选项，确保将其调整为 UEFI only，而非 legacy&#x2F;CSM。  </p>
<p><img src="https://s2.loli.net/2022/03/23/2PF3XJYG48pmREM.png#id=HbX7l&originHeight=331&originWidth=672&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">在【选择客户机操作系统】时，根据下载界面的版本号选择【其他linux X.x及更高…】的版本</p>
<p> 这个时候先别开启虚拟机，先到虚拟机-&gt;设置-&gt;选项-&gt;高级中选择”选择通过EFI而非BIOS引导(B)选项（因为我这里是EFI启动，当然也可以选择BIOS启动方式），点击确定  </p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>进入开启界面选择第一个进入</td>
<td>arch linux install medium(x86_64,UEFI)</td>
</tr>
<tr>
<td>2</td>
<td>测试网络连通性</td>
<td>ping <a href="http://www.baidu.co/">www.baidu.co</a></td>
</tr>
<tr>
<td>3</td>
<td>检查时间是否正确</td>
<td>timedatectl status</td>
</tr>
<tr>
<td>3.1</td>
<td>时间不正确解决方案</td>
<td>timedatectl set-ntp true</td>
</tr>
<tr>
<td>4</td>
<td>对硬盘进行分区（可参考【分区方案参考】）建议阅读：<a href="https://wiki.archlinux.org/title/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">https://wiki.archlinux.org/title/Partitioning_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)</a></td>
<td>使用【uefi+gpt】方式进行分区</td>
</tr>
<tr>
<td>4.1</td>
<td>分区代码</td>
<td>lsblk    #查看分区状态cfdisk &#x2F;dev&#x2F;sd*    #进入分区系统</td>
</tr>
<tr>
<td>4.2</td>
<td>初始化分区</td>
<td># EFI分区需要FAT32文件格式 mkfs.fat -F32 &#x2F;dev&#x2F;sda1mkfs.ext4 &#x2F;dev&#x2F;sda2mkswap &#x2F;dev&#x2F;sda3 -L Swapswapon &#x2F;dev&#x2F;sda3</td>
</tr>
<tr>
<td>4.3</td>
<td>挂载</td>
<td>mount &#x2F;dev&#x2F;sda2 &#x2F;mnt mkdir -p &#x2F;mnt&#x2F;boot&#x2F;EFI mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;boot&#x2F;EFI</td>
</tr>
<tr>
<td>5</td>
<td>编辑镜像源</td>
<td>nano &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlistServer &#x3D; <a href="http://mirrors.aliyun.com/archlinux/$repo/os/$arch">http://mirrors.aliyun.com/archlinux/$repo/os/$arch</a></td>
</tr>
<tr>
<td>6</td>
<td>开始安装系统</td>
<td>pacstrap -i &#x2F;mnt base base-devel linux vim dhcpcd net-tools # 这是为&#x2F;mnt下安装一些环境用于待会创建用户所使用的，包括一些基本环境以及网络相关的dhcpcd和net-tools</td>
</tr>
<tr>
<td>7</td>
<td>用以下命令生成 fstab 文件 (用 -U 或 -L 选项设置UUID 或卷标)：</td>
<td>genfstab -U &#x2F;mnt &gt;&gt; &#x2F;mnt&#x2F;etc&#x2F;fstab#生成后可以使用cat &#x2F;mnt&#x2F;etc&#x2F;fstab 查看是否生成了磁盘分区相关的内容（可忽略）</td>
</tr>
<tr>
<td>8</td>
<td>切换用户</td>
<td>arch-chroot &#x2F;mnt#切换成功后，root颜色转为灰色</td>
</tr>
<tr>
<td>9.</td>
<td>配置locale</td>
<td>vim &#x2F;etc&#x2F;locale.gen去除掉文档中【&#x2F;en_US.TF-8 UTF-8】前的【注释符号】</td>
</tr>
<tr>
<td>9.1</td>
<td>生成Locale信息，并使用locale -a&#96;列出所有启用的Locale</td>
<td>locale-gen locale -a</td>
</tr>
<tr>
<td>9.2</td>
<td>创建locale.conf文件，并提交所要使用的本地化选项</td>
<td>echo LANG&#x3D;en_US.UTF-8 &gt; &#x2F;etc&#x2F;locale.conf locale</td>
</tr>
<tr>
<td>10</td>
<td>设置主机</td>
<td></td>
</tr>
<tr>
<td>10.1</td>
<td>要设置主机名，创建 &#x2F;etc&#x2F;hostname 文件并将主机名写入该文件即可。我的主机名为arch</td>
<td>echo arch &gt; &#x2F;etc&#x2F;hostname</td>
</tr>
<tr>
<td>10.2</td>
<td>配置主机名对应的IP到 &#x2F;etc&#x2F;hosts 中：</td>
<td>vim &#x2F;etc&#x2F;hosts127.0.0.1    localhost.localdomain    localhost ::1          localhost.localdomain    localhost 127.0.1.1    arch.localdomain    arch</td>
</tr>
<tr>
<td>11</td>
<td>网络配置</td>
<td>pacman -S dhcpcdsystemctl enable dhcpcd.service</td>
</tr>
<tr>
<td>12</td>
<td>用户管理</td>
<td></td>
</tr>
<tr>
<td>12.1</td>
<td>设置root账户密码</td>
<td>passwd</td>
</tr>
<tr>
<td>12.2</td>
<td>创建普通用户并创建密码</td>
<td>useradd -m -G wheel -s &#x2F;bin&#x2F;bash freepasswd free</td>
</tr>
<tr>
<td>12.3</td>
<td>开启普通用户也能使用sudo权限，需要给wheel中的用户赋予权限,</td>
<td>visudo 删除wheel组前面的注释（#）即可：</td>
</tr>
<tr>
<td>13</td>
<td>安装grub管理器不同电脑环境需要安装不同管理器</td>
<td>pacman -S grub efibootmgr然后，还需要将其安装到EFI分区当中：grub-install –recheck &#x2F;dev&#x2F;sda</td>
</tr>
<tr>
<td>14</td>
<td>退出环境重启系统</td>
<td>exit umount -R &#x2F;mnt reboot</td>
</tr>
</tbody></table>
<h3 id="修改源"><a href="#修改源" class="headerlink" title="修改源"></a>修改源</h3><p>编辑文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">清华大学</span></span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 163</span></span></span><br><span class="line">Server = http://mirrors.163.com/archlinux/$repo/os/$arch</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># aliyun</span></span></span><br><span class="line">Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch</span><br></pre></td></tr></table></figure>
<p>更新源</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -Sy</span><br></pre></td></tr></table></figure>

<h2 id="建议参考"><a href="#建议参考" class="headerlink" title="建议参考"></a>建议参考</h2><h3 id="分区方案参考"><a href="#分区方案参考" class="headerlink" title="分区方案参考"></a>分区方案参考</h3><table>
<thead>
<tr>
<th>实际需求大约 100 MB，如果有多个内核&#x2F;启动镜像同时存在，建议分配 200 或者 300 MB。</th>
<th>&#x2F;boot - 200 MB</th>
</tr>
</thead>
<tbody><tr>
<td>传统上包括 &#x2F;usr 目录，根据安装的软件数量，会产生非常明显的增长。15-20 GB 对于大多数用户来说是一个比较合适的取值。如果你打算在这里放一个交换文件（swap file）的话，需要适当调大取值。</td>
<td>&#x2F; - 15-20 GB</td>
</tr>
<tr>
<td>除了其他数据以外，还包括<a href="https://wiki.archlinux.org/index.php/ABS">ABS</a> 树和 <a href="https://wiki.archlinux.org/index.php/Pacman">pacman</a> 缓存。保留缓存的包提供了包降级的能力，因此非常有用。也正因为这样，&#x2F;var 的大小会随着时间推移而增长。尤其是 pacman 缓存将会随着新软件的安装、系统的升级而增长。在磁盘空间不足的时候，可以安全的清理这个目录。&#x2F;var 分配 8-12 GB 对于桌面系统来说是比较合适的取值，具体取值取决于安装的软件数量。</td>
<td>&#x2F;var - 8-12 GB</td>
</tr>
<tr>
<td>通常用于存放用户数据，下载的文件和媒体文件。在桌面系统中，&#x2F;home 通常是最大的文件系统。</td>
<td>&#x2F;home - [不定]</td>
</tr>
<tr>
<td>历史上 swap 分区的大小通常是物理内存的2倍。由于当前的电脑内存容量快速增长，这条规则已经不那么适用。在拥有不足 512 MB 内存的机器上，通常为 swap 分区分配2倍内存大小的空间。如果有更大的内存（大于 1024 MB），可以分配较少的空间甚至不需要swap 分区。在拥有 2 GB 以上物理内存的情况下，不使用 swap 分区可以获得更好的性能。**注意: **如果你要使用休眠到磁盘功能，你需要参考<a href="https://wiki.archlinux.org/index.php/Suspend_and_hibernate#About_swap_partition.2Ffile_size">Suspend and hibernate#About swap partition&#x2F;file size</a>。</td>
<td>swap - [不定]</td>
</tr>
<tr>
<td>可以为需要多用户共享的文件建立一个“data”分区。也可以使用 &#x2F;home 分区用于这一目的。</td>
<td>&#x2F;data - [不定]</td>
</tr>
<tr>
<td></td>
<td>&#x2F;EFI- 512M</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>archlinux</category>
      </categories>
  </entry>
  <entry>
    <title>桌面环境与常用应用</title>
    <url>/2022/03/28/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Linux/archlinux/%E6%A1%8C%E9%9D%A2%E7%8E%AF%E5%A2%83%E4%B8%8E%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h2 id="更新系统"><a href="#更新系统" class="headerlink" title="更新系统"></a>更新系统</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -Syyu	#yy标记强制刷新 u标记升级动作</span><br></pre></td></tr></table></figure>

<h2 id="安装-KDE-Plasma-桌面环境"><a href="#安装-KDE-Plasma-桌面环境" class="headerlink" title="安装 KDE Plasma 桌面环境"></a>安装 KDE Plasma 桌面环境</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pacman -S plasma-meta konsole dolphin  #安装plasma-meta元软件包以及终端和文件管理器</span><br></pre></td></tr></table></figure>

<h2 id="配置-greeter-sddm"><a href="#配置-greeter-sddm" class="headerlink" title="配置 greeter sddm"></a>配置 greeter sddm</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable sddm</span><br></pre></td></tr></table></figure>

<h2 id="开启-32-位支持库"><a href="#开启-32-位支持库" class="headerlink" title="开启 32 位支持库"></a>开启 32 位支持库</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/pacman.conf		#！去掉[multilib]一节中两行的注释，来开启 32 位库支持。</span><br><span class="line">pacman -Syyu		#刷新 pacman 数据库</span><br></pre></td></tr></table></figure>

<h2 id="安装基础功能包"><a href="#安装基础功能包" class="headerlink" title="安装基础功能包"></a>安装基础功能包</h2><h3 id="网络配置"><a href="#网络配置" class="headerlink" title="网络配置"></a>网络配置</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl stop iwd                                                     #同上，立即关闭iwd</span><br><span class="line">sudo systemctl enable --now NetworkManager                                  #确保先启动NetworkManager</span><br></pre></td></tr></table></figure>

<h3 id="基础功能包"><a href="#基础功能包" class="headerlink" title="基础功能包"></a>基础功能包</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S ntfs-3g                                                      #识别NTFS格式的硬盘</span><br><span class="line">sudo pacman -S adobe-source-han-serif-cn-fonts wqy-zenhei                   #安装几个开源中文字体 一般装上文泉驿就能解决大多wine应用中文方块的问题</span><br><span class="line">sudo pacman -S noto-fonts-cjk noto-fonts-emoji noto-fonts-extra             #安装谷歌开源字体及表情</span><br><span class="line">sudo pacman -S firefox chromium                                             #安装常用的火狐、谷歌浏览器</span><br><span class="line">sudo pacman -S ark                                                          #与dolphin同用右键解压</span><br><span class="line">sudo pacman -S p7zip unrar unarchiver lzop lrzip                            #安装ark可选依赖</span><br><span class="line">sudo pacman -S packagekit-qt5 packagekit appstream-qt appstream             #确保Discover(软件中心）可用 需重启</span><br><span class="line">sudo pacman -S gwenview                                                     #图片查看器</span><br><span class="line">sudo pacman -S git wget kate bind                                                #一些工具</span><br></pre></td></tr></table></figure>

<h2 id="设置DNS"><a href="#设置DNS" class="headerlink" title="设置DNS"></a>设置DNS</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/resolv.con</span><br><span class="line"></span><br><span class="line">nameserver 8.8.8.8</span><br><span class="line">nameserver 2001:4860:4860::8888</span><br><span class="line">nameserver 8.8.4.4</span><br><span class="line">nameserver 2001:4860:4860::8844</span><br><span class="line"></span><br><span class="line">sudo chattr +i /etc/resolv.conf		#加入不可变标志</span><br></pre></td></tr></table></figure>

<h2 id="设置系统为中文"><a href="#设置系统为中文" class="headerlink" title="设置系统为中文"></a>设置系统为中文</h2><ol>
<li>打开 <em>System Settings</em> &gt; <em>Regional Settings</em> &gt; <em>Language</em> -&gt; <em>Add languages</em> 中选择中文加入，再拖拽到第一位，Apply。</li>
<li>再将_System Settings_ &gt; <em>Regional Settings</em> &gt; <em>Formats</em> 中的值设为中文-简体中文(zh_CN)</li>
</ol>
<h2 id="安装-yay"><a href="#安装-yay" class="headerlink" title="安装 yay"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/DE&App?id=_10%e5%ae%89%e8%a3%85-yay">安装 yay</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://archlinuxstudio.github.io/ArchLinuxTutorial/res/yay-bin-11.1.1-1-x86_64.pkg.tar.zst</span><br><span class="line">sudo pacman -U yay-bin-11.1.1-1-x86_64.pkg.tar.zst</span><br></pre></td></tr></table></figure>
<p>PS: 任何用户都可以上传自己制作的 AUR 包。由于任何人都可上传，也存在对应的风险，一般选用大众认可的包即可   github.io 也被中国大陆政府封锁，只是封锁力度暂时还没有很大。如你在下载过程中卡住，可以尝试 ctrl+c 终止命令后重新尝试下载  </p>
<h2 id="安装输入法"><a href="#安装输入法" class="headerlink" title="安装输入法"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/DE&App?id=_11%e5%ae%89%e8%a3%85%e8%be%93%e5%85%a5%e6%b3%95">安装输入法</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx5-im #基础包组</span><br><span class="line">sudo pacman -S fcitx5-chinese-addons #官方中文输入引擎</span><br><span class="line">sudo pacman -S fcitx5-anthy #日文输入引擎</span><br><span class="line">yay -S fcitx5-pinyin-moegirl #萌娘百科词库 由于中国大陆政府对github封锁，你可能在此卡住。如卡住，可根据后文设置好代理后再安装</span><br><span class="line">sudo pacman -S fcitx5-pinyin-zhwiki #中文维基百科词库</span><br><span class="line">sudo pacman -S fcitx5-material-color #主题</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EDITOR=vim sudoedit /etc/environment		#设置环境变量：编辑文件</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">加入以下内容</span></span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br></pre></td></tr></table></figure>

<h2 id="配置系统默认编辑器"><a href="#配置系统默认编辑器" class="headerlink" title="配置系统默认编辑器"></a><a href="https://archlinuxstudio.github.io/ArchLinuxTutorial/#/rookie/DE&App?id=_12%e9%85%8d%e7%bd%ae%e7%b3%bb%e7%bb%9f%e9%bb%98%e8%ae%a4%e7%bc%96%e8%be%91%e5%99%a8">配置系统默认编辑器</a></h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EDITOR=vim sudoedit /etc/profile</span><br><span class="line"></span><br><span class="line">export EDITOR=&#x27;vim&#x27;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>桌面系统</category>
        <category>archlinux</category>
      </categories>
  </entry>
  <entry>
    <title>VM安装Manjaro</title>
    <url>/2021/12/30/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Linux/manjaro/VM%E5%AE%89%E8%A3%85Manjaro/</url>
    <content><![CDATA[<p>虚拟机的版本选其它Linux5.x或更高版本内核</p>
<p><img src="https://s2.loli.net/2021/12/30/Nqjic4bEUVTwkR9.png#id=ZV6vq&originHeight=353&originWidth=776&originalType=binary&ratio=1&status=done&style=none#id=unyrP&originHeight=353&originWidth=776&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
]]></content>
      <tags>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>桌面系统</tag>
        <tag>Manjaro</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>manjaro</title>
    <url>/2022/01/06/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%A1%8C%E9%9D%A2%E7%B3%BB%E7%BB%9F/Linux/manjaro/manjaro/</url>
    <content><![CDATA[<p>安装后配置：</p>
<ol>
<li>更换国内源：</li>
</ol>
<p>sudo pacman-mirrors -c China</p>
<hr>
<ol start="2">
<li>添加archlinuxcn仓库</li>
</ol>
<p>定义： Arch Linux 中文社区仓库 是由 Arch Linux 中文社区驱动的非官方用户仓库。包含中文用户常用软件、工具、字体&#x2F;美化包等。</p>
<p>命令：sudo vi &#x2F;etc&#x2F;pacman.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在文件下追加</span><br><span class="line">[archlinuxcn]</span><br><span class="line"> SigLevel = Optional TrustedOnly</span><br><span class="line"> Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<hr>
<ol start="3">
<li>更新系统</li>
</ol>
<p>sudo pacman -Syyu</p>
<hr>
<ol start="4">
<li>安装archlinuxcn-keyring</li>
</ol>
<p>定义： 导入GPG key  。如果不导入安装某些软件可能会导致gpg签名错误损坏等sudo pacman -S archlinuxcn-keyring</p>
<hr>
<ol start="5">
<li>安装中文输入法</li>
<li>安装fcitx（ 小企鹅输入法  ）框架，以及可视化设置</li>
</ol>
<p>定义： 一个以 GPL 方式发布的输入法框架， 编写它的目是为桌面环境提供一个灵活的输入方案</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo pacman -S fcitx-im #默认全部安装</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>安装中文输入法</li>
</ol>
<p>sudo pacman -S fcitx-googlepinyinPS: 搜狗拼音在在最新的manjaro版本中有很多问题经常崩溃不建议使用，这里推荐使用fcitx-googlepinyin,你也可以选择fcitx-sunpinyin</p>
<ol start="3">
<li>新建~&#x2F;.xprofile文件，加入如下内容 – 为fcitx添加X会话的环境变量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GTK_IM_MODULE=fcitx</span><br><span class="line">export QT_IM_MODULE=fcitx</span><br><span class="line">export XMODIFIERS=&quot;@im=fcitx&quot;</span><br></pre></td></tr></table></figure>

<hr>
<ol start="6">
<li>更换中文文件夹为英文文件夹</li>
</ol>
<p>LC_ALL&#x3D;C xdg-user-dirs-update –force参考：<a href="https://wiki.archlinux.org/title/XDG_user_directories_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">XDG user directories (简体中文)</a></p>
]]></content>
      <tags>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>桌面系统</tag>
        <tag>manjaro</tag>
      </tags>
  </entry>
  <entry>
    <title>KM118设置</title>
    <url>/2021/10/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%A1%AC%E4%BB%B6/%E6%89%93%E5%8D%B0%E6%9C%BA/KM-118/KM118%E5%B7%A5%E5%85%B7%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p><a href="">118设置工具最新 V1.1.3.32</a>（密码:hzhs）<a href="https://pan.lanzoui.com/iYnXFwl2e1a?w">KM118_CLOUD_V1.01.30_GB18030_beta2</a><img src="https://cdn.nlark.com/yuque/0/2021/png/22295732/1637117836413-184bb32e-0240-432a-9594-b54534513416.png#clientId=uaca5a764-d91f-4&from=paste&height=556&id=u16dff77d&name=%E5%9B%BE%E7%89%87.png&originHeight=556&originWidth=487&originalType=binary&ratio=1&rotation=0&showTitle=false&size=24683&status=done&style=none&taskId=u031bcdb1-34cb-411a-a8eb-e08d870c325&title=&width=487" alt="图片.png">优先级如图也可先执行2试一下是否可行，不行再还原出厂设置对于KM118固件更新使用<a href="https://pan.lanzoui.com/iYnXFwl2e1a?w">KM118_CLOUD_V1.01.30_GB18030_beta2</a>进行更新</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>硬件</category>
        <category>打印机</category>
      </categories>
      <tags>
        <tag>打印机</tag>
        <tag>KM-118</tag>
        <tag>设置</tag>
      </tags>
  </entry>
  <entry>
    <title>C#基础-对象和类型</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/%E6%A6%82%E5%BF%B5/C#%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类包含成员，成员可以是静态成员或实例成员。静态成员属于类，实例成员属于对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Button okButton = new Button();	//创建一个Button对象。往后可以基于okButton 变量名.设置属性</span><br></pre></td></tr></table></figure>


<p><a href="https://blog.csdn.net/huan13479195089/article/details/126878583"> C#基础–对象和类型</a></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>C#</category>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>循环语句</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/%E6%A6%82%E5%BF%B5/%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>使用循环在面对大量数据时候会发生过久的载入时间。可以前期使用循环快速写出程序，后期优化成绑定的结构</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>C#</category>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>结构化修改程序思路设计</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/%E6%A6%82%E5%BF%B5/%E7%BB%93%E6%9E%84%E5%8C%96%E4%BF%AE%E6%94%B9%E7%A8%8B%E5%BA%8F%E6%80%9D%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<ol>
<li>目标 </li>
<li>思路设计</li>
<li>实现</li>
<li>修改日志</li>
<li>知识点</li>
<li>可优化（下一阶段进行）</li>
</ol>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>C#</category>
        <category>概念</category>
      </categories>
  </entry>
  <entry>
    <title>Tkinter</title>
    <url>/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/GUI/Tkinter/</url>
    <content><![CDATA[<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p><a href="https://zhuanlan.zhihu.com/p/435375856">tkinter的grid布局方法及参数图示讲解</a><a href="https://blog.csdn.net/u014663232/article/details/103224670">Python Tkinter详解 （十）控件的定位</a></p>
]]></content>
  </entry>
  <entry>
    <title>datetime_Python</title>
    <url>/2022/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%8C%85/datetime_Python/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datetime.datetime.now().strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"></span><br><span class="line">yesterday = time + datetime.timedelta(-<span class="number">1</span>)	<span class="comment">#减去一天</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
        <category>包</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>os_- Python</title>
    <url>/2022/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%8C%85/os_Python/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mkdir</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="comment"># 引入模块</span></span><br><span class="line">    <span class="keyword">import</span> os</span><br><span class="line">    <span class="comment"># 去除首位空格</span></span><br><span class="line">    path = path.strip()</span><br><span class="line">    <span class="comment"># 去除尾部 \ 符号</span></span><br><span class="line">    path = path.rstrip(<span class="string">&quot;\\&quot;</span>)</span><br><span class="line">    <span class="comment"># 判断路径是否存在</span></span><br><span class="line">    <span class="comment"># 存在     True</span></span><br><span class="line">    <span class="comment"># 不存在   False</span></span><br><span class="line">    isExists = os.path.exists(path)</span><br><span class="line">    <span class="comment"># 判断结果</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> isExists:</span><br><span class="line">        <span class="comment"># 如果不存在则创建目录</span></span><br><span class="line">        <span class="comment"># 创建目录操作函数</span></span><br><span class="line">        os.makedirs(path)</span><br><span class="line">        <span class="built_in">print</span>(path + <span class="string">&#x27; 创建成功&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果目录存在则不创建，并提示目录已存在</span></span><br><span class="line">        <span class="built_in">print</span>(path + <span class="string">&#x27; 目录已存在&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="comment"># 定义要创建的目录</span></span><br><span class="line">mkpath = <span class="string">&quot;E:\\工作文件夹\\web\\&quot;</span></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">mkdir(mkpath)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">source_path = os.path.abspath(<span class="string">r&#x27;E:\Projects\source_dir&#x27;</span>)</span><br><span class="line">target_path = os.path.abspath(<span class="string">r&#x27;E:\Projects\target_dir&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(target_path):</span><br><span class="line">    os.makedirs(target_path)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(source_path):</span><br><span class="line">    <span class="comment"># root 所指的是当前正在遍历的这个文件夹的本身的地址</span></span><br><span class="line">    <span class="comment"># dirs 是一个 list，内容是该文件夹中所有的目录的名字(不包括子目录)</span></span><br><span class="line">    <span class="comment"># files 同样是 list, 内容是该文件夹中所有的文件(不包括子目录)</span></span><br><span class="line">    <span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(source_path):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            src_file = os.path.join(root, file)</span><br><span class="line">            shutil.copy(src_file, target_path)</span><br><span class="line">            <span class="built_in">print</span>(src_file)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;copy files finished!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">os.remove(path)<span class="comment">#删除文件</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
        <category>包</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>selenium_Python</title>
    <url>/2023/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%8C%85/selenium_Python/</url>
    <content><![CDATA[<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chrome.exe --remote-debugging-port=9527 --user-data-dir=“F:\selenium\AutomationProfile</span><br><span class="line"></span><br><span class="line">user-data-dirr=“F:\selenium\AutomationProfile” 是在单独的配置文件中启动 chrome浏览器，可以理解为新的浏览器</span><br><span class="line">其中 9527 为端口号，可自行指定。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">options = Options()</span><br><span class="line">options.add_experimental_option(<span class="string">&quot;debuggerAddress&quot;</span>, <span class="string">&quot;127.0.0.1:9527&quot;</span>)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(browser.title)</span><br></pre></td></tr></table></figure>

<h2 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element_by_id 						(返回一个元素)</span><br><span class="line">find_element(s)_by_class_name 			(根据类名获取元素列表)</span><br><span class="line">find_element(s)_by_name 				(根据标签的name属性值返回包含标签对象元素的列表)</span><br><span class="line"></span><br><span class="line">find_element(s)_by_xpath 				(返回一个包含元素的列表)</span><br><span class="line">example：driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;loginid&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">find_element(s)_by_link_text 			(根据连接文本获取元素列表)</span><br><span class="line">find_element(s)_by_partial_link_text 	(根据链接包含的文本获取元素列表)</span><br><span class="line">find_element(s)_by_tag_name 			(根据标签名获取元素列表)</span><br><span class="line">find_element(s)_by_css_selector 		(根据css选择器来获取元素列表)</span><br></pre></td></tr></table></figure>

<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">element.click()</span><br><span class="line">对定位到的标签对象进行点击操作</span><br><span class="line"></span><br><span class="line">element.send_keys(data)</span><br><span class="line">对定位到的标签对象输入数据</span><br><span class="line"></span><br><span class="line">element.text</span><br><span class="line">通过定位获取的标签对象的text属性，获取文本内容</span><br><span class="line"></span><br><span class="line">element.get_attribute(<span class="string">&quot;属性名&quot;</span>)</span><br><span class="line">通过定位获取的标签对象的get_attribute函数，传入属性名，来获取属性的值</span><br><span class="line">example:<span class="built_in">input</span>.get_attribute(<span class="string">&#x27;value&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
        <category>包</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>xlwt</title>
    <url>/2022/04/25/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%8C%85/xlwt_Python/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># import xlwt</span></span><br><span class="line">file = xlwt.Workbook(encoding=<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 指定file以utf-8的格式打开</span></span><br><span class="line">table = file.add_sheet(<span class="string">&#x27;data&#x27;</span>)</span><br><span class="line"><span class="comment"># 指定打开的文件名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典数据</span></span><br><span class="line"></span><br><span class="line">ldata = []</span><br><span class="line">num = [a <span class="keyword">for</span> a <span class="keyword">in</span> data]</span><br><span class="line"><span class="comment"># for循环指定取出key值存入num中</span></span><br><span class="line">num.sort()</span><br><span class="line"><span class="comment"># 字典数据取出后无需，需要先排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> num:</span><br><span class="line">    <span class="comment"># for循环将data字典中的键和值分批的保存在ldata中</span></span><br><span class="line">    t = [<span class="built_in">int</span>(x)]</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> data[x]:</span><br><span class="line">        t.append(a)</span><br><span class="line">    ldata.append(t)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(ldata):</span><br><span class="line">    <span class="comment"># 将数据写入文件,i是enumerate()函数返回的序号数</span></span><br><span class="line">    <span class="keyword">for</span> j, q <span class="keyword">in</span> <span class="built_in">enumerate</span>(p):</span><br><span class="line">        <span class="comment"># print i,j,q</span></span><br><span class="line">        table.write(i, j, q)</span><br><span class="line">file.save(<span class="string">&#x27;data.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
        <category>包</category>
      </categories>
      <tags>
        <tag>Excel</tag>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python连接MySQL</title>
    <url>/2022/01/27/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%AE%9E%E7%8E%B0/Python%E8%BF%9E%E6%8E%A5MySQL/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开数据库连接</span></span><br><span class="line">db = MySQLdb.connect(<span class="string">&quot;localhost&quot;</span>, <span class="string">&quot;testuser&quot;</span>, <span class="string">&quot;test123&quot;</span>, <span class="string">&quot;TESTDB&quot;</span>, charset=<span class="string">&#x27;utf8&#x27;</span> )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用cursor()方法获取操作游标 </span></span><br><span class="line">cursor = db.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用execute方法执行SQL语句</span></span><br><span class="line">cursor.execute(<span class="string">&quot;SELECT VERSION()&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 fetchone() 方法获取一条数据</span></span><br><span class="line">data = cursor.fetchone()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Database version : %s &quot;</span> % data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭数据库连接</span></span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
        <category>实现</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>数据库</tag>
        <tag>Python</tag>
        <tag>计算机语言</tag>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title>Python连接sqlserver并实现数据库的读写操作</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%AE%9E%E7%8E%B0/Python%E8%BF%9E%E6%8E%A5sqlserver%E5%B9%B6%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%AF%BB%E5%86%99%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pyodbc</span><br><span class="line">import time</span><br><span class="line"></span><br><span class="line">class SQLServer():</span><br><span class="line">    def __init__(self, server, database):</span><br><span class="line">        self.server = server</span><br><span class="line">        self.database = database</span><br><span class="line">        self.cnxn = pyodbc.connect(</span><br><span class="line">            &#x27;DRIVER=&#123;SQL Server&#125;;SERVER=&#x27; + self.server + &#x27;;DATABASE=&#x27; + self.database + &#x27;;Trusted_Connection=yes&#x27;)</span><br><span class="line">        self.cursor = self.cnxn.cursor()</span><br><span class="line"></span><br><span class="line">    def close(self):</span><br><span class="line">        if self.cursor:</span><br><span class="line">            self.cursor.close()</span><br><span class="line">        if self.cnxn:</span><br><span class="line">            self.cnxn.close()</span><br><span class="line"></span><br><span class="line">    def call_stored_procedure_query(self, procedure_name, *args):   #查询操作</span><br><span class="line">        placeholders = &#x27;,&#x27;.join([&#x27;?&#x27; for _ in args])</span><br><span class="line">        query = f&quot;&#123;&#123;CALL &#123;procedure_name&#125; (&#123;placeholders&#125;)&#125;&#125;&quot;</span><br><span class="line">        if not args:</span><br><span class="line">            query = f&quot;&#123;&#123;CALL &#123;procedure_name&#125;&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">        retry_count = 0</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                self.cursor.nextset()</span><br><span class="line">                self.cursor.execute(query, args)</span><br><span class="line">                break</span><br><span class="line">            except pyodbc.Error as ex:	#异常处理</span><br><span class="line">                retry_count += 1</span><br><span class="line">                if retry_count &gt; 10:</span><br><span class="line">                    raise ex</span><br><span class="line">                if ex[0] == &quot;08S01&quot;:	#判断是否断网，尝试重新连接</span><br><span class="line">                    self.cnxn = pyodbc.connect(</span><br><span class="line">                        &#x27;DRIVER=&#123;SQL Server&#125;;SERVER=&#x27; + self.server + &#x27;;DATABASE=&#x27; + self.database + &#x27;;Trusted_Connection=yes&#x27;)</span><br><span class="line">                    self.cursor = self.cnxn.cursor()</span><br><span class="line">                print(f&quot;Error executing stored procedure: &#123;ex&#125;. Retrying in 5 seconds...&quot;)</span><br><span class="line">                time.sleep(5)</span><br><span class="line"></span><br><span class="line">        a = []</span><br><span class="line">        for i in self.cursor:</span><br><span class="line">            a.append(i)</span><br><span class="line">        return a</span><br><span class="line"></span><br><span class="line">    def call_stored_procedure_insert(self, procedure_name, *args):  #插入操作</span><br><span class="line">        placeholders = &#x27;,&#x27;.join([&#x27;?&#x27; for _ in args])</span><br><span class="line">        query = f&quot;&#123;&#123;CALL &#123;procedure_name&#125; (&#123;placeholders&#125;)&#125;&#125;&quot;</span><br><span class="line">        if not args:</span><br><span class="line">            query = f&quot;&#123;&#123;CALL &#123;procedure_name&#125;&#125;&#125;&quot;</span><br><span class="line"></span><br><span class="line">        retry_count = 0</span><br><span class="line">        while True:</span><br><span class="line">            try:</span><br><span class="line">                self.cursor.nextset()</span><br><span class="line">                self.cursor.execute(query, args)</span><br><span class="line">                self.cnxn.commit()</span><br><span class="line">                break</span><br><span class="line">            except pyodbc.Error as ex:</span><br><span class="line">                retry_count += 1</span><br><span class="line">                if retry_count &gt; 10:</span><br><span class="line">                    raise ex</span><br><span class="line">                if ex[0] == &quot;08S01&quot;:</span><br><span class="line">                    self.cnxn = pyodbc.connect(</span><br><span class="line">                        &#x27;DRIVER=&#123;SQL Server&#125;;SERVER=&#x27; + self.server + &#x27;;DATABASE=&#x27; + self.database + &#x27;;Trusted_Connection=yes&#x27;)</span><br><span class="line">                    self.cursor = self.cnxn.cursor()</span><br><span class="line">                print(f&quot;Error executing stored procedure: &#123;ex&#125;. Retrying in 5 seconds...&quot;)</span><br><span class="line">                time.sleep(5)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化连接</span><br><span class="line">sqlconnent = SQLServer(&#x27;服务器地址&#x27;, &#x27;数据库名&#x27;)</span><br><span class="line"># 查询操作</span><br><span class="line">sqlconnent.call_stored_procedure_query(&#x27;存储过程名&#x27;)</span><br><span class="line">#	插入操作</span><br><span class="line">sqlconnent.call_stored_procedure_insert(&#x27;存储过程名&#x27;, str(value1)， int(value2)</span><br><span class="line"># 关闭数据库连接</span><br><span class="line">sqlconnent.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
        <category>实现</category>
      </categories>
  </entry>
  <entry>
    <title>使用Python批量文字识别 (使用百度API)</title>
    <url>/2023/04/23/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%AE%9E%E7%8E%B0/%E4%BD%BF%E7%94%A8Python%E6%89%B9%E9%87%8F%E6%96%87%E5%AD%97%E8%AF%86%E5%88%AB%20(%E4%BD%BF%E7%94%A8%E7%99%BE%E5%BA%A6API)/</url>
    <content><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#UTF-8</span></span><br><span class="line"><span class="comment">#python图片批量转文字</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> aip <span class="keyword">import</span> AipOcr            <span class="comment">#没有安装aip包的记得要cmd-&gt; pip install baidu-aip</span></span><br><span class="line"></span><br><span class="line">APP_ID = <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">API_KEY = <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line">SECRET_KEY = <span class="string">&#x27;XXX&#x27;</span></span><br><span class="line"></span><br><span class="line">client = AipOcr(APP_ID, API_KEY, SECRET_KEY)</span><br><span class="line">os.chdir(<span class="string">r&#x27;D:\xxxx&#x27;</span>)   <span class="comment">#这个地方的路径是保存的图片的根目录,注意,该根目录下不能有文件夹</span></span><br><span class="line">lt = os.listdir()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> lt:</span><br><span class="line">    img = <span class="built_in">open</span>(c, <span class="string">&#x27;rb&#x27;</span>).read()</span><br><span class="line">    <span class="comment">#调用接口来识别								</span></span><br><span class="line">    msg = client.basicAccurate(img)  <span class="comment">#accurate,通用文字识别（高精度含位置版）一天只能调用50次</span></span><br><span class="line">     <span class="comment">#basicAccurate通用文字识别（高精度版) 500次	 如果使用basicGeneral,就是通用文字识别（标准版）</span></span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> msg.get(<span class="string">&#x27;words_result&#x27;</span>):		</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;D:\xxxx.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:   <span class="comment">#保存的文件位置</span></span><br><span class="line">            f.write(i.get(<span class="string">&#x27;words&#x27;</span>))</span><br><span class="line">            f.write(<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;D:\xxxx.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:		<span class="comment">#每打印出张图片回车一次,方便阅读</span></span><br><span class="line">        f.write(<span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
        <category>实现</category>
      </categories>
      <tags>
        <tag>百度API</tag>
        <tag>文本识别</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/2022/02/07/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E6%95%99%E7%A8%8B/Python/</url>
    <content><![CDATA[<h2 id="这篇文档不涉及具体函数的调用"><a href="#这篇文档不涉及具体函数的调用" class="headerlink" title="这篇文档不涉及具体函数的调用"></a>这篇文档不涉及具体函数的调用</h2><h2 id="1-编程之路"><a href="#1-编程之路" class="headerlink" title="1. 编程之路"></a>1. 编程之路</h2><p>计算机科学家像数学家一样，使用规范的语言来阐述思想（尤其是一些计算）；像工程师一样设计、组装系统，并且在多重选择中寻找最优解；像自然科学家一样观察复杂系统的行为模式，建立猜想，测试预估的结果。唯一最重要的技能就是『解决问题』。解决问题意味着要有能力把问题进行方程化，创造性地考虑解决思路，并且清晰又精确地表达出解决方案</p>
<h3 id="1-1-程序是什么？"><a href="#1-1-程序是什么？" class="headerlink" title="1.1 程序是什么？"></a>1.1 程序是什么？</h3><p>程序是一个指令的序列，来告诉机器如何进行一组运算。这种运算也许是数学上的，比如求解一组等式或者求多项式的根；当然也可以是符号运算，比如在文档中搜索和替换文字，或者一些图形化过程，比如处理图像或者播放一段视频编程的基础指令：输入系统、输出系统、数学运算、条件判断、重复判断编程的过程理解成一个把庞大复杂任务进行拆分来解决的过程，分解到适合使用上述的基本指令来解决为止。</p>
<h3 id="1-2-运算符"><a href="#1-2-运算符" class="headerlink" title="1.2 运算符"></a>1.2 运算符</h3><p>“+”、”-“、”*”、”&#x2F;“、”%”</p>
<h3 id="1-3-值和类型"><a href="#1-3-值和类型" class="headerlink" title="1.3 值和类型"></a>1.3 值和类型</h3><p>type(需要判断的对象)		#判断一个值是什么类型</p>
<hr>
<h3 id="1-4-公示语言和自然语言"><a href="#1-4-公示语言和自然语言" class="headerlink" title="1.4 公示语言和自然语言"></a>1.4 公示语言和自然语言</h3><p>定义：自然语言：就是人说的语言，比如英语、西班牙语、法语，当然包括中文了。他们往往都不是人主动去设计出来的（当然，人会试图去分析语言的规律），自然而然地发生演进。公式语言：人们为了特定用途设计出来的。比如数学的符号就是一种公式语言，特别适合表达数字和符号只见的关系。化学家也用元素符号和化学方程式来表示分子的化学结构。</p>
<hr>
<p>语法规则体现在两个方面，代号和结构。公式语言的语法规则是代号必须有严格的组合结构。你读一句英语或者公式语言中的语句时候，你必须搞清楚结构（虽然在自然语言中大家潜意识就能搞定了）。这就叫做解译。两者的差异：二义性、冗余性、文字修辞计算机程序的意义必须是无歧义和文采修饰的，能完全用代号和结构的方式进行解析。</p>
<hr>
<h2 id="2-变量，表达式，语句"><a href="#2-变量，表达式，语句" class="headerlink" title="2. 变量，表达式，语句"></a>2. 变量，表达式，语句</h2><h3 id="2-1-赋值语句"><a href="#2-1-赋值语句" class="headerlink" title="2.1 赋值语句"></a>2.1 赋值语句</h3><p>赋值语句的作用是创建一个新的变量，并且赋值给这个变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span>		<span class="comment">#数值</span></span><br><span class="line">a= <span class="string">&#x27;123&#x27;</span>	<span class="comment">#字符串</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-变量名称"><a href="#2-2-变量名称" class="headerlink" title="2.2 变量名称"></a>2.2 变量名称</h3><p>一般情况就用名字来表示这个变量的用途了变量名里面可以有下划线_，一般在多个单词组成的变量名里面往往用到下划线，比如your_name等等。</p>
<h3 id="2-3-表达式和语句"><a href="#2-3-表达式和语句" class="headerlink" title="2.3 表达式和语句"></a>2.3 表达式和语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">123</span></span><br><span class="line">a + <span class="number">123</span></span><br></pre></td></tr></table></figure>
<p>表达式是数值,变量和操作符的组合。单个值本身也被当作一个表达式，变量也是如此语句是一组具有某些效果的代码，比如创建变量，或者显示值。</p>
<h3 id="2-4-脚本模式"><a href="#2-4-脚本模式" class="headerlink" title="2.4 脚本模式"></a>2.4 脚本模式</h3><p>Python的交互模式，就是直接咱们人跟解释器来交互所以就有另一种选择了，把代码保存成脚本，然后用脚本模式让解释器来运行这些脚本。通常Python脚本文件的扩展名是.pyPython两种模式都支持，所以你可以先用交互模式做点测试，然后再写成脚本。但是两种模式之间有些区别的，所以可能也挺麻烦。</p>
<h3 id="2-5-运算符优先级"><a href="#2-5-运算符优先级" class="headerlink" title="2.5 运算符优先级"></a>2.5 运算符优先级</h3><p>括号&gt;乘方&gt;乘除&gt;加减</p>
<h3 id="2-6-字符串操作"><a href="#2-6-字符串操作" class="headerlink" title="2.6 字符串操作"></a>2.6 字符串操作</h3><p>+：字符串拼接*：字符串重复n次</p>
<h3 id="2-7-注释"><a href="#2-7-注释" class="headerlink" title="2.7 注释"></a>2.7 注释</h3><p>使用”#”来开头【pycharm】中可以使用【ctrl+&#x2F;】来实现注释快捷键</p>
<h3 id="2-8-调试"><a href="#2-8-调试" class="headerlink" title="2.8 调试"></a>2.8 调试</h3><p>定义：前置条件：要在函数开始运行之前就要实现才行后置条件：后置条件包含函数的预期效果（如画线段）和其他作用</p>
<hr>
<p>语法错误运行错误：显而易见了，就是直到运行的时候才会出现的错误。这种错误也被叫做异常，因为一般表示一些意外的尤其是比较糟糕的情况发生了语义错误：这种错误是指你的程序运行没问题，也不产生错误信息，但不能正确工作。程序可能做一些和设计目的不同的事情。调试也有点像一门实验科学。一旦你有了一个关于所出现的错误的想法，你就修改一下程序再试试看。如果你的假设是正确的，你就能够预料到修改导致的结果，这样在编程的水平上，你就上了一层台阶了，距离让程序工作起来也更近了。</p>
<p>前置条件是准备给函数调用者的。如果调用者违背了（妥当标注的）前置条件，然后函数不能正常工作，这个bug就会反馈在函数调用者上，而不是函数本身。如果前置条件得到了满足，而后置条件未能满足，这个bug就是函数的了。所以如果你的前后置条件都弄清晰，对调试很有帮助。</p>
<p>『对折调试』是一种节省调试时间的方法。比如，如果你的程序有100行，你检查一遍就要大概100步了。而对折方法就是把程序分成两半。看程序中间位置，或者靠近中间位置的，检查一些中间值。在这些位置添加一些print语句（或者其他能够能起到验证效果的东西），然后运行程序</p>
<hr>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><h3 id="3-1-函数调用"><a href="#3-1-函数调用" class="headerlink" title="3.1 函数调用"></a>3.1 函数调用</h3><p>一般来说，函数都要“传入”一个参数，“返回”一个结果。结果也被叫做返回值。Python提供了一些转换数值类型的函数。</p>
<h3 id="3-2-Math-functions"><a href="#3-2-Math-functions" class="headerlink" title="3.2 Math functions"></a>3.2 Math functions</h3><p>Python内置了一个数学模块，这一模块提供了绝大部分常用的数学函数。模块就是一系列相关函数的集合成的文件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math		<span class="comment">#导入语句</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-组合"><a href="#3-3-组合" class="headerlink" title="3.3 组合"></a>3.3 组合</h3><p>对语句的前后循环自行拼接成一条可以执行的语句</p>
<h3 id="3-4-添加新函数"><a href="#3-4-添加新函数" class="headerlink" title="3.4 添加新函数"></a>3.4 添加新函数</h3><p>函数定义要指定这个函数的名字，还需要一系列语句放到这个函数里面，当调用这个函数的时候，就会运行这些语句了。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">function_name</span>():	&lt;--头部</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)	&lt;--函数体</span><br></pre></td></tr></table></figure>

<h3 id="3-5-定义并使用"><a href="#3-5-定义并使用" class="headerlink" title="3.5 定义并使用"></a>3.5 定义并使用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">接上文</span><br><span class="line">function_name()	<span class="comment">#调用function_name函数</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-运行流程"><a href="#3-6-运行流程" class="headerlink" title="3.6 运行流程"></a>3.6 运行流程</h3><p>一个Python程序都是从第一个语句开始运行的。从首至尾，每次运行一个语句。函数的定义并不会改变程序的运行流程，但要注意，函数体内部的语句只有在函数被调用的时候才会运行。</p>
<h3 id="3-7-形式参数和实际参数"><a href="#3-7-形式参数和实际参数" class="headerlink" title="3.7 形式参数和实际参数"></a>3.7 形式参数和实际参数</h3><p>在函数里面，实际参数会被赋值给形式参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_twice</span>(<span class="params">bruce</span>):</span><br><span class="line">		<span class="built_in">print</span>(bruce)</span><br><span class="line">		<span class="built_in">print</span>(bruce)</span><br><span class="line">这个函数把传来的实际参数的值赋给了一个名字叫做burce的形式参数</span><br></pre></td></tr></table></figure>
<p>适用于Python内置函数的组合规则对自定义的函数也是适用的，所以我们可以把表达式作为实际参数传递参数的时候用的是实际参数，是把这个实际参数的值交给调用的函数，函数内部接收这个值，可以命名成任意其他名字的形式参数</p>
<h3 id="3-8-函数内部变量和形参都是局部的"><a href="#3-8-函数内部变量和形参都是局部的" class="headerlink" title="3.8 函数内部变量和形参都是局部的"></a>3.8 函数内部变量和形参都是局部的</h3><p>在函数内部建立一个变量，这个变量是仅在函数体内部才存在形式参数也是局部起作用的。例如在print_twice这个函数之外，是不存在bruce这个变量的。</p>
<h3 id="3-9-有返回值的函数-和-无返回值的函数"><a href="#3-9-有返回值的函数-和-无返回值的函数" class="headerlink" title="3.9 有返回值的函数 和 无返回值的函数"></a>3.9 有返回值的函数 和 无返回值的函数</h3><p>有返回值的函数：比如数学的函数，都会返回各种结果无返回值的函数：比如print_twice，都是进行一些操作，但不返回值</p>
<h3 id="3-10-为什么要用函数？"><a href="#3-10-为什么要用函数？" class="headerlink" title="3.10 为什么要用函数？"></a>3.10 为什么要用函数？</h3><ol>
<li>创建一个新的函数，你就可以把一组语句用一个名字来命名，这样你的程序读起来就清晰多了，后期维护调试也方便</li>
<li>函数的出现能够避免代码冗余，程序内的一些重复的内容就会简化了，变得更小巧。而且在后期进行修改的时候，你只要改函数中的一处地方就可以了，很方便</li>
<li>把长的程序切分成一个个函数，你就可以一步步来debug调试，每次只应对一小部分就可以，然后把它们组合起来就可以用了</li>
<li>精细设计的函数会对很多程序都有用处。一旦你写好了并且除了错，这种函数代码可以再利用</li>
</ol>
<h3 id="3-11-调试"><a href="#3-11-调试" class="headerlink" title="3.11 调试"></a>3.11 调试</h3><p>对于一些人来说，编程和调试是一回事。也就是说，编程就是对一个程序逐渐进行调试，一直到程序按照设想工作为止。这种思想意味着你要从一段能工作的程序来起步，一点点做小修改和调试。</p>
<h2 id="4-一个实例"><a href="#4-一个实例" class="headerlink" title="4. 一个实例"></a>4. 一个实例</h2><h3 id="4-1-模块调用"><a href="#4-1-模块调用" class="headerlink" title="4.1 模块调用"></a>4.1 模块调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">bob = turtle.Turtle()	<span class="comment">#实例化模块</span></span><br><span class="line">bob.fd(<span class="number">50</span>)</span><br><span class="line">turtle.mainloop()	<span class="comment">#mainloop函数是告诉窗口等待用户来做些事情</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-简单的重复"><a href="#4-2-简单的重复" class="headerlink" title="4.2 简单的重复"></a>4.2 简单的重复</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-3-封装"><a href="#4-3-封装" class="headerlink" title="4.3 封装"></a>4.3 封装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">bob = turtle.Turtle()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">t</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        t.fd(<span class="number">100</span>)</span><br><span class="line">        t.lt(<span class="number">90</span>)</span><br><span class="line">square(bob)</span><br></pre></td></tr></table></figure>
<p>封装：用函数的形式把一段代码包装起来</p>
<h3 id="4-4-泛化"><a href="#4-4-泛化" class="headerlink" title="4.4 泛化"></a>4.4 泛化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">bob = turtle.Turtle()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">square</span>(<span class="params">t,length</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        t.fd(length)</span><br><span class="line">        t.lt(<span class="number">90</span>)</span><br><span class="line">square(bob,<span class="number">100</span>)</span><br></pre></td></tr></table></figure>
<p>泛化：给函数添加参数，就叫做泛化，因为者可以让函数的功能更广泛</p>
<h3 id="4-5-重构"><a href="#4-5-重构" class="headerlink" title="4.5 重构"></a>4.5 重构</h3><p>将某个方法重写一下，将其实现其他功能</p>
<h3 id="4-6-开发计划"><a href="#4-6-开发计划" class="headerlink" title="4.6 开发计划"></a>4.6 开发计划</h3><p>开发计划是写程序的一系列过程。我们本章所用的就是『封装-泛化』的模式。这一过程的步骤如下：</p>
<ol>
<li>开始写一个特别小的程序，没有函数定义。</li>
<li>一旦有你的程序能用了，确定一下实现功能的这部分有练习的语句，封装成函数，并命名一下。</li>
<li>通过逐步给这个函数增加参数的方式来泛化。</li>
<li>重复1-3步骤，一直到你有了一系列能工作的函数为止。把函数复制粘贴出来，避免重复输入或者修改了。</li>
<li>看看是不是有通过重构来改进函数的可能。比如，假设你在一些地方看到了相似的代码，就可以把这部分代码做成一个函数。</li>
</ol>
<hr>
<h3 id="4-7-文档字符串"><a href="#4-7-文档字符串" class="headerlink" title="4.7 文档字符串"></a>4.7 文档字符串</h3><p>文档字符串是指：在函数开头部位，解释函数的交互界面的字符串，doc是文档</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">polyline</span>(<span class="params">t, n, length, angle</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Draws n line segments with the given length and angle (in degrees) between them.</span></span><br><span class="line"><span class="string">t is a turtle. &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">t.fd(length)</span><br><span class="line">t.lt(angle)</span><br></pre></td></tr></table></figure>

<h2 id="5-条件循环"><a href="#5-条件循环" class="headerlink" title="5. 条件循环"></a>5. 条件循环</h2><h3 id="5-1-地板除和求模"><a href="#5-1-地板除和求模" class="headerlink" title="5.1 地板除和求模"></a>5.1 地板除和求模</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">a <span class="operator">=</span> <span class="number">105</span></span><br><span class="line">b <span class="operator">=</span> a <span class="operator">/</span> <span class="number">60</span>	#[b<span class="operator">=</span><span class="number">1.75</span>]</span><br><span class="line">c <span class="operator">=</span> a <span class="operator">/</span><span class="operator">/</span> <span class="number">60</span>	#[c<span class="operator">=</span><span class="number">1</span>]地板除法会把运算结果的小数位舍弃，返回整值</span><br><span class="line">d <span class="operator">=</span> a <span class="operator">%</span> <span class="number">60</span> #[d<span class="operator">=</span><span class="number">45</span>]两个数相除然后返回余数</span><br></pre></td></tr></table></figure>

<h3 id="5-2-布尔表达式"><a href="#5-2-布尔表达式" class="headerlink" title="5.2 布尔表达式"></a>5.2 布尔表达式</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> <span class="operator">=</span><span class="operator">=</span> <span class="number">5</span> #<span class="literal">true</span>	运算符&quot;==&quot;</span><br><span class="line"><span class="number">5</span> <span class="operator">=</span><span class="operator">=</span> <span class="number">6</span> #<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-逻辑运算符"><a href="#5-3-逻辑运算符" class="headerlink" title="5.3 逻辑运算符"></a>5.3 逻辑运算符</h3><p>逻辑运算符有三种：且，或以及非</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">42</span> <span class="keyword">and</span> <span class="literal">true</span>	#且运算	全真为真</span><br><span class="line">a<span class="operator">%</span><span class="number">2</span> <span class="operator">=</span><span class="operator">=</span> <span class="number">0</span> <span class="keyword">or</span> a<span class="operator">%</span><span class="number">3</span> <span class="operator">=</span><span class="operator">=</span><span class="number">0</span>	#或运算，一真即真</span><br><span class="line"><span class="keyword">not</span>(x<span class="operator">&gt;</span>y)	#如果x<span class="operator">&gt;</span>y为真，那么x<span class="operator">&gt;</span>y即假，即x小于等于y</span><br></pre></td></tr></table></figure>

<h3 id="5-4-条件执行"><a href="#5-4-条件执行" class="headerlink" title="5.4 条件执行"></a>5.4 条件执行</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">	<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h3 id="5-5-选择执行"><a href="#5-5-选择执行" class="headerlink" title="5.5 选择执行"></a>5.5 选择执行</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x is even&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x is odd&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-6-链式条件"><a href="#5-6-链式条件" class="headerlink" title="5.6 链式条件"></a>5.6 链式条件</h3><p>有时我们要面对的可能性不只有两种，需要更多的分支。这时候可以使用连锁条件来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x is less than y&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x &gt; y:		<span class="comment">#elif是『else if』的缩写</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x is greater than y&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:		<span class="comment">#else语句必须放到整个条件链；不过else语句并不是必须有的</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x and y are equal&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-7-嵌套条件"><a href="#5-7-嵌套条件" class="headerlink" title="5.7 嵌套条件"></a>5.7 嵌套条件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x and y are equal&#x27;</span>)	</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> x &lt; y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;x is less than y&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;x is greater than y&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-8-递归运算"><a href="#5-8-递归运算" class="headerlink" title="5.8 递归运算"></a>5.8 递归运算</h3><p>一个函数可以去调用另一个函数；函数来调用自己也是允许的。这就是递归;执行这种函数的过程就叫递归运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Blastoff!&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">        countdown(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-9-无穷递归"><a href="#5-9-无穷递归" class="headerlink" title="5.9 无穷递归"></a>5.9 无穷递归</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">recurse</span>():</span><br><span class="line">    recurse()</span><br></pre></td></tr></table></figure>

<h3 id="5-10-键盘输入"><a href="#5-10-键盘输入" class="headerlink" title="5.10 键盘输入"></a>5.10 键盘输入</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;What...is your name?</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-有返回值的函数"><a href="#6-有返回值的函数" class="headerlink" title="6. 有返回值的函数"></a>6. 有返回值的函数</h2><h2 id="6-1-返回值"><a href="#6-1-返回值" class="headerlink" title="6.1 返回值"></a>6.1 返回值</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">radius</span>):</span><br><span class="line">    a = math.pi * radius**<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">absolute_value</span>(<span class="params">x</span>):</span><br><span class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> -x</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure>

<h3 id="6-2-增量式开发"><a href="#6-2-增量式开发" class="headerlink" title="6.2 增量式开发"></a>6.2 增量式开发</h3><p>要应对越来越复杂的程序，你不妨来试试增量式开发的办法。增量式开发的目的是避免长时间的调试过程，一点点对已有的小规模代码进行增补和测试</p>
<p>这个函数只需要返回一个值。我们写得这些print打印语句都是用来调试的，但一旦程序能正常工作了，就应该把print语句去掉。这些print代码也叫『脚手架代码』因为是用来构建程序的，但不会被存放在最终版本的程序中</p>
<p>这个过程的核心如下：</p>
<ol>
<li>一定要用一个能工作的程序来开始，每次逐渐添加一些细小增补。在任何时候遇到错误，都应该弄明白错误的位置。</li>
<li>用一些变量来存储中间值，这样你可以显示一下这些值，来检查一下。</li>
<li>程序一旦能工作了，你就应该把一些发挥『脚手架作用』的代码删掉，并且把重复的语句改写成精简版本，但尽量别让程序变得难以阅读。</li>
</ol>
<h3 id="6-3-布尔函数"><a href="#6-3-布尔函数" class="headerlink" title="6.3 布尔函数"></a>6.3 布尔函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_divisible</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> x % y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h2 id="7-迭代"><a href="#7-迭代" class="headerlink" title="7. 迭代"></a>7. 迭代</h2><h3 id="7-1-再赋值"><a href="#7-1-再赋值" class="headerlink" title="7.1 再赋值"></a>7.1 再赋值</h3><p>对同一个变量可以多次进行赋值。一次新的赋值使得已有的变量获得新的值</p>
<h3 id="7-2-更新变量"><a href="#7-2-更新变量" class="headerlink" title="7.2 更新变量"></a>7.2 更新变量</h3><p>这种情况下新的值是在旧值基础上进行修改得到的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = x + <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-循环：While语句"><a href="#7-3-循环：While语句" class="headerlink" title="7.3 循环：While语句"></a>7.3 循环：While语句</h3><p>在一个计算机程序里面，重复操作也被叫做迭代。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(n)</span><br><span class="line">        n = n - <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Blastoff!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-4-中断"><a href="#7-4-中断" class="headerlink" title="7.4 中断"></a>7.4 中断</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    line = <span class="built_in">input</span>(<span class="string">&#x27;&gt; &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> line == <span class="string">&#x27;done&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>		<span class="comment">#中断语句&quot;break&quot;</span></span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Done!&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="7-5-平方根"><a href="#7-5-平方根" class="headerlink" title="7.5 平方根"></a>7.5 平方根</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(y-x) &lt; epsilon:</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<h3 id="7-6-算法"><a href="#7-6-算法" class="headerlink" title="7.6 算法"></a>7.6 算法</h3><p>比如找到一个n与9的成绩，你可以把n-1写成第一位，10-n携程第二位。这个技巧是应对任何个位数字乘以9的算式。这就是一个算法了！执行算法是很无聊的，但设计算法很有趣，是智力上的一种挑战，也是计算机科学的核心部分</p>
<h2 id="8-字符串"><a href="#8-字符串" class="headerlink" title="8. 字符串"></a>8. 字符串</h2><p>一个字符串是一个序列，意味着是对其他值的有序排列</p>
<h3 id="8-1-字符串是字符"><a href="#8-1-字符串是字符" class="headerlink" title="8.1 字符串是字符"></a>8.1 字符串是字符</h3><p>字符串就是一串有序的字符。你可以通过方括号操作符，每次去访问字符串中的一个字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruit = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line">letter = fruit[<span class="number">0</span>]</span><br></pre></td></tr></table></figure>

<h3 id="8-2-len长度"><a href="#8-2-len长度" class="headerlink" title="8.2 len长度"></a>8.2 len长度</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fruit = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line"><span class="built_in">len</span>(fruit)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-用-for-循环进行遍历"><a href="#8-3-用-for-循环进行遍历" class="headerlink" title="8.3 用 for 循环进行遍历"></a>8.3 用 for 循环进行遍历</h3><p>很多计算过程都需要每次从一个字符串中拿一个字符。一般都是从头开始，依次得到每个字符，然后做点处理，然后一直到末尾。这种处理模式叫遍历。写一个遍历可以使用while 循环：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> index &lt; <span class="built_in">len</span>(fruit):</span><br><span class="line">    letter = fruit[index]</span><br><span class="line">    <span class="built_in">print</span>(letter)</span><br><span class="line">    index = index + <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>另外一种遍历的方法就是 for 循环了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> fruit:</span><br><span class="line">	<span class="built_in">print</span>(letter)</span><br></pre></td></tr></table></figure>

<h3 id="8-4-字符串切片"><a href="#8-4-字符串切片" class="headerlink" title="8.4 字符串切片"></a>8.4 字符串切片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x[n:m]</span><br><span class="line">x[:]		<span class="comment">#全部输出</span></span><br></pre></td></tr></table></figure>

<h3 id="8-5-字符串不可修改"><a href="#8-5-字符串不可修改" class="headerlink" title="8.5 字符串不可修改"></a>8.5 字符串不可修改</h3><p>你不能对一个已经存在的字符串进行任何改动。你顶多也就能建立一个新字符串，新字符串可以基于旧字符串进行一些改动。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">greeting = <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line">new_greeting = <span class="string">&#x27;J&#x27;</span> + greeting[<span class="number">1</span>:]</span><br></pre></td></tr></table></figure>

<h3 id="8-6-字符串方法"><a href="#8-6-字符串方法" class="headerlink" title="8.6 字符串方法"></a>8.6 字符串方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line">new_word = word.upper()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>new_word</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>BANANA</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">word = <span class="string">&#x27;banana&#x27;</span></span><br><span class="line">index = word.find(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>index</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="8-7-运算符-in"><a href="#8-7-运算符-in" class="headerlink" title="8.7 运算符 in"></a>8.7 运算符 in</h3><p>in 这个词在字符串操作中是一个布尔操作符，它读取两个字符串，如果前者的字符串为后者所包含，就返回真，否则为假：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;	<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> <span class="string">&#x27;banana&#x27;</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="9-列表"><a href="#9-列表" class="headerlink" title="9. 列表"></a>9. 列表</h2><h3 id="9-1-列表即序列"><a href="#9-1-列表即序列" class="headerlink" title="9.1 列表即序列"></a>9.1 列表即序列</h3><p>和字符串差不多，列表是一系列的数值的序列。在字符串里面，这些值是字符；在列表里面，这些值可以是任意类型的。一个列表中的值一般叫做列表的元素，有时候也叫列表项。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>]</span><br><span class="line">[<span class="string">&#x27;crunchy frog&#x27;</span>, <span class="string">&#x27;ram bladder&#x27;</span>, <span class="string">&#x27;lark vomit&#x27;</span>]</span><br></pre></td></tr></table></figure>
<p>列表内部可以包含一个列表作为元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="string">&#x27;spam&#x27;</span>, <span class="number">2.0</span>, <span class="number">5</span>, [<span class="number">10</span>, <span class="number">20</span>]]</span><br></pre></td></tr></table></figure>

<h3 id="9-2-列表元素可修改"><a href="#9-2-列表元素可修改" class="headerlink" title="9.2 列表元素可修改"></a>9.2 列表元素可修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cheeses[<span class="number">0</span>]		<span class="comment">#方括号内的数字用来确定索引位置</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">numbers = [<span class="number">42</span>, <span class="number">123</span>]</span><br><span class="line">numbers[<span class="number">1</span>] = <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="9-3-遍历一个列表"><a href="#9-3-遍历一个列表" class="headerlink" title="9.3 遍历一个列表"></a>9.3 遍历一个列表</h3><p>最常用的办法就是 for 循环了</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> cheese <span class="keyword">in</span> cheeses:</span><br><span class="line">    <span class="built_in">print</span>(cheese)</span><br></pre></td></tr></table></figure>

<h3 id="9-4-列表运算符"><a href="#9-4-列表运算符" class="headerlink" title="9.4 列表运算符"></a>9.4 列表运算符</h3><p>加号+运算符可以把列表拼接在一起：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = a + b</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] * <span class="number">3</span>	<span class="comment">#星号*运算符可以将列表重复指定的次数：</span></span><br></pre></td></tr></table></figure>

<h3 id="9-5-列表切片"><a href="#9-5-列表切片" class="headerlink" title="9.5 列表切片"></a>9.5 列表切片</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>]</span><br><span class="line">	t[<span class="number">1</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="9-6-列表的方法"><a href="#9-6-列表的方法" class="headerlink" title="9.6 列表的方法"></a>9.6 列表的方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">t.append(<span class="string">&#x27;d&#x27;</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t1 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">t2 = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>]</span><br><span class="line">t1.extend(t2)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = [<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">t.sort()</span><br></pre></td></tr></table></figure>

<h3 id="9-7-列表的运算"><a href="#9-7-列表的运算" class="headerlink" title="9.7 列表的运算"></a>9.7 列表的运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sum</span>(t)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="9-8-删除元素"><a href="#9-8-删除元素" class="headerlink" title="9.8 删除元素"></a>9.8 删除元素</h3><p>从一个列表中删除元素有几种方法。如果你知道你要删除元素的索引，你就可以用 pop这个方法来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = a.pop(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">[<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p>如果你不需要删掉的值了，你可以用 del 运算符来实现：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">del</span> a[<span class="number">1</span>]	<span class="comment">#可切片：del a[1:5]</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>
<p>如果你知道你要删除的元素值，但不知道索引位置，你可以使用 remove 这个方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.remove(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h3 id="9-9-列表和字符串"><a href="#9-9-列表和字符串" class="headerlink" title="9.9 列表和字符串"></a>9.9 列表和字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">join：将字符串转换成一个个元素，并转变成列表</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;test-and-test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27;-&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = a.split(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t</span><br><span class="line">[<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;and&#x27;</span>,<span class="string">&#x27;test&#x27;</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">solit：将列表的元素转变成字符串</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="string">&#x27;test&#x27;</span>,<span class="string">&#x27;and&#x27;</span>,<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27; &#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c = b.join(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="string">&#x27;test and test&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="9-10-对象和值"><a href="#9-10-对象和值" class="headerlink" title="9.10 对象和值"></a>9.10 对象和值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span>	<span class="comment">#结果为真，即两个变量指向的是同一个对象。如果你创建的是一个列表，那么就是两个对象，结果即False</span></span><br></pre></td></tr></table></figure>

<h3 id="9-11-别名"><a href="#9-11-别名" class="headerlink" title="9.11 别名"></a>9.11 别名</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b <span class="keyword">is</span> a	<span class="comment">#修改其中任何一个的值，也会导致另外一个值一起变化</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h2 id="10-字典"><a href="#10-字典" class="headerlink" title="10. 字典"></a>10. 字典</h2><h3 id="10-1-字典是一种映射"><a href="#10-1-字典是一种映射" class="headerlink" title="10.1 字典是一种映射"></a>10.1 字典是一种映射</h3><p>列表概念的推广。在列表里面，索引必须是整数；而在字典里面，你可以用几乎任何类型来做索引了</p>
<p>字典包括一系列的索引，不过就已经不叫索引了，而是叫键，然后还对应着一个个值，就叫键值。每个键对应着各自的一个单独的键值。这种键和键值的对应关系也叫键值对，有时候也叫项</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">test = &#123;one: <span class="string">&quot;test&quot;</span>&#125;	<span class="comment">#创建新字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">&#x27;one&#x27;</span> <span class="keyword">in</span> test		<span class="comment">#判断该字典是否存在one键</span></span><br></pre></td></tr></table></figure>

<h3 id="10-2-循环与字典"><a href="#10-2-循环与字典" class="headerlink" title="10.2 循环与字典"></a>10.2 循环与字典</h3><p>如果你在 for 语句里面用字典，程序会遍历字典中的所有键。</p>
<h3 id="10-3-逆向查找"><a href="#10-3-逆向查找" class="headerlink" title="10.3 逆向查找"></a>10.3 逆向查找</h3><p>给定一个字典 d，以及一个键 k，很容易找到对应的键值 v&#x3D;d[k]。这个操作就叫查找。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">reverse_lookup</span>(<span class="params">d, v</span>):</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">        <span class="keyword">if</span> d[k] == v:</span><br><span class="line">            <span class="keyword">return</span> k</span><br><span class="line">    <span class="keyword">raise</span> LookupError()</span><br><span class="line">    没有一种简单的语法能实现这样一种逆向查找；你必须搜索一下</span><br></pre></td></tr></table></figure>

<h3 id="10-4-全局变量"><a href="#10-4-全局变量" class="headerlink" title="10.4 全局变量"></a>10.4 全局变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&#x27;test&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ab</span>():</span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="string">&#x27;test2&#x27;</span></span><br><span class="line">ab()</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>
<p>要在函数体内修改全局变量的值，必须通过【global】来声明这个是全局变量</p>
<h2 id="11-元组"><a href="#11-元组" class="headerlink" title="11. 元组"></a>11. 元组</h2><h3 id="11-1-元组不可修改"><a href="#11-1-元组不可修改" class="headerlink" title="11.1 元组不可修改"></a>11.1 元组不可修改</h3><p>元组是一系列的值。这些值可以是任意类型的，并且用整数序号作为索引，所以可以发现元组和列表非常相似。二者间重要的区别就是<strong>元组是不可修改的</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>)</span><br><span class="line"><span class="comment">#元组的语法是一系列用逗号分隔的值，通常都用一对圆括号把元组的元素包括起来，当然不这样也没事</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = <span class="string">&#x27;a&#x27;</span>,		<span class="comment">#要建立一个单个元素构成的元组，必须要在结尾加上逗号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="string">&#x27;A&#x27;</span>,) + t[<span class="number">1</span>:]		<span class="comment">#元组是不能修改的，你不能修改其中的元素。但是可以用另一个元组来替换已有的</span></span><br><span class="line">元组——该语句建立了一个新的元组</span><br></pre></td></tr></table></figure>

<h3 id="11-2-元组赋值"><a href="#11-2-元组赋值" class="headerlink" title="11.2 元组赋值"></a>11.2 元组赋值</h3><p>对两个变量的值进行交换是一种常用操作。用常见语句来实现的话，就必须有一个临时变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>temp = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = temp</span><br><span class="line"><span class="comment">#上一段语句可以转换成下面条语句</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b = b, a</span><br></pre></td></tr></table></figure>

<h3 id="11-3-用元组做返回值"><a href="#11-3-用元组做返回值" class="headerlink" title="11.3 用元组做返回值"></a>11.3 用元组做返回值</h3><p>严格来说，一个函数只能返回一个值，但如果这个值是一个元组，效果就和返回多个值一样了将结果存储为一个元组，然后使用元组复制分别调用</p>
<h3 id="11-4-参数长度可变的元组"><a href="#11-4-参数长度可变的元组" class="headerlink" title="11.4 参数长度可变的元组"></a>11.4 参数长度可变的元组</h3><p>函数的参数可以有任意多个。用星号*开头来作为形式参数名，可以将所有实际参数收录到一个元组中。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">printall</span>(<span class="params">*args</span>):</span><br><span class="line">    <span class="built_in">print</span>(args)</span><br><span class="line">    </span><br><span class="line">printall(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>, <span class="number">2.0</span>, <span class="string">&#x27;3&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="11-5-列表和元组"><a href="#11-5-列表和元组" class="headerlink" title="11.5 列表和元组"></a>11.5 列表和元组</h3><p>zip 是一个内置函数，接收两个或更多的序列作为参数，然后返回返回一个元组列表，该列表中每个元组都包含了从各个序列中的一个元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line">t = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">for</span> pair <span class="keyword">in</span> <span class="built_in">zip</span>(s,t):</span><br><span class="line">    <span class="built_in">print</span>(pair)</span><br><span class="line">&gt;&gt;&gt;(<span class="string">&#x27;a&#x27;</span>, <span class="number">0</span>) (<span class="string">&#x27;b&#x27;</span>, <span class="number">1</span>) (<span class="string">&#x27;c&#x27;</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h3 id="11-6-词典与元组"><a href="#11-6-词典与元组" class="headerlink" title="11.6 词典与元组"></a>11.6 词典与元组</h3><p>字典有一个名为 items 的方法，会返回一个由元组组成的序列，每一个元组都是字典中的一个键值对</p>
<h2 id="12-文件"><a href="#12-文件" class="headerlink" title="12. 文件"></a>12. 文件</h2><p>『持久的』程序，就是把数据进行永久存储</p>
<h3 id="12-1-持久"><a href="#12-1-持久" class="headerlink" title="12.1 持久"></a>12.1 持久</h3><p>程序持久的特征：它们运行时间很长（甚至一直在运行）；这些程序还会至少永久保存一部分数据（比如存在硬盘上等等）；然后如果程序关闭了或者重新始了，也能从之前停留的状态继续工作。——例如：操作系统</p>
<h3 id="12-2-读写文件"><a href="#12-2-读写文件" class="headerlink" title="12.2 读写文件"></a>12.2 读写文件</h3><p>open 函数会返回一个文件对象，文件对象会提供各种方法来处理文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#这样用写入的模式来打开，会把旧的文件都清除掉，然后重新写入文件</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fout = <span class="built_in">open</span>(<span class="string">&#x27;output.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#write 这个方法就把数据写入到文件中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>line1 = <span class="string">&quot;This here&#x27;s the wattle,</span></span><br><span class="line"><span class="string">&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fout.write(line1)</span><br></pre></td></tr></table></figure>

<h3 id="12-3-文件名与路径"><a href="#12-3-文件名与路径" class="headerlink" title="12.3 文件名与路径"></a>12.3 文件名与路径</h3><p>文件都是按照目录（也叫文件夹）来组织存放的。每一个运行着的程序都有一个当前目录，也就是用来处理绝大多数运算和操作的默认目录</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cwd = os.getcwd()	<span class="comment">#获取当前工作目录</span></span><br></pre></td></tr></table></figure>

<h3 id="12-4-模块"><a href="#12-4-模块" class="headerlink" title="12.4 模块"></a>12.4 模块</h3><p>该模块可以把几乎所有类型的对象翻译成字符串模式，以便存储在数据库中，然后用的时候还可以把字符串再翻译回来</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dumps(t)</span><br><span class="line"><span class="string">b&#x27;\x80\x03]q\x00(K\x01K\x02K\x03e.&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="12-5-管道"><a href="#12-5-管道" class="headerlink" title="12.5 管道"></a>12.5 管道</h3><p>大多数操作系统都提供了一个命令行界面，也被称作『shell』。Shell 通常提供了很多基 础的命令，能够来搜索文件系统，以及启动应用软件。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cmd = <span class="string">&#x27;ls -l&#x27;</span> </span><br><span class="line">fp = os.popen(cmd)</span><br></pre></td></tr></table></figure>

<h3 id="12-6-编写模块"><a href="#12-6-编写模块" class="headerlink" title="12.6 编写模块"></a>12.6 编写模块</h3><p>以模块方式导入使用的程序一般用下面这样的惯用形式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(linecount(<span class="string">&#x27;wc.py&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><strong>name</strong> 是一个内置变量，当程序开始运行的时候被设置。如果程序是作为脚本来运行的，<strong>name</strong> 的值就是’<strong>main</strong>‘；这样的话，if条件满足，测试代码就会运行而如果该代码被用作模块导入了，if 条件不满足，测试的代码就不会运行了</p>
<h2 id="13-类和对象"><a href="#13-类和对象" class="headerlink" title="13. 类和对象"></a>13. 类和对象</h2><h3 id="13-1-用户自定义类型"><a href="#13-1-用户自定义类型" class="headerlink" title="13.1 用户自定义类型"></a>13.1 用户自定义类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line"><span class="string">&quot;&quot;&quot;Represents a point in 2-D space.&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">#头部代码的意思是表示新建的类名字叫 Point。然后类的体内有一个文档字符串，解释类的用途。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Point</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Point&#x27;</span>&gt;		</span><br><span class="line"><span class="comment">#因为 Point 是在顶层位置定义的，所以全名就是__main__.Point</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blank = Point()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>blank</span><br><span class="line">&lt;__main__.Point <span class="built_in">object</span> at <span class="number">0xb7e9d3ac</span>&gt;		</span><br><span class="line"><span class="comment">#类的对象就像是一个创建对象的工厂。要创建一个 Point，就可以像调用函数一样调用Point。</span></span><br><span class="line"><span class="comment">#创建一个新的对象也叫做实例化，这个对象就是类的一个实例</span></span><br></pre></td></tr></table></figure>

<h3 id="13-2-属性"><a href="#13-2-属性" class="headerlink" title="13.2 属性"></a>13.2 属性</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">blank.x = <span class="number">3.0</span>		<span class="comment">#用点号可以给实例进行赋值——不管该实例内是否存在该变量名的初始化</span></span><br><span class="line">x = blank.x		<span class="comment">#赋值</span></span><br><span class="line"><span class="built_in">print</span>(blank.x)		<span class="comment">#直接打印</span></span><br></pre></td></tr></table></figure>
<p>一个类去作为另外一个类的属性，就叫做嵌入</p>
<h3 id="13-3-对象可以修改"><a href="#13-3-对象可以修改" class="headerlink" title="13.3 对象可以修改"></a>13.3 对象可以修改</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">box.width = box.width + <span class="number">50</span></span><br><span class="line">box.height = box.height + <span class="number">100</span></span><br><span class="line"></span><br><span class="line">你还可以写专门的函数来修改对象</span><br></pre></td></tr></table></figure>

<h3 id="13-4-复制"><a href="#13-4-复制" class="headerlink" title="13.4 复制"></a>13.4 复制</h3><p>浅复制：复制一个对象中除了内嵌对象之外的所有引用；通过 copy 模块的 copy 函数来实现。深复制：复制一个对象的所有内容，包括内嵌对象，以及内嵌对象中的所有内嵌对象等等；通过 copy 模块的 deepcopy 函数来实现。</p>
<p>别名有可能让程序读起来有困难，因为在一个位置做出的修改有可能导致另外一个位置发生不可预知的情况。这样也很难去追踪指向一个对象的所有变量</p>
<p>copy 模块包含了一个名叫 copy 的函数，可以复制任意对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = Point()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.x = <span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1.y = <span class="number">4.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> copy</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2 = copy.copy(p1)</span><br><span class="line"></span><br><span class="line"><span class="comment">##p1跟p2数据相同，但不是同一个对象</span></span><br></pre></td></tr></table></figure>

<h2 id="14-类和函数"><a href="#14-类和函数" class="headerlink" title="14. 类和函数"></a>14. 类和函数</h2><h3 id="14-1-纯函数"><a href="#14-1-纯函数" class="headerlink" title="14.1 纯函数"></a>14.1 纯函数</h3><p>这种函数并不修改传来做参数的对象，也没有什么效果，比如显示值啊或者让用户输入啊等等，而只是返回一个值而已。</p>
<h3 id="14-2-原型与规划"><a href="#14-2-原型与规划" class="headerlink" title="14.2 原型与规划"></a>14.2 原型与规划</h3><p>原型与补丁模式：一种开发模式，先写一个程序的草稿，然后测试，再改正发现的错误，这样逐步演化的开发模式</p>
<p>这种模式很有效率，尤其是在你对问题的理解不是很深入的时候。不过渐进式的修改也会产生过分复杂的代码——因为要应对很多特例情况，而且也不太靠靠——因为好确定你是否找到了所有的错误。</p>
<p>设计规划开发：这种开发模式要求对所面对问题的高程度的深刻理解，相比渐进式开发和原型增补模式要更具有计划性</p>
<h2 id="15-类和方法"><a href="#15-类和方法" class="headerlink" title="15 类和方法"></a>15 类和方法</h2><p>对象往往代表着现实世界中的事物，方法则相对应地代表着现实世界中事物之间的相互作用</p>
<h3 id="15-1面向对象的特性"><a href="#15-1面向对象的特性" class="headerlink" title="15.1面向对象的特性"></a>15.1面向对象的特性</h3><p>Python 是一种面向对象的编程语言，这就意味着它提供了一些支持面向对象编程的功能，有以下这些特点：</p>
<ol>
<li>程序包含类和方法的定义。</li>
<li>大多数运算都以对象运算的形式来实现。</li>
</ol>
<h2 id="15-2-调用类的方法"><a href="#15-2-调用类的方法" class="headerlink" title="15.2 调用类的方法"></a>15.2 调用类的方法</h2><p>方法要定义在一个类定义内部，这样能保证方法和类之间的关系明确</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Represents the time of day.&quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_time</span>(<span class="params">time</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%.2d:%.2d:%.2d&#x27;</span> % (time.hour, time.minute, time.second))</span><br><span class="line"></span><br><span class="line">start = Time()</span><br><span class="line">start.hour = <span class="number">9</span></span><br><span class="line">start.minute = <span class="number">45</span></span><br><span class="line">start.second = <span class="number">00</span></span><br><span class="line"><span class="built_in">print</span>(start.print_time())</span><br></pre></td></tr></table></figure>

<h3 id="15-3-init方法"><a href="#15-3-init方法" class="headerlink" title="15.3 init方法"></a>15.3 init方法</h3><p>在对象被实例化的时候被调用采用self对内容进行赋值传递</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>:</span><br><span class="line">    <span class="comment"># inside class Time:</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, hour=<span class="number">9</span>, minute=<span class="number">45</span>, second=<span class="number">00</span></span>):</span><br><span class="line">        self.hour = hour</span><br><span class="line">        self.minute = minute</span><br><span class="line">        self.second = second</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_time</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%.2d:%.2d:%.2d&#x27;</span> % (time.hour, time.minute, time.second))</span><br><span class="line"></span><br><span class="line">time = Time()</span><br><span class="line"><span class="built_in">print</span>(time.print_time())</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>:</span><br><span class="line">    <span class="comment"># inside class Time:</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span></span>):</span><br><span class="line">        self.hour = hour</span><br><span class="line">        self.minute = minute</span><br><span class="line">        self.second = second</span><br></pre></td></tr></table></figure>

<h3 id="15-4-str方法"><a href="#15-4-str方法" class="headerlink" title="15.4 str方法"></a>15.4 str方法</h3><p><strong>str</strong> 是一种特殊的方法，就跟__init__差不多，str 方法是接收一个对象，返回一个代表该对象的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, hour=<span class="number">9</span>, minute=<span class="number">45</span>, second=<span class="number">00</span></span>):</span><br><span class="line">        self.hour = hour</span><br><span class="line">        self.minute = minute</span><br><span class="line">        self.second = second</span><br><span class="line">    <span class="comment"># inside class Time:</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%.2d:%.2d:%.2d&#x27;</span> % (self.hour, self.minute, self.second)</span><br><span class="line"></span><br><span class="line">time = Time()</span><br><span class="line"><span class="built_in">print</span>(time)</span><br></pre></td></tr></table></figure>
<p>写一个新的类的时候，总要先写出来 <strong>init</strong> 方法，这样有利于简化对象的初始化，还要写个 <strong>str</strong> 方法，这个方法在调试的时候很有用</p>
<h3 id="15-5-运算符重载"><a href="#15-5-运算符重载" class="headerlink" title="15.5 运算符重载"></a>15.5 运算符重载</h3><p>运算符重载：像+加号这样的运算符，在处理用户自定义类型的时候改变为相应的运算</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computation</span>():</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,value</span>):</span><br><span class="line">		self.value = value</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self,other</span>):</span><br><span class="line">		<span class="keyword">return</span> self.value + other</span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self,other</span>):</span><br><span class="line">		<span class="keyword">return</span> self.value - other</span><br><span class="line"></span><br><span class="line">c = Computation(<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(c + <span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(c - <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<h3 id="15-6-根据对象类型进行运算"><a href="#15-6-根据对象类型进行运算" class="headerlink" title="15.6 根据对象类型进行运算"></a>15.6 根据对象类型进行运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># inside class Time:</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Time): </span><br><span class="line">        <span class="keyword">return</span> self.add_time(other) </span><br><span class="line">    <span class="keyword">else</span>: </span><br><span class="line">        <span class="keyword">return</span> self.increment(other) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_time</span>(<span class="params">self, other</span>): </span><br><span class="line">    seconds = self.time_to_int() + other.time_to_int() </span><br><span class="line">    <span class="keyword">return</span> int_to_time(seconds) </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">increment</span>(<span class="params">self, seconds</span>): seconds += self.time_to_int() </span><br><span class="line">    <span class="keyword">return</span> int_to_time(seconds)</span><br></pre></td></tr></table></figure>


<h3 id="15-7-接口和实现"><a href="#15-7-接口和实现" class="headerlink" title="15.7 接口和实现"></a>15.7 接口和实现</h3><p>面向对象编程设计的目的之一就是让软件更容易维护，这就意味着当系统中其他部分发生改变的时候依然能让程序运行，然后可以修改程序去符合新的需求。实现这一目标的程序设计原则就是要让接口和实现分开。对于对象来说，这就意着一个类包含的方法要不能被属性表达方式的变化所影响。</p>
<h1 id="16-继承"><a href="#16-继承" class="headerlink" title="16 继承"></a>16 继承</h1><p>面向对象编程最常被人提到的语言功能就是继承了。继承就是基于一个已有的类进行修改来定义一个新的类。</p>
<h3 id="16-1-例子"><a href="#16-1-例子" class="headerlink" title="16.1 例子"></a>16.1 例子</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Card:</span><br><span class="line">    def __init__(self,suit<span class="operator">=</span><span class="number">0</span> ,rank<span class="operator">=</span><span class="number">2</span>):</span><br><span class="line">        self.suit <span class="operator">=</span> suit</span><br><span class="line">        self.rank <span class="operator">=</span> rank</span><br><span class="line">        self.suit_names<span class="operator">=</span>[<span class="string">&#x27;clubs&#x27;</span>,<span class="string">&#x27;Diamonds&#x27;</span>,<span class="string">&#x27;Hearts&#x27;</span>,<span class="string">&#x27;Spades&#x27;</span>]</span><br><span class="line">        self.rank_names<span class="operator">=</span>[<span class="keyword">None</span>,<span class="string">&#x27;Ace&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;l0&#x27;</span>,<span class="string">&#x27;Jack&#x27;</span>,<span class="string">&#x27;Queen&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;%s of %s&#x27;</span><span class="operator">%</span>(self.rank_names[self.rank],self.suit_names[self.suit])</span><br><span class="line">    ##__str__返回字符串型可供打印</span><br><span class="line"></span><br><span class="line">    def __lt__(self, other):</span><br><span class="line">        t1 <span class="operator">=</span> self.suit, self.rank</span><br><span class="line">        t2 <span class="operator">=</span> other.suit, other.rank</span><br><span class="line">        <span class="keyword">return</span> t1 <span class="operator">&lt;</span> t2</span><br><span class="line">    ##lt接收两个参数，一个是self,一个是另外一个对象，如果self严格小于另外一个对象，就返回真。</span><br><span class="line"></span><br><span class="line">class Deck:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.cards <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> suit <span class="keyword">in</span> <span class="keyword">range</span>(<span class="number">3</span>):</span><br><span class="line">            <span class="keyword">for</span> rank <span class="keyword">in</span> <span class="keyword">range</span> (<span class="number">1</span>,<span class="number">12</span>):</span><br><span class="line">                card <span class="operator">=</span> Card(suit,rank)</span><br><span class="line">                self.cards.append(card)</span><br><span class="line"></span><br><span class="line">    def __str__(self):</span><br><span class="line">        res <span class="operator">=</span> []</span><br><span class="line">        <span class="keyword">for</span> card <span class="keyword">in</span> self.cards:</span><br><span class="line">            res.append(str(card))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#x27;</span>.<span class="keyword">join</span>(res)</span><br><span class="line">        ##<span class="keyword">join</span>连接函数</span><br><span class="line"></span><br><span class="line">    def pop_card(self):</span><br><span class="line">        <span class="keyword">return</span> self.cards.pop()</span><br><span class="line">        ##牌堆</span><br><span class="line"></span><br><span class="line">    def add_card(self,card):</span><br><span class="line">        self.cards.append(card)</span><br><span class="line">        ##添加一张牌</span><br><span class="line"></span><br><span class="line">    def shuffle(self):</span><br><span class="line">        random.shuffle(self.cards)</span><br><span class="line">        ##洗牌使用random模块的shuffle方法</span><br><span class="line"></span><br><span class="line">    def move_cards(self,hand,num):</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="keyword">range</span>(num):</span><br><span class="line">            hand.add_card((self.pop_card()))</span><br><span class="line"></span><br><span class="line">##继承一个已有的类来定义新类。当前为：hand继承deck。现在在hand中也可以使用add_card方法</span><br><span class="line">class Hand(Deck):</span><br><span class="line">    def __init__(self,label<span class="operator">=</span><span class="string">&#x27;&#x27;</span>):</span><br><span class="line">        self.cards <span class="operator">=</span> []</span><br><span class="line">        self.lable <span class="operator">=</span> label</span><br><span class="line"></span><br><span class="line">deck <span class="operator">=</span> Deck()</span><br><span class="line">card <span class="operator">=</span> deck.pop_card()</span><br><span class="line">Hand().add_card(<span class="string">&#x27;Jack of Hearts&#x27;</span>)</span><br><span class="line">print(Hand)</span><br></pre></td></tr></table></figure>
<p>suit_names和rank_names这样的变量，都是在类内定义，但不在任何方法之内，这就叫做类的属性，因为它们属于类Card。</p>
<h3 id="16-2-继承"><a href="#16-2-继承" class="headerlink" title="16.2 继承"></a>16.2 继承</h3><p>继承也容易降低程序可读性。当调用一个方法的时候，有时候不容易找到该方法的定义位置。相关的代码可能跨了好几个模块。此外，很多事情可以用继承来实现，但不用继承也能做到同样效果，甚至做得更好。</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>Python</category>
        <category>教程</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>Python</tag>
        <tag>计算机语言</tag>
      </tags>
  </entry>
  <entry>
    <title>python语句</title>
    <url>/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E6%95%99%E7%A8%8B/python%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>程序是什么：一个指令的序列，来告诉机器如何进行一组运算专注于编程，而不是编程语言</p>
<ul>
<li>运算符</li>
</ul>
<p>运算符：+-*&#x2F;  ** (乘方) ^（异或）</p>
<h2 id="1-值和类型"><a href="#1-值和类型" class="headerlink" title="1. 值和类型"></a>1. 值和类型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">2</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt; <span class="comment">#整形</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">42.0</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;float&#x27;</span>&gt; <span class="comment">#浮点型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="string">&#x27;Hello, World!&#x27;</span>)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;  <span class="comment">#字符型</span></span><br></pre></td></tr></table></figure>


<h2 id="2-变量，表达式，语句"><a href="#2-变量，表达式，语句" class="headerlink" title="2. 变量，表达式，语句"></a>2. 变量，表达式，语句</h2><h3 id="2-1-赋值语句"><a href="#2-1-赋值语句" class="headerlink" title="2.1  赋值语句"></a>2.1  赋值语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x = xxx <span class="comment">#第一个x是变量名，xxx是需要赋值的对象</span></span><br></pre></td></tr></table></figure>

<p>变量名不限制长度，不能数字开头，对大小敏感。支持下划线_，例子your_name。特殊关键词不能作为变量名</p>
<h3 id="2-2-表达式和语句"><a href="#2-2-表达式和语句" class="headerlink" title="2.2  表达式和语句"></a>2.2  表达式和语句</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b = n + <span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>表达式是数值,变量和操作符的组合。单个值或变量都如此语句是一组具有某些效果的代码，比如创建变量，或者显示值。语句是可以单独出结果的，而表达式是被语句包含的，得出某个结果，交给语句处理。换句话说，解释器执行语句</p>
<h3 id="2-3-运算符优先级"><a href="#2-3-运算符优先级" class="headerlink" title="2.3  运算符优先级"></a>2.3  运算符优先级</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">();**;*/;+-</span><br></pre></td></tr></table></figure>

<p>从左往右，每个分隔符代表一个优先级；同级从左往右，乘方除外。可以用括号明确提级3.2 字符串操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">+：字符串拼接</span><br><span class="line">*：字符串重复和拼接</span><br></pre></td></tr></table></figure>


<h3 id="2-3-注释"><a href="#2-3-注释" class="headerlink" title="2.3  注释"></a>2.3  注释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#来开头。注释多是要解释这样做的目的是什么。</span></span><br></pre></td></tr></table></figure>


<h3 id="2-4-文档字符串"><a href="#2-4-文档字符串" class="headerlink" title="2.4  文档字符串"></a>2.4  文档字符串</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">number</span>():</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这是一段文档字符串</span></span><br><span class="line"><span class="string">这个函数用于输出hello字符</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Hello!&#x27;</span>)</span><br><span class="line">number()</span><br></pre></td></tr></table></figure>

<p>文档字符串是指：在函数开头部位，解释函数的交互界面的字符串，doc是文档documentation的缩写</p>
<h3 id="2-5-调试"><a href="#2-5-调试" class="headerlink" title="2.5  调试"></a>2.5  调试</h3><ul>
<li><em>语法错误：程序的结构和规则出错</em></li>
<li><em>运行错误（异常）：直到运行的时候才会出现的错误</em></li>
<li><em>语义错误：指你的程序运行没问题，也不产生错误信息，但不能正确工作</em></li>
</ul>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><h3 id="3-1-函数调用"><a href="#3-1-函数调用" class="headerlink" title="3.1  函数调用"></a>3.1  函数调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(<span class="number">42</span>)  <span class="comment">#type即使一个函数，括号内即函数的参数</span></span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;int&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>函数都要“传入”一个参数，“返回”一个结果。结果也被叫做返回值</p>
<h3 id="3-2-Math-functions（数学模块）"><a href="#3-2-Math-functions（数学模块）" class="headerlink" title="3.2  Math functions（数学模块）"></a>3.2  Math functions（数学模块）</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math <span class="comment">#导入模块</span></span><br><span class="line">具体变量名百度找</span><br></pre></td></tr></table></figure>

<p><em>模块：模块就是一系列相关函数的集合成的文件。</em></p>
<h3 id="3-3-添加新函数"><a href="#3-3-添加新函数" class="headerlink" title="3.3  添加新函数"></a>3.3  添加新函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">print_lyrics</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&quot;I&#x27;m a lumberjack, and I&#x27;m okay.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>def表示在定义一个函数，随后跟函数名，括号代表函数的参数，空就是不需要，末尾必须冒号。这些组成头部，剩下叫做函数体</p>
<blockquote>
<p>单引号和双引号效果一样，一般都是用单引号，除非字符串中已经出现</p>
</blockquote>
<h3 id="3-4-运行流程"><a href="#3-4-运行流程" class="headerlink" title="3.4  运行流程"></a>3.4  运行流程</h3><ul>
<li>一个Python程序都是从第一个语句开始运行的。从首至尾，每次运行一个语句</li>
<li>函数定义不会改变流程顺序，函数体语句只有在函数被调用才运行</li>
<li>调用函数就跳入函数体，然后从离开的地方继续执行</li>
</ul>
<h3 id="3-5-形式参数和实际参数"><a href="#3-5-形式参数和实际参数" class="headerlink" title="3.5  形式参数和实际参数"></a>3.5  形式参数和实际参数</h3><p><em>实际参数：就是调用函数时候传给他的那个参数__形式参数：函数内部定义用的参数</em></p>
<blockquote>
<p>函数内部变量和形参都是局部的</p>
</blockquote>
<h3 id="3-6-栈图"><a href="#3-6-栈图" class="headerlink" title="3.6  栈图"></a>3.6  栈图</h3><p><img src="https://raw.githubusercontent.com/liaozonglong/photo/main/img/202108301042947.png#id=phtsO&originHeight=188&originWidth=340&originalType=binary&ratio=1&status=done&style=none#id=Ep0T3&originHeight=188&originWidth=340&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">每个函数都用一个框架来表示。框架的边上要标明函数的名字，框内填写函数内部的形参和变量。一个栈中的这些框也表示了函数调用的关系等等**_main_：属于最外层框架，也被叫做主函数。当在所有函数外定义一个函数时，这个变量就属于主函数所有**</p>
<h3 id="3-7-有返回值的函数和无返回值的函数"><a href="#3-7-有返回值的函数和无返回值的函数" class="headerlink" title="3.7  有返回值的函数和无返回值的函数"></a>3.7  有返回值的函数和无返回值的函数</h3><p>如果是脚本模式，你运行一个有返回值的函数，但没有利用这个返回值，这个返回值就会永远丢失了</p>
<h3 id="3-8-封装"><a href="#3-8-封装" class="headerlink" title="3.8  封装"></a>3.8  封装</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">number</span>():</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Hello!&#x27;</span>)</span><br><span class="line">number()</span><br></pre></td></tr></table></figure>

<p>代码定义到一个函数里面，然后调用这个函数</p>
<h3 id="3-9-泛化"><a href="#3-9-泛化" class="headerlink" title="3.9  泛化"></a>3.9  泛化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">number</span>(<span class="params">a</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">		<span class="built_in">print</span>(<span class="string">&#x27;Hello!&#x27;</span>)</span><br><span class="line">number(x) <span class="comment">#此处x输入数字</span></span><br></pre></td></tr></table></figure>

<p>给函数添加一个参数</p>
<h3 id="3-10-重构"><a href="#3-10-重构" class="headerlink" title="3.10  重构"></a>3.10  重构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">number</span>(<span class="params">a</span>):</span><br><span class="line">	shuzi = <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(a):</span><br><span class="line">		<span class="built_in">print</span>(shuzi)</span><br><span class="line">		shuzi = shuzi + <span class="number">1</span></span><br><span class="line">number(x) <span class="comment">#此处x输入数字</span></span><br></pre></td></tr></table></figure>

<p>改进了界面设计，增强了代码再利用，这就叫做重构</p>
<h2 id="4-模块"><a href="#4-模块" class="headerlink" title="4.  模块"></a>4.  模块</h2><h3 id="4-1-乌龟模块"><a href="#4-1-乌龟模块" class="headerlink" title="4.1  乌龟模块"></a>4.1  乌龟模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line">bob = turtle.Turtle()</span><br></pre></td></tr></table></figure>


<h2 id="5-语句"><a href="#5-语句" class="headerlink" title="5.  语句"></a>5.  语句</h2><h3 id="5-1-地板除法"><a href="#5-1-地板除法" class="headerlink" title="5.1  地板除法"></a>5.1  地板除法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">minutes = <span class="number">105</span></span><br><span class="line">hours = minutes // <span class="number">60</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>会把运算结果的小数位舍弃，返回整值</p>
<h3 id="5-2-求模运算符"><a href="#5-2-求模运算符" class="headerlink" title="5.2  求模运算符"></a>5.2  求模运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">minutes = <span class="number">105</span></span><br><span class="line">remainder = minutes % <span class="number">60</span></span><br><span class="line">remainder</span><br><span class="line"><span class="number">45</span>   <span class="comment">#求余数</span></span><br></pre></td></tr></table></figure>


<h3 id="5-3-布尔表达式"><a href="#5-3-布尔表达式" class="headerlink" title="5.3  布尔表达式"></a>5.3  布尔表达式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span> == <span class="number">5</span></span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="number">5</span> == <span class="number">6</span></span><br><span class="line"><span class="literal">False</span></span><br><span class="line">x != y <span class="comment">#二者相等</span></span><br><span class="line">x &gt; y <span class="comment">#前者更大</span></span><br><span class="line">x &lt; y <span class="comment">#前者更小</span></span><br><span class="line">x &gt;= y <span class="comment">#大于等于</span></span><br><span class="line">x &lt;= y <span class="comment">#小于等于</span></span><br></pre></td></tr></table></figure>

<p>只有两个值，true（真）或者false（假）</p>
<h3 id="5-4-逻辑运算符"><a href="#5-4-逻辑运算符" class="headerlink" title="5.4  逻辑运算符"></a>5.4  逻辑运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">x &gt; <span class="number">0</span> <span class="keyword">and</span> x &lt; <span class="number">10</span> <span class="comment">#x仅在0-10之间才为真——且</span></span><br><span class="line">n%<span class="number">2</span> == <span class="number">0</span> <span class="keyword">or</span> n%<span class="number">3</span> == <span class="number">0</span>  <span class="comment">#一个条件为真就为真——或</span></span><br><span class="line"><span class="keyword">not</span> (x &gt; y) <span class="comment">#当x&gt;y成立，则本条件为假，反之相反</span></span><br></pre></td></tr></table></figure>

<p>逻辑运算符有三种：且，或以及非</p>
<h3 id="5-5-条件执行"><a href="#5-5-条件执行" class="headerlink" title="5.5  条件执行"></a>5.5  条件执行</h3><h4 id="5-5-1-if语句"><a href="#5-5-1-if语句" class="headerlink" title="5.5.1  if语句"></a>5.5.1  if语句</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; <span class="number">0</span>: 	</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x is positive&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>if背后是布尔表达式，条件为真，缩进语句即执行，反之相反</p>
<h4 id="5-5-2-选择执行"><a href="#5-5-2-选择执行" class="headerlink" title="5.5.2  选择执行"></a>5.5.2  选择执行</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;x is even&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;x is odd&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>存在两种备选语句，根据条件来判断。这些选择也叫【分支】</p>
<h4 id="5-5-3-链式条件"><a href="#5-5-3-链式条件" class="headerlink" title="5.5.3  链式条件"></a>5.5.3  链式条件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x is less than y&#x27;</span>)</span><br><span class="line"><span class="keyword">elif</span> x &gt; y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x     is greater than y&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x and y are equal&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>第一个为假，第二个就会被检查，以此类推。如果有一个为真，相应语句就会运行，条件判断也就结束。如果有多个条件为真，只有第一个会运行</p>
<h4 id="5-5-4-嵌套条件"><a href="#5-5-4-嵌套条件" class="headerlink" title="5.5.4  嵌套条件"></a>5.5.4  嵌套条件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x == y:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;x and y are equal&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">if</span> x &lt; y:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;x is less than y&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;x is greater than y&#x27;</span>)</span><br></pre></td></tr></table></figure>


<h4 id="5-5-5-递归运算"><a href="#5-5-5-递归运算" class="headerlink" title="5.5.5  递归运算"></a>5.5.5  递归运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countdown</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Blastoff!&#x27;</span>)</span><br><span class="line">	<span class="keyword">else</span>:</span><br><span class="line">    	<span class="built_in">print</span>(n)</span><br><span class="line">    	countdown(n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>函数来调用自己也是允许的。这就是递归</p>
<h4 id="5-5-6-无穷递归"><a href="#5-5-6-无穷递归" class="headerlink" title="5.5.6  无穷递归"></a>5.5.6  无穷递归</h4><p>如果一个递归一直都不能到达基准条件，那就会持续不断地进行自我调用，程序也就永远不会终止了。这就叫无穷递归</p>
<h4 id="5-5-7-键盘输入"><a href="#5-5-7-键盘输入" class="headerlink" title="5.5.7  键盘输入"></a>5.5.7  键盘输入</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;What...is your name?</span></span><br><span class="line"><span class="string">&#x27;</span>)</span><br><span class="line">What...<span class="keyword">is</span> your name?</span><br><span class="line">Arthur, King of the Britons!</span><br><span class="line">name</span><br><span class="line">Arthur, King of the Britons</span><br></pre></td></tr></table></figure>

<p>了内置的一个函数，名叫input</p>
<h3 id="5-6-循环语句"><a href="#5-6-循环语句" class="headerlink" title="5.6  循环语句"></a>5.6  循环语句</h3><h4 id="5-6-1-for语句"><a href="#5-6-1-for语句" class="headerlink" title="5.6.1  for语句"></a>5.6.1  for语句</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Hello!&#x27;</span>)</span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>Python</tag>
        <tag>计算机语言</tag>
        <tag>python</tag>
        <tag>python语句</tag>
      </tags>
  </entry>
  <entry>
    <title>代理的基本原理</title>
    <url>/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/%E7%88%AC%E8%99%AB/%E4%BB%A3%E7%90%86/%E4%BB%A3%E7%90%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>服务器会检测某个IP，但可以通过某种方式来伪装IP</p>
<h1 id="1-基本原理"><a href="#1-基本原理" class="headerlink" title="1 基本原理"></a>1 基本原理</h1><p>代理即代理服务器。代理用户的网络去取得网络信息，即一个中转站</p>
<h1 id="2-代理的作用"><a href="#2-代理的作用" class="headerlink" title="2 代理的作用"></a>2 代理的作用</h1><p>略</p>
<h1 id="3-爬虫代理"><a href="#3-爬虫代理" class="headerlink" title="3. 爬虫代理"></a>3. 爬虫代理</h1><p>对于爬虫来说，访问网页速度过快，很容易被封禁IP</p>
<h1 id="4-代理分类"><a href="#4-代理分类" class="headerlink" title="4. 代理分类"></a>4. 代理分类</h1><ol>
<li>根据协议划分</li>
</ol>
<ul>
<li>ftp</li>
<li>http</li>
<li>ssl&#x2F;tls</li>
<li>rtsp</li>
<li>Telnet</li>
<li>pop3&#x2F;SMTP</li>
<li>socks</li>
</ul>
<ol start="2">
<li>根据匿名程度区分</li>
</ol>
<ul>
<li>高度匿名代理</li>
<li>普通匿名代理</li>
<li>透明代理</li>
<li>间谍代理</li>
</ul>
<h1 id="5-常见代理设置"><a href="#5-常见代理设置" class="headerlink" title="5. 常见代理设置"></a>5. 常见代理设置</h1><p>使用网上的免费代理使用付费代理ADSL拨号</p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>爬虫</category>
        <category>代理</category>
      </categories>
  </entry>
  <entry>
    <title>手册</title>
    <url>/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/%E6%8E%A7%E4%BB%B6/FarPoint.Win.Spread/%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p><a href="https://www.docin.com/p-286957681.html"> Farpoint-中文手册 </a></p>
]]></content>
      <categories>
        <category>计算机</category>
        <category>计算机语言</category>
        <category>C#</category>
        <category>控件</category>
      </categories>
      <tags>
        <tag>FarPointSpread</tag>
      </tags>
  </entry>
  <entry>
    <title>Django_Python</title>
    <url>/2021/08/12/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E6%A1%86%E6%9E%B6/WEB%E6%A1%86%E6%9E%B6/Django_Python/</url>
    <content><![CDATA[<h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><p>pip install django		#安装Djangodjango-admin.py startproject testdj		#创建django项目python3 manage.py runserver	#运行django项目</p>
<p>参考：<a href="https://www.runoob.com/django/django-install.html">Django 安装</a><a href="https://www.runoob.com/django/django-first-app.html">Django 创建第一个项目</a></p>
<h2 id="网站规则"><a href="#网站规则" class="headerlink" title="网站规则"></a>网站规则</h2><blockquote>
</blockquote>
<h2 id="修改网站路径："><a href="#修改网站路径：" class="headerlink" title="修改网站路径："></a>修改网站路径：</h2><blockquote>
<p><img src="https://i.loli.net/2021/11/15/ndXEWmatS41s3Gb.png#id=rnetn&originHeight=385&originWidth=622&originalType=binary&ratio=1&status=done&style=none#id=TeN5w&originHeight=385&originWidth=622&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=">项目中如果代码有改动，服务器会自动监测代码的改动并自动重新载入，所以如果你已经启动了服务器则不需手动重启。</p>
</blockquote>
<blockquote>
</blockquote>
<h2 id="修改模板文件的路径"><a href="#修改模板文件的路径" class="headerlink" title="修改模板文件的路径"></a>修改模板文件的路径</h2><blockquote>
<p>修改HelloWorld&#x2F;settings.py，修改 TEMPLATES 中的 DIRS 为 <strong>[os.path.join(BASE_DIR, ‘templates’)]</strong><img src="https://i.loli.net/2021/11/15/ZE2wpJoI9fTYdnu.png#id=czyzP&originHeight=191&originWidth=562&originalType=binary&ratio=1&status=done&style=none#id=NFYKh&originHeight=191&originWidth=562&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
</blockquote>
<p>[</p>
<p>](<a href="https://www.runoob.com/django/django-first-app.html">https://www.runoob.com/django/django-first-app.html</a>)</p>
<h2 id="分离文档的表现形式和内容"><a href="#分离文档的表现形式和内容" class="headerlink" title="分离文档的表现形式和内容"></a>分离文档的表现形式和内容</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HelloWorld/templates/runoob.html 文件代码：</span><br><span class="line">&lt;h1&gt;&#123;&#123; hello &#125;&#125;&lt;/h1&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改 views.py，增加一个新的对象，用于向模板提交数据</span><br><span class="line">from django.shortcuts import render</span><br><span class="line"> </span><br><span class="line">def runoob(request):</span><br><span class="line">    context          = &#123;&#125;</span><br><span class="line">    context[&#x27;hello&#x27;] = &#x27;Hello World!&#x27;</span><br><span class="line">    return render(request, &#x27;runoob.html&#x27;, context)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">向Django说明模板文件的路径，修改HelloWorld/settings.py，</span><br><span class="line">修改 TEMPLATES 中的 DIRS 为 [os.path.join(BASE_DIR, &#x27;templates&#x27;)]</span><br><span class="line">代码头引入OS,import OS；</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.runoob.com/django/django-template.html">Django 模板</a></p>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>sudo pip3 install pymysql		# 安装 mysql 驱动  （必须）create database runoob default charset&#x3D;utf8;  	# 创建一个名为 runoob 数据库，编码指定为 utf8：</p>
<hr>
<p><strong>项目的 settings.py 文件中找到 DATABASES 配置项 		#修改数据库连接信息：（必须）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DATABASES = &#123; </span><br><span class="line">    &#x27;default&#x27;: </span><br><span class="line">    &#123; </span><br><span class="line">        &#x27;ENGINE&#x27;: &#x27;django.db.backends.mysql&#x27;,    # 数据库引擎</span><br><span class="line">        &#x27;NAME&#x27;: &#x27;runoob&#x27;, # 数据库名称</span><br><span class="line">        &#x27;HOST&#x27;: &#x27;127.0.0.1&#x27;, # 数据库地址，本机 ip 地址 127.0.0.1 </span><br><span class="line">        &#x27;PORT&#x27;: 3306, # 端口 </span><br><span class="line">        &#x27;USER&#x27;: &#x27;root&#x27;,  # 数据库用户名</span><br><span class="line">        &#x27;PASSWORD&#x27;: &#x27;123456&#x27;, # 数据库密码</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>** 告诉Django 使用 pymysql 模块连接 mysql 数据库：  		#修改连接模块（必须）**</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在与 settings.py 同级目录下的 __init__.py 中引入模块和进行配置</span><br><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h3><h4 id="创建-APP"><a href="#创建-APP" class="headerlink" title="创建 APP"></a>创建 APP</h4><blockquote>
<p>Django 规定，如果要使用模型，必须要创建一个 app</p>
</blockquote>
<p>django-admin.py startapp TestModel	# 创建一个 TestModel 的 app	（必须）create database 数据库名称 default charset&#x3D;utf8; 	# 防止编码问题，指定为 utf8</p>
<hr>
<p>**修改 TestModel&#x2F;models.py 文件  **</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># models.py</span><br><span class="line">from django.db import models</span><br><span class="line"> </span><br><span class="line">class Test(models.Model):</span><br><span class="line">    name = models.CharField(max_length=20)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上的类名代表了数据库表名，且继承了models.Model，类里面的字段代表数据表中的字段(name)，数据类型则由CharField（相当于varchar）、DateField（相当于datetime）， max_length 参数限定长度。</p>
</blockquote>
<h2 id="django–orm-models-字段类型说明"><a href="#django–orm-models-字段类型说明" class="headerlink" title="django–orm models 字段类型说明"></a><a href="https://www.cnblogs.com/lutt/p/13734813.html">django–orm models 字段类型说明</a></h2><blockquote>
</blockquote>
<hr>
<p>settings.py 中找到INSTALLED_APPS这一项，如下：  	#添加APP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">    &#x27;django.contrib.admin&#x27;,</span><br><span class="line">    &#x27;django.contrib.auth&#x27;,</span><br><span class="line">    &#x27;django.contrib.contenttypes&#x27;,</span><br><span class="line">    &#x27;django.contrib.sessions&#x27;,</span><br><span class="line">    &#x27;django.contrib.messages&#x27;,</span><br><span class="line">    &#x27;django.contrib.staticfiles&#x27;,</span><br><span class="line">    &#x27;TestModel&#x27;,               # 添加此项</span><br><span class="line">)</span><br></pre></td></tr></table></figure>


<h3 id="完成配置后的命令"><a href="#完成配置后的命令" class="headerlink" title="完成配置后的命令"></a>完成配置后的命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 manage.py migrate   # 创建表结构</span><br><span class="line">$ python3 manage.py makemigrations TestModel  # 让 Django 知道我们在我们的模型有一些变更</span><br><span class="line">$ python3 manage.py migrate TestModel   # 创建表结构</span><br></pre></td></tr></table></figure>


<h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><p>testdb.py中写增删改查语句，urls中写链接。详见<a href="https://www.runoob.com/django/django-model.html">数据库配置</a></p>
<p>参考：<a href="https://www.runoob.com/django/django-model.html">数据库配置</a><a href="https://www.cnblogs.com/lutt/p/13734813.html">django–orm models 字段类型说明</a></p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>GET方法：POST方法（提交数据时更常用） ：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=&quot;/search-post/&quot; method=&quot;post&quot;&gt;</span><br><span class="line">        &#123;% csrf_token %&#125;		#csrf 全称是 Cross Site Request Forgery；Django提供的防止伪装提交请求的功能。POST 方法提交的表格，必须有此标签。</span><br><span class="line">        &lt;input type=&quot;text&quot; name=&quot;q&quot;&gt;</span><br><span class="line">        &lt;input type=&quot;submit&quot; value=&quot;搜索&quot;&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line"> </span><br><span class="line">    &lt;p&gt;&#123;&#123; rlt &#125;&#125;&lt;/p&gt; 	# rlt 记号，为表格处理结果预留位置	</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>



<p>参考：<a href="https://www.runoob.com/django/django-form.html">Django 表</a></p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><blockquote>
<p>一个视图函数，简称视图，是一个简单的 Python 函数，它接受 Web 请求并且返回 Web 响应。响应可以是一个 HTML 页面、一个 404 错误页面、重定向页面、XML 文档、或者一张图片…无论视图本身包含什么逻辑，都要返回响应。代码写在哪里都可以，只要在 Python 目录下面，一般放在项目的 views.py 文件中。每个视图函数都负责返回一个 HttpResponse 对象，对象中包含生成的响应。视图层中有两个重要的对象：请求对象(request)与响应对象(HttpResponse)。</p>
</blockquote>
<h3 id="请求对象-HttpRequest-对象（简称-request-对象）"><a href="#请求对象-HttpRequest-对象（简称-request-对象）" class="headerlink" title="请求对象: HttpRequest 对象（简称 request 对象）"></a>请求对象: HttpRequest 对象（简称 request 对象）</h3><h4 id="1、GET"><a href="#1、GET" class="headerlink" title="1、GET"></a>1、GET</h4><p>取值格式：对象.方法。get()：返回字符串，如果该键对应有多个值，取出该键的最后一个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def runoob(request):</span><br><span class="line">    name = request.GET.get(&quot;name&quot;)</span><br><span class="line">    return HttpResponse(&#x27;姓名：&#123;&#125;&#x27;.format(name))</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/24/fCVnQ6ADSKBGa84.png#id=wudKG&originHeight=139&originWidth=584&originalType=binary&ratio=1&status=done&style=none#id=apIzg&originHeight=139&originWidth=584&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h4 id="2、POST"><a href="#2、POST" class="headerlink" title="2、POST"></a>2、POST</h4><p>数据类型是 QueryDict，一个类似于字典的对象，包含 HTTP POST 的所有参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def runoob(request):</span><br><span class="line">    name = request.POST.get(&quot;name&quot;)</span><br><span class="line">    return HttpResponse(&#x27;姓名：&#123;&#125;&#x27;.format(name))</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/11/24/ZCS8wjhrTABM2X6.png#id=Ns36f&originHeight=369&originWidth=1460&originalType=binary&ratio=1&status=done&style=none#id=wubRb&originHeight=369&originWidth=1460&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h4 id="3、body"><a href="#3、body" class="headerlink" title="3、body"></a>3、body</h4><p>数据类型是二进制字节流，是原生请求体里的参数内容，在 HTTP 中用于 POST，因为 GET 没有请求体。在 HTTP 中不常用，而在处理非 HTTP 形式的报文时非常有用，例如：二进制图片、XML、Json 等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def runoob(request):</span><br><span class="line">    name = request.body</span><br><span class="line">    print(name)</span><br><span class="line">    return HttpResponse(&quot;菜鸟教程&quot;)</span><br></pre></td></tr></table></figure>


<h3 id="响应对象：HttpResponse-对象"><a href="#响应对象：HttpResponse-对象" class="headerlink" title="响应对象：HttpResponse 对象"></a>响应对象：HttpResponse 对象</h3><p>响应对象主要有三种形式：HttpResponse()、render()、redirect()。<strong>HttpResponse():</strong> 返回文本，参数为字符串，字符串中写文本内容。如果参数为字符串里含有 html 标签，也可以渲染。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def runoob(request):</span><br><span class="line">    # return HttpResponse(&quot;菜鸟教程&quot;)</span><br><span class="line">    return HttpResponse(&quot;&lt;a href=&#x27;https://www.runoob.com/&#x27;&gt;菜鸟教程&lt;/a&gt;&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>render()：</strong> 第一个参数为 request，第二个参数为字符串（页面名称），第三个参数为字典（可选参数，向页面传递的参数：键为页面参数名，值为views参数名）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def runoob(request):</span><br><span class="line">    name =&quot;菜鸟教程&quot;</span><br><span class="line">    return render(request,&quot;runoob.html&quot;,&#123;&quot;name&quot;:name&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>redirect()。</strong> 重定向，跳转新页面。参数为字符串，字符串中填写页面路径。一般用于 form 表单提交后，跳转到新页面。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def runoob(request):</span><br><span class="line">    return redirect(&quot;/index/&quot;)</span><br></pre></td></tr></table></figure>

<p>参考：<a href="https://www.runoob.com/django/django-views.html">Django 视图</a></p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p>参考：<a href="https://www.runoob.com/django/django-routers.html">Django 路由</a></p>
]]></content>
      <tags>
        <tag>计算机</tag>
        <tag>[object Object]</tag>
        <tag>Python</tag>
        <tag>计算机语言</tag>
        <tag>python</tag>
        <tag>Django</tag>
        <tag>框架</tag>
        <tag>WEB框架</tag>
      </tags>
  </entry>
</search>
