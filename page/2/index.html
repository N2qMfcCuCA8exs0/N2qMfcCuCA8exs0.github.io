<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"flat","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="LZL">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="LZL">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="liaozonglong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>LZL</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">LZL</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-travel">

    <a href="/tags/%E6%97%85%E8%A1%8C" rel="section"><i class="fa fa-calendar fa-fw"></i>旅行</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/%E6%A6%82%E5%BF%B5/C#%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/%E6%A6%82%E5%BF%B5/C#%E5%9F%BA%E7%A1%80-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB%E5%9E%8B/" class="post-title-link" itemprop="url">C#基础-对象和类型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-20 16:55:16" itemprop="dateCreated datePublished" datetime="2023-04-20T16:55:16+08:00">2023-04-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">计算机语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C#</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C/%E6%A6%82%E5%BF%B5/" itemprop="url" rel="index"><span itemprop="name">概念</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>114</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>类包含成员，成员可以是静态成员或实例成员。静态成员属于类，实例成员属于对象。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Button okButton = new Button();	//创建一个Button对象。往后可以基于okButton 变量名.设置属性</span><br></pre></td></tr></table></figure>


<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/huan13479195089/article/details/126878583"> C#基础–对象和类型</a></p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%8C%85/selenium_Python/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%8C%85/selenium_Python/" class="post-title-link" itemprop="url">selenium_Python</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-19 16:38:26" itemprop="dateCreated datePublished" datetime="2023-04-19T16:38:26+08:00">2023-04-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">计算机语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/" itemprop="url" rel="index"><span itemprop="name">Python</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/%E5%8C%85/" itemprop="url" rel="index"><span itemprop="name">包</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chrome.exe --remote-debugging-port=9527 --user-data-dir=“F:\selenium\AutomationProfile</span><br><span class="line"></span><br><span class="line">user-data-dirr=“F:\selenium\AutomationProfile” 是在单独的配置文件中启动 chrome浏览器，可以理解为新的浏览器</span><br><span class="line">其中 9527 为端口号，可自行指定。</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line">options = Options()</span><br><span class="line">options.add_experimental_option(<span class="string">&quot;debuggerAddress&quot;</span>, <span class="string">&quot;127.0.0.1:9527&quot;</span>)</span><br><span class="line">browser = webdriver.Chrome(options=options)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(browser.title)</span><br></pre></td></tr></table></figure>

<h2 id="定位方法"><a href="#定位方法" class="headerlink" title="定位方法"></a>定位方法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find_element_by_id 						(返回一个元素)</span><br><span class="line">find_element(s)_by_class_name 			(根据类名获取元素列表)</span><br><span class="line">find_element(s)_by_name 				(根据标签的name属性值返回包含标签对象元素的列表)</span><br><span class="line"></span><br><span class="line">find_element(s)_by_xpath 				(返回一个包含元素的列表)</span><br><span class="line">example：driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;loginid&quot;]&#x27;</span>)</span><br><span class="line"></span><br><span class="line">find_element(s)_by_link_text 			(根据连接文本获取元素列表)</span><br><span class="line">find_element(s)_by_partial_link_text 	(根据链接包含的文本获取元素列表)</span><br><span class="line">find_element(s)_by_tag_name 			(根据标签名获取元素列表)</span><br><span class="line">find_element(s)_by_css_selector 		(根据css选择器来获取元素列表)</span><br></pre></td></tr></table></figure>

<h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">element.click()</span><br><span class="line">对定位到的标签对象进行点击操作</span><br><span class="line"></span><br><span class="line">element.send_keys(data)</span><br><span class="line">对定位到的标签对象输入数据</span><br><span class="line"></span><br><span class="line">element.text</span><br><span class="line">通过定位获取的标签对象的text属性，获取文本内容</span><br><span class="line"></span><br><span class="line">element.get_attribute(<span class="string">&quot;属性名&quot;</span>)</span><br><span class="line">通过定位获取的标签对象的get_attribute函数，传入属性名，来获取属性的值</span><br><span class="line">example:<span class="built_in">input</span>.get_attribute(<span class="string">&#x27;value&#x27;</span>)</span><br></pre></td></tr></table></figure>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/Python%20To%20EXE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/Python%20To%20EXE/" class="post-title-link" itemprop="url">Python To EXE</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-11 11:31:10" itemprop="dateCreated datePublished" datetime="2023-04-11T11:31:10+08:00">2023-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>358</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="使用工具"><a href="#使用工具" class="headerlink" title="使用工具"></a>使用工具</h2><ol>
<li>Pyinstaller<ol>
<li>安装命令：pip install pyinstaller</li>
<li>软件说明：pyinstaller是一个独立可执行的软件包，它会自行分析python代码需要的模块和库，自行将python打包成可以脱离于python环境下独立运行的程序</li>
</ol>
</li>
</ol>
<h2 id="打包步骤"><a href="#打包步骤" class="headerlink" title="打包步骤"></a>打包步骤</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 假定C盘下有一个1.py的文件</span><br><span class="line"># 打包cmd</span><br><span class="line">cd C:\</span><br><span class="line">pyinstaller -F 1.py</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例子：</span><br><span class="line">installer -F py_word.py 打包exe</span><br><span class="line">Pyinstaller -F -w py_word.py 不带控制台的打包</span><br><span class="line">Pyinstaller -F -w -i chengzi.ico py_word.py 打包指定exe图标打包</span><br></pre></td></tr></table></figure>
<p>打包完成后有一个dist文件夹，可执行文件就在里面</p>
<h2 id="进阶：压缩打包-amp-更多指令参考"><a href="#进阶：压缩打包-amp-更多指令参考" class="headerlink" title="进阶：压缩打包&amp;更多指令参考"></a>进阶：压缩打包&amp;更多指令参考</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/libaineu2004/article/details/112612421">Python脚本打包成exe，看这一篇就够了！</a></p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/GUI/Tkinter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/11/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/Python/GUI/Tkinter/" class="post-title-link" itemprop="url">Tkinter</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-04-11 11:26:38" itemprop="dateCreated datePublished" datetime="2023-04-11T11:26:38+08:00">2023-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>52</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/435375856">tkinter的grid布局方法及参数图示讲解</a><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014663232/article/details/103224670">Python Tkinter详解 （十）控件的定位</a></p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/C#/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/19/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C#/C#/" class="post-title-link" itemprop="url">C#</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-19 14:18:01" itemprop="dateCreated datePublished" datetime="2022-10-19T14:18:01+08:00">2022-10-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index"><span itemprop="name">计算机</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">计算机语言</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/C/" itemprop="url" rel="index"><span itemprop="name">C#</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>128k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:57</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="C-与-NET平台"><a href="#C-与-NET平台" class="headerlink" title="C#与 .NET平台"></a>C#与 .NET平台</h2><h3 id="1-NET之道"><a href="#1-NET之道" class="headerlink" title="1 .NET之道"></a>1 .NET之道</h3><h4 id="1-1-NET之前的世界"><a href="#1-1-NET之前的世界" class="headerlink" title="1.1 .NET之前的世界"></a>1.1 .NET之前的世界</h4><p>技术的每一次更新，都有将原先技术的复杂性、不可确定给隐藏起来，和消除的倾向</p>
<h4 id="1-2-NET的解决方案"><a href="#1-2-NET的解决方案" class="headerlink" title="1.2 .NET的解决方案"></a>1.2 .NET的解决方案</h4><p>核心功能：</p>
<ul>
<li>对已有代码具有完全的互操作性：已有的COM二进制组件可以和更新的.NET二进制组件共存，反之亦然。</li>
<li>支持多种编程语言：使用多种编程语言(C#Visual Basic、F#和S#等)创建.NET应用</li>
<li>所有支持NET的语言共享的公共运行时引擎：这个引擎的一个特点是具有一组明确定义的类型，而每一种支持NET的语言都能“明白”这些类型。</li>
<li>全面和彻底的语言集成：.NET支持跨语言的继承、异常处理和代码调试。</li>
<li>全面的基础类库：这个库除隐藏了原始API调用的复杂性外，还提供了被所有支持NET的语言所使用的一致的对象模型。</li>
<li>不关注COM底层操作：IClassFactory、IUnknown、IDispatch、lDL代码和讨时厌的与变量兼容的数据类型（如BSTR、SAFEARRAY等）不会出现在.NET二进制代码中</li>
<li>真正简化的部暑模型：在NET环境下，不需要将二进制单元注册到系统注册表了。</li>
</ul>
<h4 id="1-3-NET平台构造块-CLR、CTS和CLS-简介"><a href="#1-3-NET平台构造块-CLR、CTS和CLS-简介" class="headerlink" title="1.3 .NET平台构造块(CLR、CTS和CLS)简介"></a>1.3 .NET平台构造块(CLR、CTS和CLS)简介</h4><p>从程序员的角度，.NET可以理解为一个运行库环境和一个全面的基础类库。运行库的正式名称是CLR。其主要作用是为我们定位、加载和管理NET类型，同时也负责一些低层细节的工作，如内存管理、应用托管、处理线程、安全检查等.NET平台的另一个构造块是CTS(公共类型系统)。CTS规范完整描述了运行库所支持的所有可能的数据类型和编程结构，指定了这些实体间如何交互，也规定了它们在NET元数据格式中的表示。要注意的是，一种特定的支持.NET的语言可能不支持CTS所定义的所有特性。CLS(公共语言规范)是一个相关的规范，定义了一个让所有NET语言都支持的公共类型和编程结构的子集。这样，如果构造的NET类型仅公开与CLS兼容的特性，那么可以肯定其他所有支持.NET的语言都能使用它们。反之，如果使用了与CLS不兼容的数据类型或编程结构，就不能保证所有的NET语言能和你的NET代码库相交互。</p>
<h5 id="1-1-3-1-基础类库的作用"><a href="#1-1-3-1-基础类库的作用" class="headerlink" title="1.1.3.1 基础类库的作用"></a>1.1.3.1 基础类库的作用</h5><p>除了CLR和CTS&#x2F;CLS规范之外，.NET平台提供了一个适用于全部.NET程序语言的基础类库(BCL)。这个基础类库不仅封装了各种基本类型，如线程、文件输入&#x2F;输出(I&#x2F;O)、图形绘制以及与各种外部硬件设备的交互，还支持实际应用中用到的一些服务</p>
<h4 id="1-4-NET程序集概览"><a href="#1-4-NET程序集概览" class="headerlink" title="1.4 .NET程序集概览"></a>1.4 .NET程序集概览</h4><p>当使用支持NET的编译器生成*.dll或*.exe文件时，二进制大对象会被打包成一个程序集。不管选择了哪种.NET语言编程，需要明白的是，尽管NET二进制文件与COM服务器和非托管Windows二进制文件（*.dl或*.exe)具有相同的文件扩展名，但它们的内部却是完全不同的。例如，*.dI的.NET二进制文件不会导出与COM运行库进行通信的方法（因为NET不是COM)。</p>
<h5 id="1-1-4-1-单文件程序集和多文件程序集"><a href="#1-1-4-1-单文件程序集和多文件程序集" class="headerlink" title="1.1.4.1 单文件程序集和多文件程序集"></a>1.1.4.1 单文件程序集和多文件程序集</h5><p>大多数情况下，一个程序集只对应一个二进制文件（*.dll或*.exe)。因此，当生成一个.NET *.dll时，可以认为二进制文件和程序集完全一样。多文件程序集则由多个NET二进制文件组成，其中的每个二进制文件称作模块(module)。生成一个多文件程序集时，其中一个模块（称为主模块）一定包含程序集清单（还可能包含CIL指令和各种类型元数据)。其他相关的模块包含一个模块级的程序集清单、CIL和类型元数据。可以想到，主模块会记录程序集清单中所含的其他必要的辅助模块。</p>
<h5 id="1-1-4-2-CIL的作用"><a href="#1-1-4-2-CIL的作用" class="headerlink" title="1.1.4.2 CIL的作用"></a>1.1.4.2 CIL的作用</h5><p>通用中间语言。 目标为.NET 框架的语言被编译成CIL，然后汇编成字节码</p>
<ol>
<li>好处<ol>
<li>CIL是平台无关的。这意味着一个代码库可以在多种操作系统上运行</li>
<li>每种支持.NET的编译器生成的几乎完全相同的CIL指令</li>
</ol>
</li>
<li>将CIL编译成特定平台的指令<ol>
<li>当给定的Jitter编译器将CIL指令编译为相应的机器代码时，它会用适合目标操作系统的方式将结果缓存在内存中</li>
<li>将CIL代码编译成有意义的CPU指令的工具称为Jitter(即时)编译器，有时也称为JIT。。NET运行库环境将使用针对各种不同CPU的JIT编译器，每个编译器都会针对底层平台进行优化。</li>
</ol>
</li>
</ol>
<h5 id="1-1-4-3-NET类型元数据的作用"><a href="#1-1-4-3-NET类型元数据的作用" class="headerlink" title="1.1.4.3 .NET类型元数据的作用"></a>1.1.4.3 .NET类型元数据的作用</h5><p>除了CIL指令以外，.NET程序集还包括全部完整且准确的元数据，这些元数据描述了每一个二进制文件中定义的类型（如类、结构、枚举等）以及每个类型的成员（比如属性、方法和事件等）生成最新和最大的类型元数据总是编译器的工作而不是程序员的工作</p>
<h5 id="1-1-4-3-程序集清单的作用"><a href="#1-1-4-3-程序集清单的作用" class="headerlink" title="1.1.4.3 程序集清单的作用"></a>1.1.4.3 程序集清单的作用</h5><p>在许多细节中，清单记录了所有确保现有程序集正常工作的外部程序集、程序集的版本号、版权信息等。同类型元数据一样，生成程序集清单也是编译器的工作</p>
<h4 id="1-5-CTS"><a href="#1-5-CTS" class="headerlink" title="1.5 CTS"></a>1.5 CTS</h4><p>一个给定的程序集可能包含任意数量的不同“类型”。在.NET领域里，类型(type)是一个一般性的术语，它指的是集合{类，接口，结构，枚举，委托}里的任意一个成员。CTS（公共类型系统)是一个正式的规范，它规定了类型必须如何定义才能被CLR承载</p>
<h5 id="1-1-5-1-CTS类类型"><a href="#1-1-5-1-CTS类类型" class="headerlink" title="1.1.5.1 CTS类类型"></a>1.1.5.1 CTS类类型</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#类类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Calc</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + y&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-2-CTS接口类型"><a href="#1-1-5-2-CTS接口类型" class="headerlink" title="1.1.5.2 CTS接口类型"></a>1.1.5.2 CTS接口类型</h5><p>一般情况下，所有的.NET接口均已大写字母I开头</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#接口通常被声明为公共的，这样其他程序集就可以实现其功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDraw</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-3-CTS结构类型"><a href="#1-1-5-3-CTS结构类型" class="headerlink" title="1.1.5.3 CTS结构类型"></a>1.1.5.3 CTS结构类型</h5><p>结构可以看做是有值语义的轻量级类类型</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#结构类型</span></span><br><span class="line"><span class="keyword">struct</span> Point</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//结构可以包含字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> xPos, yPos;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构可以包含参数化构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123; xPos = x; yPos = y; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结构可以定义方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintPosition</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(&#123;0&#125;, &#123;1&#125;)&quot;</span>, xPos, yPos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-4-CTS枚举类型"><a href="#1-1-5-4-CTS枚举类型" class="headerlink" title="1.1.5.4 CTS枚举类型"></a>1.1.5.4 CTS枚举类型</h5><p>枚举是一种便利的编程结构，它可以用来组成名称&#x2F;值对</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#枚举类型</span></span><br><span class="line"><span class="built_in">enum</span> CharacterType</span><br><span class="line">&#123;</span><br><span class="line">	Widzard = <span class="number">100</span>,</span><br><span class="line">	Fighter = <span class="number">200</span>,</span><br><span class="line">	Thief	= <span class="number">300</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="1-1-5-5-CTS委托类型"><a href="#1-1-5-5-CTS委托类型" class="headerlink" title="1.1.5.5 CTS委托类型"></a>1.1.5.5 CTS委托类型</h5><p>委托在.NET中等效于类型安全的C风格的函数指针</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个C#委托类型可以“指向”任意带有两个整型参数且返回一个整型值的方法</span></span><br><span class="line"><span class="function"><span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Binaryop</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="1-6-CLS"><a href="#1-6-CLS" class="headerlink" title="1.6 CLS"></a>1.6 CLS</h4><p>CLS是一套清晰地描述了支持，.NET的编译器必须支持的最小的和完全的特征集的规则，以生成可由CLR承载的代码，你不需要记忆所有的规则也能成为精通NET的程序员。总地来说，只有那些工具&#x2F;编译器的开发人员才会对CTS和CLS规范的具体细节感兴趣。</p>
<h4 id="1-7-CLR"><a href="#1-7-CLR" class="headerlink" title="1.7 CLR"></a>1.7 CLR</h4><p>从编程角度来说，运行库(runtime)可以理解为执行给定编译代码单元所需的外部服务的集合。.NET平台提供了另一种运行库系统。与其他系统不同在于.NET提供了一个定义明确的运行库层，可以被支持.NET的所有语言和平台所共享</p>
<h4 id="1-8-程序集-x2F-命名空间-x2F-类型的区别"><a href="#1-8-程序集-x2F-命名空间-x2F-类型的区别" class="headerlink" title="1.8 程序集&#x2F;命名空间&#x2F;类型的区别"></a>1.8 程序集&#x2F;命名空间&#x2F;类型的区别</h4><p>命名空间就是一个程序集内相关类型的一个分组。一个程序集（比如mscorlib.dll)可以包含任意个命名空间，每个命名空间又可以包含多种类型。</p>
<h5 id="1-1-8-1-以编程方式访问命名空间"><a href="#1-1-8-1-以编程方式访问命名空间" class="headerlink" title="1.1.8.1 以编程方式访问命名空间"></a>1.1.8.1 以编程方式访问命名空间</h5><p>命名空间只是一种方便我们从逻辑上理解和组织关联类型的方式，这一点应该反复强调。我们再来考虑System命名空间。从你的角度看，可以假设System.Console表示一个在System命名空间中名为Console的类，然而从.NET运行库的角度看，它却不是。运行时引擎只认识名为System.Console的独立实体。</p>
<h5 id="1-1-8-2-引用外部程序集"><a href="#1-1-8-2-引用外部程序集" class="headerlink" title="1.1.8.2 引用外部程序集"></a>1.1.8.2 引用外部程序集</h5><p>Framework程序集都位于称为全局程序集缓存(GAC)的特定目录下。在安装Windows的计算机上，全局程序集缓存默认状态下都位于C:\Windows\Assembly目录下根据构建NET应用程序所用的开发工具的不同，可以有多种不同的方法来告知编译器在编译期间要包括哪些程序集。下一章将会看到如何实现，在此就不再赘述。</p>
<h4 id="1-9-使用ildasm-exe探索程序集"><a href="#1-9-使用ildasm-exe探索程序集" class="headerlink" title="1.9 使用ildasm.exe探索程序集"></a>1.9 使用ildasm.exe探索程序集</h4><p>如果感到掌握NET平台中的每一个命名空间有些困难，那么只需要记住，各命名空间的区别在于，它们包含的语义上关联的类型不同。所以，如果只需要一个控制台程序而不需要用户界面，就可以不需要了解System.windows,Forms、System.Windows和System.web命名空间。中间语言反汇编工具（ildasm.exe）可以加载任意的.NET程序集并分析它的内容</p>
<p><strong>该程序详细使用部分略过</strong></p>
<h4 id="1-10-使用Reflector-exe来查看程序集"><a href="#1-10-使用Reflector-exe来查看程序集" class="headerlink" title="1.10 使用Reflector.exe来查看程序集"></a>1.10 使用Reflector.exe来查看程序集</h4><p>ildasm只能查看底层的CIL代码，而不是使用选择的托管代码查看程序集的实现Reflector提供了一个反汇编窗口和一个允许我们根据所选语言查看底层代码的下拉列表</p>
<p><strong>该程序详细使用部分略过</strong></p>
<h4 id="1-11-部署-NET运行库"><a href="#1-11-部署-NET运行库" class="headerlink" title="1.11 部署.NET运行库"></a>1.11 部署.NET运行库</h4><p>.NET程序集只能运行在安装了.NETFramework的计算机上。就是微软官网下载的NET3.5、4.5</p>
<h4 id="1-12-NET的平台无关性"><a href="#1-12-NET的平台无关性" class="headerlink" title="1.12 .NET的平台无关性"></a>1.12 .NET的平台无关性</h4><p>.NET程序集可以在非微软系统上开发和执行</p>
<h4 id="1-13-小结"><a href="#1-13-小结" class="headerlink" title="1.13 小结"></a>1.13 小结</h4><p>.NET本质上就是一个运行库执行引擎(mscoree.dll)和基础类库(mscorlib.dll等)。CLR可以承载任意符合托管代码规则的.NET二进制文件（又称程序集）。而程序集中有很多CIL指令（以及类型元数据和程序集清单)，这些指令通过即时编译器编译为特定平台的指令。另外，本章还讲述了CLS和CTS的作用。</p>
<h3 id="2-构建C-应用程序"><a href="#2-构建C-应用程序" class="headerlink" title="2 构建C#应用程序"></a>2 构建C#应用程序</h3><h4 id="2-1-NET-Framework-4-SDK的作用"><a href="#2-1-NET-Framework-4-SDK的作用" class="headerlink" title="2.1 .NET Framework 4 SDK的作用"></a>2.1 .NET Framework 4 SDK的作用</h4><p>如果你确实要使用Visual Studio20l0。就没有必要手动安装.NET Frame-work 4 SDK。当我们安装其中任一产品的时候，都会自动安装SDK,所有的东西都是现成的。</p>
<h4 id="2-2-用csc-exe构件-C-应用程序"><a href="#2-2-用csc-exe构件-C-应用程序" class="headerlink" title="2.2 用csc.exe构件 C#应用程序"></a>2.2 用csc.exe构件 C#应用程序</h4><p>略过</p>
<h4 id="2-3-开发环境搭建"><a href="#2-3-开发环境搭建" class="headerlink" title="2.3 开发环境搭建"></a>2.3 开发环境搭建</h4><p>略过</p>
<h2 id="C-核心编程结构"><a href="#C-核心编程结构" class="headerlink" title="C#核心编程结构"></a>C#核心编程结构</h2><h3 id="3-C-核心编程-I"><a href="#3-C-核心编程-I" class="headerlink" title="3 C#核心编程#I"></a>3 C#核心编程#I</h3><h4 id="3-1-一个简单的C-程序"><a href="#3-1-一个简单的C-程序" class="headerlink" title="3.1 一个简单的C#程序"></a>3.1 一个简单的C#程序</h4><p>正式地说，定义Main()方法的类叫做应用程序对象。虽然一个可执行程序可以有多个应用程序对象（在执行单元测试的时候可能有用），但是我们必须通过命令行编译器的&#x2F;main选项或通过位于Visual Studio20l0项目属性编辑器中Application选项卡内的Startup Object下拉列表框（参见第2章)来通知编译器将哪个Main()方法用作入口点。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study.CANDNET4PRO</span>	<span class="comment">//命名空间</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">simplecprogram</span>	<span class="comment">//类名</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>static是静态成员是类级别的（不属于对象级别的），因此在调用之前不需要先创建新的类实例void：不需要在退出方法域之前使用return关键字来显式定义一个返回值</p>
<h5 id="3-1-1-指定应用程序错误代码"><a href="#3-1-1-指定应用程序错误代码" class="headerlink" title="3.1.1 指定应用程序错误代码"></a>3.1.1 指定应用程序错误代码</h5><p>虽然绝大多数Main()方法会以void作为返回值，但是C#和其他C系列的语言一样，都可以从Main()返回一个int。根据惯例，返回值0表示程序正常结束，而其他值（如-1)则表示有错误发生(要知道，值0是自动返回的，即使Main()方法的原型结构返回void）。</p>
<ol>
<li><p>将程序执行成功的返回值修改成-1</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study.CANDNET4PRO</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">simplecprogram</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用bat脚本去获取返回值（应用的返回值保存在一个叫做%ERRORLEVEL%的系统环境变量中）。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@echo <span class="keyword">off</span></span><br><span class="line"></span><br><span class="line">study</span><br><span class="line">@<span class="keyword">if</span> <span class="string">&quot;%ERRORLEVEL%&quot;</span> == <span class="string">&quot;0&quot;</span> <span class="keyword">goto</span> success</span><br><span class="line"></span><br><span class="line">  :fail</span><br><span class="line">  echo this application has faild!</span><br><span class="line">  echo <span class="keyword">return</span> value = %ERRORLEVEL%</span><br><span class="line">  <span class="keyword">goto</span> <span class="keyword">end</span></span><br><span class="line">:success</span><br><span class="line">echo this application has succeeded!</span><br><span class="line">echo <span class="keyword">return</span> value = %ERRORLEVEL%</span><br><span class="line"><span class="keyword">goto</span> <span class="keyword">end</span></span><br><span class="line">:<span class="keyword">end</span></span><br><span class="line">echo all done.</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="3-1-2-处理命令行参数"><a href="#3-1-2-处理命令行参数" class="headerlink" title="3.1.2 处理命令行参数"></a>3.1.2 处理命令行参数</h5><p>将字符串数据传入数组，其中一个方法是使用C#的for循环</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study.CANDNET4PRO</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">simplecprogram</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; args.Length; i++)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;Arg：&#123;0&#125;&quot;</span>, args[i]);</span><br><span class="line">            <span class="comment">//Console.WriteLine(&quot;hello world&quot;);</span></span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>cmd输入参数执行返回输出值</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">study.exe /arg1 -arg2 -arg3</span><br><span class="line">&gt;&gt; Arg：/arg1</span><br><span class="line">&gt;&gt; Arg：-arg2</span><br><span class="line">&gt;&gt; Arg：-arg3</span><br></pre></td></tr></table></figure>

<h5 id="3-1-3-使用Visual-studio指定命令行参数"><a href="#3-1-3-使用Visual-studio指定命令行参数" class="headerlink" title="3.1.3 使用Visual studio指定命令行参数"></a>3.1.3 使用Visual studio指定命令行参数</h5><p>调式——&gt;xxx调试参数——&gt;命令行参数</p>
<h4 id="3-2-System-nvironment类的其他成员"><a href="#3-2-System-nvironment类的其他成员" class="headerlink" title="3.2 System.nvironment类的其他成员"></a>3.2 System.nvironment类的其他成员</h4><p>这个类允许我们通过不同的静态成员获取大量有关运行.NET应用程序的操作系统的细节</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> c.biancheng.net;</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"><span class="keyword">using</span> System.Threading.Tasks;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study.CANDNET4PRO</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title">ENVIRONMENT</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span>[] theargs = Environment.GetCommandLineArgs();</span><br><span class="line">            <span class="keyword">foreach</span>(<span class="built_in">string</span> arg <span class="keyword">in</span> theargs)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;arg：&#123;0&#125;&quot;</span>,arg);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>System.Environment的其他部分属性ExitCode，获取或设置应用程序中任何地方的退出代码Is64BitOperatingSystem，返回布尔值，代表主机是否运行64位操作系统MachineName，获取当前机器的名字NewLine，获得当前环境的换行符SystemDirectory，返回通向系统目录的完整路径UserName，返回启动这个应用程序的用户的名称参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/fangchen12312/article/details/54907075">https://blog.csdn.net/fangchen12312/article/details/54907075</a></p>
<h4 id="3-3-System-Console类"><a href="#3-3-System-Console类" class="headerlink" title="3.3 System.Console类"></a>3.3 System.Console类</h4><p>Console类封装了基于控制台应用程序的输入、输出和错误流操作。</p>
<h5 id="3-3-1-使用console类进行基本的输入和输出"><a href="#3-3-1-使用console类进行基本的输入和输出" class="headerlink" title="3.3.1 使用console类进行基本的输入和输出"></a>3.3.1 使用console类进行基本的输入和输出</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;1&quot;</span>);     <span class="comment">//标准输出</span></span><br><span class="line">        getuserdata();      <span class="comment">//调用方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getuserdata</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;please enter your name&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> username = Console.ReadLine();       <span class="comment">//等待用户输入并赋值</span></span><br><span class="line">        Console.Write(<span class="string">&quot;please enter your age&quot;</span>);</span><br><span class="line">        <span class="built_in">string</span> userage = Console.ReadLine();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        ConsoleColor prev = Console.ForegroundColor;  <span class="comment">//获取console当前的颜色</span></span><br><span class="line">        Console.ForegroundColor = ConsoleColor.Yellow;  <span class="comment">//设hiconsole的颜色为黄色</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, userage, username);  <span class="comment">//输出变量</span></span><br><span class="line"></span><br><span class="line">        Console.ForegroundColor = prev;  <span class="comment">//将颜色设置回去</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-格式化控制台输出"><a href="#3-3-2-格式化控制台输出" class="headerlink" title="3.3.2 格式化控制台输出"></a>3.3.2 格式化控制台输出</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, userage, username);  <span class="comment">//输出变量</span></span><br><span class="line"><span class="comment">//该语句中的&#123;0&#125;是占位符，可以用来传递一些要等到运行时才能知道其值得数据片段</span></span><br><span class="line"><span class="comment">//也不受顺序限制</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;1&#125; &#123;0&#125;&quot;</span>, <span class="number">30</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">// 输出：10 30</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-格式化数值类型"><a href="#3-3-3-格式化数值类型" class="headerlink" title="3.3.3 格式化数值类型"></a>3.3.3 格式化数值类型</h5><table>
<thead>
<tr>
<th>字符串格式字符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>c或c</td>
<td>用于格式化货币。默认情况下，这个标志会以当地的货币符号为前缀（美国英语中是一个美元符号[S])</td>
</tr>
<tr>
<td>D或d</td>
<td>用于格式化十进制数。这个标志还可以用干指定填充值的最小个数</td>
</tr>
<tr>
<td>E或e</td>
<td>用于指数记数法。无论指数常数是大写()还是小写()，都进行转换控制</td>
</tr>
<tr>
<td>F或f</td>
<td>用于定点小数的格式化。这个标志也用于指定填充值的最小个数</td>
</tr>
<tr>
<td>G或g</td>
<td>代表general。.这个字符能用来将一个数格式化为定点或指数格式</td>
</tr>
<tr>
<td>N或n</td>
<td>用于基本的数值格式化（带逗号）</td>
</tr>
<tr>
<td>X或x</td>
<td>用于十六进制格式化。如果使用大写的X,十六进制格式也会包含大写的字符</td>
</tr>
</tbody></table>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0:c&#125;, 9999&quot;</span>); <span class="comment">//格式化数值语法</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-4在控制台应用程序外格式化数值数据"><a href="#3-3-4在控制台应用程序外格式化数值数据" class="headerlink" title="3.3.4在控制台应用程序外格式化数值数据"></a>3.3.4在控制台应用程序外格式化数值数据</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> usermessage = <span class="built_in">string</span>.Format(&#123;<span class="number">0</span>:x&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>在其他语法中也可以使用格式化字符</p>
<h4 id="3-4-系统数据类型和C-简化符号"><a href="#3-4-系统数据类型和C-简化符号" class="headerlink" title="3.4 系统数据类型和C#简化符号"></a>3.4 系统数据类型和C#简化符号</h4><p>C#数据类型关键字其实是system命名空间中完整类型的简化符号例如：bool、int对应System.Boolean、System.Int32每一个数值类型（short、int等)都对应System命名空间中的一个结构。简单来说，结构是分配在栈上的值类型。而string和object是引用类型，也就是说变量是分配在托管堆上的。值类型可以在内存中快速分配，并且具有固定的可预测的生存周期。</p>
<h5 id="3-4-1-变量声明和初始化"><a href="#3-4-1-变量声明和初始化" class="headerlink" title="3.4.1 变量声明和初始化"></a>3.4.1 变量声明和初始化</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> myInt0; <span class="comment">//先声明后赋值</span></span><br><span class="line">    myInt0 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> myInt1 = <span class="number">1</span>; <span class="comment">//声明同时初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> myInt2 = <span class="number">2</span>, myInt3 = <span class="number">3</span>; <span class="comment">//一行声明多个相同实际类型的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-内建数据类型的新操作符"><a href="#3-4-2-内建数据类型的新操作符" class="headerlink" title="3.4.2 内建数据类型的新操作符"></a>3.4.2 内建数据类型的新操作符</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">bool</span> b = <span class="keyword">new</span> <span class="built_in">bool</span>();    <span class="comment">//设置为false</span></span><br><span class="line">    <span class="built_in">int</span> i = <span class="keyword">new</span> <span class="built_in">int</span>();  <span class="comment">//设置为0</span></span><br><span class="line">    DateTime dt = <span class="keyword">new</span> DateTime();   <span class="comment">//设置为1/1/0001 12:00:00 AM</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>允许使用new关键字来创建变量，它姜变量自动设置为其默认值</p>
<h5 id="3-4-3-数据类型类的层次结构"><a href="#3-4-3-数据类型类的层次结构" class="headerlink" title="3.4.3 数据类型类的层次结构"></a>3.4.3 数据类型类的层次结构</h5><p>类层次结构顶端的类型会为派生类型提供一些默认行为</p>
<h5 id="3-4-4-数值数据类型的成员"><a href="#3-4-4-数值数据类型的成员" class="headerlink" title="3.4.4 数值数据类型的成员"></a>3.4.4 数值数据类型的成员</h5><p>.NET的数值类型支持MaxValue和MinValue属性，还有很多其它类型的属性，但在此不提及</p>
<h5 id="3-4-5-System-Boolean成员"><a href="#3-4-5-System-Boolean成员" class="headerlink" title="3.4.5 System.Boolean成员"></a>3.4.5 System.Boolean成员</h5><p>bool类型的值只能来自集合{true|false}</p>
<h5 id="3-4-6-System-Char成员"><a href="#3-4-6-System-Char成员" class="headerlink" title="3.4.6 System.Char成员"></a>3.4.6 System.Char成员</h5><p>char与string二者都是表示一组连续的字符串的，但string表示一组连续的字符串（hello），而char则表示听类型中的单个字符（h）</p>
<h5 id="3-4-7-从字符串中解析数值"><a href="#3-4-7-从字符串中解析数值" class="headerlink" title="3.4.7 从字符串中解析数值"></a>3.4.7 从字符串中解析数值</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> b = <span class="built_in">bool</span>.Parse(<span class="string">&quot;True&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>parse将字符true解析为bool类型</p>
<h5 id="3-4-8-System-DateTime-和-System-TimeSpan"><a href="#3-4-8-System-DateTime-和-System-TimeSpan" class="headerlink" title="3.4.8 System.DateTime 和 System.TimeSpan"></a>3.4.8 System.DateTime 和 System.TimeSpan</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取当前时间</span></span><br><span class="line">    DateTime dt0 = DateTime.Now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造年月日</span></span><br><span class="line">    DateTime dt1 = <span class="keyword">new</span> DateTime(<span class="number">2010</span>, <span class="number">10</span>, <span class="number">17</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出格式化.月，日</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, dt1.Date, dt1.DayOfWeek);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建小时、分钟、秒的变量</span></span><br><span class="line">    TimeSpan ts = <span class="keyword">new</span> TimeSpan(<span class="number">4</span>, <span class="number">30</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从当前timespan中减去15分钟并输出结果</span></span><br><span class="line">    Console.WriteLine(ts.Subtract(<span class="keyword">new</span> TimeSpan(<span class="number">0</span>, <span class="number">15</span>, <span class="number">0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-9-NET4-System-Mum-erics命名空间"><a href="#3-4-9-NET4-System-Mum-erics命名空间" class="headerlink" title="3.4.9 NET4 System.Mum.erics命名空间"></a>3.4.9 NET4 System.Mum.erics命名空间</h5><p>NET4引入了一个新的命名空间System.Numerics,它定义了BigInteger结构。顾名思义，BigInteger数据类型可用来表示较大的数值（例如，美国国债），它没有固定的上下限。大部分程序都不需要使用BigIneteger结构，但一旦需要定义较大的数值时，你就需要为项目添加System.Numerics.dll程序集的引用需要特殊设置，此处不提及</p>
<h4 id="3-5-使用字符串数据"><a href="#3-5-使用字符串数据" class="headerlink" title="3.5 使用字符串数据"></a>3.5 使用字符串数据</h4><p>具体字符串方法关键词：System.String成员</p>
<h5 id="3-5-1-基本的字符串操作"><a href="#3-5-1-基本的字符串操作" class="headerlink" title="3.5.1 基本的字符串操作"></a>3.5.1 基本的字符串操作</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> test = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, test);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, test.ToUpper());</span><br><span class="line">Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, test.ToLower());</span><br></pre></td></tr></table></figure>
<p>ToUpper()并不会改变变量</p>
<h5 id="3-5-2-字符串拼接"><a href="#3-5-2-字符串拼接" class="headerlink" title="3.5.2 字符串拼接"></a>3.5.2 字符串拼接</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> test0 = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> test1 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> test2 = test0 + test1;</span><br><span class="line">    <span class="built_in">string</span> test2 = <span class="built_in">string</span>.concat(test0,test1);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, test2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>test0 + test1调用的是string.concat()方法</p>
<h5 id="3-5-3-转义字符"><a href="#3-5-3-转义字符" class="headerlink" title="3.5.3 转义字符"></a>3.5.3 转义字符</h5><p>\a可以出发系统警报</p>
<h5 id="3-5-4-定义逐字字符串"><a href="#3-5-4-定义逐字字符串" class="headerlink" title="3.5.4 定义逐字字符串"></a>3.5.4 定义逐字字符串</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// @在表示路径时候很有用</span></span><br><span class="line">    Console.WriteLine(<span class="string">@&quot;C:\test\test&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字字符串可以保存空格</span></span><br><span class="line">    <span class="built_in">string</span> test = <span class="string">@&quot;this is a vert&quot;</span>;</span><br><span class="line">    Console.WriteLine(test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-5-字符串和相等性"><a href="#3-5-5-字符串和相等性" class="headerlink" title="3.5.5 字符串和相等性"></a>3.5.5 字符串和相等性</h5><p>进行对引用类型相等性测试时，如果引用类型指向内存中的相同对象，则返回true</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> s1 = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, s1 == <span class="string">&quot;TEST&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, s1 == <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-5-6-字符串是不可变的"><a href="#3-5-6-字符串是不可变的" class="headerlink" title="3.5.6 字符串是不可变的"></a>3.5.6 字符串是不可变的</h5><p>一旦将初始值赋给字符串对象，字符数据就不能改变了。string类型的方法其实返回了一个按修改格式的新字符串对象</p>
<h5 id="3-5-7-System-Text-StringBuilder类型"><a href="#3-5-7-System-Text-StringBuilder类型" class="headerlink" title="3.5.7 System.Text.StringBuilder类型"></a>3.5.7 System.Text.StringBuilder类型</h5><p>StringBuilder的独特之处在于，当我们调用这个类型的成员时，都是直接修改对象内部的字符数据（因此更高效），而不是获取按修改后格式的数据副本。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引用</span></span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sb.AppendLine(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        sb.AppendLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        sb.AppendLine(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">        Console.WriteLine(sb.ToString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>默认情况下只能保存16个字符串以下的数据，可以通过构造函数来改变初始值</p>
<h4 id="3-6窄化和宽化数据类型转换"><a href="#3-6窄化和宽化数据类型转换" class="headerlink" title="3.6窄化和宽化数据类型转换"></a>3.6窄化和宽化数据类型转换</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">short</span> numb1 = <span class="number">9</span>, numb2 = <span class="number">10</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&quot;</span>, numb1, numb2, test(numb1, numb2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">test</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//方法test要求传入int，但Main传入了short，但程序造成执行。因为编译器把每一个short隐性宽化成int</span></span><br><span class="line"><span class="comment">//宽化用于定义隐式向上转换，并且不会导致数据丢失</span></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">short</span> numb1 = <span class="number">9</span>, numb2 = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">short</span> numb3 = (<span class="built_in">short</span>)test(numb1, numb2);</span><br><span class="line">    <span class="comment">//显示强制转换int为short（并允许数据丢失）</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0&#125; + &#123;1&#125; = &#123;2&#125;&quot;</span>, numb1, numb2, numb3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">test</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-1-捕捉窄化数据转换中的错误"><a href="#3-6-1-捕捉窄化数据转换中的错误" class="headerlink" title="3.6.1 捕捉窄化数据转换中的错误"></a>3.6.1 捕捉窄化数据转换中的错误</h5><p>显示强制转换允许我们强制编译器应用窄化转换（即使这样做可能导致数据丢失）。但有可能出现数据上溢，或数据下溢，并且没有报错。C#提供的checked和unchecked关键字将确保数据丢失肯定会被检测到</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">byte</span> b1 = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">byte</span> b2 = <span class="number">250</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//告诉编译器增加CIL代码，如果发生上溢或下溢就抛出异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span> sum = checked((<span class="built_in">byte</span>)Add(b1, b2));</span><br><span class="line">        Console.WriteLine(sum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (OverflowException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-2-设置项目级别的溢出检测"><a href="#3-6-2-设置项目级别的溢出检测" class="headerlink" title="3.6.2 设置项目级别的溢出检测"></a>3.6.2 设置项目级别的溢出检测</h5><p>C#编译器提供了&#x2F;checked标志。如果启用的话，所有运算都会被检测是否溢出。无需使用checked关键字具体设置到VS属性页中去设置</p>
<h5 id="3-6-3-unchecked关键字"><a href="#3-6-3-unchecked关键字" class="headerlink" title="3.6.3 unchecked关键字"></a>3.6.3 unchecked关键字</h5><p>该关键字是用来忽略溢出运算的</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unchecked</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">byte</span> sum = (<span class="built_in">byte</span>)(b1 + b2);</span><br><span class="line">    Console.WriteLine(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-6-4-System-Convert的作用"><a href="#3-6-4-System-Convert的作用" class="headerlink" title="3.6.4 System.Convert的作用"></a>3.6.4 System.Convert的作用</h5><p>同样可以用于宽化或窄化数据。是否采用是个人喜好问题</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">byte</span> myByte = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">int</span> myInt = <span class="number">200</span>;</span><br><span class="line">        myByte = Convert.ToByte(myInt);</span><br><span class="line">        Console.WriteLine(myByte);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-7-隐式类型本地变量"><a href="#3-7-隐式类型本地变量" class="headerlink" title="3.7 隐式类型本地变量"></a>3.7 隐式类型本地变量</h4><p>为每个变量显示地指定数据类型一直是很好的做法，但C#语言还可以使用var关键字来创造隐式类型的本地变量var关键字不必指定具体数据类型（int、 bool灯）。运行时，编译器将根据本地数据点的初始值来自动推断实际的数据类型</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> myIntt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> myBool = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-7-1-隐式类型变量的限制"><a href="#3-7-1-隐式类型变量的限制" class="headerlink" title="3.7.1 隐式类型变量的限制"></a>3.7.1 隐式类型变量的限制</h5><p>隐式类型只能用于方法或属性范围内的本地变量。用var关键字定义返回值、参数或自定义类型的字段数据，都是不合法的。具体略</p>
<h5 id="3-7-2-隐式类型数据是强类型数据"><a href="#3-7-2-隐式类型数据是强类型数据" class="headerlink" title="3.7.2 隐式类型数据是强类型数据"></a>3.7.2 隐式类型数据是强类型数据</h5><p>该数据点将视为它声明的类型。为该变量分配不同类型将导致编译时错误</p>
<h5 id="3-7-3-隐式类型本地变量的用途"><a href="#3-7-3-隐式类型本地变量的用途" class="headerlink" title="3.7.3 隐式类型本地变量的用途"></a>3.7.3 隐式类型本地变量的用途</h5><p>使用var声明本地变量并不能带来什么好处。这样会给其他阅读代码的人带来困扰，由于你无法快速判断实际的数据类型在某些情况下无法显式定义查询的返回类型，这时隐式类型就很有用了在代码中滥用隐式类型是一种糟糕的设计</p>
<h4 id="3-8-C-迭代结构"><a href="#3-8-C-迭代结构" class="headerlink" title="3.8 C#迭代结构"></a>3.8 C#迭代结构</h4><p>C#提供了如下四种迭代结构</p>
<ul>
<li>for</li>
<li>foreach&#x2F;in</li>
<li>while</li>
<li>do&#x2F;while</li>
</ul>
<h5 id="3-8-1-for循环"><a href="#3-8-1-for循环" class="headerlink" title="3.8.1 for循环"></a>3.8.1 for循环</h5><p>如果需要迭代一段代码固定次数，for语句会提供很大的灵活性</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ForandForEachLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// &quot;i&quot;仅在for循环域内可见</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Number is: &#123;0&#125; &quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-8-2-foreach循环"><a href="#3-8-2-foreach循环" class="headerlink" title="3.8.2 foreach循环"></a>3.8.2 foreach循环</h5><p>foreach关键字允许遍历数组中的所有项</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ForAndForEachLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span>[] carTypes = &#123;<span class="string">&quot;Ford&quot;</span>, <span class="string">&quot;DMW&quot;</span>, <span class="string">&quot;Yugo&quot;</span>, <span class="string">&quot;Honda&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">string</span> c <span class="keyword">in</span> carTtpes)</span><br><span class="line">        Console.WriteLine(c);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span>[] myInts = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> myInts)</span><br><span class="line">        Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-8-3-在foreach结构中使用var"><a href="#3-8-3-在foreach结构中使用var" class="headerlink" title="3.8.3 在foreach结构中使用var"></a>3.8.3 在foreach结构中使用var</h5><p>编译器可以准确地推断“类型的类型”</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">VarInForeachLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] myInts = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line">    <span class="comment">//在标准foreach中使用“var”</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> item <span class="keyword">in</span> myInts)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Item value: &#123;0&#125;&quot;</span>, item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-8-4-while和do-x2F-while循环结构"><a href="#3-8-4-while和do-x2F-while循环结构" class="headerlink" title="3.8.4 while和do&#x2F;while循环结构"></a>3.8.4 while和do&#x2F;while循环结构</h5><p>当希望执行一段语句直到满足某个终止条件时，while循环结构很有用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExecuteWhileLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> userIsDone = <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对字符串的小写副本进行测试</span></span><br><span class="line">    <span class="keyword">while</span>(userIsDone.ToLower() != <span class="string">&quot;yes&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;Are you done? [yes] [no]: &quot;</span>);</span><br><span class="line">        userIsDone = Console.ReadLine();</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In while loop&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>do&#x2F;while肯定会执行至少一次对应的代码块</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExecuteDowhileLoop</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> userIsDone = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;In do/while loop&quot;</span>);</span><br><span class="line">        Console.Write(<span class="string">&quot;Are you done? [yes] [no]: &quot;</span>);</span><br><span class="line">        userIsDone = Console.ReadLine();</span><br><span class="line">    &#125;<span class="keyword">while</span>(userIsDone.ToLower() != <span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-条件结构和关系-x2F-相等操作符"><a href="#3-9-条件结构和关系-x2F-相等操作符" class="headerlink" title="3.9 条件结构和关系&#x2F;相等操作符"></a>3.9 条件结构和关系&#x2F;相等操作符</h4><p>C#定义了两个结构来根据各种情况改变程序的流程</p>
<ul>
<li>if&#x2F;else</li>
<li>switch</li>
</ul>
<h5 id="3-9-1-if-x2F-else语句"><a href="#3-9-1-if-x2F-else语句" class="headerlink" title="3.9.1 if&#x2F;else语句"></a>3.9.1 if&#x2F;else语句</h5><p>C#中的if&#x2F;else语句只能用于布尔表达式，不能用于-1和0这样的值<strong>逻辑操作符</strong>&amp;&amp;和||操作符在必要时会“短路”处理，条件只要达成后面就不继续判断</p>
<table>
<thead>
<tr>
<th>逻辑操作符</th>
<th>示例</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>if((age &#x3D;&#x3D; 30)  &amp;&amp; (name &#x3D;&#x3D;”Fred”))</td>
<td>与。所有为真则真</td>
</tr>
<tr>
<td>&amp;#124;&amp;#124;</td>
<td>if((age &#x3D;&#x3D; 30)  &amp;#124;&amp;#124; (name &#x3D;&#x3D;”Fred”))</td>
<td>或。一个为真则真</td>
</tr>
<tr>
<td>！</td>
<td>if(!myBool)</td>
<td>非。表达式为假则真</td>
</tr>
</tbody></table>
<h5 id="3-9-2-switch语句"><a href="#3-9-2-switch语句" class="headerlink" title="3.9.2 switch语句"></a>3.9.2 switch语句</h5><p>switch语句允许我们根据预定义的选择来处理程序流程</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ExecuteSwitch</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> langChoice = Console.ReadLine();</span><br><span class="line">    <span class="built_in">int</span> n = <span class="built_in">int</span>.Parse(langChoice);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is 1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;this is 2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="literal">default</span>:</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;good luck&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-C-核心编程-II"><a href="#4-C-核心编程-II" class="headerlink" title="4 C#核心编程#II"></a>4 C#核心编程#II</h3><h4 id="4-1-方法和参数修饰符"><a href="#4-1-方法和参数修饰符" class="headerlink" title="4.1 方法和参数修饰符"></a>4.1 方法和参数修饰符</h4><p>方法可以在类或结构的范围内实现，并且可以被各种关键字修饰以限制其行为</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// static 返回值 方法名（参数）&#123;...&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-1-默认的参数传递行为"><a href="#4-1-1-默认的参数传递行为" class="headerlink" title="4.1.1 默认的参数传递行为"></a>4.1.1 默认的参数传递行为</h5><p>参数传入函数的默认行为是按照值传递。数据的副本会被传入函数，如果在成员的作用于内修改参数的值，改变的就是调用者数据值的副本，而原先的值不会改变</p>
<h5 id="4-1-2-out修饰符"><a href="#4-1-2-out修饰符" class="headerlink" title="4.1.2 out修饰符"></a>4.1.2 out修饰符</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y, <span class="keyword">out</span> <span class="built_in">int</span> ans</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    ans = x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-3-ref修饰符"><a href="#4-1-3-ref修饰符" class="headerlink" title="4.1.3 ref修饰符"></a>4.1.3 ref修饰符</h5><p>如果希望方法可以对在调用者作用域中声明的不同数据进行操作（通常是改变它的值），例如，排序和交换例程，就必须使用引用参数。注意输出参数和引用参数之间的区别。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SwapStrings</span>(<span class="params"><span class="keyword">ref</span> <span class="built_in">string</span> s1, <span class="keyword">ref</span> <span class="built_in">string</span> s2</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> tempStr = s1;</span><br><span class="line">    s1 = s2;</span><br><span class="line">    s2 = tempStr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;Flip&quot;</span>;</span><br><span class="line">    <span class="built_in">string</span> s2 = <span class="string">&quot;Flop&quot;</span>;</span><br><span class="line">    Console.WriteLine(s1,s2);</span><br><span class="line">    SwapString(<span class="keyword">ref</span> s1, <span class="keyword">ref</span> s2);</span><br><span class="line">    Console.WriteLine(s1,s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;</span><br><span class="line">Flip, Flop</span><br><span class="line">Flop, Flip</span><br></pre></td></tr></table></figure>

<h5 id="4-1-4-params修饰符"><a href="#4-1-4-params修饰符" class="headerlink" title="4.1.4 params修饰符"></a>4.1.4 params修饰符</h5><p>params关键字可以把可变数量的参数（相同类型）作为个逻辑参数传给方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">CalcuateAverage</span> (<span class="params"><span class="keyword">params</span> <span class="built_in">double</span>[] values</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(valuse.Length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; values.Length; i++)</span><br><span class="line">        sum += valuse[i];</span><br><span class="line">    <span class="keyword">return</span> ( sum / values.Length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-5-定义可选参数"><a href="#4-1-5-定义可选参数" class="headerlink" title="4.1.5 定义可选参数"></a>4.1.5 定义可选参数</h5><p>可以创建包含可选参数的方法。这允许调用者不指定不必要的参数，而是使用参数的默认值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">EnterLogData</span>(<span class="params"><span class="built_in">string</span> message, <span class="built_in">string</span> owner = <span class="string">&quot;Programmer&quot;</span></span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Error: &#123;0&#125;&quot;</span>, message);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Owner of Error: &#123;0&#125;&quot;</span>, owner);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    EnterLogData(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    EnterLogData(<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-6-使用命名参数调用方式"><a href="#4-1-6-使用命名参数调用方式" class="headerlink" title="4.1.6 使用命名参数调用方式"></a>4.1.6 使用命名参数调用方式</h5><p>与可选参数一样，支持命名参数的主要原因也是为了简化与COM的互操作允许在调用方法时以任意顺序指定参数的值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1</span>(<span class="params"><span class="built_in">string</span> a, <span class="built_in">string</span> b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(a);</span><br><span class="line">    Console.WriteLine(b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    print1(b: <span class="string">&quot;123&quot;</span>, a: <span class="string">&quot;321&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">321</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h5 id="4-1-7-成员重载"><a href="#4-1-7-成员重载" class="headerlink" title="4.1.7 成员重载"></a>4.1.7 成员重载</h5><p>当我们定义一组名字相同的成员时，如果它们的参数数量（或类型）不同，这样的成员就叫做被重载。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用int版本的Add</span></span><br><span class="line">    	Console.WriteLine(Add(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用double版本的Add</span></span><br><span class="line">        Console.WriteLine(Add(<span class="number">4.3</span>, <span class="number">4.4</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">double</span> <span class="title">Add</span>(<span class="params"><span class="built_in">double</span> x, <span class="built_in">double</span> y</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">long</span> <span class="title">Add</span>(<span class="params"><span class="built_in">long</span> x, <span class="built_in">long</span> y</span>)</span></span><br><span class="line">    &#123; <span class="keyword">return</span> x + y; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-C-中的数组操作"><a href="#4-2-C-中的数组操作" class="headerlink" title="4.2 C#中的数组操作"></a>4.2 C#中的数组操作</h4><p>数组是一组通过数字索引来访问的数据项。更精确地说，数组是一组相同类型的数据点(int数组、string数组，SportsCars数组等)</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SimpleArrays</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span>[] myInts = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">3</span>];	<span class="comment">//创建数组并设定边界</span></span><br><span class="line">        myInts[<span class="number">0</span>] = <span class="number">100</span>;	<span class="comment">//填充值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br></pre></td></tr></table></figure>

<h5 id="4-2-1-C-数组初始化语法"><a href="#4-2-1-C-数组初始化语法" class="headerlink" title="4.2.1 C#数组初始化语法"></a>4.2.1 C#数组初始化语法</h5><p>需要创建一个已知大小的数组，并且希望快速指定初始值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ArrayInitialization</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用new关键字的数组初始化语法</span></span><br><span class="line">    <span class="built_in">string</span>[] stringArray = <span class="keyword">new</span> <span class="built_in">string</span>[] &#123; <span class="string">&quot;one&quot;</span>, <span class="string">&quot;two&quot;</span>, <span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">	<span class="comment">//不使用new关键字的数组初始化语法</span></span><br><span class="line">    <span class="built_in">bool</span>[] boolArray = &#123; flase, flase, <span class="literal">true</span>&#125;;</span><br><span class="line">	<span class="comment">//使用new关键字和大小的数组初始化</span></span><br><span class="line">    <span class="built_in">int</span>[] intArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">4</span>] &#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-2-隐式类型本地数组"><a href="#4-2-2-隐式类型本地数组" class="headerlink" title="4.2.2 隐式类型本地数组"></a>4.2.2 隐式类型本地数组</h5><p>var同样可以用来定义数组。混合数组会报错</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeclarImplicaaitArrays</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//a为int[]</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span>[] &#123; <span class="number">1</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="comment">//b为string[]</span></span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span>[] &#123; <span class="string">&quot;t&quot;</span>, <span class="string">&quot;e&quot;</span> &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-定义object数组"><a href="#4-2-3-定义object数组" class="headerlink" title="4.2.3 定义object数组"></a>4.2.3 定义object数组</h5><p>System.Object是.NET类型系统中所有类型（包括基本数据类型）的最终基类。所以Objent的子项可以是任意东西</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">object</span>[] test = <span class="keyword">new</span> <span class="built_in">object</span>[<span class="number">4</span>];</span><br><span class="line">    test[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    test[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">    test[<span class="number">2</span>] = <span class="keyword">new</span> DateTime(<span class="number">1969</span>, <span class="number">3</span>, <span class="number">24</span>);</span><br><span class="line">    test[<span class="number">3</span>] = <span class="string">&quot;tet&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">object</span> obj <span class="keyword">in</span> test)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="4-2-4-使用多维数组"><a href="#4-2-4-使用多维数组" class="headerlink" title="4.2.4 使用多维数组"></a>4.2.4 使用多维数组</h5><p>矩形数组，每一行长度都相同</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RectMultdimensionaArray</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[,] myMatrix;</span><br><span class="line">    myMatrix = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">6</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>, j++)</span><br><span class="line">            myMareix[i,j] = i * j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>交错数组，每一个都有各自的上界</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">JaggeMuitidimensionaArray</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[][] myJagArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>][];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; myJagArray.Length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//声明一个具有5个不同数组的数组</span></span><br><span class="line">        myJagArray[i] = <span class="keyword">new</span> <span class="built_in">int</span>[i + <span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; myJagArray[i].Length; j++)</span><br><span class="line">            Console.Write(myJagArray[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<h5 id="4-2-5-数组作为参数（和返回值）"><a href="#4-2-5-数组作为参数（和返回值）" class="headerlink" title="4.2.5 数组作为参数（和返回值）"></a>4.2.5 数组作为参数（和返回值）</h5><p>将数组作为参数进行传递</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintArray</span>(<span class="params"><span class="built_in">int</span>[] myInsts</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i =  <span class="number">0</span>; i &lt; myInts.Length; i++)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, i, myInsts[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PassAndReceiveArrays</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span>[] args = &#123;<span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    PrintArray(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-2-6-System-Array基类"><a href="#4-2-6-System-Array基类" class="headerlink" title="4.2.6 System.Array基类"></a>4.2.6 System.Array基类</h5><p>每一个数组都从System.Array类获得了很多功能。使用这些公共成员，我们就能使用统一的对象模型来操作数组</p>
<h4 id="4-3-枚举类型"><a href="#4-3-枚举类型" class="headerlink" title="4.3 枚举类型"></a>4.3 枚举类型</h4><p>在构建系统的时候，创建一组符号名来对应已知的数字值会很方便。例如，如果创建一个工资系统，我们可能会希望使用诸如副总裁、经理、职员、实习生等常量来指代员工类型。C#支持自定义枚举的概念来满足这种需求。例如，下面是一个名为EmpType的枚举：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义枚举</span></span><br><span class="line"><span class="built_in">enum</span> EmpType</span><br><span class="line">&#123;</span><br><span class="line">	Manager,</span><br><span class="line">	Grunt,</span><br><span class="line">	Contractor,</span><br><span class="line">	VicePresident</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-控制枚举的底层存储"><a href="#4-3-1-控制枚举的底层存储" class="headerlink" title="4.3.1 控制枚举的底层存储"></a>4.3.1 控制枚举的底层存储</h5><p>默认情况下，用来保存枚举值的存储类型是System.Int32(C#int),当然也可以改成我们喜欢的类型。C#枚举可以以相似的方式定义为核心系统类型(byte、short、int或long)。如果我们构建的NET应用程序将会被部署在低内存的设备中（如支持.NET的手机或PDA),并且希望尽可能节省内存，那么改变枚举的实际类型可能会很有用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> EmpType : <span class="built_in">byte</span></span><br><span class="line">&#123;</span><br><span class="line">	manager =<span class="number">10</span>,</span><br><span class="line">	grunt = <span class="number">1</span>,</span><br><span class="line">	contractor = <span class="number">100</span>,</span><br><span class="line">	vicepresident = <span class="number">9</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-声明枚举变量"><a href="#4-3-2-声明枚举变量" class="headerlink" title="4.3.2 声明枚举变量"></a>4.3.2 声明枚举变量</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AskForBonus接受EmpType作为唯一变量，根据传入参数的值，输出对应的请求响应</span></span><br><span class="line"><span class="built_in">enum</span> EmpType</span><br><span class="line">    &#123;</span><br><span class="line">        Manageer,</span><br><span class="line">        Grunt,</span><br><span class="line">        Contractor,</span><br><span class="line">        VicePresident</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EmpType emp = EmpType.Contractor;</span><br><span class="line">        AskForBonus(emp);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AskForBonus</span>(<span class="params">EmpType e</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> EmpType.Manageer:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EmpType.Grunt:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EmpType.Contractor:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> EmpType.VicePresident:</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-3-3-System-Enum类型"><a href="#4-3-3-System-Enum类型" class="headerlink" title="4.3.3 System.Enum类型"></a>4.3.3 System.Enum类型</h5><p>略</p>
<h5 id="4-3-4-动态获取枚举的名称-x2F-值对"><a href="#4-3-4-动态获取枚举的名称-x2F-值对" class="headerlink" title="4.3.4 动态获取枚举的名称&#x2F;值对"></a>4.3.4 动态获取枚举的名称&#x2F;值对</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        EmpType emp = EmpType.Contractor;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125;&quot;</span>, emp.ToString());</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将输出Contractor</span></span><br></pre></td></tr></table></figure>


<h4 id="4-4-结构类型"><a href="#4-4-结构类型" class="headerlink" title="4.4 结构类型"></a>4.4 结构类型</h4><p>结构类型很适合在应用程序中对数学、几何以及其他“原子”实体建模。结构（和枚举相似）是用户自定义的类型，然而，结构不只是一组名称值对。结构是可以包含许多数据字段和操作这些字段的成员的类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)	<span class="comment">//调用</span></span></span><br><span class="line">&#123;</span><br><span class="line">    Point test;</span><br><span class="line">    test.x = <span class="number">349</span>;</span><br><span class="line">    test.y = <span class="number">76</span>;</span><br><span class="line">    test.Display();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Point	<span class="comment">//设置结构</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//结构的字段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Increment</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        x++; y++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Decrement</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        x--; y--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;X = &#123;0&#125;, Y = &#123;1&#125;&quot;</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-5-值类型和引用类型"><a href="#4-5-值类型和引用类型" class="headerlink" title="4.5 值类型和引用类型"></a>4.5 值类型和引用类型</h4><p>C#结构在.NET类库中是属于隐式派生自System.ValueType中。System.ValueType的作用是确保所有派生类型（如任何结构)都分配在栈上而不是垃圾回收堆上。创建和销毁分配在栈上的数据都很快，因为它的生命周期是由定义的作用域决定的</p>
<h5 id="4-5-1-值类型、引用类型和赋值操作符"><a href="#4-5-1-值类型、引用类型和赋值操作符" class="headerlink" title="4.5.1 值类型、引用类型和赋值操作符"></a>4.5.1 值类型、引用类型和赋值操作符</h5><p>当把一个值类型赋给另外一个时，就是对字段成员逐一进行复制。对于System.Int32这样的简单数据类型，唯一需要复制的成员就是数值。然而，对于我们的Point,X和Y值会被复制到新的结构变量中。</p>
<h5 id="4-5-2-包含引用类型的值类型"><a href="#4-5-2-包含引用类型的值类型" class="headerlink" title="4.5.2 包含引用类型的值类型"></a>4.5.2 包含引用类型的值类型</h5><p>当值类型包含其他引用类型时，赋值将生成一个引用的副本。这样就有两个独立的结构，每一个都包含指向内存中同一个对象的引用（也就是“浅复制”）。</p>
<h5 id="4-5-3-按值传递引用类型"><a href="#4-5-3-按值传递引用类型" class="headerlink" title="4.5.3 按值传递引用类型"></a>4.5.3 按值传递引用类型</h5><p>略</p>
<h5 id="4-5-4-按引用类型传递引用类型"><a href="#4-5-4-按引用类型传递引用类型" class="headerlink" title="4.5.4 按引用类型传递引用类型"></a>4.5.4 按引用类型传递引用类型</h5><p>按引用传递引用类型时需要记住的黄金规则如下：如果按引用传递引用类型，被调用者可能改变对象的状态数据的值和所引用的对象，如果按值传递引用类型，被调用者可能改变对象的状态数据的值，但不能改变所引用的对象。</p>
<h4 id="4-6-C-可空类型"><a href="#4-6-C-可空类型" class="headerlink" title="4.6 C#可空类型"></a>4.6 C#可空类型</h4><p>从.NET2.0发布后，我们就可以创建可控数据类型了</p>
<h5 id="4-6-1-使用可空类型"><a href="#4-6-1-使用可空类型" class="headerlink" title="4.6.1 使用可空类型"></a>4.6.1 使用可空类型</h5><p>所有数值类型都是值类型。值类型在声明之前是不允许被赋予null的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">int</span>? t1 = <span class="number">10</span>;	<span class="comment">//【?】声明可空类型</span></span><br><span class="line">    <span class="built_in">double</span>? t2 = <span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串是引用类型，不需要声明</span></span><br><span class="line">    <span class="comment">// string? s = &quot;oops&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-6-2-操作符"><a href="#4-6-2-操作符" class="headerlink" title="4.6.2 ??操作符"></a>4.6.2 ??操作符</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        DatabaseReader dr = <span class="keyword">new</span> DatabaseReader();</span><br><span class="line">        <span class="built_in">int</span> myData = dr.GetIntFromDatabase() ?? <span class="number">100</span>;    <span class="comment">//如果返回值为空，则将本地变量赋值为100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可替代if语句，让整体代码量更加紧凑</p>
<h3 id="5-定义封装的类类型"><a href="#5-定义封装的类类型" class="headerlink" title="5 定义封装的类类型"></a>5 定义封装的类类型</h3><p>如何构建支持任意数量的构造函数的定义的定义明确的类类型</p>
<h4 id="5-1-C-类类型"><a href="#5-1-C-类类型" class="headerlink" title="5.1 C#类类型"></a>5.1 C#类类型</h4><p>就.NET平台而言，最基础的编程结构就是类类型类是由字段数据（通常叫做成员变量）以及操作这个数据的成员（如构造函数、属性、方法、事件等）所构成的自定义类型</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span>	<span class="comment">//定义类类型</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Car的“状态”</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> petName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> currSpeed;</span><br><span class="line">	<span class="comment">//为了保护状态数据的完整性，最好将数据定义为私有的（或者是受保护的），并且通过类型属性对数据提供受控制的访问</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Car的功能</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintState</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;&#123;0&#125; is goint &#123;1&#125; MPH&quot;</span>, petName, currSpeed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpeedUp</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currSpeed += delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">stringp[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car myCar = <span class="keyword">new</span> Car();	<span class="comment">//分配和设置Car对象</span></span><br><span class="line">        <span class="comment">//，第一句代码只是声明了指向尚未被创建的car对象的引用。在我们通过new关键字把引用赋给对象之后，这个引用才会指向内存中的有效类实例。</span></span><br><span class="line">        myCar.petName = <span class="string">&quot;Hnery&quot;</span>;</span><br><span class="line">        myCar.currSpeed = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt;=<span class="number">10</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            myCar.SpeedUp(<span class="number">5</span>);</span><br><span class="line">            myCar.PrintState();</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用new关键字来分配对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params">stringp[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Car test = <span class="keyword">new</span> Car();</span><br><span class="line">    test.petName = <span class="string">&quot;Fred&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-2-构造函数"><a href="#5-2-构造函数" class="headerlink" title="5.2 构造函数"></a>5.2 构造函数</h4><p>C#支持构造函数，它允许在创建对象时创建其状态。构造函数是类的特殊方法，在使用new关键字创建对象时被间接调用。然而，和“普通”方法不同，构造函数永远不会返回值（即使是void),并且它的名字总是和需要构造的类的名字相同。</p>
<h5 id="5-2-1-默认构造函数的作用"><a href="#5-2-1-默认构造函数的作用" class="headerlink" title="5.2.1 默认构造函数的作用"></a>5.2.1 默认构造函数的作用</h5><p>除了把新对象分配到内存中，默认构造函数确保所有字段数据都设置为正确的默认值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Car的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> petName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> currSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        petName = <span class="string">&quot;chuck&quot;</span>;</span><br><span class="line">        currSpeed = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car chuck = <span class="keyword">new</span> Car();</span><br><span class="line">        chuck.printState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-2-定义自定义的构造函数"><a href="#5-2-2-定义自定义的构造函数" class="headerlink" title="5.2.2 定义自定义的构造函数"></a>5.2.2 定义自定义的构造函数</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> petName;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> currSpeed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义的默认构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        petName = <span class="string">&quot;Chuck&quot;</span>;</span><br><span class="line">        currSpeed = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> pn</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        PetName = pn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> pn, <span class="built_in">int</span> cs</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        petName = pn;</span><br><span class="line">        currSpeed = cs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据传递不同参数调用不同的初始值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Car chuck = <span class="keyword">new</span> Car();</span><br><span class="line">    chuck.printState();</span><br><span class="line"></span><br><span class="line">    Car mary = <span class="keyword">new</span> Car(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    mary.printState();</span><br><span class="line"></span><br><span class="line">    Car daisy = <span class="keyword">new</span> Car(<span class="string">&quot;Daisy&quot;</span>, <span class="number">75</span>);</span><br><span class="line">    daisy.printState();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-2-3-定义自定义的构造函数"><a href="#5-2-3-定义自定义的构造函数" class="headerlink" title="5.2.3 定义自定义的构造函数"></a>5.2.3 定义自定义的构造函数</h5><p>略</p>
<h4 id="5-3-this关键字的作用"><a href="#5-3-this关键字的作用" class="headerlink" title="5.3 this关键字的作用"></a>5.3 this关键字的作用</h4><p>this关键字可能的用途就是，解决当传人参数的名字和类型数据字段的名字相同时产生的作用域歧义</p>
<h5 id="5-3-1-使用this进行串联构造函数调用"><a href="#5-3-1-使用this进行串联构造函数调用" class="headerlink" title="5.3.1 使用this进行串联构造函数调用"></a>5.3.1 使用this进行串联构造函数调用</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> t0;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> t1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span>(<span class="params"><span class="built_in">int</span> shuzi</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shuzi &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            shuzi = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t0 = shuzi;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span>(<span class="params"><span class="built_in">int</span> shuzi, <span class="built_in">string</span> name</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (shuzi &gt; <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            shuzi = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t0 = shuzi;</span><br><span class="line">        t1 = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要理解的是，使用this关键字串联构造函数不是强制的。但如果使用这项技术，类定义就会更容易维护、更简明。再说一次，使用这项技术可以简化编程任务，因为真正的工作都交给了一个构造函数（通常这个构造函数有大多数的参数）来做，而其他构造函数只是在推卸责任。</p>
<h5 id="5-3-2-观察构造函数流程"><a href="#5-3-2-观察构造函数流程" class="headerlink" title="5.3.2 观察构造函数流程"></a>5.3.2 观察构造函数流程</h5><p>略</p>
<h5 id="5-3-3-再谈可选参数"><a href="#5-3-3-再谈可选参数" class="headerlink" title="5.3.3 再谈可选参数"></a>5.3.3 再谈可选参数</h5><p>略</p>
<h4 id="5-4-static关键字"><a href="#5-4-static关键字" class="headerlink" title="5.4 static关键字"></a>5.4 static关键字</h4><p>C#类（或结构）可以通过static关键字来定义许多静态成员。如果这样的话，这些成员就只能直接从类级别而不是对象引用调用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误的方法——WriteLine不是实例级别的方法</span></span><br><span class="line">Console c = <span class="keyword">new</span> Console();</span><br><span class="line">c.WriteLine(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//正确的方法</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;Hello world&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="5-4-1-定义静态方法"><a href="#5-4-1-定义静态方法" class="headerlink" title="5.4.1 定义静态方法"></a>5.4.1 定义静态方法</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Teenager</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Random r = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">GetRandomNumber</span>(<span class="params"><span class="built_in">short</span> upperLimit</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> r.Next(upperLimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> <span class="title">Complain</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>[] messages = &#123;<span class="string">&quot;Do i have to?&quot;</span>, <span class="string">&quot;He started it!&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;I&#x27;m too tired...&quot;</span>, <span class="string">&quot;I hate chool!&quot;</span>,</span><br><span class="line">                             <span class="string">&quot;You are sooooo wrong!&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">return</span> messages[GetRandomNumber(<span class="number">5</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">        Console.WriteLine(Teenager.Complain());	<span class="comment">//类中静态方法调用方法</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-4-2-定义静态数据"><a href="#5-4-2-定义静态数据" class="headerlink" title="5.4.2 定义静态数据"></a>5.4.2 定义静态数据</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SavingsAccount</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> currBalance;</span><br><span class="line">    <span class="comment">//静态数据点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">double</span> currInterestRate = <span class="number">0.04</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SavingsAccount</span> (<span class="params"><span class="built_in">double</span> balance</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        currBalance = balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，当创建SavingsAccount类的新实例时，静态数据的值没有重置，因为CLR把数据分配到内存中只会进行一次。之后，所有SavingsAccount类型的对象会操作同一个值。在设计C#类时，哪一部分数据应该定义为静态成员，而哪一部分数据不应该定义为静态成员，这是一个难题。尽管没有硬性规定，但要记住静态数据字段是由所有对象共享的。因此，如果你要定义一个所有对象都可以分享的数据点，就可以使用静态成员。</p>
<h5 id="5-4-3-定义静态构造函数"><a href="#5-4-3-定义静态构造函数" class="headerlink" title="5.4.3 定义静态构造函数"></a>5.4.3 定义静态构造函数</h5><p>略</p>
<h5 id="5-4-4-定义静态类"><a href="#5-4-4-定义静态类" class="headerlink" title="5.4.4 定义静态类"></a>5.4.4 定义静态类</h5><p>可以在类级别应用static关键字。那样子不能使用new关键字来创建，并且只能包含用static关键字标记的成员或字段</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">TimeUtilclass</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintTime</span>()</span></span><br><span class="line">    &#123;Console.WriteLine(DateTime.Now.ToShortTimestring()); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintDate</span>()</span></span><br><span class="line">    &#123;Console.WriteLine(DateTime.Today.ToShortDatestring()); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-5-定义OOP的支柱"><a href="#5-5-定义OOP的支柱" class="headerlink" title="5.5 定义OOP的支柱"></a>5.5 定义OOP的支柱</h4><p>所有基于对象的语言必须满足OOP的3个核心原则</p>
<ul>
<li>封装：这种语言怎样隐藏一个对象的内部实现并且保护数据的完整性？</li>
<li>继承：这种语言时怎样促进代码重用的？</li>
<li>多态：这种语言怎样让你用同样的方式处理相关对象的？</li>
</ul>
<h5 id="5-5-1-封装的作用"><a href="#5-5-1-封装的作用" class="headerlink" title="5.5.1 封装的作用"></a>5.5.1 封装的作用</h5><p>这是将对象用户不必了解的实现细节隐藏起来的一种语言能力</p>
<h5 id="5-5-2-继承的作用"><a href="#5-5-2-继承的作用" class="headerlink" title="5.5.2 继承的作用"></a>5.5.2 继承的作用</h5><p>它是指基于已有类定义来创建新类定义的语言能力子类可以继承基类（或称父类）核心的功能，并扩展基类的行为</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Radio</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Power</span>(<span class="params"><span class="built_in">bool</span> turnOn</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Radio on:(0&#125;&quot;</span>,turnon);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//汽车“has-a”收音机</span></span><br><span class="line">	<span class="keyword">private</span> Radio myRadio = <span class="keyword">new</span> Radio();</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TurnonRadio</span>(<span class="params"><span class="built_in">bool</span> onoff</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">//到内部对象的委托调用</span></span><br><span class="line">		myRadio.Power (onoff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//调用在内部被转发到Radio</span></span><br><span class="line">    <span class="function">Car viper <span class="keyword">new</span> <span class="title">car</span>()</span>;</span><br><span class="line">    viper.TurnonRadio(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-3-多态的作用"><a href="#5-5-3-多态的作用" class="headerlink" title="5.5.3 多态的作用"></a>5.5.3 多态的作用</h5><p>它表示的是语言以同一种方式处理相关对象的能力</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Shape[] myShapes = <span class="keyword">new</span> Shape[<span class="number">3</span>];</span><br><span class="line">        myShapes[<span class="number">0</span>] = <span class="keyword">new</span> Hexagon();</span><br><span class="line">        myShapes[<span class="number">1</span>] = <span class="keyword">new</span> Circle();</span><br><span class="line">        myShapes[<span class="number">2</span>] = <span class="keyword">new</span> Hexagon();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Shape s <span class="keyword">in</span> myShapes)</span><br><span class="line">        &#123;</span><br><span class="line">            s.Draw();</span><br><span class="line">        &#125;</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-6-C-访问修饰符"><a href="#5-6-C-访问修饰符" class="headerlink" title="5.6 C#访问修饰符"></a>5.6 C#访问修饰符</h4><p>在使用封装的时候，我们必须考虑类型的哪些方面对我们应用程序的哪些部分可见。准确地说，类型（类、接口、结构、枚举以及委托）以及它们的成员（属性、方法、构造函数、字段等）总是使用某个关键字来定义，这个关键字用来控制它们对应用程序其他部分如何“可见”。尽管C#定义了许多关键字来控制权限，但是它们会因为应用的地方不同.（类型或成员）而不同</p>
<h5 id="5-6-1-默认的访问修饰符"><a href="#5-6-1-默认的访问修饰符" class="headerlink" title="5.6.1 默认的访问修饰符"></a>5.6.1 默认的访问修饰符</h5><p>默认情况下，类型成员是隐式私有的。如果要从其他类型调用对象的成员，我们必须将它们标记为公共可访问的</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具有公共默认构造函数的公共类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Radio</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Radio</span>()</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-6-2-访问修饰符和嵌套类型"><a href="#5-6-2-访问修饰符和嵌套类型" class="headerlink" title="5.6.2 访问修饰符和嵌套类型"></a>5.6.2 访问修饰符和嵌套类型</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\\嵌套类型是直接声明在类或结构作用域中的类型</span><br><span class="line"></span><br><span class="line">\\一个嵌套在公共类中的私有枚举</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SportsCar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">enum</span> CarColor</span><br><span class="line">    &#123;</span><br><span class="line">        Red, Green, Blue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-7-第一个支柱：C-的封装服务"><a href="#5-7-第一个支柱：C-的封装服务" class="headerlink" title="5.7 第一个支柱：C#的封装服务"></a>5.7 第一个支柱：C#的封装服务</h4><p>封装概念的核心是，对象的内部数据不应该从对象实例直接访问。如果调用者想改变对象的状态，就要使用访问方法（即getter)和修改方法（即setter)。在C#中，封装是通过public、private、protected和internal关键字在语法级别体现的封装提供了一种保护状态数据完整性的方法。与定义公共字段相比（很容易发生数据损坏)，应该更多地定义私有数据字段，这种字段可以由调用者间接地操作</p>
<h5 id="5-7-1-使用传统的访问方法和修改方法执行封装"><a href="#5-7-1-使用传统的访问方法和修改方法执行封装" class="headerlink" title="5.7.1 使用传统的访问方法和修改方法执行封装"></a>5.7.1 使用传统的访问方法和修改方法执行封装</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字段数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> empName;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> empID;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currPay;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span>(<span class="params"><span class="built_in">string</span> name,<span class="built_in">int</span> id,<span class="built_in">float</span> pay</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        empName name;</span><br><span class="line">        empID id;</span><br><span class="line">        currpay pay;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GiveBonus</span>(<span class="params"><span class="built_in">float</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	currPay += amount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Name:&#123;0)&quot;</span>,empName);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ID:(0)&quot;</span>,empID);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Pay:(0)&quot;</span>,currPay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-7-2-使用-NET属性进行封装"><a href="#5-7-2-使用-NET属性进行封装" class="headerlink" title="5.7.2 使用.NET属性进行封装"></a>5.7.2 使用.NET属性进行封装</h5><p>.NET语言还是提倡使用属性来强制数据封装状态数据。属性总是映射到“实际的”访问方法和修改方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> empName;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> empID;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">float</span> currPay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Name</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> empName; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">value</span>.Length &gt; <span class="number">15</span>)</span><br><span class="line">            	Console.WriteLine(<span class="string">&quot;Error!Name must be less than 16 characters!&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                empName = <span class="keyword">value</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Employee emp = <span class="keyword">new</span> Employee(<span class="string">&quot;test&quot;</span>,<span class="number">456</span>,<span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//设置和获取Name属性</span></span><br><span class="line">    emp.Name = <span class="string">&quot;Mart&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>属性就等同于公共数据点，在背后会调用响应的get或set块来保持封装</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int表示该属性所封装的数据类型</span></span><br><span class="line"><span class="comment">//数据类型必须与相关的字段(empID)相同</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> ID<span class="comment">//没有括号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">get</span> &#123; <span class="keyword">return</span> empID; &#125;</span><br><span class="line">    <span class="keyword">set</span> &#123; empID = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-7-3-使用类的属性"><a href="#5-7-3-使用类的属性" class="headerlink" title="5.7.3 使用类的属性"></a>5.7.3 使用类的属性</h5><p>通常类的构造函数会接受传入参数，检查有效数据，赋值给内部私有字段为了简化代码，并把所有的错误检查隔离到一个中心位置，可以一直再类中使用属性</p>
<h5 id="5-7-4-属性的内部表示"><a href="#5-7-4-属性的内部表示" class="headerlink" title="5.7.4 属性的内部表示"></a>5.7.4 属性的内部表示</h5><p>许多程序员往往使用get和set前缀来命名传统的访问方法和修改方法（例如，get_Name() 和et_Name())。这种命名约定本身没有问题。然而，在底层，C#属性也是使用同样的前缀用CL 代码来表示的，理解这一点非常重要。 例如，如果用ildasm.exe打开EmployeeApp.cxe程序集，将看到每一个属性实际上被映射到由CLR 内部调用的隐藏的get_x()&#x2F;set_Xx()方法</p>
<h5 id="5-7-5-控制属性get-x2F-set语句的可见性级别"><a href="#5-7-5-控制属性get-x2F-set语句的可见性级别" class="headerlink" title="5.7.5 控制属性get&#x2F;set语句的可见性级别"></a>5.7.5 控制属性get&#x2F;set语句的可见性级别</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象用户只能获取值，然而Emloyee类和派生类型可以设置值</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span> &#123; <span class="keyword">return</span> empSSN; &#125;</span><br><span class="line">	<span class="keyword">protected</span> <span class="keyword">set</span> &#123; empSSN = <span class="keyword">value</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-7-6-只读和只写属性"><a href="#5-7-6-只读和只写属性" class="headerlink" title="5.7.6 只读和只写属性"></a>5.7.6 只读和只写属性</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//忽略set块，即只读。反之一样，忽略get块即只写</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">string</span> test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">get</span> &#123; <span class="keyword">return</span> empSSN； &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-7-7-静态属性"><a href="#5-7-7-静态属性" class="headerlink" title="5.7.7 静态属性"></a>5.7.7 静态属性</h5><p>静态成员是在类级别访问的，而不能从这个类的实例（对象）访问</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//静态属性必须在静态数据上操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">string</span> companyName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">string</span> Company</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> <span class="keyword">return</span> companyName;</span><br><span class="line">        <span class="keyword">set</span> companyName <span class="keyword">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//与静态属性交互</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with Encapsulation *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置公司</span></span><br><span class="line">    Employee.Company = <span class="string">&quot;My Company&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;These folks work at (0).&quot;</span>,Employee.Company);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Employee emp <span class="keyword">new</span> <span class="title">Employee</span> (<span class="params"><span class="string">&quot;Marvin&quot;</span>,<span class="number">24</span>,<span class="number">456</span>,<span class="number">30000</span>,<span class="string">&quot;111-11-1111&quot;</span></span>)</span>;</span><br><span class="line">    emp.GiveBonus(<span class="number">1000</span>);</span><br><span class="line">    emp.Displaystats();</span><br><span class="line">        </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-8-自动属性"><a href="#5-8-自动属性" class="headerlink" title="5.8 自动属性"></a>5.8 自动属性</h4><p>C#语言提供了另外一种使用最少的代码定义简单的封装服务的方法，这种方法就是使用自动属性语法要简化封装字段数据的过程，可以使用自动属性语法。顾名思义，该特性使用一种新的语法，为编译器减轻了定义私有返回字段和相关C#属性成员的工作。考虑下面对于Car类的改造，我们使用这种语法快速创建了3个属性：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//原语句</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//使用标准属性语法的Car类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> carName = <span class="built_in">string</span>.Empty;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> carName; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; carName <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//改造语句</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自动属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自动属性也可以将get/set设置为私有和公共的</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> SomeotherProperty &#123; <span class="keyword">get</span>; <span class="keyword">protected</span> <span class="keyword">set</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>在定义自动属性时，只指定访问修饰符、实际的数据类型、属性名称和空的get&#x2F;set作用域。在编译时，编译器为类型自动生成了私有返回字段和适当的get&#x2F;set实现逻辑。</p>
<h5 id="5-8-1-与自动属性交互"><a href="#5-8-1-与自动属性交互" class="headerlink" title="5.8.1 与自动属性交互"></a>5.8.1 与自动属性交互</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自动属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Speed &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> Color &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Car Name: &#123;0&#125;&quot;</span>,PetName);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Speed: &#123;0&#125;&quot;</span>,Speed);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Color: &#123;0&#125;&quot;</span>,Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在使用定义了自动属性的对象时，可以用属性语法来设置和获取值：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Automatic Properties *****n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    Car c = <span class="keyword">new</span> Car();</span><br><span class="line">    c.PetName = <span class="string">&quot;Frank&quot;</span>;</span><br><span class="line">    c.Speed = <span class="number">55</span>;</span><br><span class="line">    c.Color = <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Your car is named (0)?That&#x27;s odd...&quot;</span>, c.PetName):</span><br><span class="line">    c.Displaystats();</span><br><span class="line">                      </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="5-8-2-关于自动属性和默认值"><a href="#5-8-2-关于自动属性和默认值" class="headerlink" title="5.8.2 关于自动属性和默认值"></a>5.8.2 关于自动属性和默认值</h5><p>你可以直接在代码库中使用封装了数字或布尔数据的自动属性，因为隐藏的返回字段将设置一个可以直接使用的安全的默认值。但如果自动属性包装了另一个类变量，隐藏的私有引用类型的默认值也将设置为null。</p>
<h4 id="5-9-对象初始化器语法"><a href="#5-9-对象初始化器语法" class="headerlink" title="5.9 对象初始化器语法"></a>5.9 对象初始化器语法</h4><p>当你使用其他人设计的类时，包括使用NET基础类库中的类时，你往往会发现没有一个构造函数允许我们设置所有的状态数据。因此，程序员常常被迫去挑选最合适的构造函数，然后再使用所提供的一些属性赋值。为了简化新建对象的过程，C#提供了对象初始化器语法。使用这项技术，只用少量代码就可以创建对象并设置一些属性和公共字段。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xVal,<span class="built_in">int</span> yval</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xVal;</span><br><span class="line">        Y = yval;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span> &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Console.writeLine(<span class="string">&quot;[&#123;0),(1)]&quot;</span>,X,Y);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    现在，考虑下面的创建Point对象的方法：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过手动设置各个属性来创建Point</span></span><br><span class="line">    <span class="function">Point firstPoint <span class="keyword">new</span> <span class="title">Point</span>()</span>;</span><br><span class="line">    firstPoint.X = <span class="number">10</span>;</span><br><span class="line">    firstPoint.Y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//或通过自定义构造函数创建Point</span></span><br><span class="line">    Point anotherPoint = <span class="keyword">new</span> Point(<span class="number">20</span>,<span class="number">20</span>);</span><br><span class="line">    anotherPoint.Displaystats();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//或使用对象初始化语法创建Point</span></span><br><span class="line">    Point finalPoint = <span class="keyword">new</span> Point &#123; X = <span class="number">30</span>, Y = <span class="number">30</span> &#125;;</span><br><span class="line">    finalPoint.Displaystats();</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一个Point变量没有像以前那样使用自定义构造函数，但仍然可以对公共的X、Y属性赋值。在后台调用的是类型的默认构造函数，然后再给指定的属性赋值。因此，对象初始化语法只是使用默认构造函数创建类变量并设置各个属性状态数据的语法的简写形式。</p>
<h5 id="5-9-1-使用初始化语法调用自定义构造函数"><a href="#5-9-1-使用初始化语法调用自定义构造函数" class="headerlink" title="5.9.1 使用初始化语法调用自定义构造函数"></a>5.9.1 使用初始化语法调用自定义构造函数</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">enum</span> PointColor</span><br><span class="line">&#123; LightBlue,BloodRed,Gold &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> PointColor Color&#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span> (<span class="params"><span class="built_in">int</span> xVal,<span class="built_in">int</span> yval</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xVal;</span><br><span class="line">        y = yval;</span><br><span class="line">        Color = PointColor.Gold;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span> (<span class="params">PointColor ptColor</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Color ptColor;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span></span><br><span class="line"><span class="function">    	: <span class="title">this</span>(<span class="params">PointColor.BloodRed</span>)</span> &#123;&#125;</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;[&#123;0),&#123;1)]&quot;</span>,X,Y);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Point is &#123;0)&quot;</span>,Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用这个新的构造函数，可以创建一个金色的点（位置在(90,20)：</span></span><br><span class="line"><span class="comment">//使用初始化语法调用自定义构造函数</span></span><br><span class="line"><span class="function">Point goldPoint <span class="keyword">new</span> <span class="title">Point</span> (<span class="params">PointColor.Gold</span>)</span>&#123;X = <span class="number">90</span>,Y = <span class="number">20</span> &#125;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Value of Point is:&#123;0&#125;&quot;</span>,goldPoint.Displaystats());</span><br></pre></td></tr></table></figure>


<h5 id="5-9-2-初始化内部类型"><a href="#5-9-2-初始化内部类型" class="headerlink" title="5.9.2 初始化内部类型"></a>5.9.2 初始化内部类型</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Point topLeft <span class="keyword">new</span> <span class="title">Point</span> ()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Point bottomRight <span class="keyword">new</span> <span class="title">Point</span> ()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Point TopLeft</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> topLeft; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123;topLeft=<span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Point BottomRight</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> bottomRight; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; bottomRight = <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Displaystats</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;[TopLeft:(0),(1),(2)BottomRight:(3),(4),(5)]&quot;</span>,</span><br><span class="line">            topLeft.X,topLeft.Y,topLeft.Color,</span><br><span class="line">            bottomRight.X,bottomRight.Y,bottomRight.Color);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用对象初始化语法，可以像下面这样新建Rectangle变量并设置内部Point:</span></span><br><span class="line"><span class="comment">//创建并初始化Rectangle</span></span><br><span class="line">Rectangle myRect = <span class="keyword">new</span> Rectangle</span><br><span class="line">&#123;</span><br><span class="line">    TopLeft = <span class="keyword">new</span> Point &#123; X = <span class="number">10</span>,Y = <span class="number">10</span> &#125;</span><br><span class="line">    BottomRight = <span class="keyword">new</span> Point &#123; X = <span class="number">200</span>,Y = <span class="number">200</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法从根本上减少了代码量，看起来更简洁</span></span><br></pre></td></tr></table></figure>


<h4 id="5-10-常量数据"><a href="#5-10-常量数据" class="headerlink" title="5.10 常量数据"></a>5.10 常量数据</h4><p>如果我们要为应用程序定义逻辑上和某个类或结构相关的一组已知值的话，就非常有用。const关键字来定义常量（赋初始值之后无法给改变）。定义常量时必须为常量指定初始值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">const</span> <span class="built_in">double</span> PI = <span class="number">3.14</span>;</span><br></pre></td></tr></table></figure>

<h5 id="5-10-1-只读字段"><a href="#5-10-1-只读字段" class="headerlink" title="5.10.1 只读字段"></a>5.10.1 只读字段</h5><p>和常量类似，在赋初始值后无法改变。但和常量不同的是，赋给只读字段的值可以在运行时决定</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">readonly</span> <span class="built_in">double</span> PI;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">test</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PI = <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-10-2-静态只读字段"><a href="#5-10-2-静态只读字段" class="headerlink" title="5.10.2 静态只读字段"></a>5.10.2 静态只读字段</h5><p>只读字段不是隐式静态的。如果要从类级别公开PI，就必须显式使用stactic关键字</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行前就知道值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">double</span> PI = <span class="number">3.14</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果在运行时才赋值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="built_in">double</span> PI;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">test</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PI = <span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-11-分部类型"><a href="#5-11-分部类型" class="headerlink" title="5.11 分部类型"></a>5.11 分部类型</h4><p>在创建类时，多数代码在确立后基本可以忽略不记。例如，字段数据、属性和构造函数在生产过程中很少变动，而方法却需要经常修改如果愿意，你可以将一个类分布到多个C#文件中</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单个文件</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字段数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//转换成多个文件</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//test.cs</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test.Internal.cs</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//字段数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译这个修改后的项目，你会发现一切都没有变化。分部类的整个理念都是在设计时实现的。</p>
<h3 id="6-继承和多态"><a href="#6-继承和多态" class="headerlink" title="6 继承和多态"></a>6 继承和多态</h3><p>使用继承永来构建一组相关类。我们会看到，这种形式的代码重用允许我们在父类中定义通用功能，并且这种功能可以披子类所使用（或者改变）。然后，我们会学习如何使用虚成员和抽象成员在类层次结构中创建多态接口。</p>
<h4 id="6-1-继承的基本机制"><a href="#6-1-继承的基本机制" class="headerlink" title="6.1 继承的基本机制"></a>6.1 继承的基本机制</h4><p>代码重用归为两类：经典继承（is-a关系）、包含\委托模型（has-a关系）经典继承的基本思想是新的类可以利用既有类的功能</p>
<h5 id="6-1-1-指定既有类的父类"><a href="#6-1-1-指定既有类的父类" class="headerlink" title="6.1.1 指定既有类的父类"></a>6.1.1 指定既有类的父类</h5><p>作为新类基础的既有类叫做基类或父类。基类的作用是为扩展它的类定义所有公共数据以及成员。扩展类叫做派生类或子类。在C#中，我们在类定义中利用冒号操作符在类之间创建“is-a”关系：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Minivan是一个car</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Minivan</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尽管Minivan中没有内容，但其从Car继承了每一个公共成员的访问权限，因此可以如下使用</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Basic Inheritance *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//创建Minivan对象</span></span><br><span class="line">    Minivan myvan = <span class="keyword">new</span> Minivan();</span><br><span class="line">    myvan.Speed = <span class="number">10</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;My van is going (0)MPH&quot;</span>,</span><br><span class="line">    myvan.Speed);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不能通过对象引用来访问私有成员</span></span><br><span class="line">    my.curSpeed = <span class="number">55</span>; <span class="comment">//该语句会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-1-2-多个基类"><a href="#6-1-2-多个基类" class="headerlink" title="6.1.2 多个基类"></a>6.1.2 多个基类</h5><p>.NET平台不允许类的多重继承。C#要求一个类只能有一个直接基类虽然一个类只能有一个直接基类，但是一个接口可以直接从多个接口派生。使用这个技巧，可以构建灵活的接口层次来建模复杂的行为</p>
<h5 id="6-1-3-sealed关键字"><a href="#6-1-3-sealed关键字" class="headerlink" title="6.1.3 sealed关键字"></a>6.1.3 sealed关键字</h5><p>C#提供了另外一个关键字sealed来防止发生继承。如果我们将类标记为sealed,编译器将不会允许我们从这个类型派生。例如，假设我们认为进一步扩展MiniVan类是无意义的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MiniVan类不会被扩展</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Minivan</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如果尝试从这个类派生的话，就会收到一个编译时错误：</span><br><span class="line"><span class="comment">//错误！不能扩展用sealed关键字标记的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">DeluxeMiniVan</span> : <span class="title">MiniVan</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-2-回顾Visual-Studio类关系图"><a href="#6-2-回顾Visual-Studio类关系图" class="headerlink" title="6.2 回顾Visual Studio类关系图"></a>6.2 回顾Visual Studio类关系图</h4><p>略</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h4 id="6-3-OOP的第二个支柱：继承"><a href="#6-3-OOP的第二个支柱：继承" class="headerlink" title="6.3 OOP的第二个支柱：继承"></a>6.3 OOP的第二个支柱：继承</h4><p>我们可以看到SalesPerson是一个mployee(Manager也一样)。在经典的继承模型中，基类（如ployee)用于定义所有派生类型共有的一般特征。子类（如SalesPerson和Manager)通过增加特定的行为来扩展这些一般功能。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经理需要知道它们的股票期权数量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Manager</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="built_in">int</span> Stockoptions &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-3-1-使用base关键字控制基类的创建"><a href="#6-3-1-使用base关键字控制基类的创建" class="headerlink" title="6.3.1 使用base关键字控制基类的创建"></a>6.3.1 使用base关键字控制基类的创建</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span>(<span class="params"><span class="built_in">string</span> fullName,<span class="built_in">int</span> age,<span class="built_in">int</span> empID,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="built_in">float</span> currPay,<span class="built_in">string</span> ssn,<span class="built_in">int</span> numbofopts</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个属性由Manager类来定义</span></span><br><span class="line">    Stockoptions = numbofOpts;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用从父类继承的属性来为传入参数赋值</span></span><br><span class="line">    ID = empID;</span><br><span class="line">    Age = age;</span><br><span class="line">    Name = fullName;</span><br><span class="line">    Pay = currPay;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//嗅！这会导致编译器错误，因为SSN属性是只读的</span></span><br><span class="line">    SocialSecurityNumber = ssn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Manager</span>(<span class="params"><span class="built_in">string</span> fullName,<span class="built_in">int</span> age,<span class="built_in">int</span> empID,</span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="built_in">float</span> currpay,<span class="built_in">string</span> ssn,<span class="built_in">int</span> numbofOpts</span>)</span></span><br><span class="line"><span class="function">	: <span class="title">base</span>(<span class="params">fullName,age,empID,currpay,ssn</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个属性由Manager类定义</span></span><br><span class="line">    Stockoptions numbofopts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>base关键字挂接构造函数签名，这代表派生构造函数将数据传递到最近的父构造函数中。在这里，我们显式调用由Employee定义的5个参数的构造函数，从而节省子类创建过程中不必要的调用。</p>
<h5 id="6-3-2-家族的秘密：protected关键字"><a href="#6-3-2-家族的秘密：protected关键字" class="headerlink" title="6.3.2 家族的秘密：protected关键字"></a>6.3.2 家族的秘密：protected关键字</h5><p>当基类定义了受保护数据或受保护成员时，它就创建了一组可以直接被任何后代访问的项。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//受保护的状态数据</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//派生类现在可以直接访问这些信息了</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> empName;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> empID;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">float</span> currPay;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">int</span> empAge;</span><br><span class="line">    <span class="keyword">protected</span> <span class="built_in">string</span> empSSN;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="built_in">string</span> companyName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="6-3-3-增加密封类"><a href="#6-3-3-增加密封类" class="headerlink" title="6.3.3 增加密封类"></a>6.3.3 增加密封类</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//为了防止其他人扩展类，可以使用sealed关键字：</span></span><br><span class="line"><span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">PTSalesperson</span> : <span class="title">SalesPerson</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PTSalesPerson</span>(<span class="params"><span class="built_in">string</span> fullName,<span class="built_in">int</span> age,<span class="built_in">int</span> empID,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="built_in">float</span> currPay,<span class="built_in">string</span> ssn,<span class="built_in">int</span> numbofSales</span>)</span></span><br><span class="line"><span class="function">     : <span class="title">base</span> (<span class="params">fullName,age,empID,currpay,ssn,numbofSales</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//假设其他成员…</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果我们希望构建新类来使用密封类的功能，唯一的办法就是使用包含委托模型（也叫“has-a”关系)。</p>
<h4 id="6-4-包含-x2F-委托编程"><a href="#6-4-包含-x2F-委托编程" class="headerlink" title="6.4 包含&#x2F;委托编程"></a>6.4 包含&#x2F;委托编程</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个类型会作为包含类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">BenfitPackage</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">ComputePayDeduction</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">125.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//包含BenfitPackage对象的类</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span> BenfitPackage test = <span class="keyword">new</span> BenfitPackage();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//已经成功地包含了另外要给对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果要公开被包含对象的功能给外部世界，就需要委托</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//包含一个BenefitPackage对象</span></span><br><span class="line">    <span class="keyword">protected</span> BenefitPackage empBenefits = <span class="keyword">new</span> BenefitPackage();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//公开对象的保险金行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetBenefitCost</span> ()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> empBenefits.ComputePayDeduction(); &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//通过自定义属性公开对象</span></span><br><span class="line">    <span class="keyword">public</span> BenefitPackage Benefits</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> empBenefits; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; empBenefits <span class="keyword">value</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>嵌套类型的概念就是”has-a”关系的另一种说法</p>
<h4 id="6-5-OOP的第三个支柱：C-的多态支持"><a href="#6-5-OOP的第三个支柱：C-的多态支持" class="headerlink" title="6.5 OOP的第三个支柱：C#的多态支持"></a>6.5 OOP的第三个支柱：C#的多态支持</h4><p>相关类型如何对相同的请求做出不同的相应</p>
<h5 id="6-5-1-virtual和override关键字"><a href="#6-5-1-virtual和override关键字" class="headerlink" title="6.5.1 virtual和override关键字"></a>6.5.1 virtual和override关键字</h5><p>如果基类希望定义可以由子类重写的方法，就必须用virtual关键字标志方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个方法现在可以由派生类“重写”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">GiveBonus</span>(<span class="params"><span class="built_in">float</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	currPay += amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用override关键字重写方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Salesperson</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//销售人员的奖金受销售量的影响</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">GiveBonus</span>(<span class="params"><span class="built_in">float</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> salesBonus = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (numberofSales &gt;<span class="number">0</span> &amp;numberofSales &lt;<span class="number">100</span>)</span><br><span class="line">            salesBonus <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (numberofSales &gt;<span class="number">101</span> &amp;numberofSales &lt;<span class="number">200</span>)</span><br><span class="line">                salesBonus = <span class="number">15</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            	salesBonus = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-2-使用Visual-Studio2010重写虚方法"><a href="#6-5-2-使用Visual-Studio2010重写虚方法" class="headerlink" title="6.5.2 使用Visual Studio2010重写虚方法"></a>6.5.2 使用Visual Studio2010重写虚方法</h5><p>Visual Studio20l0有一个非常有用的、可以在重写虚成员时使用的特性。如果在类类型中输入“override”单词（然后按空格键），智能感知会自动显示定义在父类中的所有可重写成员的列表</p>
<h5 id="6-5-3-密封虚成员"><a href="#6-5-3-密封虚成员" class="headerlink" title="6.5.3 密封虚成员"></a>6.5.3 密封虚成员</h5><p>有时我们不希望密封整个类，而只希望防止派生类型来重写某个虚方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SalesPerson密封了GiveBonus()方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">SalesPerson</span> : <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">sealed</span> <span class="keyword">void</span> <span class="title">GiveBonus</span>(<span class="params"><span class="built_in">float</span> amount</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-4-抽象类"><a href="#6-5-4-抽象类" class="headerlink" title="6.5.4 抽象类"></a>6.5.4 抽象类</h5><p>由于很多基类都是比较模糊的实体，好的设计师会防止在代码中直接创建新的ployee对象。在C#中，我们可以使用abstract关键字来强制这种编程方式，因此创建一个抽象基类：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将Employee类更新为抽象类来防止直接实例化</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">partial</span> <span class="keyword">class</span> <span class="title">Employee</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-5-构建多态接口"><a href="#6-5-5-构建多态接口" class="headerlink" title="6.5.5 构建多态接口"></a>6.5.5 构建多态接口</h5><p>抽象基类的多态接口只是指一组虚的或者抽象的方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层次结构中的抽象基类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Shape</span>(<span class="params"><span class="built_in">string</span> name =<span class="string">&quot;NoName&quot;</span></span>)</span></span><br><span class="line">    &#123; PetName = name; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>;<span class="keyword">set</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个虚方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Console.WriteLine(<span class="string">&quot;Inside Shape.Draw()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//circle没有重写Draw()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">circle</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hexagon重写了Draw()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Hexagon</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hexagon</span> ()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hexagon</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">		Console.WriteLine(<span class="string">&quot;Drawing (0)the Hexagon&quot;</span>,PetName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>要强制每一个子类重写Draw()方法，我们可以把Draw()定义为Shape类的一个抽象方法，也就是说我们没有提供默认的实现。在C#中可以使用abstract关键字将方法标记为抽象的。注意，abstract成员没有提供任何实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//强制所有子类来定义如何被呈现</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//即使不实现抽象的Draw()方法，Circle也必须是抽象的，我们必须标记abstract</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">circle</span> : <span class="title">Shape</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">circle</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">circle</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing (0&#125;the circle&quot;</span>,PetName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优美的代码</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个图形对象数组</span></span><br><span class="line">    Shape[] myShapes = (<span class="keyword">new</span> Hexagon(),<span class="keyword">new</span> circle(),<span class="keyword">new</span> Hexagon(<span class="string">&quot;Mick&quot;</span>),</span><br><span class="line">        <span class="keyword">new</span> circle(<span class="string">&quot;Beth&quot;</span>),<span class="keyword">new</span> Hexagon (<span class="string">&quot;Linda&quot;</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//循环每一个项来和多态接口进行交互</span></span><br><span class="line">    <span class="keyword">foreach</span> (Shape s <span class="keyword">in</span> myShapes)</span><br><span class="line">    &#123;</span><br><span class="line">        s.Draw ();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-5-6-成员投影"><a href="#6-5-6-成员投影" class="headerlink" title="6.5.6 成员投影"></a>6.5.6 成员投影</h5><p>C#提供了逻辑上和方法重写相对的功能，叫做投影（shadowing)。正式地说，如果派生类定义的成员和定义在基类中的成员一致，派生类就投影了父类的版本。在真实情况下，如果我们（或者我们的团队)从一个不是自己创建的类来创建子类就很可能会发生这样的情况</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类扩展了circle并隐藏了继承的Draw()方法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ThreeDcircle</span> : <span class="title">circle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//隐藏任何在我之上的Draw()实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">new</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing a 3D circle&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用new关键字显式生命派生类型的实现故意设计为隐藏父类的版本</span></span><br></pre></td></tr></table></figure>


<h4 id="6-6-基类-x2F-派生类的转换规则"><a href="#6-6-基类-x2F-派生类的转换规则" class="headerlink" title="6.6 基类&#x2F;派生类的转换规则"></a>6.6 基类&#x2F;派生类的转换规则</h4><p>类类型强制转换操作的规则.NET平台下，系统中的最高基类是System.Object。因此，所有东西都是(“is-a”)object,并且可以照此进行处理。因此，在对象变量中保存任何类型的实例都是合法的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用object保存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CastingExamples</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Manager是(is-a)System.Object,因此我们刚好可以在对象变量中存储Manager引用</span></span><br><span class="line">    <span class="comment">//用object变量保存Manager引用也是可以的</span></span><br><span class="line">    <span class="function"><span class="built_in">object</span> frank <span class="keyword">new</span> <span class="title">Manager</span>(<span class="params"><span class="string">&quot;Frank Zappa&quot;</span>,<span class="number">9</span>,<span class="number">3000</span>,<span class="number">40000</span>,<span class="string">&quot;111-11-1111&quot;</span>,<span class="number">5</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 接受单个employee类型的参数，因为是&quot;is-a&quot;关系，所以可以直接将任何Employee类的后代直接传递到这个方法中</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GivePromotion</span>(<span class="params">Employee emp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//增加工资</span></span><br><span class="line">    <span class="comment">//在公司车库新增停车位</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0)was promoted!&quot;</span>emp.Name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CastingExamples</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Manager是(is-a)System.object,因此我们刚好可以在对象变量中存储Manger引用</span></span><br><span class="line">    <span class="function"><span class="built_in">object</span> frank <span class="keyword">new</span> <span class="title">Manager</span>(<span class="params"><span class="string">&quot;Frank Zappa&quot;</span>,<span class="number">9</span>,<span class="number">3000</span>,<span class="number">40000</span>,<span class="string">&quot;111-11-1111&quot;</span>,<span class="number">5</span></span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Manager同样是Employee</span></span><br><span class="line">    <span class="function">Employee moonUnit <span class="keyword">new</span> <span class="title">Manager</span> (<span class="params"><span class="string">&quot;MoonUnit Zappa&quot;</span>,<span class="number">2</span>,<span class="number">3001</span>,<span class="number">20000</span>,<span class="string">&quot;101-11-1321&quot;</span>,<span class="number">1</span></span>)</span>;</span><br><span class="line">    GivePromotion(moonUnit);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//PTSalesPerson SalesPerson</span></span><br><span class="line">    Sa1 esPerson ji11=<span class="keyword">new</span> <span class="function">PTSa1 <span class="title">esPerson</span>(<span class="params"><span class="string">&quot;Ji11&quot;</span>,<span class="number">834</span>,<span class="number">3002</span>,<span class="number">100000</span>,<span class="string">&quot;111-12-1119&quot;</span>,<span class="number">90</span></span>):</span></span><br><span class="line"><span class="function">    <span class="title">GivePromotion</span>(<span class="params">ji1l</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从基类类型隐式转换为派生类型</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//错误。因为传递的不是一个Employee，而是一个object。继承链位置比前者高，不支持隐式转换</span></span><br><span class="line"><span class="function"><span class="built_in">object</span> frank <span class="keyword">new</span> <span class="title">Manager</span>(<span class="params"><span class="string">&quot;Frank Zappa&quot;</span>,<span class="number">9</span>,<span class="number">3000</span>,<span class="number">40000</span>,<span class="string">&quot;111-11-1111&quot;</span>,<span class="number">5</span></span>)</span>;</span><br><span class="line">GivePromotion(frank);</span><br><span class="line"></span><br><span class="line"><span class="comment">//要将object变量传递给GivePromotion()方法，必须使用如下的代码：</span></span><br><span class="line">GivePromotion ((Manager)frank);</span><br></pre></td></tr></table></figure>

<h5 id="6-6-1-C-的as关键字"><a href="#6-6-1-C-的as关键字" class="headerlink" title="6.6.1 C#的as关键字"></a>6.6.1 C#的as关键字</h5><p>但是C#提供了s关键字在运行时快速检测某个类型是否和另外一个兼容。如果我们使用as关键字，就可以通过检查nul1返回值来检测兼容性。考虑如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用“as”来测试兼容性</span></span><br><span class="line">Hexagon hex2 = frank <span class="keyword">as</span> Hexagon;</span><br><span class="line"><span class="keyword">if</span> (hex2 == <span class="literal">null</span>)</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Sorry,frank is not a Hexagon...&quot;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="6-6-2-C-的is关键字"><a href="#6-6-2-C-的is关键字" class="headerlink" title="6.6.2 C#的is关键字"></a>6.6.2 C#的is关键字</h5><p>除了as关键字，C#语言还提供了is关键字来检测两个项是否兼容。然而，和as关键字不同的是，如果类型不兼容，is关键字就返回false而不是null引用。考虑如下GivePromotion()方法的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GivePromotion</span> (<span class="params">Employee emp</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;(0)was promoted!&quot;</span>emp.Name);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (emp <span class="keyword">is</span> SalesPerson)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)made (1&#125;sale(s)!&quot;</span>emp.Name,</span><br><span class="line">            ((SalesPerson)emp).SalesNumber);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (emp <span class="keyword">is</span> Manager)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)had (1)stock options...&quot;</span>,emp.Name,</span><br><span class="line">            ((Manager)emp).Stockoptions);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="6-7-超级父类：System-object"><a href="#6-7-超级父类：System-object" class="headerlink" title="6.7 超级父类：System.object"></a>6.7 超级父类：System.object</h4><p>在.NET世界中，每一个类型最终都会从一个叫System.Object(可以用C#关键字Object表示)的基类派生。Object类定义了一组框架中所有类型公共的成员。System.object定义了一组成员。某些项被声明为Virtual。可以被重写</p>
<h5 id="6-7-1-重写System-Object-Tostring"><a href="#6-7-1-重写System-Object-Tostring" class="headerlink" title="6.7.1 重写System.Object.Tostring()"></a>6.7.1 重写System.Object.Tostring()</h5><p>这对于调试（由于其他原因)来说很有用。至于如何构建这个字符串，就看个人喜好了，然而，推荐的方式是使用分号来分割每一个名称&#x2F;值对并且在方括号中包装整个字符串(.NET基础类库中的很多类型都遵循这个方式)。下面是Person类重写ToString()的代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">string</span> myState;</span><br><span class="line">    myState = <span class="built_in">string</span>.Format (<span class="string">&quot;[First Name:(0);Last Name:(1);Age:(2)]&quot;</span>,</span><br><span class="line">        FirstName,LastName,Age);</span><br><span class="line">    <span class="keyword">return</span> mystate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-7-2-重写System-Object-Equals"><a href="#6-7-2-重写System-Object-Equals" class="headerlink" title="6.7.2 重写System.Object.Equals()"></a>6.7.2 重写System.Object.Equals()</h5><p>略</p>
<h5 id="6-7-3-重写System-Object-GetHashCode"><a href="#6-7-3-重写System-Object-GetHashCode" class="headerlink" title="6.7.3 重写System.Object.GetHashCode()"></a>6.7.3 重写System.Object.GetHashCode()</h5><p>略</p>
<h5 id="6-7-4-测试修改后的Person类"><a href="#6-7-4-测试修改后的Person类" class="headerlink" title="6.7.4 测试修改后的Person类"></a>6.7.4 测试修改后的Person类</h5><p>跟前两个相关联的测试。略</p>
<h5 id="6-7-5-System-Object的静态成员"><a href="#6-7-5-System-Object的静态成员" class="headerlink" title="6.7.5 System.Object的静态成员"></a>6.7.5 System.Object的静态成员</h5><p>System.Object还定义了两个（非常有用的）静态成员来测试基于值或基于引用的相等性。考虑如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMembersofobject</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//System.Object的静态成员</span></span><br><span class="line">    Person p3 = <span class="keyword">new</span> Person(<span class="string">&quot;Sally&quot;</span>,<span class="string">&quot;Jones&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    Person p4 = <span class="keyword">new</span> Person(<span class="string">&quot;Sally&quot;</span>,<span class="string">&quot;Jones&quot;</span>,<span class="number">4</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;P3 and P4 have same state:(0)&quot;</span>,<span class="built_in">object</span>.Equals(p3,p4));</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;P3 and P4 are pointing to same object:(0)&quot;</span>,</span><br><span class="line">        <span class="built_in">object</span>.ReferenceEquals(p3,p4));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们只需要传入两个对象（任何类型)并允许System.Object类自动检测细节。如果为自定义类型重新定义了相等性，或者需要检测两个引用变量是否指向内存中相同区域（通过静态的ReferenceEquals()方法)，这些方法就会很有用。</p>
<h3 id="7-结构化异常处理"><a href="#7-结构化异常处理" class="headerlink" title="7 结构化异常处理"></a>7 结构化异常处理</h3><p>诸如try、catch、throw、finally之类处理异常的C#关键字，还要了解应用程序级异常与系统级异常的区别以及System.Exception基类，其中还将介绍创建自定义异常和如何利用Visual Studio2010异常调试工具等主题。</p>
<h4 id="7-1-错误、bug与异常"><a href="#7-1-错误、bug与异常" class="headerlink" title="7.1 错误、bug与异常"></a>7.1 错误、bug与异常</h4><p>即便是最好的软件也经常伴随着各种各样的问题</p>
<ul>
<li>bug：由程序员一方引起的错误</li>
<li>用户错误：运行程序用户引起的。例如：输入非法字符串时</li>
<li>异常：编程时很难被估摸到。例如：试图链接一个已经不存在的数据库</li>
</ul>
<h4 id="7-2-NET异常处理的作用"><a href="#7-2-NET异常处理的作用" class="headerlink" title="7.2 .NET异常处理的作用"></a>7.2 .NET异常处理的作用</h4><p>结构化异常处理方案的优点在于，开发人员现在有了统一的而且对.NET领域内各种语言都通用的方式来处理错误。因此，一个C#程序员处理错误的方法和VB程序员、使用C+&#x2F;CLI的C++程序员处理错误的方法在语法上相似。更棒的是，用以引发和捕获异常的语法在不同程序集间或计算机间都是一致的。例如，如果使用C#构建WC℉服务，可以向远程调用者抛出一个SOAP错误，而使用的关键字与在同一个应用中的方法之间抛出异常的关键字完全相同。.NET异常的另一好处是，我们不再是通过接收意义模糊的数字常量来确定问题，而是可以通过异常，它们包含容易读懂的问题描述信息和首次触发异常时调用栈的详细快照。此外，我们还能够为最终用户提供相应的帮助链接信息，将他们引向一个URL,其中包含相应错误的详细信息和程序员自定义的数据。</p>
<h5 id="7-2-1-NET异常处理的四要素"><a href="#7-2-1-NET异常处理的四要素" class="headerlink" title="7.2.1 NET异常处理的四要素"></a>7.2.1 NET异常处理的四要素</h5><p>结构化异常处理编程要使用4个互相关联的实体：</p>
<ul>
<li>一个表示异常详细信息的类类型：</li>
<li>一个向调用者引发异常类实例的成员，</li>
<li>调用者的一段调用异常成员的代码块：</li>
<li>调用者的一段处理（或捕获）将要发生异常的代码块。</li>
</ul>
<h5 id="7-2-2-System-Exception基类"><a href="#7-2-2-System-Exception基类" class="headerlink" title="7.2.2 System.Exception基类"></a>7.2.2 System.Exception基类</h5><p>所有用户定义和系统定义的异常最终都继承自System.Exception基类（它继承自System.Object基类)。这个类的代码如下（请注意其中有些成员是虚的，这样就可能被派生类型重写）</p>
<h4 id="7-3-最简单的例子"><a href="#7-3-最简单的例子" class="headerlink" title="7.3 最简单的例子"></a>7.3 最简单的例子</h4><p>略</p>
<h5 id="7-3-1-引发普通的异常"><a href="#7-3-1-引发普通的异常" class="headerlink" title="7.3.1 引发普通的异常"></a>7.3.1 引发普通的异常</h5><p>我们将创建并设定一个新的System.Exception类的实例，并通过类的构造函数为只读属性Message赋值。如果将异常对象返回被调用者，可以使用C#中的throw关键字。下面是新Accelerate()方法的相关代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这次如果用户加速到超过最大速度，就会引发异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (carIsDead)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)is out of order...&quot;</span>,PetName);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentSpeed +delta;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSpeed &gt;MaxSpeed)</span><br><span class="line">        &#123;</span><br><span class="line">            carIsDead <span class="literal">true</span>;</span><br><span class="line">            CurrentSpeed =<span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用throw关键字引发异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format (<span class="string">&quot;(0)has overheated!&quot;</span>,PetName));</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=&gt;CurrentSpeed (0&#125;&quot;</span>,CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，异常应当仅仅在一个较为致命的条件满足后引发（比如未发现必要的文件，连接数据库失败等等)。</p>
<h5 id="7-3-2-捕获异常"><a href="#7-3-2-捕获异常" class="headerlink" title="7.3.2 捕获异常"></a>7.3.2 捕获异常</h5><p>当调用一个可能引发异常的方法时，应当使用ty&#x2F;catch块。一旦捕获到异常对象，将能够调用异常对象成员来释放问题的详细信息。如何处理这份数据取决于我们自己。你可能希望将其记录到报告文件里，写进Windows事件日志里，发电子邮件给系统管理员或者将问题显示给最终用户</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理引发的异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Car mycar = <span class="keyword">new</span> car(<span class="string">&quot;Zippy&quot;</span>,<span class="number">20</span>);</span><br><span class="line">    myCar.CrankTunes (<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//加速车到超过最大速度以触发异常</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        myCar.Accelerate(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Method:(0)&quot;</span>,e.Targetsite);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message:(0)&quot;</span>,e.Message);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Source:(0&#125;&quot;</span>,e.Source);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//异常被处理了，转到下一个语句</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-4-配置异常的状态"><a href="#7-4-配置异常的状态" class="headerlink" title="7.4 配置异常的状态"></a>7.4 配置异常的状态</h4><p>Exception类还会提供其他成员(Targetsite、StackTrace、HelpLink和Data),这些成员在需要进一步界定问题本质时很有用。</p>
<h5 id="7-4-1-TargetSite属性"><a href="#7-4-1-TargetSite属性" class="headerlink" title="7.4.1 TargetSite属性"></a>7.4.1 TargetSite属性</h5><p>System.Exception,Targetsite属性帮助我们了解引发某个异常的方法的各种信息。输出Targetsite的值将显示返回值、名称、引发异常方法的参数。可是，Targetsite不是只返回华而不实的字符串，而是返回一个强类型的ystem.Reflection.MethodBase对象。这种类型可用于收集引发异常的方法以及定义引发异常的方法的类的许多信息。假定我们的上一个catch逻辑更新为如下代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>(]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//Targetsite实际上返回一个MethodBase对象</span></span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">***Error!***&quot;</span>)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Member name:(0)&quot;</span>,e.Targetsite);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Class defining member:(0&#125;&quot;</span>,</span><br><span class="line">            e.Targetsite.DeclaringType);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Member type:(0&#125;&quot;</span>,e.Targetsite.MemberType);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message:(0&#125;&quot;</span>,e.Message);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Source:(0)&quot;</span>,e.Source);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">*****Out of exception logic *****&quot;</span>)</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-2-StackTrace属性"><a href="#7-4-2-StackTrace属性" class="headerlink" title="7.4.2 StackTrace属性"></a>7.4.2 StackTrace属性</h5><p>System.Exception.StackTrace属性帮助我们标识引发异常的一系列调用。需要注意的是，StackTrace的值是异常创建时自动产生的，无法为其赋值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(<span class="string">&quot;Stack:(0)&quot;</span>, e.StackTrace);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-3-HelpLink属性"><a href="#7-4-3-HelpLink属性" class="headerlink" title="7.4.3 HelpLink属性"></a>7.4.3 HelpLink属性</h5><p>Targetsite属性和StackTrace属性能够帮助程序员了解指定的异常，它们对最终用户而言却基本上没什么用。你已经看到System.Exception.Message属性可用来获取呈现给当前用户的可以阅读的信息。默认情况下，HelpLink属性的值是一个空字符串。如果读者需要用一个有意义的值填充该属性，就要在引发System.Exception类型异常之前赋值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (carIsDead)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)is out of order...&quot;</span>,PetName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentSpeed +=delta;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSpeed &gt;MaxSpeed)</span><br><span class="line">        &#123;</span><br><span class="line">        carIsDead <span class="literal">true</span>;</span><br><span class="line">        CurrentSpeed <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//我们儒要调用H1 pLink属性，因此需要在异常对象引发之前先创建一个本地变量</span></span><br><span class="line">        Exception ex =</span><br><span class="line">        	<span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format (<span class="string">&quot;(0&#125;has overheated!&quot;</span>,PetName));</span><br><span class="line">        ex.HelpLink = <span class="string">&quot;http://www.CarsRUs.com&quot;</span>；</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;=&gt;CurrentSpeed (0)&quot;</span>,CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span>逻辑块将被更新，以输出如下的帮助链接信息：</span><br><span class="line"><span class="keyword">catch</span>(Exception e)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Help Link:&#123;0)&quot;</span>,e.HelpLink);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-4-4-Data属性"><a href="#7-4-4-Data属性" class="headerlink" title="7.4.4 Data属性"></a>7.4.4 Data属性</h5><p>System.Exception中的Data属性允许我们使用用户提供的相应信息（如时间戳）来填充异常对象。Data属性返回一个实现了定义在System.Collections命名空间下的IDictionary接口的对象</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (carIsDead)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0)is out of order...&quot;</span>,PetName);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        CurrentSpeed += delta;</span><br><span class="line">        <span class="keyword">if</span> (CurrentSpeed &gt;=MaxSpeed)</span><br><span class="line">        &#123;</span><br><span class="line">            carIsDead <span class="literal">true</span>;</span><br><span class="line">            Currentspeed <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//我们需要调用He1 pLink属性，因此需要在异常对象引发之前先创建一个本地变量</span></span><br><span class="line">            Exception ex =</span><br><span class="line">                <span class="keyword">new</span> Exception(<span class="built_in">string</span>.Format (<span class="string">&quot;(0)has overheated!&quot;</span>,PetName));</span><br><span class="line">            ex.HelpLink <span class="string">&quot;http://www.CarsRUs.com&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//填充关于错误的自定义数据</span></span><br><span class="line">            ex.Data.Add(<span class="string">&quot;TimeStamp&quot;</span>,</span><br><span class="line">                <span class="built_in">string</span>.Format (<span class="string">&quot;The car exploded at (0)&quot;</span>,DateTime.Now));</span><br><span class="line">            ex.Data.Add(<span class="string">&quot;Cause&quot;</span>,<span class="string">&quot;You have a lead foot.&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;=&gt;CurrentSpeed (0)&quot;</span>,CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-5-系统级异常（System-SystemException"><a href="#7-5-系统级异常（System-SystemException" class="headerlink" title="7.5 系统级异常（System.SystemException)"></a>7.5 系统级异常（System.SystemException)</h4><p>.NET平台引发的异常应被称为系统异常。这些异常被认为是无法修复的致命错误。系统异常直接派生自名为System.SystemException的基类</p>
<p>当一个异常类型派生自System.SystemException时，能够判断引发该异常的实体是.NET运行库而不是正在执行的应用程序代码库</p>
<h4 id="7-6-应用程序级异常-Sytem-ApplicationException"><a href="#7-6-应用程序级异常-Sytem-ApplicationException" class="headerlink" title="7.6 应用程序级异常(Sytem.ApplicationException)"></a>7.6 应用程序级异常(Sytem.ApplicationException)</h4><p>就像系统异常一样，应用程序异常并不在一组构造函数外再定义其他任何成员。从功能上来讲，System.ApplicationException的唯一目的就是标识出错误的来源。当读者处理一个派生自System.ApplicationException的异常时，可以设想异常是由正在执行的应用程序代码库引发的，而不是由.NET基础类库或NET运行时引擎引发的。</p>
<h5 id="7-6-1-构建自定义异常，第一部分"><a href="#7-6-1-构建自定义异常，第一部分" class="headerlink" title="7.6.1 构建自定义异常，第一部分"></a>7.6.1 构建自定义异常，第一部分</h5><p>假定要构建一个自定义异常，第一步就是要创建于给派生自System.Exception&#x2F;System.ApplicationException的新类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个自定义异常描述了car-is-dead条件下的详细信息</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarIsDeadException</span> <span class="title">ApplicationException</span></span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，可以重写Exception中的方法，和自定义构造</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarIsDeadException</span> : <span class="title">ApplicationException</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">string</span> messageDetails String.Empty;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DateTime <span class="title">ErrorTimeStamp</span> (<span class="params"><span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">public</span> <span class="built_in">string</span> CauseofError (<span class="keyword">get</span>;<span class="keyword">set</span>;</span>)</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="title">CarIsDeadException</span>()</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarIsDeadException</span>(<span class="params"><span class="built_in">string</span> message,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="built_in">string</span> cause,DateTime time</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        messageDetails message;</span><br><span class="line">        CauseofError cause;</span><br><span class="line">        ErrorTimeStamp time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写Exception.Message属性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> Message</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">string</span>.Format (<span class="string">&quot;Car Error Message:(0)&quot;</span>,messageDetails);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-6-2-构建自定义异常，第二部分"><a href="#7-6-2-构建自定义异常，第二部分" class="headerlink" title="7.6.2 构建自定义异常，第二部分"></a>7.6.2 构建自定义异常，第二部分</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CarIsDeadException</span> <span class="title">ApplicationException</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> DateTime ErrorTimestamp &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> CauseofError &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarIsDeadException</span>()</span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将信息传递给父对象构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarIsDeadException</span>(<span class="params"><span class="built_in">string</span> message,<span class="built_in">string</span> cause,DateTime time</span>)</span></span><br><span class="line"><span class="function">        :<span class="title">base</span>(<span class="params">message</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            CauseofError cause;</span><br><span class="line">            ErrorTimestamp time;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请注意，这次我们并没有定义一个字符串变量来呈现信息，也没有重写Message属性，仅是将参数传递到基类构造函数而已。通过这样的设计，一个自定义异常类就没有任何基类重写，和一个派生自System.ApplicationException的特定命名的类没有任何差别了。自定义异常类的作用并不是提供继承基类之外附加的功能，而是提供明确标识错误种类的强命名类型，因此客户会为不同类型的异常提供不同的处理程序逻辑。</p>
<h5 id="7-6-3-构建自定义异常，第三部分"><a href="#7-6-3-构建自定义异常，第三部分" class="headerlink" title="7.6.3 构建自定义异常，第三部分"></a>7.6.3 构建自定义异常，第三部分</h5><p>如果读者想构造一个真正意义上严谨规范的自定义异常类，需要确保类遵守ET异常处理的最佳实践。具体来讲，自定义异常需要：</p>
<ul>
<li>继承自ApplicationException类，</li>
<li>有[System..Serializable]特性标记，</li>
<li>定义一个默认的构造函数；</li>
<li>定义一个设定继承的Message属性的构造函数；</li>
<li>定义一个处理“内部异常”的构造函数：</li>
<li>定义一个处理类型序列化的构造函数。</li>
</ul>
<h4 id="7-7-处理多个异常"><a href="#7-7-处理多个异常" class="headerlink" title="7.7 处理多个异常"></a>7.7 处理多个异常</h4><p>要牢记的一条首要原则就是，要保证将catch块按照下面的原则结构化：最前面的catch捕获最特定的异常（也就是一个异常类型派生关系链中排在最上面的派生类型），最后面的catch捕获最普通的异常（也就是指定异常继承关系链中的基类，在本例中是System.Exception)。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这段代码编译正常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Handling Multiple Exceptions *****n&quot;</span>);</span><br><span class="line">    <span class="function">Car mycar <span class="keyword">new</span> <span class="title">Car</span>(<span class="params"><span class="string">&quot;Rusty&quot;</span>,<span class="number">90</span></span>)</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//触发超出范围的异常</span></span><br><span class="line">        mycar.Accelerate(<span class="number">-10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (CarIsDeadException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ArgumentOutofRangeException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//捕获CarIaDeadException和ArgumentoutofRangeException之后的所有异常</span></span><br><span class="line">    <span class="keyword">catch</span> (Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="7-7-1-通用的catch语句"><a href="#7-7-1-通用的catch语句" class="headerlink" title="7.7.1 通用的catch语句"></a>7.7.1 通用的catch语句</h5><p>C#也支持通用catch块，它不显式接收由指定成员引发的异常对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的catch</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Handling Multiple Exceptions *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="function">Car mycar <span class="keyword">new</span> <span class="title">car</span>(<span class="params"><span class="string">&quot;Rusty&quot;</span>,<span class="number">90</span></span>)</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        myCar.Accelerate(<span class="number">90</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Something bad happened...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种处理方法获取不到有用的信息，但他是被允许的，可以通用处理所有错误</p>
<h5 id="7-7-2-再次引发异常"><a href="#7-7-2-再次引发异常" class="headerlink" title="7.7.2 再次引发异常"></a>7.7.2 再次引发异常</h5><p>可以在try块逻辑中向之前的调用者再次引发一个调用栈异常。要想这样，仅仅在catch块中使用throw关键字就行了，它通过调用逻辑链传递异常。在catch块只能处理即将发生的部分错误时这样做很有用：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//传递异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//给汽车加速的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(CarIsDeadException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//执行一些处理此错误的操作并传递异常</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终用户将看到一个系统提供的错误对话框。通常情况下，只需要向调用者再次引发部分处理过的异常，使之能够恰当地处理即将发生的异常。</p>
<h5 id="7-7-3-内部异常"><a href="#7-7-3-内部异常" class="headerlink" title="7.7.3 内部异常"></a>7.7.3 内部异常</h5><p>在处理一个异常的时候遇到另一个异常，最好的习惯是将这个新异常对象标识为与第一个异常类型相同的新对象中的“内部错误”，这个建议比较拗口。我们之所以需要创建一个异常的新对象来等待处理，是因为声明一个内部错误的唯一途径就是将其作为一个构造函数参数。考虑以下代吗：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (CarIsDeadException e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Filestream fs File.Open(<span class="string">@&quot;C:\carErrors.txt&quot;</span>,FileMode.Open);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception e2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//引发记录新异常的异常，还有第一个异常的相关信息</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CarIsDeadException(e.Message,e2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="7-7-4-finally块"><a href="#7-7-4-finally块" class="headerlink" title="7.7.4 finally块"></a>7.7.4 finally块</h5><p>一个try&#x2F;catch块后面可能接着会定义一个finally块。finally块并不是必须要有的，它是为了保证不管是否有异常（或其他任何类型)，一组代码语句始终都能被执行。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Handling Multiple Exceptions *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="function">Car mycar <span class="keyword">new</span> <span class="title">Car</span>(<span class="params"><span class="string">&quot;Rusty&quot;</span>,<span class="number">90</span></span>)</span>;</span><br><span class="line">    myCar.CrankTunes(<span class="literal">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//车的加速逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(CarIsDeadException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理CarIsDeadException</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(ArgumentOutofRangeException e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理ArgumentoutofRangeException</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(Exception e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//处理其他任何异常</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//不论异常发生与否，以下语句总是被执行</span></span><br><span class="line">        myCar.CrankTunes (<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Console,ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-8-谁在引发什么异常"><a href="#7-8-谁在引发什么异常" class="headerlink" title="7.8 谁在引发什么异常"></a>7.8 谁在引发什么异常</h4><p>“我怎么知道指定的基础类库中的方法可能引发哪个异常呢？”最终的答案就是：参阅.NET Framework4SDK文档。帮助系统文档中的每个方法都有指定成员可能引发的异常。另外一个可供选择的办法是：在Visual Studio2010中可以通过悬停鼠标光标在代码窗口的成员名称上，来浏览该基础类库成员可能引发的所有异常（如果有的话)的列表</p>
<h4 id="7-9-未处理异常的后果"><a href="#7-9-未处理异常的后果" class="headerlink" title="7.9 未处理异常的后果"></a>7.9 未处理异常的后果</h4><p>其实就是一个演示弹窗。略</p>
<h4 id="7-10-使用Visual-Studio调试未处理的异常"><a href="#7-10-使用Visual-Studio调试未处理的异常" class="headerlink" title="7.10 使用Visual Studio调试未处理的异常"></a>7.10 使用Visual Studio调试未处理的异常</h4><p>请注意，为了解决这些问题，Visual Studio2010提供了大量工具来帮助我们调试未处理自定义异常。再次假定将Car对象加速超过了速度上限。如果启动了调试会话（选择Debug→StartDebugging菜单)，Visual Studio会在未处理异常引发时自动中断。利用好调试功能，来测试出异常</p>
<h4 id="7-11-损坏状态异常简介"><a href="#7-11-损坏状态异常简介" class="headerlink" title="7.11 损坏状态异常简介"></a>7.11 损坏状态异常简介</h4><p>在Windows API中，常常会陷入一些低级别的表示“状态损坏”的错误中。简而言之，如果Windows操作系统发出了一个状态损坏的错误，你的程序就会面临崩遗。正因如此，就不要指望恢复应用了，唯一正确的做法是终止程序。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HandledProcessCorruptedstateExceptions)</span></span><br><span class="line"><span class="meta">static int Main(string[</span>]args)</span><br><span class="line"> &#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//假设Main()调用的方法可以运行整个程序</span></span><br><span class="line">        RunMyApplication();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果到达这里，说明发生了一些很精糕的事情</span></span><br><span class="line">        <span class="comment">//打印消息并退出程序吧…这就是我们的命运</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Ack!Huge problem:(0)&quot;</span>,ex.Message);</span><br><span class="line">        <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>


<h3 id="8-对象的生命周期"><a href="#8-对象的生命周期" class="headerlink" title="8 对象的生命周期"></a>8 对象的生命周期</h3><p>C#程序员从来不直接从内存中删别除一个托管对象（回忆一下，在C#语言中没有delete关键字）。相反，NET对象被分配到一块叫做托管堆(managed heap)的内存区域上，在那里它们会在“将来的某一时刻”被垃圾回收器自动销毁。</p>
<h4 id="8-1-类、对象和引用"><a href="#8-1-类、对象和引用" class="headerlink" title="8.1 类、对象和引用"></a>8.1 类、对象和引用</h4><p>类只是一个蓝图，它描述了这个类型的实例在内存中看起来是什么样子定义类后，可以使用new关键字分配任意数量的对象new关键字返回的是一个指向堆上对象的引用，而不是真正对象本身</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">printhello</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">print1</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在托管堆上创建一个新的printhello对象，返回一个对这个对象的引用（&#x27;t(栈)&#x27;）</span></span><br><span class="line">        printhello t = <span class="keyword">new</span> printhello;</span><br><span class="line">        Console.WriteLine(t.print1().Tostring());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-对象生命周期的基础"><a href="#8-2-对象生命周期的基础" class="headerlink" title="8.2 对象生命周期的基础"></a>8.2 对象生命周期的基础</h4><p>你无需对托管堆进行直接操作，它将自动管理。当一个对象从代码库的任何部分都不可访问时，垃圾回收器就会从堆中删除它</p>
<h5 id="8-2-1-CIL的new指令"><a href="#8-2-1-CIL的new指令" class="headerlink" title="8.2.1 CIL的new指令"></a>8.2.1 CIL的new指令</h5><p>要理解托管堆不只是一个由CLR访问的随机内存块。.NET垃圾回收器是堆的“清洁工”，它会压缩空的内存块来实现优化（必要的时候）。为了辅助这一行为，托管堆保存着一个指针(常称为下一个对象的指针或新对象指针)，它精确地指示下一个对象将被分配的位置。此外，newobj指令通知CLR执行下面的核心任务。</p>
<ul>
<li>计算分配对象所需要的总内存数（包含数据成员和基类所需的内存)。</li>
<li>检查托管堆，确保有足够的空间来放置要分配的对象。如果空间足够，调用类型的构造函数，最终将内存中新对象的引用返回给调用者，它的地址恰好是下一个对象的指针的上一个位置。</li>
<li>最后，在将引用返回给调用者之前，移动下一个对象的指针，指向托管堆上的下一个可用的</li>
</ul>
<p>位置。因为我们经常需要在应用程序中频繁地分配对象，托管堆上的空间最终会用完。当处理newobj指令时，如果CLR判定托管堆没有足够的空间来分配所请求的类型，它会执行一次垃圾回收来尝试释放内存</p>
<h5 id="8-2-2-将对象引用设置为空"><a href="#8-2-2-将对象引用设置为空" class="headerlink" title="8.2.2 将对象引用设置为空"></a>8.2.2 将对象引用设置为空</h5><p>C&#x2F;C++程序员通常将指针变量设置为NULL来确保不再引用非托管内存。将引用赋值为NULL并不意味着强制垃圾回收器立即启动并把对象从堆上移除。我们完成的唯一事情就是显式取消引用和之前引用所指向对象之间的连接。因此，和其他C系列的语言（或VB6.0)相比，在C#中将引用设置为NULL意义就不大了，不管怎么样，这样做也不会有什么害处。</p>
<h4 id="8-3-应用程序根的作用"><a href="#8-3-应用程序根的作用" class="headerlink" title="8.3 应用程序根的作用"></a>8.3 应用程序根的作用</h4><p>根(root)就是一个存储位置，其中保存着对托管堆上一个对象的引用。严格地说，根可以属于下面任何一个类别：</p>
<ul>
<li>全局对象的引用（虽然在C#中不允许，但是CIL代码的确允许分配全局对象)</li>
<li>静态对象&#x2F;静态字段的引用</li>
<li>应用程序代码库中局部对象的引用</li>
<li>传递进一个方法的对象参数的引用</li>
<li>等待被终结的对象的引用</li>
<li>任何引用对象的CPU寄存器</li>
</ul>
<h4 id="8-4-对象的代"><a href="#8-4-对象的代" class="headerlink" title="8.4 对象的代"></a>8.4 对象的代</h4><p>当CLR试图寻找不可访问的对象时，它不会逐个检查托管堆上的每一个对象。为了帮助优化这个过程，堆上的每一个对象被指定为属于某“代”(generation)。代的设计思路很简单：对象在堆上存在的时间越长，它就更可能应该保留。例如，定义桌面应用程序主窗口的类将一直停留在内存中直到程序结束。相反，最近才放在堆上的对象可能很快就不可访问了（例如在一个方法作用域中创建的对象)。基于这些假设，堆上的每一个对象都属于下列某代。会依次向高代进行访问，看是否能拿到更多内存</p>
<ul>
<li>第0代：从没有被标记为回收的新分配的对象。</li>
<li>第1代：在上一次垃圾回收中没有被回收的对象（也就是，它被标记为回收，但因为已经获取了足够的堆空间而没有被删除)。</li>
<li>第2代：在一次以上的垃圾回收后仍然没有被回收的对象。</li>
</ul>
<h4 id="8-5-NET1-0至-NET3-5的并发垃圾回收"><a href="#8-5-NET1-0至-NET3-5的并发垃圾回收" class="headerlink" title="8.5 .NET1.0至.NET3.5的并发垃圾回收"></a>8.5 .NET1.0至.NET3.5的并发垃圾回收</h4><p>在.NET4之前，运行时使用并发垃圾回收技术来清理不再使用的对象。在这个模型下，当对第0代或第1代对象执行回收时，垃圾收集器会暂时挂起当前进程中的所有活动线程，以确保应用程序在回收过程中不会访问托管堆。</p>
<h4 id="8-6-NET4下的后台垃圾回收"><a href="#8-6-NET4下的后台垃圾回收" class="headerlink" title="8.6 .NET4下的后台垃圾回收"></a>8.6 .NET4下的后台垃圾回收</h4><p>.NET4改变了垃圾回收器处理线程挂起的方式，它在清理托管堆上的对象时，使用后台垃圾回收。尽管它叫这个名称，但并不意味着所有的垃圾回收都发生在额外的后台执行线程。后台垃圾回收用于非暂时代上的对象，而对于暂时代上的对象，.NET运行时将使用一个专用后台线程进行回收。</p>
<h4 id="8-7-System-GC类型"><a href="#8-7-System-GC类型" class="headerlink" title="8.7 System.GC类型"></a>8.7 System.GC类型</h4><p>极少需要在代码中直接使用这个类一般情况下，只有在创建那些使用非托管资源的类时，才需要使用System.Gc的成员。例如，使用.NET平台调用协议调用基于C的Windows API,或一些非常低级且复杂的COM互操作逻辑。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 强制一次垃圾回收，并等待每一个对象都被终结</span></span><br><span class="line">    GC.Collect();</span><br><span class="line">    GC.waitForPendingFinalizers();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-8-构建可终结对象"><a href="#8-8-构建可终结对象" class="headerlink" title="8.8 构建可终结对象"></a>8.8 构建可终结对象</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System.object</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">object</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Finalize</span>()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当为自定义的类重写Fina1ize()时，就建立了一个地方，来为类型执行必要的清理逻辑。因为这个成员被定义为受保护的，所以不可能通过点操作符从类实例中直接调用一个对象的Finalize()方法。相反，在从内存删除这个对象之前，垃圾回收器会调用对象的Finalize()方法（如果支持的话)。大多数C#类都不需要显式地清理逻辑，也不需要自定义终结器。原因很简单：如果类使用了其他托管对象，一切都最终会被回收。只是在你使用非托管资源时（例如原始的操作系统文件句柄、原始的非托管数据库连接、非托管内存或其他非托管资源)，才可能需要设计一个在用完后清理自身的类。在.NET平台上，非托管资源是通过使用PInvoke(平台调用)服务直接调用操作系统的API,或通过一些复杂的COM交互获得的。</p>
<h5 id="8-8-1-重写System-object-Finalize"><a href="#8-8-1-重写System-object-Finalize" class="headerlink" title="8.8.1 重写System.object.Finalize()"></a>8.8.1 重写System.object.Finalize()</h5><p>在极其个别的情况下，确实需要创建一个使用非托管资源的类，你显然希望保证底层内存以一种可预测的方式被释放。C#终结器和构造函数很相似，因为它们和定义它们的类具有相同的名字。此外，终结器具有波浪号(~)前缀。然而，和构造方法不同的是，终结器不接受访问修饰符（它们是受隐式保护的），不接受参数，也不能被重载（一个类只能有一个终结器）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用终结器语法重写System.object.Finalize()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyResourceWrapper</span></span><br><span class="line">&#123;</span><br><span class="line">    ~MyResourceWrapper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//清除这里非托管的资源</span></span><br><span class="line">        <span class="comment">//当被销毁时蜂鸣（仅为测试目的）</span></span><br><span class="line">        Conso1e.Beep（）;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="8-8-2-终结过程的细节"><a href="#8-8-2-终结过程的细节" class="headerlink" title="8.8.2 终结过程的细节"></a>8.8.2 终结过程的细节</h5><p>尽管对象的终结能够保证对象可以清除非托管的资源，但它本质上仍然是非确定的，而且由于额外的幕后处理，速度会变得相当慢。</p>
<h4 id="8-9-构建可处置对象"><a href="#8-9-构建可处置对象" class="headerlink" title="8.9 构建可处置对象"></a>8.9 构建可处置对象</h4><p>很多非托管资源都非常宝贵(如数据库和文件句柄)，所以它们应该尽可能快地被清除，而不能依靠垃圾回收的发生如果提供IDisposable接口，就是假设当对象用户不再使用这个对象时，会在这个对象引用离开作用域之前手工调用Dispose()。这样，对象可以执行任何必要的非托管资源的清除工作，而且不会再有将对象放在终结队列上导致的性能损失，也不必等待垃圾回收器触发类的终结逻辑。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现IDisposable</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyResourcewrapper</span> <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对象用户应该在完成使用这个对象时调用这个方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这里清除非托管资源</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//抛弃包含的其他可处置对象</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//出于测试目的</span></span><br><span class="line">        Console.WriteLine (<span class="string">&quot;****In Dispose!*****&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设我们已经导入了System.Io命名空间</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DisposeFilestream</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">FileStream fs <span class="keyword">new</span> <span class="title">Filestream</span>(<span class="params"><span class="string">&quot;myFile.txt&quot;</span>,FileMode.OpenorCreate</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//确实有点混淆，这两个方法调用完成相同的事情</span></span><br><span class="line">    fs.close();</span><br><span class="line">    fs.Dispose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类型实现了IDisposable,调用Dispose()总是正确的。<strong>重用C#的using关键字</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当退出using作用域时，自动调用Dispose()</span></span><br><span class="line">    <span class="keyword">using</span>(<span class="function">MyResourceWrapper rw <span class="keyword">new</span> <span class="title">MyResourceWrapper</span> ())</span></span><br><span class="line">    &#123;      </span><br><span class="line">        <span class="comment">//使用xw对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="8-10-构建可终结类型和可处置类型"><a href="#8-10-构建可终结类型和可处置类型" class="headerlink" title="8.10 构建可终结类型和可处置类型"></a>8.10 构建可终结类型和可处置类型</h4><p>将两个技术混合进同一个类定义是可行的。这样做可以获得两种模型的好处。如果对象用户记住了调用Dispose(),可以通过调用cC.SuppressFinalize()通知垃圾回收器跳过终结过程，如果对象用户忘记了调用Dispose(),对象最终也将被终结并有机会释放内部资源。对象的内部非托管资源会用其中一种方式释放掉。下面是修改后的yResourceWrapper,它现在既是可终结的，也是可处置的，它定义在C#控制台应用程序FinalizableDisposableClass中：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//高级的资源包装器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyResourceWrapper</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果对象用户忘记调用Dispose(),垃圾回收器会调用这个方法</span></span><br><span class="line">    ~MyResourcewrapper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//清除所有内部的非托管资源</span></span><br><span class="line">        <span class="comment">//不要调用任何托管对象的Dispose()</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//对象用户将调用这个方法来尽快清除资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//在这里清除非托管资源</span></span><br><span class="line">        <span class="comment">//在其他包含的可处置对象上调用Dispose()</span></span><br><span class="line">            </span><br><span class="line">        <span class="comment">//如果用户调用了Dispose()就不需要终结，因此跳过终结</span></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>正式的处置模式</strong>首先，Finalize()和Dispose()方法都要清除相同的非托管资源。这当然导致了重复的代码，它很容易使维护复杂化。理想情况下，应该定义一个私有的辅助函数供两个方法调用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MyResourceWrapper</span> : <span class="title">IDisposable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//用来判断Dispose()是否已经被调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> disposed <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Dispose</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用辅助方法</span></span><br><span class="line">        <span class="comment">//指定true表示对象用户触发了清理过程</span></span><br><span class="line">        CleanUp(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在跳过终结</span></span><br><span class="line">        GC.SuppressFinalize(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUp</span>(<span class="params"><span class="built_in">bool</span> disposing</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//保证我们还没有被处置</span></span><br><span class="line">        <span class="keyword">if</span>(!<span class="keyword">this</span>,disposed)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="comment">//如果disposing等于true,释放所有托管的资源</span></span><br><span class="line">            <span class="keyword">if</span> (disposing)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//释放托管的资源</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在这里清理非托管的资源</span></span><br><span class="line">        &#125;</span><br><span class="line">        disposed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ~MyResourcewrapper()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//调用辅助方法</span></span><br><span class="line">        <span class="comment">//指定false表示Gc触发了清理过程</span></span><br><span class="line">        CleanUp(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-11-延迟对象实例化"><a href="#8-11-延迟对象实例化" class="headerlink" title="8.11 延迟对象实例化"></a>8.11 延迟对象实例化</h4><p>在创建类时，可能偶尔会在代码中添加一个永远不会被使用的特殊成员变量，因为用户不会调用使用了它们的方法（或属性）。这很正常。但是，如果成员变量的初始化需要很大的内存空间，问题就来了。.NET4基础类库提供了一个非常有趣的泛型类Lazy&lt;&gt;,它定义在mscorlib.d11内的System命名空间下。该类所定义的数据在代码库实际使用它之前是不会被创建的。由于它是一个泛型类，因此第一次使用时必须指定要创建的项的类型，可以是任意ET基础类库中的类型或自定义类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MediaPlayer包含Lazy&lt;AllTracks&gt;对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">MediaPlayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Lazy&lt;AllTracks&gt; allSongs = <span class="keyword">new</span> Lazy&lt;AllTracks&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AllTracks <span class="title">GetAllTracks</span> ()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回所有歌曲</span></span><br><span class="line">        <span class="keyword">return</span> allSongs.Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这里没有分配AllTracks对象</span></span><br><span class="line">    <span class="function">Mediaplayer myPlayer <span class="keyword">new</span> <span class="title">Mediaplayer</span>()</span>;</span><br><span class="line">    myPlayer.play();</span><br><span class="line">                  </span><br><span class="line">    <span class="comment">//在调用GetA11 Tracks()时分配AllTracks</span></span><br><span class="line">    MediaPlayer yourplayer = <span class="keyword">new</span> Mediaplayer();</span><br><span class="line">    AllTracks yourMusic = yourPlayer.GetAllTracks();</span><br><span class="line">    </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定制延迟数据的创建</strong>但如果AllTracks类包含其他的构造函数，并且你想调用它们会如何呢？Lazy&lt;&gt;类允许指定一个泛型委托作为可选参数。在创建其包装的类型时，它将调用指定的方法。该泛型委托的类型为System.Punc&lt;&gt;,它所指向的方法的返回值类型与相关的Lazy&lt;&gt;变量所创建的类型是相同的，并且可以包含16个参数（用泛型类型参数表示)。在大多数情况下，都不需要向Func&lt;&gt;所指向的方法传入任何参数</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Mediaplayer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在创建AllTracks对象时使用Lambda表达式添加额外的代码</span></span><br><span class="line">    <span class="keyword">private</span> Lazy&lt;AllTracks&gt; allSongs = <span class="keyword">new</span> Lazy&lt;AllTracks&gt;( () =&gt;</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Creating AllTracks object!&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AllTracks();</span><br><span class="line">         &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AllTracks <span class="title">GetAllTracks</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//返回所有的歌曲</span></span><br><span class="line">        <span class="keyword">return</span> allSongs.Value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="高级C-编程结构"><a href="#高级C-编程结构" class="headerlink" title="高级C#编程结构"></a>高级C#编程结构</h2><h3 id="9-接口"><a href="#9-接口" class="headerlink" title="9 接口"></a>9 接口</h3><p>本章剩余的部分会研究许多定义在.NET基础类库中的标准接口。我们会看到，自定义类和结构完全可以实现这些预定义的接口，以支持对象克隆、对象枚举和对象排序等的高级行为。</p>
<h4 id="9-1-接口类型"><a href="#9-1-接口类型" class="headerlink" title="9.1 接口类型"></a>9.1 接口类型</h4><pre><code> 首先给出接口类型的正式定义。接口就是一组抽象成员的集合。抽象方法是纯粹的协议，在其中没有提供默认的实现。由接口定义的某个特定成员依赖于它所模拟的确切行为。一个类（或者一个结构）可以支持任意数量的接口，因此也就支持了多种行为。
</code></pre>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//IDbConnection接口定义了一组所有连接对象都支持的公共成员</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDbConnection</span> : <span class="title">IDisposable</span>	<span class="comment">//interface是接口定义关键字</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//方法</span></span><br><span class="line">    <span class="function">IDbTransaction <span class="title">BeginTransaction</span>()</span>;</span><br><span class="line">    <span class="function">IDbTransaction <span class="title">BeginTransaction</span>(<span class="params">IsolationLevel il</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ChangeDatabase</span>(<span class="params"><span class="built_in">string</span> databaseName</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span>()</span>;</span><br><span class="line">    <span class="function">IDbCommand <span class="title">CreateCommand</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">open</span>()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性</span></span><br><span class="line">    <span class="built_in">string</span> Connectionstring <span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="built_in">int</span> ConnectionTimeout <span class="keyword">get</span>;</span><br><span class="line">    <span class="built_in">string</span> Database <span class="keyword">get</span>;</span><br><span class="line">    Connectionstate State <span class="keyword">get</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对比接口类型和抽象基类</strong>虽然类定义了一组抽象成员，它完全可以再定义许多构造函数、字段数据、非抽象成员（具有实现）等。而接口，只能包含抽象成员。由抽象父类创建的多态接口有一个主要的限制，那就是只有派生类型才支持由抽象父类定义的成员。定义了接口之后，它就可以被任何层次结构、任何命名空间或任何程序集（由任何NET编程语言写的)中的任何类型来实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="built_in">object</span> <span class="title">clone</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-2-定义自定义接口"><a href="#9-2-定义自定义接口" class="headerlink" title="9.2 定义自定义接口"></a>9.2 定义自定义接口</h4><p>接口新建：prohect—&gt;add new  item——&gt;interface接口使用interface关键字来定义；接口不指定基类；接口成员也不指定访问修饰符</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个pointy表现为一个只读属性</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPointy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//在接口中的读写属性为以下形式</span></span><br><span class="line">    <span class="comment">//retType PropName &#123; get;set; &#125;</span></span><br><span class="line">    <span class="comment">//而接口中的只写属性是</span></span><br><span class="line">    <span class="comment">//retType PropName &#123; set; &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">byte</span> Points &#123; <span class="keyword">get</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口类型就其本身而言没什么用，因为它们只是抽象成员的集合，除非被类或接口实现</p>
<h4 id="9-3-实现接口"><a href="#9-3-实现接口" class="headerlink" title="9.3 实现接口"></a>9.3 实现接口</h4><p>如果类（或结构）选择通过支持接口来扩展功能，就需要在其类型定义中使用逗号分隔的列表。要知道要知道直接基类必须是冒号操作符后的第一个项。如果类类型从System.Object直接继承，我们完全可以只在列表中提供类支持的接口，因为如果没有特别指明，C#编译器会从System.Object扩展我们的类型</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类派生自System.Object并且实现一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Pencil</span> : <span class="title">IPointy</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//这个类也派生自System.Object并且实现一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SwitchBlade</span> : <span class="title">object</span>,<span class="title">IPointy</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//这个类派生自一个自定义基类并且实现一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Fork</span> : <span class="title">Utensil</span>,<span class="title">IPointy</span></span><br><span class="line">&#123;...&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//这个结构隐式派生自System.ValueType并且实现两个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Arrow : ICloneable,IPointy</span><br><span class="line">&#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//名为Triangle(三角形)的新的Shape派生类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Triangle</span> <span class="title">Shape</span>,<span class="title">IPointy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Triangle</span>(<span class="params"><span class="built_in">string</span> name</span>):<span class="title">base</span>(<span class="params">name</span>)</span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Draw</span>()</span></span><br><span class="line">    &#123; Console.WriteLine(<span class="string">&quot;Drawing &#123;0&#125;the Triangle&quot;</span>,PetName);&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//IPointy实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span> Points</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123;<span class="keyword">return</span> <span class="number">3</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-4-在对象级别调用接口成员"><a href="#9-4-在对象级别调用接口成员" class="headerlink" title="9.4 在对象级别调用接口成员"></a>9.4 在对象级别调用接口成员</h4><p>如何才能动态判断一个类型支持哪些接口呢？</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Interfaces *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//调用IPointy定义的Points属性</span></span><br><span class="line">    Hexagon hex = <span class="keyword">new</span> Hexagon();	<span class="comment">//</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Points:(0)&quot;</span>,hex.Points);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在运行时判断一个类型是否支持一个指定接口的一种方式是使用显式强制转换。如果这个类型不支持被请求的接口，将收到一个无效转换异常（InvalidCastException)。使用结构化异常处理妥善处置这种可能的异常，例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//捕获可能发生的InvalidCastException异常</span></span><br><span class="line">    Circle c = <span class="keyword">new</span> Circle(<span class="string">&quot;Lisa&quot;</span>);</span><br><span class="line">    IPointy itfpt = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        itfpt = (IPointy)c;</span><br><span class="line">        Console.WriteLine(itfPt.Points);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvalidCastException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用try&#x2F;catch逻辑并非是最好的解决方法，在首次调用该接口成员之前判断其支持哪个接口更加理想</p>
<h5 id="9-4-1-获取接口引用：as关键字"><a href="#9-4-1-获取接口引用：as关键字" class="headerlink" title="9.4.1 获取接口引用：as关键字"></a>9.4.1 获取接口引用：as关键字</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//我们能将六角形hex2视为实现了IPointy接口吗</span></span><br><span class="line">    Hexagon hex2 = <span class="keyword">new</span> Hexagon(<span class="string">&quot;Peter&quot;</span>);</span><br><span class="line">    IPointy itfpt2 = hex2 <span class="keyword">as</span> IPointy;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(itfpt2 != nu11)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Points:(0)&quot;</span>,itfpt2.Points);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;OoPS!Not pointy、.·&quot;</span>):</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当使用as关键字的时候，无需使用try&#x2F;catch逻辑。如果引用非空，说明调用的是一个正确的接口引用。</p>
<h5 id="9-4-2-获取接口引用：is关键字"><a href="#9-4-2-获取接口引用：is关键字" class="headerlink" title="9.4.2 获取接口引用：is关键字"></a>9.4.2 获取接口引用：is关键字</h5><p>如果要考察的对象与指定接口不符，将返回false值</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with Interfaces ****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成Shape数组</span></span><br><span class="line">    Shape[]myshapes = &#123; <span class="keyword">new</span> Hexagon(),<span class="keyword">new</span> circle(),<span class="keyword">new</span> Triangle(<span class="string">&quot;Joe&quot;</span>),<span class="keyword">new</span> circle(<span class="string">&quot;JoJo&quot;</span>)&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;myShapes.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//Shape基类定义一个抽象的Draw()成员，由此所有Shape都知道如何绘制自己</span></span><br><span class="line">        myShapes [i].Draw();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//哪些是有棱角的</span></span><br><span class="line">        <span class="keyword">if</span>(myshapes[i] <span class="keyword">is</span> IPointy)</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-&gt;Points:(0&#125;&quot;</span>,((IPointy)myShapes[i]).Points);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;-&gt;(0)\&#x27;s not pointy!&quot;</span>myShapes fi].PetName);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-5-接口作为参数"><a href="#9-5-接口作为参数" class="headerlink" title="9.5 接口作为参数"></a>9.5 接口作为参数</h4><p>读者可以构造将接口作为参数的方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义了一个名为IDraw3D的接口</span></span><br><span class="line"><span class="comment">//模拟能以绝佳3D效果呈现一个类型的能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDraw3D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw3D</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Circle支持IDraw3D接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">ThreeDCircle</span>:<span class="title">Circle</span>,<span class="title">IDraw3D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw3D</span>()</span></span><br><span class="line"><span class="function">    Console.<span class="title">WriteLine</span>(<span class="params"><span class="string">&quot;Drawing circle in 3D!&quot;</span></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hexagon支持IPointy与IDraw3D接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Hexagon</span> : <span class="title">Shape</span>,<span class="title">IPointy</span>,<span class="title">IDraw3D</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Draw3D</span>()</span></span><br><span class="line"><span class="function">    Console.<span class="title">WriteLine</span>(<span class="params"><span class="string">&quot;Drawing Hexagon in 3D!&quot;</span></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制任何支持IDraw3D接口的类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawIn3D</span>(<span class="params">IDraw3D itf3d</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;-&gt;Drawing IDraw3D compatible type&quot;</span>);</span><br><span class="line">    itf3d.Draw3D();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制任何支持IDraw3D接口的类型</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DrawIn3D</span>(<span class="params">IDraw3D itf3d</span>)</span></span><br><span class="line"><span class="function">Console.<span class="title">WriteLine</span>(<span class="params"><span class="string">&quot;-&gt;Drawing IDraw3D compatible type&quot;</span></span>)</span>;</span><br><span class="line">itf3d.Draw3D();</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以测试Shape数组中的项是否支持接口，如果支持，就将其传入DrawIn3D()方法：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Interfaces *****</span></span><br><span class="line"><span class="string">&quot;</span>)</span><br><span class="line">    Shape[]<span class="function">myshapes <span class="keyword">new</span> <span class="title">Hexagon</span>(),<span class="keyword">new</span> <span class="title">circle</span>(),<span class="keyword">new</span> <span class="title">Triangle</span>(),<span class="keyword">new</span> <span class="title">circle</span>(<span class="params"><span class="string">&quot;JoJo&quot;</span></span>))</span></span><br><span class="line"><span class="function">    <span class="title">for</span>(<span class="params"><span class="built_in">int</span> i=<span class="number">0</span>;i&lt;myShapes.Length;i++</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//支持绘制为3D吗</span></span><br><span class="line">        <span class="keyword">if</span>(myShapes[i]<span class="keyword">is</span> IDraw3D)</span><br><span class="line">            DrawIn3D((IDraw3D)myShapes [i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-6-接口作为返回值"><a href="#9-6-接口作为返回值" class="headerlink" title="9.6 接口作为返回值"></a>9.6 接口作为返回值</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个方法返回数组中第一个实现了IPointy的对象</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> IPointy <span class="title">FindFirstPointyshape</span>(<span class="params">Shape[]shapes</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">foreach</span> (Shape s <span class="keyword">in</span> shapes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s <span class="keyword">is</span> IPointy)</span><br><span class="line">        <span class="keyword">return</span> s <span class="keyword">as</span> IPointy;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Interfaces&#x27;*****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//构建Shape数组</span></span><br><span class="line">    Shape[]<span class="function">myShapes <span class="keyword">new</span> <span class="title">Hexagon</span> ()<span class="keyword">new</span> <span class="title">circle</span>(),<span class="keyword">new</span> <span class="title">Triangle</span>(<span class="params"><span class="string">&quot;Joe&quot;</span></span>),<span class="keyword">new</span> <span class="title">circle</span>(<span class="params"><span class="string">&quot;JoJo&quot;</span></span>)&#125;</span>;</span><br><span class="line">    <span class="comment">//获取第一个pointy项</span></span><br><span class="line">    <span class="comment">//为安全起见，在使用前最好检查firstPointyItem是否为nul1</span></span><br><span class="line">    <span class="function">IPointy firstPointyItem <span class="title">FindFirstPointyshape</span>(<span class="params">myShapes</span>)</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;The item has (0&#125;points&quot;</span>,firstpointyItem.Points);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-7-接口类型数组"><a href="#9-7-接口类型数组" class="headerlink" title="9.7 接口类型数组"></a>9.7 接口类型数组</h4><p>同样的接口可以由多个类型实现，即使这些类型不处于相同的类层次结构中如果已经定义了PitchFork、Fork和Knife类型，那么现在可以定义一个支持IPointy接口的对象数组。既然这些成员都支持同样的接口，因此可以抛开类层次结构的全部差异性，通过数组进行迭代并将每个对象视为支持IPointy接口的对象：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个数组只能包含实现了IPo1nty接口的类型</span></span><br><span class="line">    IPointy[] myPointyobjects = (<span class="keyword">new</span> Hexagon(),<span class="keyword">new</span> Knife(),<span class="keyword">new</span> Triangle(),<span class="keyword">new</span> Fork(),<span class="keyword">new</span> PitchFork());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span>(IPointy i <span class="keyword">in</span> myPointyobjects)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Object has (0&#125;points.&quot;</span>,i.Points);</span><br><span class="line">    Console.ReadLine();‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-8-使用Visual-Studio2010实现接口"><a href="#9-8-使用Visual-Studio2010实现接口" class="headerlink" title="9.8 使用Visual Studio2010实现接口"></a>9.8 使用Visual Studio2010实现接口</h4><p>略</p>
<h4 id="9-9-通过显式接口实现解决命名冲突"><a href="#9-9-通过显式接口实现解决命名冲突" class="headerlink" title="9.9 通过显式接口实现解决命名冲突"></a>9.9 通过显式接口实现解决命名冲突</h4><p>一个类或结构可以实现许多接口。因此，我们很有可能会实现包含同名成员的接口，所以就熏要处理命名冲突。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//绘制到表单上</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawToForm</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//绘制到内存中</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawToMemory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//呈现到打印机</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawToPrinter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Octagon</span> <span class="title">IDrawToForm</span>,<span class="title">IDrawToMemory</span>,<span class="title">IDrawToPrinter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//对某个接口显式绑定Draw()</span></span><br><span class="line">    <span class="keyword">void</span> IDrawToForm.Draw()</span><br><span class="line">	&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing to form...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> IDrawToMemory.Draw (</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing to memory...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> IDrawToPrinter.Draw()</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Drawing to a printer...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在使用这种语法时，不能提供访问修饰符，显式实现的成员总是自动为私有的。也就是在对象级别就不可用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Interface Name clashes *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    Octagon oct = <span class="keyword">new</span> octagon();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在必须使用转换来访问draw()成员</span></span><br><span class="line">    IDrawToForm itfForm = (IDrawToForm)oct;</span><br><span class="line">    itfForm.Draw ();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果以后不需要接口变量，可以简化成这个形式</span></span><br><span class="line">    ((IDrawToPrinter)oct).Draw();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以使用“as”关键字</span></span><br><span class="line">    <span class="keyword">if</span> (oct <span class="keyword">is</span> IDrawToMemory)</span><br><span class="line">        ((IDrawToMemory)oct).Draw ()</span><br><span class="line"></span><br><span class="line">    Console,ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-10-设计接口层次结构"><a href="#9-10-设计接口层次结构" class="headerlink" title="9.10 设计接口层次结构"></a>9.10 设计接口层次结构</h4><p>接口可以组织成接口层次结构。和类层次结构相似，如果接口扩展了既有接口，它就继承了父接口定义的抽象成员。如果希望扩展既有接口功能又不变动既有代码，接口层次结构就会很有用</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IDrawable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//层次结构</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IAdvancedDraw</span> : <span class="title">IDrawable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawInBoundingBox</span>(<span class="params"><span class="built_in">int</span> top,<span class="built_in">int</span> left,<span class="built_in">int</span> bottom,<span class="built_in">int</span> right</span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DrawUpsideDown</span>()</span>;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>接口类型的多重继承</strong>一个接口可以扩展多个基接口</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口可以是多重继承的</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IDrawable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IPrintable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span>()</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Draw</span>()</span>;<span class="comment">//&lt;--注意，可能导致命名冲突</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//多重接口继承。没有问题</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title">IShape</span> : <span class="title">IDrawable</span>,<span class="title">IPrintable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">int</span> <span class="title">GetNumberofsides</span>()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-11-构建可枚举类型（IEnumerable和IEnumerator"><a href="#9-11-构建可枚举类型（IEnumerable和IEnumerator" class="headerlink" title="9.11 构建可枚举类型（IEnumerable和IEnumerator)"></a>9.11 构建可枚举类型（IEnumerable和IEnumerator)</h4><p>任何支持GetEnumerator()方法的类型都可以通过foreach结构进行运算</p>
<p>编译器通知我们Garage类没有实现名为GetEnumerator()的方法。这个方法是由隐藏在System.Collections命名空间中的IEnumerable接口定义的。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//显示定义方法</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//Garage包含一组car对象</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Garage</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> car[] = carArray <span class="keyword">new</span> Car[<span class="number">4</span>];</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//启动时填充一些car对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Garage</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        carArray[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Rusty&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        carArray[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Clunker&quot;</span>,<span class="number">55</span>);</span><br><span class="line">        carArray[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Zippy&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        carArray[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Fred&quot;</span>,<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnuerator</span>()</span></span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="comment">//返回数组对象的IEnumberator</span></span><br><span class="line">    	<span class="keyword">return</span> carArray.GetEnumerator();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//定义完成后则此代码可以执行</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    	Carage carLot = <span class="keyword">new</span> Garage();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carLot)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(c.PetName, c.CurrentSpeed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并且手动与IEnuerator交互也是可行的</span></span><br><span class="line">IEnumerator i = carLot.Getnumerator();</span><br><span class="line">i.MoveNext();</span><br><span class="line">Car myCar = (Car)i.Current;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果不想让用户直接交互，可以在对象级隐藏此功能</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> IEnumerator.GetEnmerator()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> carArray.GetEnumerator();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样的话，对象用户就不能找到Garage的GetEnumerator()方法，而foreach结构会在必要的候在后台获得接口。</span></span><br></pre></td></tr></table></figure>

<h5 id="9-11-1-用yield关键字构建迭代器方法"><a href="#9-11-1-用yield关键字构建迭代器方法" class="headerlink" title="9.11.1 用yield关键字构建迭代器方法"></a>9.11.1 用yield关键字构建迭代器方法</h5><p>迭代器就是这样一个成员方法，它指定了容器内部项被foreach处理时该如何返回。yield关键字用来向调用方的foreach结构指定返回值。当到达yield return语句后，当前位置被存储下来，下次调用迭代器时会从这个位置开始执行</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Garage</span></span><br><span class="line"><span class="title">private</span> <span class="title">car</span>[]<span class="title">carArray</span> = <span class="keyword">new</span> Car[<span class="number">4</span>];</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//迭代器方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IEnumerator <span class="title">GetEnumerator</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carArray)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-11-2-构建命名迭代器"><a href="#9-11-2-构建命名迭代器" class="headerlink" title="9.11.2 构建命名迭代器"></a>9.11.2 构建命名迭代器</h5><p>yield关键字从技术上说可以结合任何方法一起使用，无论方法名是什么。这些方法（技术上称为命名选代器）独特之处在于可以接受许多参数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IEnumerable <span class="title">GetTheCars</span>(<span class="params"><span class="built_in">bool</span> ReturnRevesed</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//逆序返回项</span></span><br><span class="line">    <span class="keyword">if</span>(ReturnRevesed)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = carArray.Length;i != <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> carArray[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//按顺序返回数组中的项</span></span><br><span class="line">        <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carArray)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">yield</span> <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with the yield Keyword *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="function">Garage carLot <span class="keyword">new</span> <span class="title">Garage</span>()</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用GetEnumerator()获取项</span></span><br><span class="line">    <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carLot)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0&#125;is going (1&#125;MPH&quot;</span>,c.PetName,c.CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用命名迭代器来获取项（逆序）</span></span><br><span class="line">    <span class="comment">//新方法允许调用者以正序和逆序（如果传入的参数值为tue)来获取子项</span></span><br><span class="line">    <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> carLot.GetThecars(<span class="literal">true</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;(0&#125;is going (1&#125;MPH&quot;</span>,c.PetName,c.CurrentSpeed);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>命名迭代器是很有用的结构，因为一个自定义容器可以定义多重方式来请求返回的集。</p>
<h5 id="9-11-3-迭代器方法的内部表示"><a href="#9-11-3-迭代器方法的内部表示" class="headerlink" title="9.11.3 迭代器方法的内部表示"></a>9.11.3 迭代器方法的内部表示</h5><p>那么，总结一下可枚举对象的构建吧。记住，如果自定义类型要和C#的foreach关键字一起使用的话，容器就需要定义一个名为GetEnumerator()的方法，它由IEnumerable接口类型来定制。通常，这个方法的实现只是交给保存子对象的内部成员，然而，我们也可以使用yield return语法来提供多个“命名迭代器”方法。</p>
<h4 id="9-12-构建可克隆的对象-ICloneable"><a href="#9-12-构建可克隆的对象-ICloneable" class="headerlink" title="9.12 构建可克隆的对象(ICloneable)"></a>9.12 构建可克隆的对象(ICloneable)</h4><p>如果想使自己的自定义类型支持向调用方返回自身同样副本的能力，需要实现标准ICloneable接口。如在本章开头提到的，这个类型定义了一个简单的方法Clone():</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Point现在支持克隆能力</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span> : <span class="title">ICloneable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> x &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xPos,<span class="built_in">int</span> yPos</span>)</span>&#123;X xPos;Y yPos;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span> &#123;&#125;</span><br><span class="line">    <span class="comment">//重写Object.Tostring()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">Tostring</span>()</span></span><br><span class="line">    &#123; <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;X (0);Y (1)&quot;</span>,X,Y); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个当前对象的副本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">clone</span>()</span></span><br><span class="line">    &#123;<span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="keyword">this</span>.X,<span class="keyword">this</span>.Y);&#125;</span><br><span class="line">&#125;</span><br><span class="line">                                    </span><br><span class="line">这样我们就可以创建完全独立的Poit类型的副本了，如下所示：</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with object cloning *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//请注意Clone()返回了一个普通object类型</span></span><br><span class="line">    <span class="comment">//需要显式转换来获取派生类型</span></span><br><span class="line">    Point p3 = <span class="keyword">new</span> Point(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">    Point p4 = (Point)p3.Clone();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变p4.x将不影响P3,x</span></span><br><span class="line">    P4.X=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//输出每个对象</span></span><br><span class="line">    Console.WriteLine(p3);</span><br><span class="line">    Console.WriteLine(p4);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以用此代码简化Clone()方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">clone</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>更复杂的克隆示例</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个类定义了一个点</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PointDescription</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> Guid PointID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PointDescription</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        PetName = <span class="string">&quot;No-name&quot;</span>;</span><br><span class="line">        PointID = Guid.NewGuid();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> PointDescription desc = <span class="keyword">new</span> PointDescription();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xPos, <span class="built_in">int</span> yPos, <span class="built_in">string</span> petName</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xPos; Y = yPos;</span><br><span class="line">        desc.PetName = petName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xPos, <span class="built_in">int</span> yPos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xPos; Y = yPos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写Object.ToString()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;X &#123;0&#125;;Y &#123;1&#125;;Name &#123;2&#125;;</span></span><br><span class="line"><span class="string">ID &#123;3&#125;</span></span><br><span class="line"><span class="string">&quot;</span>,</span><br><span class="line">        X, Y, desc.PetName, desc.PointID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前对象的副本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">object</span> <span class="title">Clone</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取浅复制</span></span><br><span class="line">        Point newPoint = (Point)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充间距</span></span><br><span class="line">        PointDescription currentDesc = <span class="keyword">new</span> PointDescription();</span><br><span class="line">        currentDesc.PetName = <span class="keyword">this</span>.desc.PetName;</span><br><span class="line">        newPoint.desc = currentDesc;</span><br><span class="line">        <span class="keyword">return</span> newPoint;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;*****Fun with object cloning *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Cloned p3 and stored new Point in p4&quot;</span>);</span><br><span class="line">        Point p3 = <span class="keyword">new</span> Point(<span class="number">100</span>, <span class="number">100</span>, <span class="string">&quot;Jane&quot;</span>);</span><br><span class="line">        Point p4 = (Point)p3.Clone();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Before modification:&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p3:&#123;0&#125;&quot;</span>, p3);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p4:&#123;0&#125;&quot;</span>, p4);</span><br><span class="line">        p4.desc.PetName = <span class="string">&quot;My new Point&quot;</span>;</span><br><span class="line">        p4.X = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">Changed p4.desc.petName and p4.X&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;After modification:&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p3:&#123;0&#125;&quot;</span>, p3);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;p4:&#123;0&#125;&quot;</span>, p4);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>概括一下克隆过程：如果有一个仅包含值类型的类或结构，使用Memberwiseclone()实现Clone()方法。如果有一个保存其他引用类型的自定义类型，需要建立一个考虑了每个引用类型成员变量的新对象。</p>
<h4 id="9-13-构建可比较的对象-IComparable"><a href="#9-13-构建可比较的对象-IComparable" class="headerlink" title="9.13 构建可比较的对象(IComparable)"></a>9.13 构建可比较的对象(IComparable)</h4><p>System.IComparable接口指定了一种允许一个对象可基于某些特定键值进行排序的行为。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Car类的迭代可以基于CarID进行排序</span></span><br><span class="line"><span class="keyword">using</span> study;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Currentspeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> CarID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> currsp, <span class="built_in">int</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Currentspeed = currsp;</span><br><span class="line">            PetName = name;</span><br><span class="line">            CarID = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于C#int数据类型（只是CLR System.Int32的简写形式)实现了IComparable,我们就可以按如下所示的方法实现car的CompareTo()方法：</span></span><br><span class="line">        <span class="built_in">int</span> IComparable.CompareTo(<span class="built_in">object</span> obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Car temp = obj <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.CarID.CompareTo(temp.CarID);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Parameter is not a Car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Car[] myAutos = <span class="keyword">new</span> Car[<span class="number">5</span>];</span><br><span class="line">            myAutos[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Rusty&quot;</span>, <span class="number">80</span>, <span class="number">1</span>);</span><br><span class="line">            myAutos[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mary&quot;</span>, <span class="number">40</span>, <span class="number">234</span>);</span><br><span class="line">            myAutos[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;viper&quot;</span>, <span class="number">40</span>, <span class="number">34</span>);</span><br><span class="line">            myAutos[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mel&quot;</span>, <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line">            myAutos[<span class="number">4</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Chucky&quot;</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//建立一个Car对象数组</span></span><br><span class="line">            <span class="comment">//显示当前数组</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Here is the unordered set of cars:&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> myAutos)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, c.CarID, c.PetName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//现在，使用IComparable为它们排序</span></span><br><span class="line">            Array.Sort(myAutos);</span><br><span class="line">            Console.WriteLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//显示排序后的数组</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Here is the ordered set of cars:&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> myAutos)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125;&#123;1&#125;&quot;</span>, c.CarID, c.PetName);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-13-1-指定多个排序顺序-IComparer"><a href="#9-13-1-指定多个排序顺序-IComparer" class="headerlink" title="9.13.1 指定多个排序顺序(IComparer)"></a>9.13.1 指定多个排序顺序(IComparer)</h5><p>那如果要构建一个既可通过D排序又可通过昵称排序的Cr类型，该怎么办呢？如果读者对这种行为感兴趣，就需要与另一个标准接口IComparer打交道。它按如下代码所示定义在</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Car类的迭代可以基于CarID进行排序</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Currentspeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> CarID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> currsp, <span class="built_in">int</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Currentspeed = currsp;</span><br><span class="line">            PetName = name;</span><br><span class="line">            CarID = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于C#int数据类型（只是CLR System.Int32的简写形式)实现了IComparable,我们就可以按如下所示的方法实现car的CompareTo()方法：</span></span><br><span class="line">        <span class="built_in">int</span> IComparable.CompareTo(<span class="built_in">object</span> obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Car temp = obj <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.CarID.CompareTo(temp.CarID);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Parameter is not a Car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PetNameComparer</span> : <span class="title">IComparer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> IComparer.Compare(<span class="built_in">object</span> o1, <span class="built_in">object</span> o2)</span><br><span class="line">        &#123;</span><br><span class="line">            Car t1 = o1 <span class="keyword">as</span> Car;</span><br><span class="line">            Car t2 = o2 <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span>(t1 != <span class="literal">null</span> &amp;&amp; t2 != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> String.Compare(t1.PetName, t2.PetName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;parameter is not a car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">start</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Car[] myAutos = <span class="keyword">new</span> Car[<span class="number">5</span>];</span><br><span class="line">            myAutos[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Rusty&quot;</span>, <span class="number">80</span>, <span class="number">1</span>);</span><br><span class="line">            myAutos[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mary&quot;</span>, <span class="number">40</span>, <span class="number">234</span>);</span><br><span class="line">            myAutos[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;viper&quot;</span>, <span class="number">40</span>, <span class="number">34</span>);</span><br><span class="line">            myAutos[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mel&quot;</span>, <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line">            myAutos[<span class="number">4</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Chucky&quot;</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//按照名称进行排序</span></span><br><span class="line">            Array.Sort(myAutos, <span class="keyword">new</span> PetNameComparer());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//转储排序后的数组</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Ordering by pet name:&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> myAutos)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, c.CarID, c.PetName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="9-13-2-自定义属性、自定义排序类型"><a href="#9-13-2-自定义属性、自定义排序类型" class="headerlink" title="9.13.2 自定义属性、自定义排序类型"></a>9.13.2 自定义属性、自定义排序类型</h5><p>使用强关联属性按照名称排序，而不是使用独立的类型进行排序</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Car类的迭代可以基于CarID进行排序</span></span><br><span class="line"><span class="keyword">using</span> System.Collections;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">study</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> Currentspeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">int</span> CarID &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> currsp, <span class="built_in">int</span> id</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Currentspeed = currsp;</span><br><span class="line">            PetName = name;</span><br><span class="line">            CarID = id;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由于C#int数据类型（只是CLR System.Int32的简写形式)实现了IComparable,我们就可以按如下所示的方法实现car的CompareTo()方法：</span></span><br><span class="line">        <span class="built_in">int</span> IComparable.CompareTo(<span class="built_in">object</span> obj)</span><br><span class="line">        &#123;</span><br><span class="line">            Car temp = obj <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span> (temp != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.CarID.CompareTo(temp.CarID);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;Parameter is not a Car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> IComparer SortByPetName</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">get</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> (IComparer)<span class="keyword">new</span> PetNameComparer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PetNameComparer</span> : <span class="title">IComparer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> IComparer.Compare(<span class="built_in">object</span> o1, <span class="built_in">object</span> o2)</span><br><span class="line">        &#123;</span><br><span class="line">            Car t1 = o1 <span class="keyword">as</span> Car;</span><br><span class="line">            Car t2 = o2 <span class="keyword">as</span> Car;</span><br><span class="line">            <span class="keyword">if</span>(t1 != <span class="literal">null</span> &amp;&amp; t2 != <span class="literal">null</span>)</span><br><span class="line">                <span class="keyword">return</span> String.Compare(t1.PetName, t2.PetName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ArgumentException(<span class="string">&quot;parameter is not a car!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">start</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Car[] myAutos = <span class="keyword">new</span> Car[<span class="number">5</span>];</span><br><span class="line">            myAutos[<span class="number">0</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Rusty&quot;</span>, <span class="number">80</span>, <span class="number">1</span>);</span><br><span class="line">            myAutos[<span class="number">1</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mary&quot;</span>, <span class="number">40</span>, <span class="number">234</span>);</span><br><span class="line">            myAutos[<span class="number">2</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;viper&quot;</span>, <span class="number">40</span>, <span class="number">34</span>);</span><br><span class="line">            myAutos[<span class="number">3</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Mel&quot;</span>, <span class="number">40</span>, <span class="number">4</span>);</span><br><span class="line">            myAutos[<span class="number">4</span>] = <span class="keyword">new</span> Car(<span class="string">&quot;Chucky&quot;</span>, <span class="number">40</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">            Array.Sort(myAutos, Car.SortByPetName);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Ordering by pet name:&quot;</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (Car c <span class="keyword">in</span> myAutos)</span><br><span class="line">                Console.WriteLine(<span class="string">&quot;&#123;0&#125; &#123;1&#125;&quot;</span>, c.CarID, c.PetName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="10-泛型"><a href="#10-泛型" class="headerlink" title="10 泛型"></a>10 泛型</h3><p>C#数组允许我们定义一组固定上限的同-一类型的项（包括System.Object的数组，它本质上表示任何类型的数组)。虽然通常这可以满足我们的要求，但是在很多时候我们需要更灵活的数据结构，比如动态增长和收缩的容器或者容器只可以保存符合某个条件的对象（比如，只能从给定基类派生的对象，实现某个特殊接口的项等)。础类库中引入了一个以集合为中心的新命名空间：System.Collections.Generic命名空间。本章会介绍，泛型容器和它们的非泛型版本相比，在很多方面要优越得多，因为它们提供了更多类型安全和性能优势</p>
<h4 id="10-1-非泛型集合"><a href="#10-1-非泛型集合" class="headerlink" title="10.1 非泛型集合"></a>10.1 非泛型集合</h4><p>在学习如何在程序中使用泛型之前，研究一下非泛型集合类的问题会非常有用。这将有助于你更好地理解泛型要解决的首要问题。引入System.Collections命名空间：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections;</span><br></pre></td></tr></table></figure>

<h5 id="10-1-1-性能问题"><a href="#10-1-1-性能问题" class="headerlink" title="10.1.1 性能问题"></a>10.1.1 性能问题</h5><p>我们有时需要用一个类别的变量来表示另一个类别的变量。为此，C#提供了称为装箱的简单机制来实现A类——&gt;打包——&gt;B类重定引用，类型</p>
<p>尽管装箱和拆箱对程序员来说很方便，但是这种方式带来的堆&#x2F;栈内存转移会导致性能问题（执行速度和代码多少)，并且也缺乏类型安全(1)必须在托管堆上分配一个新对象。(2)基于栈数据的值必须被转移到新分配的内存位置。(3)在拆箱时，保存在堆对象中的值必须转移回栈。(4)堆上无用的对象（最后）会被回收。</p>
<h5 id="10-1-2-类型安全问题"><a href="#10-1-2-类型安全问题" class="headerlink" title="10.1.2 类型安全问题"></a>10.1.2 类型安全问题</h5><p>非泛型世界中的另一个类型安全问题：由于System.Collections中的大多数类所操作的都是System.Object,因此它们可以容纳任何类型</p>
<p>与非泛型容器相比，泛型容器的一些优势如下所示。</p>
<ul>
<li>泛型提供了更好的性能，因为它们不会导致装箱或拆箱的损耗。</li>
<li>泛型更类型安全，因为它们只包含我们指定的类型。</li>
<li>泛型大幅减少了构建自定义集合类型的需要，因为基础类库提供了几个预制的容器。</li>
</ul>
<h4 id="10-2-泛型类型参数的作用"><a href="#10-2-泛型类型参数的作用" class="headerlink" title="10.2 泛型类型参数的作用"></a>10.2 泛型类型参数的作用</h4><p>当你在，NET Framework4SDK文档或Visual Studio20l0对象浏览器中看到泛型项时，你会发现其表现形式为一对尖括号及其内部的字母或其他标记尖括号中标记的正式名称为类型参数，但你也可以通俗地将其称为占位符。<T>符号读作of T。因此IEnumerable<T>读作IEnumerable ofT,或者也可以称其为类型T的枚举。</p>
<h5 id="10-2-1-为泛型类-x2F-结构指定类型参数"><a href="#10-2-1-为泛型类-x2F-结构指定类型参数" class="headerlink" title="10.2.1 为泛型类&#x2F;结构指定类型参数"></a>10.2.1 为泛型类&#x2F;结构指定类型参数</h5><p>在创建泛型类或泛型结构的实例时，需要在声明变量和调用构造函数时指定类型参数。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该List&lt;&gt;只能容纳Person对象·</span></span><br><span class="line">List&lt;Person&gt; morePeople = <span class="keyword">new</span> List&lt;Person&gt;();</span><br></pre></td></tr></table></figure>

<h5 id="10-2-2-为泛型成员指定类型参数"><a href="#10-2-2-为泛型成员指定类型参数" class="headerlink" title="10.2.2 为泛型成员指定类型参数"></a>10.2.2 为泛型成员指定类型参数</h5><p>非泛型类或结构都支持泛型成员（如方法和属性)。因此在调用这种方法时，你仍然需要指定占位符的值。例如，System.Array支持一些泛型方法（.NET2.0中添加的)。如现在的Sort()静态方法包含一个相应的泛型方法Sort<T>()。考虑下面的代码段，其中T为int类型：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span>[] myInts=(<span class="number">10</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">93</span>&#125;:</span><br><span class="line"><span class="comment">//为sort&lt;&gt;()泛型方法指定占位符</span></span><br><span class="line">Array.Sort&lt;<span class="built_in">int</span>&gt;(myInts);</span><br><span class="line">              </span><br><span class="line"><span class="keyword">foreach</span> (<span class="built_in">int</span> i <span class="keyword">in</span> myInts)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-2-3-为泛型接口指定类型参数"><a href="#10-2-3-为泛型接口指定类型参数" class="headerlink" title="10.2.3 为泛型接口指定类型参数"></a>10.2.3 为泛型接口指定类型参数</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span> : <span class="title">IComparable</span>&lt;<span class="title">Car</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//IComparable&lt;T&gt;的实现</span></span><br><span class="line">    <span class="built_in">int</span> IComparable&lt;car&gt;.CompareTo(Car obj)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CarID &gt; obj.CarID)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.CarID &lt; obj.CarID)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里你不用判断传入的参数是否为Car,因为它只能为car。如果传入的数据类型不兼容，将得到编译时错误。</p>
<h4 id="10-3-System-Collectiong-Generic命名空间"><a href="#10-3-System-Collectiong-Generic命名空间" class="headerlink" title="10.3 System.Collectiong.Generic命名空间"></a>10.3 System.Collectiong.Generic命名空间</h4><p>System.Collectiong.Generic命名空间中为大多数非泛型接口都定义了泛型版本。略</p>
<h5 id="10-3-1-集合初始化语法"><a href="#10-3-1-集合初始化语法" class="headerlink" title="10.3.1 集合初始化语法"></a>10.3.1 集合初始化语法</h5><p>这个C#语言特性让你可以用与填充基础数组类似的语法，来填充ArrayList或List<T>等容器。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化标准的数组</span></span><br><span class="line"><span class="built_in">int</span>[] myArrayOfInts=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//初始化整数的泛型List&lt;&gt;</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt;myGenericList = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt; &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用数字数据初始化ArrayList</span></span><br><span class="line">ArrayList myList = <span class="keyword">new</span> ArrayList &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="10-3-2-使用List类"><a href="#10-3-2-使用List类" class="headerlink" title="10.3.2 使用List类"></a>10.3.2 使用List<T>类</h5><p>List<T>类是System.Collections.Generic命名空间中最常用的类型，因为它可以动态调整内容</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里我们使用初始化语法将对象填人List&lt;T&gt;,将其作为调用n次add()方法的简写形式。打印集合的项数和枚举各个项之后，</span></span><br><span class="line"><span class="comment">//调用了Insert()方法。如你所见，Insert()可以向List&lt;T&gt;中的指定索引位置插入一个新项。</span></span><br><span class="line"><span class="comment">//最后调用了ToArray()方法，它基于原始的List&lt;T&gt;,返回一个Person对象数组。我们使用数组索引器语法，对该数组再次执行循环。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseGenericList</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用集合/对象初始化语法，构建一个Person对象的列表</span></span><br><span class="line">    List&lt;Person&gt;<span class="function">people <span class="keyword">new</span> <span class="title">List</span>&lt;<span class="title">Person</span>&gt;()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Person &#123;FirstName=<span class="string">&quot;Homer&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">47</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> Person &#123;FirstName=<span class="string">&quot;Marge&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">45</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> Person &#123;FirstName=<span class="string">&quot;Lisa&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">9</span>&#125;,</span><br><span class="line">        <span class="keyword">new</span> Person &#123;FirstName=<span class="string">&quot;Bart&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">8</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">                    </span><br><span class="line">    <span class="comment">//打印列表中项的个数</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Items in list:(0&#125;&quot;</span>,people.Count);</span><br><span class="line">    <span class="comment">//枚举列表</span></span><br><span class="line">    <span class="keyword">foreach</span> (Person p <span class="keyword">in</span> people)</span><br><span class="line">        Console.WriteLine(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//插入一个新Person</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">-&gt;Inserting new person.&quot;</span>);</span><br><span class="line">    people.Insert(<span class="number">2</span>,<span class="keyword">new</span> Person FirstName <span class="string">&quot;Maggie&quot;</span>,LastName <span class="string">&quot;Simpson&quot;</span>,Age <span class="number">2</span> ))</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Items in list:(0)&quot;</span>,people.Count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将数据复制到新的数组中</span></span><br><span class="line">    Person[] arrayofPeople = people.ToArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>;i&lt;arrayofPeople.Length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;First Names:(0)&quot;</span>,arrayofPeople[i].FirstName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-3-3-使用Stack类"><a href="#10-3-3-使用Stack类" class="headerlink" title="10.3.3 使用Stack类"></a>10.3.3 使用Stack<T>类</h5><p>Stack<T>类表示以后进先出的方式维护数据的集合。它包含Push()和Pop()方法，可以向栈压入数据或从栈移除数据。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里，我们构建了包含3个Persen的栈，按名字的顺序添加：Homer、Marge和Lisa。在观察</span></span><br><span class="line"><span class="comment">//栈时，得到的永远是栈顶对象，因此，我们先调用Peek()来显示第三个Person对象。在一系列的Pop()</span></span><br><span class="line"><span class="comment">//和Peek()调用之后，栈最终为空，这时再调用Peek()和Pop()将触发系统异常</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseGenericstack</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    Stack&lt;Person&gt;stackofPeople = <span class="keyword">new</span> Stack&lt;Person&gt;();</span><br><span class="line">    stackofPeople.Push(<span class="keyword">new</span> Person &#123;FirstName <span class="string">&quot;Homer&quot;</span>,LastName <span class="string">&quot;Simpson&quot;</span>,Age <span class="number">47</span> &#125;)</span><br><span class="line">    stackofPeople.Push(<span class="keyword">new</span> Person &#123;FirstName <span class="string">&quot;Marge&quot;</span>,LastName <span class="string">&quot;Simpson&quot;</span>,Age <span class="number">45</span> &#125;)</span><br><span class="line">    stackofPeople.Push(<span class="keyword">new</span> Person &#123;FirstName =<span class="string">&quot;Lisa&quot;</span>,LastName <span class="string">&quot;Simpson&quot;</span>,Age <span class="number">9</span> &#125;)</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//观察栈顶的项，取出，再次观察</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;First person is:(0)&quot;</span>,stackofPeople.Peek());</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;Popped off (0)&quot;</span>,stackofPeople.Pop());</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">First person is:(0&#125;&quot;</span>,stackofPeople.Peek());</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Popped off (0)&quot;</span>,stackofPeople.Pop());</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">First person item is:(0)&quot;</span>,stackofPeople.Peek());</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Popped off &#123;0&#125;&quot;</span>,stackofPeople.Pop());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">nFirst person is:(0)&quot;</span>,stackofPeople.Peek());</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Popped off (0)&quot;</span>,stackofPeople.Pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (InvalidoperationException ex)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">Error!&#123;0&#125;&quot;</span>,ex.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-3-4-使用Queue类"><a href="#10-3-4-使用Queue类" class="headerlink" title="10.3.4 使用Queue类"></a>10.3.4 使用Queue<T>类</h5><p>如果你需要对一个以先到先得方式处理数据的场景进行建模，Queue<T>类是很适合的</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetCoffee</span>(<span class="params">Person p</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;(0)got coffee!&quot;</span>,p.FirstName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//现在假设你有另一个辅助方法，在其内部调用GetCoffee():</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseGenericQueue</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建一个包含3个人的队列</span></span><br><span class="line">    Queue&lt;Person&gt;peopleQ = <span class="keyword">new</span> Queue&lt;Person&gt;();</span><br><span class="line">    peopleQ.Enqueue(<span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Homer&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">47</span>));</span><br><span class="line">    peopleQ.Enqueue(<span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Marge&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">45</span>));</span><br><span class="line">    peopleQ.Enqueue(<span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Lisa&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">9</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//观察队列中的第一个人</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;&#123;0)is first in line!&quot;</span>,peopleQ.Peek().FirstName);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//移除队列中的人</span></span><br><span class="line">    GetCoffee(peopleQ.Dequeue());</span><br><span class="line">    Getcoffee(peopleQ.Dequeue());</span><br><span class="line">    GetCoffee(peopleQ.Dequeue());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//再次从队列中获取数据</span></span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        GetCoffee(peopleQ.Dequeue());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(InvalidoperationException e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Error!(0)&quot;</span>,e.Message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//————————————————————————</span></span><br><span class="line"><span class="comment">//Homer is first in line!</span></span><br><span class="line"><span class="comment">//Homer got coffee!</span></span><br><span class="line"><span class="comment">//Marge got coffee!</span></span><br><span class="line"><span class="comment">//Lisa got coffee!</span></span><br><span class="line"><span class="comment">//Error！Queue empty,</span></span><br><span class="line"><span class="comment">//————————————————————————</span></span><br></pre></td></tr></table></figure>

<h5 id="10-3-5-使用Sortedset类"><a href="#10-3-5-使用Sortedset类" class="headerlink" title="10.3.5 使用Sortedset类"></a>10.3.5 使用Sortedset<T>类</h5><p>SortedSet<T>类中的项是排序的，在插入和移除项之后，也能自动确保排序正确，因此该类十分有用。不过，你必须通知SortedSet<T>按何种方式进行排序</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">SortPeopleByAge</span> : <span class="title">IComparer</span>&lt;<span class="title">Person</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Compare</span>(<span class="params">Person firstPerson,Person secondPerson</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstPerson.Age &gt; secondPerson.Age)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (firstPerson.Age &lt; secondPerson.Age)</span><br><span class="line">            <span class="keyword">return</span><span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行应用程序，列表中的对象将永远按Ag属性的值排序，而与插入和移除对象的顺序无关</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//现在在Program类中添加下面的新方法，我们假设在Main()中调用该方法：</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseSortedset</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//添加一些不同年龄的人</span></span><br><span class="line">    SortedSet&lt;Person&gt;setofPeople - <span class="keyword">new</span> Sortedset&lt;Person&gt;(<span class="keyword">new</span> SortPeopleByAge())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Homer&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">47</span>),</span><br><span class="line">        <span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Marge&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">45</span>),</span><br><span class="line">        <span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Lisa&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">9</span>),</span><br><span class="line">        <span class="keyword">new</span> Person (FirstName=<span class="string">&quot;Bart&quot;</span>,LastName=<span class="string">&quot;Simpson&quot;</span>,Age=<span class="number">8</span>)</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//各项是按照年龄排序的</span></span><br><span class="line">    <span class="keyword">foreach</span> (Person p <span class="keyword">in</span> setofPeople)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(p);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加一些具有不同年龄的人</span></span><br><span class="line">    setofPeople.Add(<span class="keyword">new</span> Person FirstName =<span class="string">&quot;Saku&quot;</span>,LastName <span class="string">&quot;Jones&quot;</span>,Age <span class="number">1</span> &#125;)</span><br><span class="line">    setofPeople.Add(<span class="keyword">new</span> Person FirstName <span class="string">&quot;Mikko&quot;</span>,LastName <span class="string">&quot;Jones&quot;</span>,Age <span class="number">32</span> ))</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//仍然按照年龄排序</span></span><br><span class="line">    <span class="keyword">foreach</span> (Person p <span class="keyword">in</span> setofPeople)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-4-创建自定义泛型方法"><a href="#10-4-创建自定义泛型方法" class="headerlink" title="10.4 创建自定义泛型方法"></a>10.4 创建自定义泛型方法</h4><p>尽管大多数开发者通常使用基础类库中已知的泛型类型，不过你也可以构建自己的泛型成员和自定义泛型类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该方法最大的优势在于，只需要维护一个Swap&lt;T&gt;()版本，而且它能以类型安全的方式操作任意</span></span><br><span class="line"><span class="comment">//两个给定参数类型的项。更重要的是，栈数据保留在栈上，堆数据保留在堆上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//该方法可以交换任意两个由类型参数&lt;T&gt;指定的项</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Swap</span>&lt;<span class="title">T</span>&gt;(<span class="params"><span class="keyword">ref</span> T a,<span class="keyword">ref</span> T b</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;You sent the Swap()method a (0)&quot;</span>,<span class="keyword">typeof</span>(T)）;</span><br><span class="line">    T temp;</span><br><span class="line">    temp = a;</span><br><span class="line">    a =b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with Custom Generic Methods *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两个整数</span></span><br><span class="line">    inta=<span class="number">10</span>,b=<span class="number">90</span>:</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Before swap:(0),(1]&quot;</span>,a,b);</span><br><span class="line">    Swap&lt;<span class="built_in">int</span>&gt;(<span class="keyword">ref</span> a,<span class="keyword">ref</span> b);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After swap:(0),(1)&quot;</span>,a,b);</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//交换两个字符串</span></span><br><span class="line">    <span class="built_in">string</span> s1 = <span class="string">&quot;Hello&quot;</span>,s2 = <span class="string">&quot;There&quot;</span>;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Before swap:(0&#125;&#123;1)!&quot;</span>,s1,s2);</span><br><span class="line">    Swap&lt;<span class="built_in">string</span>&gt;(<span class="keyword">ref</span> s1,<span class="keyword">ref</span> s2);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;After swap:(0)(1)!&quot;</span>,s1,s2);</span><br><span class="line">    </span><br><span class="line">    Console.ReadLine(）;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类型参数的推断</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用诸如Swa&lt;T&gt;之类的泛型方法时，当（且仅当)泛型方法需要参数时，我们可以选择省略类型参数，因为编译器会基于成员参数推断类型参数.</span></span><br><span class="line"><span class="comment">//举个例子，我们可以通过将以下代码添加到Main()中来交换两个ystem.Boolean类型的值：</span></span><br><span class="line"><span class="built_in">bool</span> bl = <span class="literal">true</span>,b2 = <span class="literal">false</span>;</span><br><span class="line">Console.WriteLine(<span class="string">&quot;Before swap:(0),(1)&quot;</span>,bl,b2);</span><br><span class="line">Swap(<span class="keyword">ref</span> bl,<span class="keyword">ref</span> b2);</span><br><span class="line">Console.WriteLine(<span class="string">&quot;After swap:(0),(1)&quot;</span>,b1,b2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尽管编译器可以根据声明61和b2的类型发现正确的类型参数，但你还是应该养成显式指定类型参数的习惯：</span></span><br><span class="line">Swap&lt;<span class="built_in">bool</span>&gt;(<span class="keyword">ref</span> b1,<span class="keyword">ref</span> b2);</span><br></pre></td></tr></table></figure>

<h4 id="10-5-创建自定义泛型结构和类"><a href="#10-5-创建自定义泛型结构和类" class="headerlink" title="10.5 创建自定义泛型结构和类"></a>10.5 创建自定义泛型结构和类</h4><p>新建一个Console Application项目GenericPoint略</p>
<h5 id="10-5-1-泛型代码中的default关键字"><a href="#10-5-1-泛型代码中的default关键字" class="headerlink" title="10.5.1 泛型代码中的default关键字"></a>10.5.1 泛型代码中的default关键字</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在C#中，default关键字被重载</span></span><br><span class="line"><span class="comment">//和泛型一起使用时，它表示一个类型参数的默认值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ResetPoint</span> ()</span></span><br><span class="line">&#123;</span><br><span class="line">    x =<span class="literal">default</span>(T);</span><br><span class="line">    Y =<span class="literal">default</span>(T);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在引人泛型时，default关键字被赋予了双重身份。除了在switch结构内部使用外，还可用于设置类型参数的默认值。这是非常有用的，因为一个泛型类型预先并不知道实际的占位符，因此无法安全地假设默认值是什么。类型参数的默认值如下：</p>
<ul>
<li>数值的默认值为0；</li>
<li>引用类型的默认值为nul1,</li>
<li>一个结构的字段被设为0（值类型）或null（引用类型)。</li>
</ul>
<h5 id="10-5-2-泛型基类"><a href="#10-5-2-泛型基类" class="headerlink" title="10.5.2 泛型基类"></a>10.5.2 泛型基类</h5><p>泛型类可以作为其他类的基类，它可以定义许多虚方法和抽象方法。但需要遵守如下规则：</p>
<ol>
<li>首先，如果一个非泛型类扩展了一个泛型类，派生类必须指定一个类型参数：</li>
<li>第二，如果泛型基类定义了泛型虚方法或抽象方法，派生类型必须使用指定类型参数重写泛型方法：</li>
<li>第三，如果派生类型也是泛型，则它能够（可选地）重用类型占位符。</li>
</ol>
<h4 id="10-6-类型参数的约束"><a href="#10-6-类型参数的约束" class="headerlink" title="10.6 类型参数的约束"></a>10.6 类型参数的约束</h4><p>而NET平台使用were关键字可以得到更加具体的类型参数信息。使用这个关键字，可以对给定的类型参数添加一组约束，C#编译器将在编译时检查这些约束除非要创建类型安全的自定义集合，否则你很少会在C#项目中使用where关键字。</p>
<h5 id="10-6-1-使用where关键字的示例"><a href="#10-6-1-使用where关键字的示例" class="headerlink" title="10.6.1 使用where关键字的示例"></a>10.6.1 使用where关键字的示例</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MyGenericclass派生自object,并且包含项为实现了IDrawable的类，并且必须支持默认构造函数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericclass</span>&lt;<span class="title">T</span>&gt; <span class="keyword">where</span> <span class="title">T</span> : <span class="keyword">class</span>,<span class="title">IDrawable</span>,<span class="title">new</span>()&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//new()约束必须总是在列为的末尾new()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果你创建的自定义泛型集合指定了多个类型参数，可以为每个类型参数指定约束集，各约束集之间用where子句分隔：</span></span><br><span class="line"><span class="comment">//&lt;K&gt;必须扩展SomeBaseclass,并且必须包含默认构造函数</span></span><br><span class="line"><span class="comment">//&lt;T&gt;必须为结构，并且实现泛型IComparab1e接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MyGenericclass</span>&lt;<span class="title">K</span>,<span class="title">T</span>&gt;<span class="keyword">where</span> <span class="title">K</span> <span class="title">SomeBaseclass</span>,<span class="title">new</span>()</span><br><span class="line">                                <span class="keyword">where</span> <span class="title">T</span> <span class="title">struct</span>,<span class="title">IComparable</span>&lt;<span class="title">T</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="10-6-2-操作符约束的不足"><a href="#10-6-2-操作符约束的不足" class="headerlink" title="10.6.2 操作符约束的不足"></a>10.6.2 操作符约束的不足</h5><p>在创建泛型方法时，如果对类型参数应用任何C#操作符(+、一、*、&#x3D;等)，都将产生令人惊奇的编译器错误。泛型并不是万能的，不能对类型参数进行操作符操作看上去就是它的主要限制之一。</p>
<h3 id="11-委托、事件和lambda"><a href="#11-委托、事件和lambda" class="headerlink" title="11 委托、事件和lambda"></a>11 委托、事件和lambda</h3><p>回调机制可用于各种应用程序，但它们对于图形用户界面来说尤其重要，因为控件（如按钮)需要在正确的环境下调用外部方法（如单击按钮时、鼠标滑过按钮表面时等）。在NET平台下，委托类型用来定义和响应应用程序中的回调。事实上，NET委托类型是一个类型安全的对象，指向可以以后调用的其他方法。和传统的C++函数指针不同，NET委托是内置支持多路广播和异步方法调用的对象。</p>
<h4 id="11-1-NET委托类型"><a href="#11-1-NET委托类型" class="headerlink" title="11.1 .NET委托类型"></a>11.1 .NET委托类型</h4><p>使用回调，程序员可以使一个函数返回报告给（即回调）程序中的另一个函数。在NET Framework里，回调仍是可能的，它们的功能是由使用更为安全和面向对象的委托(delegate)来完成的。本质上来讲，委托是一个类型安全的对象，它指向程序中另一个以后会被调用的方法（或多个方法）。委托类型包含3个重要的信息：</p>
<ul>
<li>它所调用的方法的名称；</li>
<li>该方法的参数（可选)：</li>
<li>该方法的返回值（可选)。</li>
</ul>
<p>NET Framework中每个委托（包括自定义委托)都被自动赋予同步或异步访问方法的能力，可以不用手工创建与管理一个hread对象而直接调用另一个辅助执行线程上的方法</p>
<h4 id="11-2-在C-中定义委托类型"><a href="#11-2-在C-中定义委托类型" class="headerlink" title="11.2 在C#中定义委托类型"></a>11.2 在C#中定义委托类型</h4><p>在C#中创建一个委托类型时，需要使用delegate关键字。委托的名称可以自由选择。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个委托可以指向任何传入两个整数返回一个整数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Binaryop</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="11-3-System-MulticastDelegate与System-Delegate基类"><a href="#11-3-System-MulticastDelegate与System-Delegate基类" class="headerlink" title="11.3 System.MulticastDelegate与System.Delegate基类"></a>11.3 System.MulticastDelegate与System.Delegate基类</h4><p>使用C#中delegate关键字创建委托的时候，也就间接声明了一个派生自System.Multicast-Delegate的类。这个类使其继承类可以访问包含由委托对象维护的方法地址的列表以及一些处理调用列表的附加方法（与少数重载的操作符)。</p>
<h4 id="11-4-最简单的委托示例"><a href="#11-4-最简单的委托示例" class="headerlink" title="11.4 最简单的委托示例"></a>11.4 最简单的委托示例</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">SimpleDelegate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个委托可以指向任何传入两个整数并返回一个整数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="built_in">int</span> <span class="title">Binaryop</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个类包含了BinaryOp将指向的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleMath</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;<span class="keyword">return</span> x + y;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">Subtract</span>(<span class="params"><span class="built_in">int</span> x,<span class="built_in">int</span> y</span>)</span></span><br><span class="line">        &#123;<span class="keyword">return</span> x - y;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine (<span class="string">&quot;****Simple Delegate Example *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建一个指向mpleMath,dd()方法的Binaryop对象</span></span><br><span class="line">            Binaryop b = <span class="keyword">new</span> Binaryop(SimpleMath.Add);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//使用委托对象间接调用dd()方法</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;10 + 10 is &#123;0&#125;&quot;</span>,b(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>委托对象</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Simple Delegate Example *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//NET委托也可以指向实例方法</span></span><br><span class="line">    SimpleMath m =<span class="keyword">new</span> SimpleMath();</span><br><span class="line">    Binaryop b =<span class="keyword">new</span> Binaryop(m.Add);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//显示这个对象的信息</span></span><br><span class="line">    DisplayDelegateInfo(b);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;10 + 10 is (0)&quot;</span>,b(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-5-使用委托发送对象状态通知"><a href="#11-5-使用委托发送对象状态通知" class="headerlink" title="11.5 使用委托发送对象状态通知"></a>11.5 使用委托发送对象状态通知</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//内部状态数据</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Currentspeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> MaxSpeed &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span> PetName &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//汽车能用还是不能用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> carIsDead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>()</span> &#123; MaxSpeed = <span class="number">100</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span>(<span class="params"><span class="built_in">string</span> name, <span class="built_in">int</span> maxSp, <span class="built_in">int</span> currSp</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Currentspeed = currSp;</span><br><span class="line">        MaxSpeed = maxSp;</span><br><span class="line">        PetName = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1)定义委托类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CarEngineHandler</span>(<span class="params"><span class="built_in">string</span> msgForCaller</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2)定义每个委托类型的成员变量</span></span><br><span class="line">    <span class="keyword">private</span> CarEngineHandler listofHandlers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3)向调用者添加注册函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterwithCarEngine</span>(<span class="params">CarEngineHandler methodToCall</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listofHandlers = methodToCall;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果汽车不能用了，触发引爆事件</span></span><br><span class="line">        <span class="keyword">if</span> (carIsDead)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (listofHandlers != <span class="literal">null</span>)</span><br><span class="line">                listofHandlers(<span class="string">&quot;Sorry,this car is dead...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Currentspeed += delta;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//快不能用了吗</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span> == (MaxSpeed - Currentspeed) &amp;&amp; listofHandlers != <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                listofHandlers(<span class="string">&quot;Careful buddy!Gonna blow!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Currentspeed &gt;= MaxSpeed)</span><br><span class="line">                carIsDead = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                Console.WriteLine(<span class="string">&quot;CurrentSpeed (0)&quot;</span>, Currentspeed);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;****Delegates as event enablers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        <span class="comment">//首先，创建一个Car对象</span></span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在，告诉汽车，它想要向我们发送信息时调用哪个方法</span></span><br><span class="line">        c1.RegisterwithCarEngine(<span class="keyword">new</span> Car.CarEngineHandler(OnCarEngineEvent));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加速（这将触发事件）</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;****Speeding up ****&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要传入事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnCarEngineEvent</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">*****Message From Car object *****&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=&gt;&#123;0&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-5-1-支持多路广播"><a href="#11-5-1-支持多路广播" class="headerlink" title="11.5.1 支持多路广播"></a>11.5.1 支持多路广播</h5><p>NET委托内置支持多路广播。换句话说，一个委托对象可以维护一个可调用方法的列表而不只是单独一个方法。给一个委托对象添加多个方法时，不用直接分配，重载+&#x3D;操作符即可。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//现在支持多路广播</span></span><br><span class="line">    <span class="comment">//注意现在我们正在使用+一操作符，而不是量值操作符</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">RegisterwithCarEngine</span>(<span class="params">CarEngineHandler methodToCall</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listofHandlers += methodTocall;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;****Delegates as event enablers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        <span class="comment">//首先，创建一个Car对象</span></span><br><span class="line">        Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在，告诉汽车，它想要向我们发送信息时调用哪个方法</span></span><br><span class="line">        c1.RegisterwithCarEngine(<span class="keyword">new</span> Car.CarEngineHandler(OnCarEngineEvent));</span><br><span class="line">        c1.RegisterwithCarEngine(<span class="keyword">new</span> Car.CarEngineHandler(OnCarEngineEvent2));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加速（这将触发事件）</span></span><br><span class="line">        Console.WriteLine(<span class="string">&quot;****Speeding up ****&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">            c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要传入事件的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnCarEngineEvent</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">*****Message From Car object *****&quot;</span>);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=&gt;&#123;0&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">OnCarEngineEvent2</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;=&gt;&#123;0&#125;&quot;</span>, msg.ToUpper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-5-2-从委托的调用列表中移除成员"><a href="#11-5-2-从委托的调用列表中移除成员" class="headerlink" title="11.5.2 从委托的调用列表中移除成员"></a>11.5.2 从委托的调用列表中移除成员</h5><p>Delegate类还定义了一个静态Remove()方法，允许调用者动态地从委托对象的调用列表中移除方法。这样，调用者就可以在运行时简单地“退订”某个已知的通知。你可以直接在代码中调用Delegate.Remove(),不过C#开发者可以使用-&#x3D;操作符作为简写方式。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">UnRegisterwithCarEngine</span>(<span class="params">CarEngineHandler methodToCall</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        listofHandlers -= methodToCall;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Delegates as event enablers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//首先，创建一个Car对象</span></span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>, <span class="number">100</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定对象，稍后注销</span></span><br><span class="line">    Car.CarEngineHandler handler2 = <span class="keyword">new</span> Car.CarEngineHandler(OnCarEngineEvent2);</span><br><span class="line">    c1.RegisterwithCarEngine(handler2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加速（这将触发事件）</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Speeding up ****&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注销handler2程序</span></span><br><span class="line">    c1.UnRegisterwithCarEngine(handler2);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-6-方法组转换语法"><a href="#11-6-方法组转换语法" class="headerlink" title="11.6 方法组转换语法"></a>11.6 方法组转换语法</h4><p>当然，如果要调用ulticastDelegate或Delegate中继承的任何成员，手工创建一个委托变量是最直接的方式。但大多数情况下，我们并不需要依靠委托对象。我们常常使用委托对象只是为了传递作为构造函数参数的方法名称。为了简化操作，C#提供了一种叫做方法组转换的简便方法。该特性允许我们在调用以委托作为参数的方法时直接提供方法的名称，而不用创建委托对象。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Delegates as event enablers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//首先，创建一个Car对象</span></span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在，告诉汽车，它想要向我们发送信息时调用哪个方法</span></span><br><span class="line">    c1.RegisterwithCarEngine(CallMeHere);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加速（这将触发事件）】</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Speeding up ****&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">    c1.UnRegisterwithCarEngine(CallMeHere);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CallMeHere</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;=&gt;Message from Car:&#123;0&#125;&quot;</span>, msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-7-委托协变"><a href="#11-7-委托协变" class="headerlink" title="11.7 委托协变"></a>11.7 委托协变</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">DelegateCovariance</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//定义委托类型，它指向返回Car对象的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> Car <span class="title">ObtaincarDelegate</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">GetBasiccar</span>()</span></span><br><span class="line">        &#123;  <span class="keyword">return</span> <span class="keyword">new</span> car();&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Sportscar <span class="title">Getsportscar</span>()</span></span><br><span class="line">        &#123;  <span class="keyword">return</span> <span class="keyword">new</span> Sportscar();&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;*****Delegate Covariance *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">        </span><br><span class="line">            ObtaincarDelegate targetA = <span class="keyword">new</span> obtaincarDelegate(GetBasiccar);</span><br><span class="line">            Car c = targetA();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Obtained a &#123;0&#125;&quot;</span>,c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//协变允许这种目标对象赋值</span></span><br><span class="line">            UbtainVehicleDelegate targetB = <span class="keyword">new</span> ObtainvehicleDelegate(GetSportscar);</span><br><span class="line">            Sportscar sc = (SportsCar)targetB();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Obtained a (0)&quot;</span>,sc);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-8-泛型委托"><a href="#11-8-泛型委托" class="headerlink" title="11.8 泛型委托"></a>11.8 泛型委托</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">GenericDelegate</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个泛型委托可以调用任何返回void并接受单个参数的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MyGenericDelegate</span>&lt;<span class="title">T</span>&gt;(<span class="params">T arg</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine (<span class="string">&quot;****Generic Delegates *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//注册目标</span></span><br><span class="line">            MyGenericDelegate&lt;<span class="built_in">string</span>&gt;<span class="function">strTarget</span></span><br><span class="line"><span class="function">            <span class="keyword">new</span> <span class="title">MyGenericDelegate</span>&lt;<span class="title">string</span>&gt;(<span class="params">StringTarget</span>)</span>;</span><br><span class="line">            strTarget(<span class="string">&quot;Some string data&quot;</span>);</span><br><span class="line">            </span><br><span class="line">            MyGenericDelegate&lt;<span class="built_in">int</span>&gt;<span class="function">intTarget</span></span><br><span class="line"><span class="function">            <span class="keyword">new</span> <span class="title">MyGenericDelegate</span>&lt;<span class="title">int</span>&gt;(<span class="params">IntTarget</span>)</span>;</span><br><span class="line">            intTarget(<span class="number">9</span>);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">StringTarget</span>(<span class="params"><span class="built_in">string</span> arg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;arg in uppercase is:(0&#125;&quot;</span>,arg.ToUpper());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">IntTarget</span>(<span class="params"><span class="built_in">int</span> arg</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;++arg is:(0)&quot;</span>,++arg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-9-C-事件"><a href="#11-9-C-事件" class="headerlink" title="11.9 C#事件"></a>11.9 C#事件</h4><p>委托存在一些问题。例如：重复代码、如果没将委托的成员变量定义为私有的，调用者就可以直接访问委托对象公共的委托成员打破了封装，不仅会导致代码难以维护和调试，还会导致应用程序的安全风险！我们不希望给其他应用程序改变委托指向的权力以及没有我们的许可直接调用成员的权力。</p>
<h5 id="11-9-1-event关键字"><a href="#11-9-1-event关键字" class="headerlink" title="11.9.1 event关键字"></a>11.9.1 event关键字</h5><p>为了简化自定义方法的构建来为委托调用列表增加和删除方法，C#提供了event关键字。会自动提供注册和注销方法以及委托类型任何必要的成员变量。这些委托成员变量总是声明为私有的，因此不能直接从触发事件的对象访问它们</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//这个委托用来与Car的事件协作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CarEngineHandler</span>(<span class="params"><span class="built_in">string</span> msg</span>)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这种汽车可以发送这些事件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CarEngineHandler Exploded;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> CarEngineHandler AboutToBlow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Accelerate</span>(<span class="params"><span class="built_in">int</span> delta</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//如果汽车不能用了，触发引爆事件</span></span><br><span class="line">    <span class="keyword">if</span> (carIsDead)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Exploded != <span class="literal">null</span>)</span><br><span class="line">            Exploded(<span class="string">&quot;Sorry,this car is dead...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Currentspeed += delta;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//快不能用了吗</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">10</span> == (MaxSpeed - Currentspeed) &amp;&amp; AboutToBlow != <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            AboutToBlow(<span class="string">&quot;Careful buddy!Gonna blow!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Currentspeed &gt;= MaxSpeed)</span><br><span class="line">            carIsDead = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;CurrentSpeed &#123;0&#125;&quot;</span>, Currentspeed);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们已经设定了cr对象发送两个自定义事件，这不再需要定义自定义注册函数，也不需要声明委托成员变量</p>
<h5 id="11-9-2-揭开事件的神秘面纱"><a href="#11-9-2-揭开事件的神秘面纱" class="headerlink" title="11.9.2 揭开事件的神秘面纱"></a>11.9.2 揭开事件的神秘面纱</h5><p>C#事件事实上会扩展为两个隐藏的公共方法，一个带add_前缀，另一个带remove_前缀。前缀后面是C#事件的名称。</p>
<h5 id="11-9-3-监听传入的事件"><a href="#11-9-3-监听传入的事件" class="headerlink" title="11.9.3 监听传入的事件"></a>11.9.3 监听传入的事件</h5><p>C#事件也简化了注册调用者事件处理程序的操作。现在无需指定自定义辅助方法，调用者仅需使用+&#x3D;和-&#x3D;操作符即可（操作符将在后台触发正确的addx()或remove_XXX()方法）。注册一个事件要遵循以下模式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册一个事件要遵循以下模式</span></span><br><span class="line"><span class="comment">//Nameofobject.NameofEvent +new RelatedDelegate(functionToCall);</span></span><br><span class="line">Car.EngineHandler d = <span class="keyword">new</span> Car.CarEventHandler(CarExplodedEventHandler)</span><br><span class="line">myCar.Exploded += d;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要与事件源断开时，使用-=操作符：</span></span><br><span class="line"><span class="comment">// Nameofobject.NameofEvent -new RelatedDelegate(functionToCall);</span></span><br><span class="line">mycar.Exploded -= d;</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Fun with Events *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>,<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册事件处理程序</span></span><br><span class="line">    c1.AboutToBlow+=CarIsAlmostDoomed;</span><br><span class="line">    c1.AboutToBlow +=CarAboutToBlow;</span><br><span class="line">    c1.Exploded +=CarExploded;</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Speeding up *****&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; <span class="number">6</span>;i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    c1.Exploded -= CarExploded;</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;</span></span><br><span class="line"><span class="string">*****Speeding up *****&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span>（<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line">    </span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="11-9-4-使用Visual-Studio2010简化事件注册"><a href="#11-9-4-使用Visual-Studio2010简化事件注册" class="headerlink" title="11.9.4 使用Visual Studio2010简化事件注册"></a>11.9.4 使用Visual Studio2010简化事件注册</h5><p>略</p>
<h5 id="11-9-5-创建自定义的事件参数"><a href="#11-9-5-创建自定义的事件参数" class="headerlink" title="11.9.5 创建自定义的事件参数"></a>11.9.5 创建自定义的事件参数</h5><p>略</p>
<h5 id="11-9-6-泛型EvenHandler委托"><a href="#11-9-6-泛型EvenHandler委托" class="headerlink" title="11.9.6 泛型EvenHandler委托"></a>11.9.6 泛型EvenHandler<T>委托</h5><p>由于很多自定义委托接受object作为第一个参数，EvenArgs派生类型作为第二个参数，我们可以通过使用泛型EvenHandler<T>类型来进一步简化之前的示例，其中T就是自定义的EventArgs</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;CarEventArgs&gt;Exploded;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> EventHandler&lt;CarEventArgs&gt;AboutToBlow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine (<span class="string">&quot;****Prim and Proper Events *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//像平常一样创建一个Car</span></span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>,<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注册事件处理程序</span></span><br><span class="line">    c1.AboutToBlow += CarIsAlmostDoomed;</span><br><span class="line">    c1.AboutToBlow += CarAboutToBlow;</span><br><span class="line">    </span><br><span class="line">    EventHandler&lt;CarEventArgs&gt; d = <span class="keyword">new</span> EventHandler&lt;CarEventArgs&gt;(CarExploded);</span><br><span class="line">    c1.Exploded += d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-10-C-匿名方法"><a href="#11-10-C-匿名方法" class="headerlink" title="11.10 C#匿名方法"></a>11.10 C#匿名方法</h4><p>当一个调用者想监听传进来的事件时，它必须定义一个唯一的与相关联委托签名匹配的方法方法很少会被调用委托之外的任何程序所调用。从生产效率的角度来说，手工定义一个由委托对象调用的方法显得有点烦琐，不会很受欢迎。为了解决这一情况，现在可以在事件注册时直接将一个委托与一段代码相关联。这种代码的正式名称为匿名方法。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[]args</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Anonymous Methods *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    Car c1 = <span class="keyword">new</span> Car(<span class="string">&quot;SlugBug&quot;</span>,<span class="number">100</span>,<span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//注册事件处理程序作为匿名方法</span></span><br><span class="line">    c1.AboutToBlow += <span class="built_in">delegate</span></span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Eek!Going too fast!&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">    c1.AboutToBlow += <span class="built_in">delegate</span>(<span class="built_in">object</span> sender,CarEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Message from Car:(0)&quot;</span>,e.msg);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    c1.Exploded += <span class="built_in">delegate</span>(<span class="built_in">object</span> sender,CarEventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fatal Message from car:(0)&quot;</span>,e.msg);</span><br><span class="line">    &#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//这最终会触发事件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i <span class="number">0</span>;i&lt;<span class="number">6</span>;i++)</span><br><span class="line">        c1.Accelerate(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    Console.ReadLine ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>访问本地变量</strong>匿名方法它使我们能访问定义它们的方法（称为定义方法）的本地变量。这些变量称为匿名方法的外部变量。有关匿名方法作用域与定义方法的作用域之间的交互，有几个重要的知识点，如下所示。</p>
<ul>
<li>匿名方法不能访问定义方法中的ref或out参数。</li>
<li>匿名方法中的本地变量不能与外部方法中的本地变量重名。</li>
<li>匿名方法可以访问外部类作用域中的实例变量（或静态变量）。</li>
<li>匿名方法内的本地变量可以与外部类的成员变量同名（本地变量的作用域不同，可以隐藏外部类的成员变量)。</li>
</ul>
<h4 id="11-11-Lambda表达式"><a href="#11-11-Lambda表达式" class="headerlink" title="11.11 Lambda表达式"></a>11.11 Lambda表达式</h4><p>Lambda表达式只是用更简单的方式来写匿名方法，彻底简化了对.NET委托类型的使用。考虑泛型List<T>类的FidA11()方法。当你需要从一个集合中提取子集时，可以使用该方法，其原型如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//System,Collections.Generic,List&lt;T&gt;类中的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">FindAll</span>(<span class="params">Predicate&lt;T&gt; match</span>)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">AnonymousMethodsyntax</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立整数列表</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt;list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    list.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">20</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">44</span> &#125;);</span><br><span class="line">                           </span><br><span class="line">    <span class="comment">//现在使用匿名方法</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; evenNumbers = list.FindAll(<span class="built_in">delegate</span>(<span class="built_in">int</span> i)</span><br><span class="line">    	&#123; <span class="keyword">return</span> ( i % <span class="number">2</span> ) == <span class="number">0</span>; &#125; );</span><br><span class="line">                             </span><br><span class="line">    Console.WriteLine (<span class="string">&quot;Here are your even numbers:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> evenNumber <span class="keyword">in</span> evenNumbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;(0)\t&quot;</span>, evenNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以使用Lambda表达式进一步简化对FindA11()方法的调用。使用新的语法时，底层的委托对象将会消失得无影无踪。请看下面的Program类的新方法：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LambdaExpressionSyntax</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//建立一个整数列表</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    list.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">20</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">44</span> &#125;);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//现在使用Lambda表达式</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt;evenNumbers = list.FindAll(i =&gt; (i % <span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    Console.WriteLine(<span class="string">&quot;Here are your even numbers:&quot;</span>)</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> evenNumber <span class="keyword">in</span> evenNumbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;&#123;0&#125;\t&quot;</span>,evenNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-11-1-剖析Lambda表达式"><a href="#11-11-1-剖析Lambda表达式" class="headerlink" title="11.11.1 剖析Lambda表达式"></a>11.11.1 剖析Lambda表达式</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ”i&quot;就是我们的参数列表</span></span><br><span class="line"><span class="comment">// (i % 2) == 0 就是处理&quot;i&quot;的表达式</span></span><br><span class="line">List&lt;<span class="built_in">int</span>&gt;evenNumbers = list.FindAll(i =&gt; (i % <span class="number">2</span>) == <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h5 id="11-11-2-使用多个语句处理参数"><a href="#11-11-2-使用多个语句处理参数" class="headerlink" title="11.11.2 使用多个语句处理参数"></a>11.11.2 使用多个语句处理参数</h5><p>C#允许使用一系列代码语句来定义Lambda表达式。当表达式必须使用多行代码处理参数时，你可以使用一对花括号确定这些语句的范围</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">LambdaExpressionsyntax</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建整型列表</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt;list = <span class="keyword">new</span> List&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line">    list.AddRange(<span class="keyword">new</span> <span class="built_in">int</span>[] &#123;<span class="number">20</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">44</span> &#125; );</span><br><span class="line">                           </span><br><span class="line">    <span class="comment">//现在使用语句块编写Lambda表达式</span></span><br><span class="line">    List&lt;<span class="built_in">int</span>&gt; evenNumbers = list.FindAll( (i)=&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;value of i is currently:(0)&quot;</span>,i);</span><br><span class="line">        <span class="built_in">bool</span> isEven = ( ( i %<span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> isEven;</span><br><span class="line">    &#125;):</span><br><span class="line">                           </span><br><span class="line">    Console.WriteLine (<span class="string">&quot;Here are your even numbers:&quot;</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (<span class="built_in">int</span> evenNumber <span class="keyword">in</span> evenNumbers)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.Write(<span class="string">&quot;(0)\t&quot;</span>,evenNumber);</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-11-3-含有多个（或零个）参数的Lambda表达式"><a href="#11-11-3-含有多个（或零个）参数的Lambda表达式" class="headerlink" title="11.11.3 含有多个（或零个）参数的Lambda表达式"></a>11.11.3 含有多个（或零个）参数的Lambda表达式</h5><p>Lambda表达式可以处理多个参数或者不提供任何参数</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleMath</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">MathMessage</span>(<span class="params"><span class="built_in">string</span> msg, <span class="built_in">int</span> result</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> MathMessage mmDelegate;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetMathHandler</span>(<span class="params">MathMessage target</span>)</span></span><br><span class="line">    &#123;mmDelegate = target;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> x, <span class="built_in">int</span> y</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (mmDelegate != <span class="literal">null</span>)</span><br><span class="line">            mmDelegate.Invoke (<span class="string">&quot;Adding has completed!&quot;</span>,x +y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用Lambda表达式注册w/委托</span></span><br><span class="line">    SimpleMath m = <span class="keyword">new</span> SimpleMath();</span><br><span class="line">    m.SetMathHandler((msg, result)=&gt;</span><br><span class="line">         &#123;Console.WriteLine(<span class="string">&quot;Message:(0),Result:(1)&quot;</span>,msg,result);&#125;);</span><br><span class="line">                     </span><br><span class="line">    <span class="comment">//执行Lambda表达式</span></span><br><span class="line">    m.Add(<span class="number">10</span>,<span class="number">10</span>);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="11-11-4-使用Lambda表达式重新编写CarEvents示例"><a href="#11-11-4-使用Lambda表达式重新编写CarEvents示例" class="headerlink" title="11.11.4 使用Lambda表达式重新编写CarEvents示例"></a>11.11.4 使用Lambda表达式重新编写CarEvents示例</h5><p>略</p>
<h3 id="12-高级C-语言特征"><a href="#12-高级C-语言特征" class="headerlink" title="12 高级C#语言特征"></a>12 高级C#语言特征</h3><p>高级的语法构造</p>
<h4 id="12-1-索引器方法"><a href="#12-1-索引器方法" class="headerlink" title="12.1 索引器方法"></a>12.1 索引器方法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用索引操作符遍历传入的命令行参数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; args.Length; i++)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Args:&#123;0&#125;&quot;</span>,args[i]);</span><br><span class="line">                                          </span><br><span class="line">    <span class="comment">//声明一个局部整数数组</span></span><br><span class="line">    <span class="built_in">int</span>[] myInts = &#123;<span class="number">10</span>,<span class="number">9</span>,<span class="number">100</span>,<span class="number">432</span>,<span class="number">9874</span>&#125;:</span><br><span class="line">                                          </span><br><span class="line">    <span class="comment">//使用素引操作符访问每个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">int</span> j=<span class="number">0</span> ; j &lt; myInts.Length ; j++)</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Index &#123;0&#125;&#123;1&#125;&quot;</span>j,myInts[j]);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C#允许构建按照标准数组方式索引的自定义类和结构。顺理成章地能以这种方式访问子项的方法称为索引器方法(indexer method)。构建自定义集合类（泛型或非泛型)时，这个特殊的语言功能特别有用。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseGenericListofPeople</span>()</span></span><br><span class="line">&#123;</span><br><span class="line">    List&lt;Person&gt;myPeople = <span class="keyword">new</span> List&lt;Person&gt;();</span><br><span class="line">    myPeople.Add(<span class="keyword">new</span> Person(<span class="string">&quot;Lisa&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">9</span>));</span><br><span class="line">    myPeople.Add(<span class="keyword">new</span> Person(<span class="string">&quot;Bart&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">7</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//改变第一个人的索引器</span></span><br><span class="line">    myPeople[<span class="number">0</span>] = <span class="keyword">new</span> Person (<span class="string">&quot;Maggie&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过索引器获取和显示每一项</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>;i &lt; myPeople.Count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Person number:&#123;0&#125;&quot;</span>,i);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Name:&#123;0&#125;&#123;1&#125;&quot;</span>,myPeople[i].FirstName,</span><br><span class="line">            myPeople[i].LastName);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Age:&#123;0&#125;&quot;</span>,myPeople[i].Age);</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-1-使用字符串值索引对象"><a href="#12-1-1-使用字符串值索引对象" class="headerlink" title="12.1.1 使用字符串值索引对象"></a>12.1.1 使用字符串值索引对象</h5><p>由于ListDictionary类型允许使用字符串标记（例如一个人名）来访问其中包含的类型，我们可以设定新的索引器如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PeopleCollection</span> : <span class="title">IEnumerable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> Dictionary&lt;<span class="built_in">string</span>, Person&gt;listPeople = <span class="keyword">new</span> Dictionary&lt;<span class="built_in">string</span>,Person&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个索引器基于一个字符串索引返回一个Car</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">this</span>(<span class="params"><span class="built_in">string</span> name]</span></span></span><br><span class="line"><span class="params"><span class="function">    &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> (Person</span>)listPeople[name]</span>; &#125;</span><br><span class="line">        <span class="keyword">set</span> &#123; listPeople[name] = <span class="keyword">value</span>; &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearPeople</span>()</span></span><br><span class="line">	&#123; listPeople.clear();&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Count</span><br><span class="line">	&#123;<span class="keyword">get</span> &#123;<span class="keyword">return</span> listPeople.Count;&#125;</span><br><span class="line"></span><br><span class="line">    IEnumerator IEnumerable.GetEnumerator (</span><br><span class="line">    &#123;<span class="keyword">return</span> listPeople.GetEnumerator();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;*****Fun with Indexers *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line"></span><br><span class="line">    PeopleCollection myPeople = <span class="keyword">new</span> PeopleCollection();</span><br><span class="line"></span><br><span class="line">    myPeople[<span class="string">&quot;Homer&quot;</span>] = <span class="keyword">new</span> Person (<span class="string">&quot;Homer&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">40</span>);</span><br><span class="line">    myPeople[<span class="string">&quot;Marge&quot;</span>] = <span class="keyword">new</span> Person (<span class="string">&quot;Marge&quot;</span>,<span class="string">&quot;Simpson&quot;</span>,<span class="number">38</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取&quot;Homer&quot;并输出数据</span></span><br><span class="line">    Person homer = myPeople[<span class="string">&quot;Homer&quot;</span>];</span><br><span class="line">    Console.WriteLine (homer.Tostring ());</span><br><span class="line"></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-2-重载索引器方法"><a href="#12-1-2-重载索引器方法" class="headerlink" title="12.1.2 重载索引器方法"></a>12.1.2 重载索引器方法</h5><p>索引器方法可以在单个类或结构上被重载</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">DataTableCollection</span> : <span class="title">InternalDataCollectionBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//重载的索引器</span></span><br><span class="line">    <span class="keyword">public</span> DataTable <span class="keyword">this</span>[<span class="built_in">string</span> name] &#123;<span class="keyword">get</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> DataTable <span class="keyword">this</span>[<span class="built_in">string</span> name,<span class="built_in">string</span> tableNamespace] &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">    <span class="keyword">public</span> DataTable <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;<span class="keyword">get</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-3-多维的索引器"><a href="#12-1-3-多维的索引器" class="headerlink" title="12.1.3 多维的索引器"></a>12.1.3 多维的索引器</h5><p>如果真想特立独行，也可以创建一个传入多个参数的索引器。假定有一个以二维数组方式存储子项的自定义集合，可以设定索引器方法如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeContainer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span>[,] my2DintArray = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>,<span class="number">10</span>];</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> <span class="keyword">this</span>[<span class="built_in">int</span> row,<span class="built_in">int</span> column]</span><br><span class="line">    &#123;<span class="comment">/*从二维数组中取值或赋值*/</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-1-4-在接口类型上定义索引器"><a href="#12-1-4-在接口类型上定义索引器" class="headerlink" title="12.1.4 在接口类型上定义索引器"></a>12.1.4 在接口类型上定义索引器</h5><p>最后，要知道索引器可以在指定NET接口上定义，这样实现类型就可以提供自定义实现。以下是一个接口的简单示例，它定义了使用数字索引器获取字符串对象的协议：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IStringContainer</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//该接口定义了一个索引器，该素引器基于数字索引返回字符串</span></span><br><span class="line">    <span class="built_in">string</span> <span class="keyword">this</span>[<span class="built_in">int</span> index] &#123;<span class="keyword">get</span>;<span class="keyword">set</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-2-操作符重载"><a href="#12-2-操作符重载" class="headerlink" title="12.2 操作符重载"></a>12.2 操作符重载</h4><p>+操作符本身可以根据所提供的数据类型（本例中是字符串和整数）不同而有不同的功能。当+操作符被用于数字类型时，结果就是操作数之和；而当+操作符用于字符串类型时，结果就是字符串的串联。C#语言允许我们构建自定义类型和结构，它们也能对同一组基本操作符（如+)做出不同的反应。一定要注意不能重载每个内建C#操作符。</p>
<h5 id="12-2-1-重载二元操作符"><a href="#12-2-1-重载二元操作符" class="headerlink" title="12.2.1 重载二元操作符"></a>12.2.1 重载二元操作符</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仅是一个简单的C#类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> X &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Y &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span>(<span class="params"><span class="built_in">int</span> xPos, <span class="built_in">int</span> yPos</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        X = xPos;</span><br><span class="line">        Y = yPos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载+操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> + (Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(p1.X + p2.X, p1.Y + p2.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重载-操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> - (Point p1, Point p2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(p1.X - p2.X, p1.Y - p2.Y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">string</span> <span class="title">ToString</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">string</span>.Format(<span class="string">&quot;[(0),(1)]&quot;</span>, <span class="keyword">this</span>.X, <span class="keyword">this</span>.Y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;****Fun with overloaded Operators *****</span></span><br><span class="line"><span class="string">&quot;</span>);</span><br><span class="line">    <span class="comment">//创建两个点</span></span><br><span class="line">    Point ptone = <span class="keyword">new</span> Point(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line">    Point ptTwo = <span class="keyword">new</span> Point(<span class="number">40</span>, <span class="number">40</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone &#123;0&#125;&quot;</span>, ptone);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptTwo &#123;0&#125;&quot;</span>, ptTwo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个点相加得到一个更大的点</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone ptTwo:(0)&quot;</span>, ptone + ptTwo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将两个点相减得到一个更小的点</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone ptTwo:(0]&quot;</span>, ptone - ptTwo);</span><br><span class="line">    Console.ReadLine():</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-2-x3D-与-操作符"><a href="#12-2-2-x3D-与-操作符" class="headerlink" title="12.2.2 +&#x3D;与-+操作符"></a>12.2.2 +&#x3D;与-+操作符</h5><p>如果一个类型重载了相关的二元操作符，这些简写赋值操作符会自动具有相应的新功能</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重载二元操作符时，能产生新的简写赋值操作符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自动改变功能的+=</span></span><br><span class="line">    Point ptThree = <span class="keyword">new</span> Point(<span class="number">90</span>,<span class="number">5</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptThree (0)&quot;</span>,ptThree);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptThree += ptTwo:&#123;0&#125;&quot;</span>,ptThree +ptTwo);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//自动改变功能的-=</span></span><br><span class="line">    Point ptFour = <span class="keyword">new</span> Point (<span class="number">0</span>,<span class="number">500</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptFour &#123;0&#125;&quot;</span>,ptFour);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptFour -ptThree:&#123;0&#125;&quot;</span>,ptFour -ptThree);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-3-重载一元操作符"><a href="#12-2-3-重载一元操作符" class="headerlink" title="12.2.3 重载一元操作符"></a>12.2.3 重载一元操作符</h5><p>C#也允许我们重载各种-一元操作符，例如++与-。在重载一元操作符时，也要通过operator关键字定义一个静态方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//将传人的Point的X/Y值加1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> ++(Point pl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(pl.X + <span class="number">1</span>, pl.Y + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将传人的Point的X/Y值减1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Point <span class="keyword">operator</span> --(Point pl)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(p1.X - <span class="number">1</span>, p1.Y - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//也可以按如下代码增减Point的X和Y值：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//向Point应用++和--元操作符</span></span><br><span class="line">    Point ptFive = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;++ptFive = &#123;0&#125;&quot;</span>, ++ptFive); <span class="comment">//[2, 2]</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;--ptFive = &#123;0&#125;&quot;</span>, --ptFive); <span class="comment">//[1, 1]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用相同的操作符进行后递增和后递减</span></span><br><span class="line">    Point ptSix = <span class="keyword">new</span> Point(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptsix ++ = &#123;0&#125;&quot;</span>, ptSix++); <span class="comment">//[20, 20]</span></span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptsix -- = &#123;0&#125;&quot;</span>, ptSix--); <span class="comment">//[21, 21]</span></span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-4-重载相等操作符"><a href="#12-2-4-重载相等操作符" class="headerlink" title="12.2.4 重载相等操作符"></a>12.2.4 重载相等操作符</h5><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Point的变体也重载了==和！=操作符</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Point</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">bool</span> <span class="title">Equals</span>(<span class="params"><span class="built_in">object</span> o</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> o.ToString() = <span class="keyword">this</span>.ToString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">GetHashCode</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ToString().GetHashCode();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//现在，让我们来重载==和！=操作符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> ==(Point p1, Point p2)</span><br><span class="line">    &#123; <span class="keyword">return</span> p1.Equals(p2); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">bool</span> <span class="keyword">operator</span> !=(Point p1, Point p2)</span><br><span class="line">    &#123; <span class="keyword">return</span> !p1.Equals(p2); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="12-2-5-重载比较操作符"><a href="#12-2-5-重载比较操作符" class="headerlink" title="12.2.5 重载比较操作符"></a>12.2.5 重载比较操作符</h5><p>如果重载&lt;也必须重载&gt;</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用重载的&lt;与&gt;操作符</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone &lt; ptTwo &#123;0&#125;&quot;</span>,ptone &lt; ptTwo);</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;ptone &gt; ptTwo &#123;0&#125;&quot;</span>,ptone &gt; ptTwo);</span><br><span class="line">    Console.ReadLine();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">略</span><br></pre></td></tr></table></figure>

<h4 id="12-3-自定义类型转换"><a href="#12-3-自定义类型转换" class="headerlink" title="12.3 自定义类型转换"></a>12.3 自定义类型转换</h4><p>C#提供两个关键字explicit和implicit,可用来控制发生转换时类型的响应方式</p>
<h3 id="13-LINQ-to-Object"><a href="#13-LINQ-to-Object" class="headerlink" title="13 LINQ to Object"></a>13 LINQ to Object</h3><p>创建何种类型的应用程序，都需要在执行时访定的是，数据随处可见，如L文件、关系数据库、内存中的集合、基元数组等。在过去，根据数据位置的不同，程序员需要使用不同且不相关的API。,NET3.5引人了语言集成查询(LNQ),它提供了一种简明的、对称的、强类型的方式访向各种各样的数据存储。本章将开始研究LNQ,首先关注的是LINQ to Object。</p>
<h2 id="用-NET程序集编程"><a href="#用-NET程序集编程" class="headerlink" title="用.NET程序集编程"></a>用.NET程序集编程</h2><h3 id="14-NET程序集入门"><a href="#14-NET程序集入门" class="headerlink" title="14 .NET程序集入门"></a>14 .NET程序集入门</h3><p>书前13章中的每一个应用程序都是传统的、“独立”的应用程序，这里的“独立”是指所本有程字逻辑都封装在一个可执行文件中（.使cxc),然而，二进制重用(binary reuse)的t是NET平台的一个主要特点，它使得应用程序可以使用多个外部程序集（又称代码库）里面的类型。本章将对创建、部署和配置NET程序集的核心细节进行重点分析。本章首先介绍NET命名空间的构造，接着阐述单文件程序集和多文件程序集之间、“私有”程序集和“共享”程序集之间的区别，然后分析NET运行库如何解析一个程序集的位置，并进而理解全局程序集缓存(GAC)、应用程序配置文件(*.config文件)、发行者策略程序集以及ystem.Confi-guration命名空间。</p>
<h3 id="15-类型反射、晚期绑定和基于特性的编程"><a href="#15-类型反射、晚期绑定和基于特性的编程" class="headerlink" title="15 类型反射、晚期绑定和基于特性的编程"></a>15 类型反射、晚期绑定和基于特性的编程</h3><p>如第14章讲到的，在NET中，程序集是基本的部署单元。使用集成在Visual Studio2010中的象浏览器（和其他DE),可以查看项目所引用程序集的类型。此外，对于一个NET二进制文件，使用外部工具（如ildasm.exe和reflector..exe)可以查看底层的CIL代码、类型元数据和程序集清单。除了在设计时对NET程序集进行研究外，也可以使用System.Reflection命名空间通过编程获取相同的信息。本章的第一个任务就是明确反射的作用以及理解NET元数据的必要性。</p>
<h3 id="16-进程、应用程序域和对象上下文"><a href="#16-进程、应用程序域和对象上下文" class="headerlink" title="16 进程、应用程序域和对象上下文"></a>16 进程、应用程序域和对象上下文</h3><p>前章研究了CLR解析外部引用程序集位置的步骤以及.NET元数据的作用。本章将深入探讨序集由CLR承载的细节，并阐述进程、应用程序域和对象上下文（context)之间的关系。简单地说，进程可以承载一组相关的.NET程序集，而应用程序域（简称AppDomain)是对该进程的逻辑细分。你将看到，一个应用程序域进一步被细分成多个上下文边界，这些边界用来分组目的相似的NET对象。使用上下文的概念，CLR便能够确保恰当地控制那些带特殊运行时要求的对象。尽管大多数的日常编程任务可能不会直接使用进程、应用程序域或对象上下文，但在使用很多.NET API时，理解这些话题是非常重要的，如WCF、多线程和并行处理以及对象序列化。</p>
<h3 id="17-CIL和动态程序集的作用"><a href="#17-CIL和动态程序集的作用" class="headerlink" title="17 CIL和动态程序集的作用"></a>17 CIL和动态程序集的作用</h3><p>在热痛楼价用包硅受倍技他在英京中分招一托深有的作将*.cs代码文件翻译为CL代码、类型元数据和程序集清单。事实上，CL是一个成熟的.NET编程语言，包含自已的语法、语义和编译器(ilasm.exe)。本章将介绍这个NET平台的母语。你将理解CL指令、CL特性和CIL操作码之间的区别，还将学习各种CL编程工具以及.NET程序集正反向工程的作用，然后介绍了使用CL语法定义命名空间，类型和成员的基础知识，最后研究了System.Ref1 ection.Bmit命名空间的作用以及如何在运行时动态构造程序集（使用CL指令）。当然，很少有程序员会在日常工作中使用原始的CL代码。因此，我将在本章开头介绍为什么了解这个底层NET语言的语法和语义是很重要的。</p>
<h3 id="18-动态类型和动态语言运行时"><a href="#18-动态类型和动态语言运行时" class="headerlink" title="18 动态类型和动态语言运行时"></a>18 动态类型和动态语言运行时</h3><p>ET4为C#引人了一个新的关键字dynamic。该关键字允许我们在强类型的分号和花括号之间使用脚本化的行为，使用这种松散的类型，可以极大地简化一些复杂的细还可以获得与大量基于NET的动态语言（如IronRuby、IronPython)交互的能力。本章，我们将学习dynamic关键字的方方面面，理解如何使用DLR”(Dynamic Language Runtime,动态语言运行时)将松散的类型映射到正确的内存对象。理解了DLR提供的诸多服务之后，你将看到一些示例，它们使用动态类型来简化后期绑定方法的调用（通过反射服务）并且可以方便地与遗留的COM库进行通信。</p>
<h2 id="NET基础类库"><a href="#NET基础类库" class="headerlink" title=".NET基础类库"></a>.NET基础类库</h2><h3 id="19-构件多线程应用程序"><a href="#19-构件多线程应用程序" class="headerlink" title="19 构件多线程应用程序"></a>19 构件多线程应用程序</h3><p>人喜欢运行缓慢迟钝的应用程序。而且，也没人喜欢在影响程序其他部分响应速度的应用袋如单击工具条中的其项。在NET发布之前，构的应用程序需要编写极其复杂的C++代码和Windows线程API。幸好.NET平台提供了许多简单的方法来构建在特殊的执行路径执行复杂操作的软件。首先，回顾ET的委托类型，并理解它对异步方法调用的内在支持。你将看到，这项技术允许用户自动地在次线程中调用某个方法，而不需要手工创建或配置线程。</p>
<h3 id="20-文件输入输出和对象序列化"><a href="#20-文件输入输出和对象序列化" class="headerlink" title="20 文件输入输出和对象序列化"></a>20 文件输入输出和对象序列化</h3><p>如果要创建成熟的桌面应用程序，那么在用户会话之间保存信息的功能是必不可少的。本章将从.NET Framework的视角来研究一系列与I&#x2F;O相关的主题。首先研究System.Io命名空间定义的一些重要类型，进而理解怎样以编程方式修改计算机的目录和文件结构。掌握了这些后，接下来的任务就是研究读写基于字符、二进制、字符串、内存的各种数据存储内容的方法。</p>
<h3 id="21-ADO-NET之一：连接层"><a href="#21-ADO-NET之一：连接层" class="headerlink" title="21 ADO.NET之一：连接层"></a>21 ADO.NET之一：连接层</h3><p>如你所愿，NET平台定义了许多命名空间，允许同本地&#x2F;远程的数据库进行交互，我们把这些命名空间统称为ADO.NET。本章首先会总体介绍ADO.NET的作用，然后会重点讨论ADO.NET的数据提供程序。，NET平台支持许多数据提供程序，每一个都为和特定的数据库管理系统(微软SQL Server、Oracle、MySQL等)进行通信做了优化。</p>
<h3 id="22-ADO-NET之二：断开连接层"><a href="#22-ADO-NET之二：断开连接层" class="headerlink" title="22 ADO.NET之二：断开连接层"></a>22 ADO.NET之二：断开连接层</h3><hr>
<p>title: C#<br>date: 2022-8-22 10:39:26<br>tags:</p>
<p>- </p>
<p>categories: </p>
<ul>
<li>计算机</li>
<li>计算机语言</li>
<li>C#</li>
</ul>
<hr>
<h2 id="1-C-最小程序结构"><a href="#1-C-最小程序结构" class="headerlink" title="1. C#最小程序结构"></a>1. C#最小程序结构</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;	<span class="meta">#在程序中包含system命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">HelloWorldApplication</span>	#<span class="title">name</span>空间申请，下级可包含多个类</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">HelloWorld</span> #类声明，下级可包含多个方法</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)	#mian方法，所有C#程序的入口点，说明执行类时将做的动作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* 我的第一个 C# 程序*/</span>	<span class="meta">#注释</span></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World&quot;</span>);	<span class="meta">#writeline是console的方法</span></span><br><span class="line">            Console.ReadKey();	<span class="meta">#同上，当这个是等待按键动作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-C-基本语法"><a href="#2-C-基本语法" class="headerlink" title="2. C#基本语法"></a>2. C#基本语法</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;	<span class="meta">#在任何 C# 程序中的第一条语句都是using System</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span>	#类声明</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 成员变量</span></span><br><span class="line">        <span class="built_in">double</span> length;	<span class="meta">#变量创建</span></span><br><span class="line">        <span class="built_in">double</span> width;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Acceptdetails</span>()	#函数体，Acceptdetails为Rectangle【成员函数】</span></span><br><span class="line">        &#123;</span><br><span class="line">            length = <span class="number">4.5</span>;    </span><br><span class="line">            width = <span class="number">3.5</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Length: &#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Width: &#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Area: &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExecuteRectangle</span>	#<span class="title">main</span>方法及启动实例化<span class="title">Rectangle</span>类的类</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = <span class="keyword">new</span> Rectangle();	实例化并重命名r</span><br><span class="line">            r.Acceptdetails();	<span class="meta">#使用方法</span></span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-C-数据类型值类型"><a href="#3-C-数据类型值类型" class="headerlink" title="3. C#数据类型值类型"></a>3. C#数据类型<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-data-types.html">值类型</a></h2><h3 id="3-1-值类型"><a href="#3-1-值类型" class="headerlink" title="3.1 值类型"></a>3.1 <a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-data-types.html">值类型</a></h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">DataTypeApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Size of int: &#123;0&#125;&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">int</span>));	<span class="meta">#sizeof实际上是获取了数据在内存中所占用的存储空间，以字节为单位来计数。</span></span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>###引用类型引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。</p>
<p>####对象：对象可以分配任何其他类型的值，但在分类之前，需要类型转换####动态类型：####字符串类型####对象</p>
<p>###指针类型</p>
<p>##C#类型转换</p>
<ul>
<li><strong>隐式类型转换</strong> - 这些转换是 C# 默认的以安全方式进行的转换, 不会导致数据丢失。例如，从小的整数类型转换为大的整数类型，从派生类转换为基类。</li>
<li><strong>显式类型转换</strong> - 显式类型转换，即强制类型转换。显式转换需要强制转换运算符，而且强制转换会造成数据丢失。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">TypeConversionApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExplicitConversion</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">double</span> d = <span class="number">5673.74</span>;</span><br><span class="line">            <span class="built_in">int</span> i;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 强制转换 double 为 int</span></span><br><span class="line">            i = (<span class="built_in">int</span>)d;</span><br><span class="line">            Console.WriteLine(i);</span><br><span class="line">            Console.ReadKey();</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-type-conversion.html">C# 类型转换方法</a>##C#变量 一个变量只不过是一个供程序操作的存储区的名字。在 C# 中，每个变量都有一个特定的类型，类型决定了变量的内存大小和布局。范围内的值可以存储在内存中，可以对变量进行一系列操作</li>
</ul>
<p>##C#常量常量是固定值，程序执行期间不会改变。常量可以是任何基本数据类型，比如整数常量、浮点常量、字符常量或者字符串常量，还有枚举常量。常量可以被当作常规的变量，只是它们的值在定义后不能被修改。</p>
<p>##C#运算符运算符是一种告诉编译器执行特定的数学或逻辑操作的符号。C# 有丰富的内置运算符，分类如下：</p>
<ul>
<li><p>算术运算符</p>
<ul>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><ul>
<li></li>
</ul>
</li>
<li><p>&#x2F;</p>
</li>
<li><p>%（取模）</p>
</li>
<li><p>++（自增1）</p>
</li>
<li><p>–（自减1）</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">OperatorsAppl</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">int</span> a = <span class="number">21</span>;</span><br><span class="line">            <span class="built_in">int</span> b = <span class="number">10</span>;</span><br><span class="line">            <span class="built_in">int</span> c;</span><br><span class="line"></span><br><span class="line">            c = a + b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 1 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            c = a - b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 2 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            c = a * b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 3 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            c = a / b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 4 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            c = a % b;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 5 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ++a 先进行自增运算再赋值</span></span><br><span class="line">            c = ++a;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 6 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此时 a 的值为 22</span></span><br><span class="line">            <span class="comment">// --a 先进行自减运算再赋值</span></span><br><span class="line">            c = --a;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Line 7 - c 的值是 &#123;0&#125;&quot;</span>, c);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>c &#x3D; a++</strong>: 先将 a 赋值给 c，再对 a 进行自增运算。</p>
</li>
<li><p><strong>c &#x3D; ++a</strong>: 先将 a 进行自增运算，再将 a 赋值给 c 。</p>
</li>
<li><p><strong>c &#x3D; a–</strong>: 先将 a 赋值给 c，再对 a 进行自减运算。</p>
</li>
<li><p><strong>c &#x3D; –a</strong>: 先将 a 进行自减运算，再将 a 赋值给 c 。</p>
</li>
</ul>
</li>
<li><p>关系运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;&#x3D;</td>
<td>检查两个操作数的值是否相等，如果相等则条件为真。</td>
<td>(A &#x3D;&#x3D; B) 不为真。</td>
</tr>
<tr>
<td>!&#x3D;</td>
<td>检查两个操作数的值是否相等，如果不相等则条件为真。</td>
<td>(A !&#x3D; B) 为真。</td>
</tr>
<tr>
<td>&gt;</td>
<td>检查左操作数的值是否大于右操作数的值，如果是则条件为真。</td>
<td>(A &gt; B) 不为真。</td>
</tr>
<tr>
<td>&lt;</td>
<td>检查左操作数的值是否小于右操作数的值，如果是则条件为真。</td>
<td>(A &lt; B) 为真。</td>
</tr>
<tr>
<td>&gt;&#x3D;</td>
<td>检查左操作数的值是否大于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &gt;&#x3D; B) 不为真。</td>
</tr>
<tr>
<td>&lt;&#x3D;</td>
<td>检查左操作数的值是否小于或等于右操作数的值，如果是则条件为真。</td>
<td>(A &lt;&#x3D; B) 为真。</td>
</tr>
</tbody></table>
</li>
<li><p>逻辑运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;&amp;</td>
<td>称为逻辑与运算符。如果两个操作数都非零，则条件为真。</td>
<td>(A &amp;&amp; B) 为假。</td>
</tr>
<tr>
<td>&amp;#124;&amp;#124;</td>
<td>称为逻辑或运算符。如果两个操作数中有任意一个非零，则条件为真。</td>
<td>(A &amp;#124;&amp;#124; B) 为真。</td>
</tr>
<tr>
<td>!</td>
<td>称为逻辑非运算符。用来逆转操作数的逻辑状态。如果条件为真则逻辑非运算符将使其为假。</td>
<td>!(A &amp;&amp; B) 为真。</td>
</tr>
</tbody></table>
</li>
<li><p>位运算符（用于二进制移动，即60的二进制为00111100）</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>如果同时存在于两个操作数中，二进制 AND 运算符复制一位到结果中。</td>
<td>(A &amp; B) 将得到 12，即为 0000 1100</td>
</tr>
<tr>
<td>&amp;#124;</td>
<td>如果存在于任一操作数中，二进制 OR 运算符复制一位到结果中。</td>
<td>(A &amp;#124; B) 将得到 61，即为 0011 1101</td>
</tr>
<tr>
<td>^</td>
<td>如果存在于其中一个操作数中但不同时存在于两个操作数中，二进制异或运算符复制一位到结果中。</td>
<td>(A ^ B) 将得到 49，即为 0011 0001</td>
</tr>
<tr>
<td>~</td>
<td>按位取反运算符是一元运算符，具有”翻转”位效果，即0变成1，1变成0，包括符号位。</td>
<td>(~A ) 将得到 -61，即为 1100 0011，一个有符号二进制数的补码形式。</td>
</tr>
<tr>
<td>&lt;&lt;</td>
<td>二进制左移运算符。左操作数的值向左移动右操作数指定的位数。</td>
<td>A &lt;&lt; 2 将得到 240，即为 1111 0000</td>
</tr>
<tr>
<td>&gt;&gt;</td>
<td>二进制右移运算符。左操作数的值向右移动右操作数指定的位数。</td>
<td>A &gt;&gt; 2 将得到 15，即为 0000 1111</td>
</tr>
</tbody></table>
</li>
</ul>
<p>假设如果 A &#x3D; 60，且 B &#x3D; 13，现在以二进制格式表示，它们如下所示：A &#x3D; 0011 1100B &#x3D; 0000 1101—————–A&amp;B &#x3D; 0000 1100A|B &#x3D; 0011 1101A^B &#x3D; 0011 0001~A  &#x3D; 1100 0011</p>
<ul>
<li><p>赋值运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>&#x3D;</td>
<td>简单的赋值运算符，把右边操作数的值赋给左边操作数</td>
<td>C &#x3D; A + B 将把 A + B 的值赋给 C</td>
</tr>
<tr>
<td>+&#x3D;</td>
<td>加且赋值运算符，把右边操作数加上左边操作数的结果赋值给左边操作数</td>
<td>C +&#x3D; A 相当于 C &#x3D; C + A</td>
</tr>
<tr>
<td>-&#x3D;</td>
<td>减且赋值运算符，把左边操作数减去右边操作数的结果赋值给左边操作数</td>
<td>C -&#x3D; A 相当于 C &#x3D; C - A</td>
</tr>
<tr>
<td>*&#x3D;</td>
<td>乘且赋值运算符，把右边操作数乘以左边操作数的结果赋值给左边操作数</td>
<td>C *&#x3D; A 相当于 C &#x3D; C * A</td>
</tr>
<tr>
<td>&#x2F;&#x3D;</td>
<td>除且赋值运算符，把左边操作数除以右边操作数的结果赋值给左边操作数</td>
<td>C &#x2F;&#x3D; A 相当于 C &#x3D; C &#x2F; A</td>
</tr>
<tr>
<td>%&#x3D;</td>
<td>求模且赋值运算符，求两个操作数的模赋值给左边操作数</td>
<td>C %&#x3D; A 相当于 C &#x3D; C % A</td>
</tr>
<tr>
<td>&lt;&lt;&#x3D;</td>
<td>左移且赋值运算符</td>
<td>C &lt;&lt;&#x3D; 2 等同于 C &#x3D; C &lt;&lt; 2</td>
</tr>
<tr>
<td>&gt;&gt;&#x3D;</td>
<td>右移且赋值运算符</td>
<td>C &gt;&gt;&#x3D; 2 等同于 C &#x3D; C &gt;&gt; 2</td>
</tr>
<tr>
<td>&amp;&#x3D;</td>
<td>按位与且赋值运算符</td>
<td>C &amp;&#x3D; 2 等同于 C &#x3D; C &amp; 2</td>
</tr>
<tr>
<td>^&#x3D;</td>
<td>按位异或且赋值运算符</td>
<td>C ^&#x3D; 2 等同于 C &#x3D; C ^ 2</td>
</tr>
<tr>
<td>&amp;#124;&#x3D;</td>
<td>按位或且赋值运算符</td>
<td>C &amp;#124;&#x3D; 2 等同于 C &#x3D; C &amp;#124; 2</td>
</tr>
</tbody></table>
</li>
<li><p>其他运算符</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>sizeof()</td>
<td>返回数据类型的大小。</td>
<td>sizeof(int)，将返回 4.</td>
</tr>
<tr>
<td>typeof()</td>
<td>返回 class 的类型。</td>
<td>typeof(StreamReader);</td>
</tr>
<tr>
<td>&amp;</td>
<td>返回变量的地址。</td>
<td>&amp;a; 将得到变量的实际地址。</td>
</tr>
<tr>
<td>*</td>
<td>变量的指针。</td>
<td>*a; 将指向一个变量。</td>
</tr>
<tr>
<td>? :</td>
<td>条件表达式</td>
<td>如果条件为真 ? 则为 X : 否则为 Y</td>
</tr>
<tr>
<td>is</td>
<td>判断对象是否为某一类型。</td>
<td>If( Ford is Car) &#x2F;&#x2F; 检查 Ford 是否是 Car 类的一个对象。</td>
</tr>
<tr>
<td>as</td>
<td>强制转换，即使转换失败也不会抛出异常。</td>
<td>Object obj &#x3D; new StringReader(“Hello”);StringReader r &#x3D; obj as StringReader;</td>
</tr>
</tbody></table>
</li>
</ul>
<p>##C@#判断</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-if.html">if 语句</a></td>
<td>一个 <strong>if 语句</strong> 由一个布尔表达式后跟一个或多个语句组成。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-if-else.html">if…else 语句</a></td>
<td>一个 <strong>if 语句</strong> 后可跟一个可选的 <strong>else 语句</strong>，else 语句在布尔表达式为假时执行。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-nested-if.html">嵌套 if 语句</a></td>
<td>您可以在一个 <strong>if</strong> 或 <strong>else if</strong> 语句内使用另一个 <strong>if</strong> 或 <strong>else if</strong> 语句。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-switch.html">switch 语句</a></td>
<td>一个 <strong>switch</strong> 语句允许测试一个变量等于多个值时的情况。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-nested-switch.html">嵌套 switch 语句</a></td>
<td>您可以在一个 <strong>switch</strong> 语句内使用另一个 **switch ** 语句。</td>
</tr>
</tbody></table>
<p>##C#循环</p>
<table>
<thead>
<tr>
<th>循环类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-while-loop.html">while 循环</a></td>
<td>当给定条件为真时，重复语句或语句组。它会在执行循环主体之前测试条件。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-for-loop.html">for&#x2F;foreach 循环</a></td>
<td>多次执行一个语句序列，简化管理循环变量的代码。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-do-while-loop.html">do…while 循环</a></td>
<td>除了它是在循环主体结尾测试条件外，其他与 while 语句类似。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-nested-loops.html">嵌套循环</a></td>
<td>您可以在 while、for 或 do..while 循环内使用一个或多个循环。</td>
</tr>
</tbody></table>
<p>##C#封装<strong>封装</strong> 被定义为”把一个或多个项目封闭在一个物理的或者逻辑的包中”。在面向对象程序设计方法论中，封装是为了防止对实现细节的访问。抽象和封装是面向对象程序设计的相关特性。抽象允许相关信息可视化，封装则使开发者_实现所需级别的抽象_。C# 封装根据具体的需要，设置使用者的访问权限，并通过 <strong>访问修饰符</strong> 来实现。一个 <strong>访问修饰符</strong> 定义了一个类成员的范围和可见性。C# 支持的访问修饰符如下所示：</p>
<ul>
<li><p>public：所有对象都可以访问；</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">double</span> length;</span><br><span class="line">		<span class="keyword">public</span> <span class="built_in">double</span> width;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> length * width;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">		&#123;</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;长度：&#123;0&#125;&quot;</span>,length);</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;宽度：&#123;0&#125;&quot;</span>,width);</span><br><span class="line">			Console.WriteLine(<span class="string">&quot;面积：&#123;0&#125;&quot;</span>,GetArea());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">		&#123;</span><br><span class="line">			Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">			r.length = <span class="number">4.5</span>;</span><br><span class="line">			r.width = <span class="number">3.5</span>;</span><br><span class="line">			r.Display();</span><br><span class="line">			Console.ReadLine();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在上面的实例中，成员变量 length 和 width 被声明为 public，所以它们可以被函数 Main() 使用 Rectangle 类的实例 r 访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员函数 Display() 和 GetArea() 可以直接访问这些变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员函数 Display() 也被声明为 public，所以它也能被 Main() 使用 Rectangle 类的实例 r 访问</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>private：对象本身在对象内部可以访问；</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//成员变量</span></span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> length;</span><br><span class="line">        <span class="keyword">private</span> <span class="built_in">double</span> width;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Acceptdetails</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入长度：&quot;</span>);</span><br><span class="line">            length = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;请输入宽度：&quot;</span>);</span><br><span class="line">            width = Convert.ToDouble(Console.ReadLine());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;长度： &#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;宽度： &#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//end class Rectangle    </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">            r.Acceptdetails();</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">成员变量 length 和 width 被声明为 private，所以它们不能被函数 Main() 访问。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">成员函数 AcceptDetails() 和 Display() 可以访问这些变量。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于成员函数 AcceptDetails() 和 Display() 被声明为 public，所以它们可以被 Main() 使用 Rectangle 类的实例 r 访问。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>protected：只有该类对象及其子类对象可以访问</p>
</li>
<li><p>internal：同一个程序集的对象可以访问；</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">RectangleApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Rectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//成员变量</span></span><br><span class="line">        <span class="keyword">internal</span> <span class="built_in">double</span> length;</span><br><span class="line">        <span class="keyword">internal</span> <span class="built_in">double</span> width;</span><br><span class="line">       </span><br><span class="line">        <span class="function"><span class="built_in">double</span> <span class="title">GetArea</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> length * width;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Display</span>()</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;长度： &#123;0&#125;&quot;</span>, length);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;宽度： &#123;0&#125;&quot;</span>, width);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>, GetArea());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//end class Rectangle    </span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">ExecuteRectangle</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Rectangle r = <span class="keyword">new</span> Rectangle();</span><br><span class="line">            r.length = <span class="number">4.5</span>;</span><br><span class="line">            r.width = <span class="number">3.5</span>;</span><br><span class="line">            r.Display();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>protected internal：访问限于当前程序集或派生自包含类的类型。</p>
</li>
</ul>
<p>##C#方法一个方法是把一些相关的语句组织在一起，用来执行一个任务的语句块。每一个 C# 程序至少有一个带有 Main 方法的类。要使用一个方法，您需要：</p>
<ul>
<li><p>定义方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;Access Specifier&gt; &lt;Return Type&gt; &lt;Method Name&gt;(Parameter List)</span><br><span class="line">&#123;</span><br><span class="line">   Method Body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    Access Specifier：访问修饰符，这个决定了变量或方法对于另一个类的可见性。</span><br><span class="line">    Return type：返回类型，一个方法可以返回一个值。返回类型是方法返回的值的数据类型。如果方法不返回任何值，则返回类型为 <span class="keyword">void</span>。</span><br><span class="line">    Method name：方法名称，是一个唯一的标识符，且是大小写敏感的。它不能与类中声明的其他标识符相同。</span><br><span class="line">    Parameter list：参数列表，使用圆括号括起来，该参数是用来传递和接收方法的数据。参数列表是指方法的参数类型、顺序和数量。参数是可选的，也就是说，一个方法可能不包含参数。</span><br><span class="line">    Method body：方法主体，包含了完成任务所需的指令集。</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindMax</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">      <span class="built_in">int</span> result;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">         result = num1;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         result = num2;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用方法</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">CalculatorApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">NumberManipulator</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">FindMax</span>(<span class="params"><span class="built_in">int</span> num1, <span class="built_in">int</span> num2</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">/* 局部变量声明 */</span></span><br><span class="line">         <span class="built_in">int</span> result;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">            result = num1;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">            result = num2;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">/* 局部变量定义 */</span></span><br><span class="line">         <span class="built_in">int</span> a = <span class="number">100</span>;</span><br><span class="line">         <span class="built_in">int</span> b = <span class="number">200</span>;</span><br><span class="line">         <span class="built_in">int</span> ret;</span><br><span class="line">         NumberManipulator n = <span class="keyword">new</span> NumberManipulator();</span><br><span class="line"></span><br><span class="line">         <span class="comment">//调用 FindMax 方法</span></span><br><span class="line">         ret = n.FindMax(a, b);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;最大值是： &#123;0&#125;&quot;</span>, ret );</span><br><span class="line">         Console.ReadLine();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>###参数传递</p>
<table>
<thead>
<tr>
<th>方式</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>值参数</td>
<td>这种方式复制参数的实际值给函数的形式参数，实参和形参使用的是两个不同内存中的值。在这种情况下，当形参的值发生改变时，不会影响实参的值，从而保证了实参数据的安全。</td>
</tr>
<tr>
<td>引用参数</td>
<td>这种方式复制参数的内存位置的引用给形式参数。这意味着，当形参的值发生改变时，同时也改变实参的值。</td>
</tr>
<tr>
<td>输出参数</td>
<td>这种方式可以返回多个值。</td>
</tr>
</tbody></table>
<p>##C#可控类型###单问号 ? 与 双问号 ?? <a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-nullable.html">https://www.runoob.com/csharp/csharp-nullable.html</a>##C#数组 数组是一个存储相同类型元素的固定大小的顺序集合。数组是用来存储数据的集合，通常认为数组是一个同一类型变量的集合。  ###声明数组</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">datatype[] arrayName;</span><br><span class="line">    datatype 用于指定被存储在数组中的元素的类型。</span><br><span class="line">    [ ] 指定数组的秩（维度）。秩指定数组的大小。</span><br><span class="line">    arrayName 指定数组的名称。</span><br><span class="line">例：</span><br><span class="line"><span class="built_in">double</span>[] balance;</span><br></pre></td></tr></table></figure>
<p>###初始化数组</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line">声明一个数组不会在内存中初始化数组。当初始化数组变量时，您可以赋值给数组。</span><br><span class="line"></span><br><span class="line">数组是一个引用类型，所以您需要使用 <span class="keyword">new</span> 关键字来创建数组的实例</span><br></pre></td></tr></table></figure>
<p>###赋值给数组</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span>[] balance = <span class="keyword">new</span> <span class="built_in">double</span>[<span class="number">10</span>];</span><br><span class="line">balance[<span class="number">0</span>] = <span class="number">4500.0</span>;</span><br><span class="line"></span><br><span class="line">您可以在声明数组的同时给数组赋值，比如：</span><br><span class="line"><span class="built_in">double</span>[] balance = &#123; <span class="number">2340.0</span>, <span class="number">4523.69</span>, <span class="number">3421.0</span>&#125;;</span><br><span class="line"></span><br><span class="line">您也可以创建并初始化一个数组，比如：</span><br><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br><span class="line">在上述情况下，你也可以省略数组的大小，比如：</span><br><span class="line"><span class="built_in">int</span> [] marks = <span class="keyword">new</span> <span class="built_in">int</span>[]  &#123; <span class="number">99</span>,  <span class="number">98</span>, <span class="number">92</span>, <span class="number">97</span>, <span class="number">95</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>###访问数组元素</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">double</span> salary = balance[<span class="number">9</span>];</span><br></pre></td></tr></table></figure>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">ArrayApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">MyArray</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">int</span> []  n = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">10</span>]; <span class="comment">/* n 是一个带有 10 个整数的数组 */</span></span><br><span class="line">         <span class="built_in">int</span> i,j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 初始化数组 n 中的元素 */</span>        </span><br><span class="line">         <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ )</span><br><span class="line">         &#123;</span><br><span class="line">            n[ i ] = i + <span class="number">100</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* 输出每个数组元素的值 */</span></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++ )</span><br><span class="line">         &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Element[&#123;0&#125;] = &#123;1&#125;&quot;</span>, j, n[j]);</span><br><span class="line">         &#125;</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##C#字符串</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">StringApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="comment">//字符串，字符串连接</span></span><br><span class="line">            <span class="built_in">string</span> fname, lname;</span><br><span class="line">            fname = <span class="string">&quot;Rowan&quot;</span>;</span><br><span class="line">            lname = <span class="string">&quot;Atkinson&quot;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">string</span> fullname = fname + lname;</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Full Name: &#123;0&#125;&quot;</span>, fullname);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//通过使用 string 构造函数</span></span><br><span class="line">            <span class="built_in">char</span>[] letters = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span> &#125;;</span><br><span class="line">            <span class="built_in">string</span> greetings = <span class="keyword">new</span> <span class="built_in">string</span>(letters);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Greetings: &#123;0&#125;&quot;</span>, greetings);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//方法返回字符串</span></span><br><span class="line">            <span class="built_in">string</span>[] sarray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;From&quot;</span>, <span class="string">&quot;Tutorials&quot;</span>, <span class="string">&quot;Point&quot;</span> &#125;;</span><br><span class="line">            <span class="built_in">string</span> message = String.Join(<span class="string">&quot; &quot;</span>, sarray);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//用于转化值的格式化方法</span></span><br><span class="line">            DateTime waiting = <span class="keyword">new</span> DateTime(<span class="number">2012</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">17</span>, <span class="number">58</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">string</span> chat = String.Format(<span class="string">&quot;Message sent at &#123;0:t&#125; on &#123;0:D&#125;&quot;</span>,</span><br><span class="line">            waiting);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Message: &#123;0&#125;&quot;</span>, chat);</span><br><span class="line">            Console.ReadKey() ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##C#结构体 结构体是值类型数据结构。它使得一个单一变量可以存储各种数据类型的相关数据。<strong>struct</strong> 关键字用于创建结构体。  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line">     </span><br><span class="line"><span class="keyword">struct</span> Books</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> title;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> author;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">string</span> subject;</span><br><span class="line">   <span class="keyword">public</span> <span class="built_in">int</span> book_id;</span><br><span class="line">&#125;;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">testStructure</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">   &#123;</span><br><span class="line"></span><br><span class="line">      Books Book1;        <span class="comment">/* 声明 Book1，类型为 Books */</span></span><br><span class="line">      Books Book2;        <span class="comment">/* 声明 Book2，类型为 Books */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">/* book 1 详述 */</span></span><br><span class="line">      Book1.title = <span class="string">&quot;C Programming&quot;</span>;</span><br><span class="line">      Book1.author = <span class="string">&quot;Nuha Ali&quot;</span>;</span><br><span class="line">      Book1.subject = <span class="string">&quot;C Programming Tutorial&quot;</span>;</span><br><span class="line">      Book1.book_id = <span class="number">6495407</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* book 2 详述 */</span></span><br><span class="line">      Book2.title = <span class="string">&quot;Telecom Billing&quot;</span>;</span><br><span class="line">      Book2.author = <span class="string">&quot;Zara Ali&quot;</span>;</span><br><span class="line">      Book2.subject =  <span class="string">&quot;Telecom Billing Tutorial&quot;</span>;</span><br><span class="line">      Book2.book_id = <span class="number">6495700</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 打印 Book1 信息 */</span></span><br><span class="line">      Console.WriteLine( <span class="string">&quot;Book 1 title : &#123;0&#125;&quot;</span>, Book1.title);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 1 author : &#123;0&#125;&quot;</span>, Book1.author);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 1 subject : &#123;0&#125;&quot;</span>, Book1.subject);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 1 book_id :&#123;0&#125;&quot;</span>, Book1.book_id);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 打印 Book2 信息 */</span></span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 2 title : &#123;0&#125;&quot;</span>, Book2.title);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 2 author : &#123;0&#125;&quot;</span>, Book2.author);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 2 subject : &#123;0&#125;&quot;</span>, Book2.subject);</span><br><span class="line">      Console.WriteLine(<span class="string">&quot;Book 2 book_id : &#123;0&#125;&quot;</span>, Book2.book_id);      </span><br><span class="line"></span><br><span class="line">      Console.ReadKey();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有点类似于数据库中每一条记录的记录方式</p>
<p>##C#枚举枚举是一组命名整型常量。枚举类型是使用 <strong>enum</strong> 关键字声明的。C# 枚举是值类型。换句话说，枚举包含自己的值，且不能继承或传递继承。</p>
<p>枚举列表中的每个符号代表一个整数值，一个比它前面的符号大的整数值。默认情况下，第一个枚举符号的值是 0.例如：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EnumTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">enum</span> Day &#123; Sun, Mon, Tue, Wed, Thu, Fri, Sat &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = (<span class="built_in">int</span>)Day.Sun;</span><br><span class="line">        <span class="built_in">int</span> y = (<span class="built_in">int</span>)Day.Fri;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Sun = &#123;0&#125;&quot;</span>, x);</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;Fri = &#123;0&#125;&quot;</span>, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Sun = 0</span></span><br><span class="line"><span class="comment">Fri = 5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>##C#类 当你定义一个类时，你定义了一个数据类型的蓝图。这实际上并没有定义任何的数据，但它定义了类的名称意味着什么，也就是说，类的对象由什么组成及在这个对象上可执行什么操作。对象是类的实例。构成类的方法和变量称为类的成员。  </p>
<p>###类的定义类的定义是以关键字 <strong>class</strong> 开始，后跟类的名称。类的主体，包含在一对花括号内。下面是类定义的一般形式：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;access specifier&gt; <span class="keyword">class</span>  <span class="title">class_name</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// member variables</span></span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable1;</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variable2;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;data type&gt; variableN;</span><br><span class="line">    <span class="comment">// member methods</span></span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method1(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; method2(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    &lt;access specifier&gt; &lt;<span class="keyword">return</span> type&gt; methodN(parameter_list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>访问标识符 <access specifier> 指定了对类及其成员的访问规则。如果没有指定，则使用默认的访问标识符。类的默认访问标识符是 <strong>internal</strong>，成员的默认访问标识符是 <strong>private</strong>。</li>
<li>数据类型 <data type> 指定了变量的类型，返回类型 <return type> 指定了返回的方法返回的数据类型。</li>
<li>如果要访问类的成员，你要使用点（.）运算符。</li>
<li>点运算符链接了对象的名称和成员的名称。</li>
</ul>
<p>###成员函数的封装</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">BoxApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Box</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">       <span class="keyword">private</span> <span class="built_in">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span>(<span class="params"> <span class="built_in">double</span> len </span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">            length = len;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBreadth</span>(<span class="params"> <span class="built_in">double</span> bre </span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">            breadth = bre;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHeight</span>(<span class="params"> <span class="built_in">double</span> hei </span>)</span></span><br><span class="line">       &#123;</span><br><span class="line">            height = hei;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getVolume</span>()</span></span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Boxtester</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line">            Box Box1 = <span class="keyword">new</span> Box();        <span class="comment">// 声明 Box1，类型为 Box</span></span><br><span class="line">            Box Box2 = <span class="keyword">new</span> Box();        <span class="comment">// 声明 Box2，类型为 Box</span></span><br><span class="line">            <span class="built_in">double</span> volume;               <span class="comment">// 体积</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box1 详述</span></span><br><span class="line">            Box1.setLength(<span class="number">6.0</span>);</span><br><span class="line">            Box1.setBreadth(<span class="number">7.0</span>);</span><br><span class="line">            Box1.setHeight(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box2 详述</span></span><br><span class="line">            Box2.setLength(<span class="number">12.0</span>);</span><br><span class="line">            Box2.setBreadth(<span class="number">13.0</span>);</span><br><span class="line">            Box2.setHeight(<span class="number">10.0</span>);</span><br><span class="line">       </span><br><span class="line">            <span class="comment">// Box1 的体积</span></span><br><span class="line">            volume = Box1.getVolume();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box1 的体积： &#123;0&#125;&quot;</span> ,volume);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Box2 的体积</span></span><br><span class="line">            volume = Box2.getVolume();</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Box2 的体积： &#123;0&#125;&quot;</span>, volume);</span><br><span class="line">           </span><br><span class="line">            Console.ReadKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 成员变量是对象的属性（从设计角度），且它们保持私有来实现封装。这些变量只能使用公共成员函数来访问。  ###C#中的构造函数类的 <strong>构造函数</strong> 是类的一个特殊的成员函数，当创建类的新对象时执行。构造函数的名称与类的名称完全相同，它没有任何返回类型。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LineApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Line</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">double</span> length;   <span class="comment">// 线条的长度</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Line</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span>(<span class="params"> <span class="built_in">double</span> len </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getLength</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Line line = <span class="keyword">new</span> Line();    </span><br><span class="line">         <span class="comment">// 设置线条长度</span></span><br><span class="line">         line.setLength(<span class="number">6.0</span>);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;线条的长度： &#123;0&#125;&quot;</span>, line.getLength());</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>默认的构造函数</strong>没有任何参数。但是如果你需要一个带有参数的构造函数可以有参数，这种构造函数叫做<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-class.html"><strong>参数化构造函数</strong></a>###C#中的析构函数类的 <strong>析构函数</strong> 是类的一个特殊的成员函数，当类的对象超出范围时执行。析构函数的名称是在类的名称前加上一个波浪形（~）作为前缀，它不返回值，也不带任何参数。析构函数用于在结束程序（比如关闭文件、释放内存等）之前释放资源。析构函数不能继承或重载。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">LineApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Line</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">double</span> length;   <span class="comment">// 线条的长度</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Line</span>()  <span class="comment">// 构造函数</span></span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;对象已创建&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      ~Line() <span class="comment">//析构函数</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;对象已删除&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span>(<span class="params"> <span class="built_in">double</span> len </span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         length = len;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">getLength</span>()</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">return</span> length;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Line line = <span class="keyword">new</span> Line();</span><br><span class="line">         <span class="comment">// 设置线条长度</span></span><br><span class="line">         line.setLength(<span class="number">6.0</span>);</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;线条的长度： &#123;0&#125;&quot;</span>, line.getLength());          </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对象已创建</span></span><br><span class="line"><span class="comment">线条的长度： 6</span></span><br><span class="line"><span class="comment">对象已删除</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>##C#继承继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的<strong>基类</strong>，这个新的类被称为<strong>派生类</strong>。继承的思想实现了 <strong>属于（IS-A）</strong> 关系。###基类的初始化 派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。  </p>
<p>###C#多重继承多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。<strong>C# 不支持多重继承</strong>。但是，您可以使用接口来实现多重继承。</p>
<p>##C#多态性多态是同一个行为具有多个不同表现形式或形态的能力。<strong>多态性</strong>意味着有多重形式。在面向对象编程范式中，多态性往往表现为”一个接口，多个功能”。多态性可以是静态的或动态的。在<strong>静态多态性</strong>中，函数的响应是在编译时发生的。在<strong>动态多态性</strong>中，函数的响应是在运行时发生的。</p>
<p>###静态多态性在编译时，函数和对象的连接机制被称为早期绑定，也被称为静态绑定。C# 提供了两种技术来实现静态多态性。分别为：</p>
<ul>
<li>函数重载</li>
<li>运算符重载</li>
</ul>
<p>###函数重载 您可以在同一个范围内对相同的函数名有多个定义。函数的定义必须彼此不同，可以是参数列表中的参数类型不同，也可以是参数个数不同。不能重载只有返回类型不同的函数声明  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PolymorphismApplication</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestData</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b, <span class="built_in">int</span> c</span>)</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> a + b + c;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="built_in">int</span> <span class="title">Add</span>(<span class="params"><span class="built_in">int</span> a, <span class="built_in">int</span> b</span>)</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">return</span> a + b;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span>  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            TestData dataClass = <span class="keyword">new</span> TestData();</span><br><span class="line">            <span class="built_in">int</span> add1 = dataClass.Add(<span class="number">1</span>, <span class="number">2</span>);  </span><br><span class="line">            <span class="built_in">int</span> add2 = dataClass.Add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(<span class="string">&quot;add1 :&quot;</span> + add1);</span><br><span class="line">            Console.WriteLine(<span class="string">&quot;add2 :&quot;</span> + add2);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###动态多态性C# 允许您使用关键字 <strong>abstract</strong> 创建抽象类，用于提供接口的部分类的实现。当一个派生类继承自该抽象类时，实现即完成。<strong>抽象类</strong>包含抽象方法，抽象方法可被派生类实现。派生类具有更专业的功能。请注意，下面是有关抽象类的一些规则：</p>
<ul>
<li>您不能创建一个抽象类的实例。</li>
<li>您不能在一个抽象类外部声明一个抽象方法。</li>
<li>通过在类定义前面放置关键字 <strong>sealed</strong>，可以将类声明为<strong>密封类</strong>。当一个类被声明为 <strong>sealed</strong> 时，它不能被继承。抽象类不能被声明为 sealed。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">namespace</span> <span class="title">PolymorphismApplication</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Shape</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="built_in">int</span> <span class="title">area</span>()</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">class</span> <span class="title">Rectangle</span>:  <span class="title">Shape</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> length;</span><br><span class="line">      <span class="keyword">private</span> <span class="built_in">int</span> width;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span>(<span class="params"> <span class="built_in">int</span> a=<span class="number">0</span>, <span class="built_in">int</span> b=<span class="number">0</span></span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         length = a;</span><br><span class="line">         width = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">int</span> <span class="title">area</span> ()</span></span><br><span class="line">      &#123;</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;Rectangle 类的面积：&quot;</span>);</span><br><span class="line">         <span class="keyword">return</span> (width * length);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title">RectangleTester</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">         Rectangle r = <span class="keyword">new</span> Rectangle(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">         <span class="built_in">double</span> a = r.area();</span><br><span class="line">         Console.WriteLine(<span class="string">&quot;面积： &#123;0&#125;&quot;</span>,a);</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>##C#运算符重载 您可以重定义或重载 C# 中内置的运算符。因此，程序员也可以使用用户自定义类型的运算符。重载运算符是具有特殊名称的函数，是通过关键字 <strong>operator</strong> 后跟运算符的符号来定义的。与其他函数一样，重载运算符有返回类型和参数列表。  </p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Box <span class="keyword">operator</span>+ (Box b, Box c)</span><br><span class="line">&#123;</span><br><span class="line">   Box box = <span class="keyword">new</span> Box();</span><br><span class="line">   box.length = b.length + c.length;</span><br><span class="line">   box.breadth = b.breadth + c.breadth;</span><br><span class="line">   box.height = b.height + c.height;</span><br><span class="line">   <span class="keyword">return</span> box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-operator-overloading.html">https://www.runoob.com/csharp/csharp-operator-overloading.html</a></p>
<p>##C#接口接口定义了所有类继承接口时应遵循的语法合同。接口定义了语法合同 <strong>“是什么”</strong> 部分，派生类定义了语法合同 <strong>“怎么做”</strong> 部分。接口定义了属性、方法和事件，这些都是接口的成员。接口只包含了成员的声明。成员的定义是派生类的责任。接口提供了派生类应遵循的标准结构。接口使得实现接口的类或结构在形式上保持一致。抽象类在某种程度上与接口类似，但是，它们大多只是用在当只有少数方法由基类声明由派生类实现时。接口本身并不实现任何功能，它只是和声明实现该接口的对象订立一个必须实现哪些行为的契约。抽象类不能直接实例化，但允许派生出具体的，具有实际功能的类。<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-interface.html">https://www.runoob.com/csharp/csharp-interface.html</a></p>
<p>##C#命名空间<strong>命名空间</strong>的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。我们举一个计算机系统中的例子，一个文件夹(目录)中可以包含多个文件夹，每个文件夹中不能有相同的文件名，但不同文件夹中的文件可以重名。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">namespace_name</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 代码声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##C#预处理器指令预处理器指令指导编译器在实际编译开始之前对信息进行预处理。所有的预处理器指令都是以 # 开始。且在一行上，只有空白字符可以出现在预处理器指令之前。预处理器指令不是语句，所以它们不以分号（;）结束。<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-preprocessor-directives.html">https://www.runoob.com/csharp/csharp-preprocessor-directives.html</a></p>
<p>##C#正则表达式<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-regular-expressions.html">https://www.runoob.com/csharp/csharp-regular-expressions.html</a></p>
<p>##C#异常处理<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-exception-handling.html">https://www.runoob.com/csharp/csharp-exception-handling.html</a></p>
<p>##C#文件的输入与输出<a target="_blank" rel="noopener" href="https://www.runoob.com/csharp/csharp-file-io.html">https://www.runoob.com/csharp/csharp-file-io.html</a></p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/09/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E4%BF%9D%E6%8A%A4%E8%87%AA%E7%84%B6/%E4%BF%9D%E6%8A%A4%E8%87%AA%E7%84%B6-%E4%B8%8D%E7%95%99%E7%97%95%E8%BF%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/09/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E4%BF%9D%E6%8A%A4%E8%87%AA%E7%84%B6/%E4%BF%9D%E6%8A%A4%E8%87%AA%E7%84%B6-%E4%B8%8D%E7%95%99%E7%97%95%E8%BF%B9/" class="post-title-link" itemprop="url">保护自然-不留痕迹</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-09 09:15:54" itemprop="dateCreated datePublished" datetime="2022-10-09T09:15:54+08:00">2022-10-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-28 14:04:14" itemprop="dateModified" datetime="2023-04-28T14:04:14+08:00">2023-04-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/" itemprop="url" rel="index"><span itemprop="name">户外</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">登山知识与技巧</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E4%BF%9D%E6%8A%A4%E8%87%AA%E7%84%B6/" itemprop="url" rel="index"><span itemprop="name">保护自然</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.8k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>2 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="制定务实的目标"><a href="#制定务实的目标" class="headerlink" title="制定务实的目标"></a>制定务实的目标</h2><p>每支队伍都有的极限，为了人员安全，就只好不顾对环境的破坏</p>
<h2 id="控制队伍人数"><a href="#控制队伍人数" class="headerlink" title="控制队伍人数"></a>控制队伍人数</h2><p>在确保安全的前提下，队伍的上限人数是多少</p>
<h2 id="考虑多种状态"><a href="#考虑多种状态" class="headerlink" title="考虑多种状态"></a>考虑多种状态</h2><p>获取当地相当信息，以帮助决定团队登山的地点、时间以及使用何种不留哼唧的技巧</p>
<ul>
<li>环境比较敏感与脆弱的区域，包括动物、植物与地质</li>
<li>土壤的状态与含水量</li>
</ul>
<p>你携带的包装越少越好</p>
<h2 id="行进或扎营"><a href="#行进或扎营" class="headerlink" title="行进或扎营"></a>行进或扎营</h2><h3 id="使用山径原则"><a href="#使用山径原则" class="headerlink" title="使用山径原则"></a>使用山径原则</h3><p>遵守以下使用山径原则：</p>
<ul>
<li>尽量走现成的山径</li>
<li>不要随意踩踏山径外的区域，即使是遇到泥泞或其他难行路况</li>
<li>保护路旁的植被。山径通常只允许一个人行走，不能并排行进，不要随意拓宽山径。</li>
<li>勿随便选择路径。随意选择路径不会节省时间，反而会耗费许多体力。随意开路会让泥土裸露</li>
<li>尽量在雪地上行走。在春秋季节，经过土壤水分饱和的雪土交界带是十分危险的，要格外小心。</li>
<li>带一个口袋，随时拉拾其他登山者丢弃的垃圾。</li>
<li>在行进中遇到沙暴时，不要乱跑。</li>
<li>选择在自然恢复能力较强的地方休总。如果因为环境容易遭到破坏或植被过于茂密而无法离开山径，请在山径上比较宽阔的地方休息。</li>
<li>当上山下山的两支登山者相遇时，通常是下山的队伍站在路旁，让上山的队伍先行。</li>
<li>沿着溪边行走要格外小心，避免造成水土流失</li>
</ul>
<p>山径外行走原则：</p>
<ul>
<li>保持缓慢的速度，随时留意周围的环境，选择对环境破坏最小的路线。</li>
<li>在山径外行走，尤其是在容易受损的草地上行进时，请分开，让每个人走在不同的路径上，除非那里已被其他登山者走出了明显的路径</li>
<li>请勿践踏草本植物。在山径外行走时，请寻找裸露的地表、岩石或有莎草科植物覆盖的坚硬地面行走。</li>
<li>在春季、晚秋通过土壤水分达到饱和的雪土交界带，要格外留心。</li>
<li>不要沿路堆石堆，更不要在树上刻字。</li>
<li>去程时做标记请在回程时拆除。</li>
</ul>
<h3 id="使用营地原则"><a href="#使用营地原则" class="headerlink" title="使用营地原则"></a>使用营地原则</h3><p>坚守“60米原则”：营地要距离水源、道路及其他登山者至少60米尽量使用现成的营地</p>
<h3 id="选择营地指南"><a href="#选择营地指南" class="headerlink" title="选择营地指南"></a>选择营地指南</h3><p>开发成熟的现有营地&gt;雪地&gt;岩面&gt;沙地、泥地或碎石底&gt;森林中的酸性腐植层&gt;有植物覆盖的草地&gt;林线上有植被覆盖的草地&gt;湖泊或者溪流沿岸</p>
<h3 id="原始环境搭建帐篷"><a href="#原始环境搭建帐篷" class="headerlink" title="原始环境搭建帐篷"></a>原始环境搭建帐篷</h3><ul>
<li>一个原始环境最多停留一到两天，然后必须换到其他地方</li>
<li>帐篷不要搭在一起</li>
<li>分散如厕地点和行走路线，以免在同一条路线上过度踩踏植被。</li>
<li>在有坡度的地方扎营，不然帐篷底下可能会积水，这就必须要挖排水沟。</li>
<li>不要把不平的地面铲平。</li>
</ul>
<p>离营时，应尽力将营地恢复成原有的状态。在原始环境中遵循不留痕迹原则需要下一番工夫才行，例如用天然物质掩盖使用过的地方、抹去痕迹，并把被压成垫状的草弄松等。</p>
<h2 id="使用炉具"><a href="#使用炉具" class="headerlink" title="使用炉具"></a>使用炉具</h2><p>炉具不会消耗自然资源，也不会让山里烟雾迷茫。此外，炉具的使用不受天气限制，比生营火更容易、更快、更方便。营火对自然的破坏其实挺大的</p>
<h2 id="妥善处理排泄物"><a href="#妥善处理排泄物" class="headerlink" title="妥善处理排泄物"></a>妥善处理排泄物</h2><p>登山若经常在恶劣的环境中行进，例如高山、沙漠和极地。在这些地方，人类排泄物的分解速度都很慢，甚至根本不会分解</p>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><p>保持60米原则，并且远离水源、山径、营地和人群聚集区。在裸地和岩石上小便，不要对准植物。如果在攀岩或冰面，请在尿液能顺着攀岩路径下流的地点小解。</p>
<p>可以使用河沙、球果、阔叶、雪代替卫生纸。如果一定要用卫生纸，请使用天然色泽及无味的。不要焚烧卫生纸，将它们放在胶袋里带下山去。</p>
<h3 id="猫坑掩埋法"><a href="#猫坑掩埋法" class="headerlink" title="猫坑掩埋法"></a>猫坑掩埋法</h3><p>适合低海拔且有较厚腐植层的地方</p>
<p>如果一个地方你能轻易找到，别人也一样。走得远一点</p>
<p>先用铲子和冰斧将草皮或地表整理出一个直径为10至15厘米的圆，再将表层草皮移开放在一边。猫坑的深度不要超过20厘米，大体上和腐植层相当，因为腐植层中的东西分解速度最快。方便完后，用松软的土壤把排泄物盖上，用棍子或铲子稍加混合，接着把草皮盖上，最后封好猫坑，整理附近的植被，恢复原貌。</p>
<h3 id="将排泄物背下山"><a href="#将排泄物背下山" class="headerlink" title="将排泄物背下山"></a>将排泄物背下山</h3><p>在热门的冰河路线，高山贫瘠的矿物土壤地带、沙漠、岩壁、冰攀路线、极区冻原等地方，以及冬季登山时，将排泄物装好背出去已成为登山者的首选做法。</p>
<h4 id="使用双层袋"><a href="#使用双层袋" class="headerlink" title="使用双层袋"></a>使用双层袋</h4><p>跟人们处理宠物狗的排泄物一样可以在内层塑料袋使用氨水海绵、石灰或猫砂来抑制气味</p>
<h4 id="裂隙掩埋法"><a href="#裂隙掩埋法" class="headerlink" title="裂隙掩埋法"></a>裂隙掩埋法</h4><h4 id="遵循“60米原则”"><a href="#遵循“60米原则”" class="headerlink" title="遵循“60米原则”"></a>遵循“60米原则”</h4><p>在清洗时，请遵循“60米原则”。洗碗时，可用热水代替洗洁精废水一定要远离水源，并位于营地下方处。废水也可以以弧形猛泼出去，让废水形成水雾</p>
<p>跳入湖泊或溪流前，先把身体清洗干净，不然这些油脂与化学物质会对水生植物造成伤害</p>
<h2 id="山林守护者"><a href="#山林守护者" class="headerlink" title="山林守护者"></a>山林守护者</h2><h3 id="保护荒野原貌"><a href="#保护荒野原貌" class="headerlink" title="保护荒野原貌"></a>保护荒野原貌</h3><p>露营之后请尽量恢复原貌</p>
<p>少用锯子、斧头、钉子</p>
<p>不要破坏植物，采摘植物</p>
<h3 id="善待野生动物"><a href="#善待野生动物" class="headerlink" title="善待野生动物"></a>善待野生动物</h3><p>不要投喂动物不要打扰攀登路线上筑巢</p>
<h3 id="为同伴着想"><a href="#为同伴着想" class="headerlink" title="为同伴着想"></a>为同伴着想</h3><p>减少自己的声音听音乐用耳机</p>
<h4 id="将影响降至最低"><a href="#将影响降至最低" class="headerlink" title="将影响降至最低"></a>将影响降至最低</h4><p>自己背炉具绳子使用自然色的松动的石头试着塞紧</p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/08/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0/%E9%80%9A%E8%BF%87%E5%9B%B0%E9%9A%BE%E5%9C%B0%E5%BD%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/08/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0/%E9%80%9A%E8%BF%87%E5%9B%B0%E9%9A%BE%E5%9C%B0%E5%BD%A2/" class="post-title-link" itemprop="url">通过困难地形</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-08 09:13:22" itemprop="dateCreated datePublished" datetime="2022-10-08T09:13:22+08:00">2022-10-08</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/" itemprop="url" rel="index"><span itemprop="name">户外</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">登山知识与技巧</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0/" itemprop="url" rel="index"><span itemprop="name">行走</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.1k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="灌木丛"><a href="#灌木丛" class="headerlink" title="灌木丛"></a>灌木丛</h2><p>在偏远地区，灌木丛简直是登山者的噩梦，密生的灌木丛会遮住危险的悬崖、巨石和沟壑。灌木本身也会缠住绳子或冰斧。以下是登山者常用的避开灌木丛的方法：</p>
<p>尽量跟着山径走：走8km山经可能快过穿越1km灌木丛在积雪覆盖灌木丛时穿过避开雪崩路线寻找大树，大树旁的灌木丛会比较稀疏走在碎石或残雪上寻找兽径走山脊的主棱或支棱沿着溪流行走直接在河道上行走走地势较高的路线走悬崖的底部</p>
<h2 id="碎石坡"><a href="#碎石坡" class="headerlink" title="碎石坡"></a>碎石坡</h2><p>碎石区的石块比较大，通常，一只脚踩上没有问题，石砾区的石块比较小，有些就像粗砂一样，大一点的直径有几厘米，只要一踩上去就会陷下去。石块较大的碎石坡是经年累月形成的，泥土已经将碎石的间隙填满，摩擦较大，不容易滑动，形成了一条天然的易走的山径。但形成时间不长的碎石坡或火山上的碎石坡因为没有长出植物，石块很容易松动。如果走在这样的石坡上，最好是踩在那些长出苔藓的石块上，因为这样的石块比较稳固，没有经常移动，否则就长不出苔藓。</p>
<p>保持警惕，脚下石头松落随时准备跳开。走一步要规划四五步。可以使用登山杖探路</p>
<p>队伍不要拉太长，避免落石增加动能，造成更严重的伤害</p>
<p>砾石区下坡可以采取大步滑踩下降，类似于滑雪的技巧</p>
<h2 id="积雪路径"><a href="#积雪路径" class="headerlink" title="积雪路径"></a>积雪路径</h2><p>如果积雪覆盖了整条路径，就要注意寻找积雪未覆盖的地面物体，这些物体的位置往往是雪层较薄的地方。</p>
<p>溪水的冲刷会不断融化雪桥的底层，直到雪桥丧失支撑登山者的功能。为了避免掉入水中，在过雪桥时先观察雪面是否有凹陷、颜色是否有变化，并仔细听是否有流水的声音。如果雪原底部有水流出表示下面有洞，从水量的大小可以看出洞的大小。可以用冰斧刺探较薄的雪层，以确定下面是否有空洞。</p>
<p>##过溪过溪会消耗大量的时问和精力，而且危险程度也最高。</p>
<p>###寻找过溪点尽可能从可以达到的高处来判断过溪点。尽可能从最宽处过溪（窄处路径短，但水流急）</p>
<p>判断溪水的来源，如果是融雪，那么可以等待第二天清晨过溪</p>
<h3 id="过溪"><a href="#过溪" class="headerlink" title="过溪"></a>过溪</h3><p>解开背包腰带和胸口，如果摔倒可以快速卸掉背包，便于游泳</p>
<p>利用倒木过溪：最好的方式，如果不平等等状态，采取登山杖等工具。必要可以骑在倒木上用手撑着慢慢移动</p>
<p>利用石头过溪：过溪前，必须在脑中预定线路</p>
<p>涉水过溪：注意装备防水。难度大：可以穿着登山鞋过溪（把袜子和鞋垫放进背包）水深：建议脱掉长裤或其他衣物，减少水中行走的阻力水深但水不急：保持和水流大致相同的速度，朝着下游方向斜横过溪（阻力最小的方法）</p>
<p>最好的过溪姿势：面朝上游、身体略微倾斜、登山杖朝上游方向插入水中作为第三个支撑点</p>
<p>只要水超过膝盖，溪水就有一定得危险</p>
<p><strong>结队过溪</strong>：木头：两个或两个以上的登山者可以利用木头来互相保证安全，任何人失去平衡都可以靠木头来恢复绳索（常用）：</p>
<h3 id="落水"><a href="#落水" class="headerlink" title="落水"></a>落水</h3><p>安全姿势：双脚朝向下游，保持仰泳姿势。如果遇到拦截物，迅速恢复头先脚后，借助“拦截物”尝试上岸</p>
<p>倒木摔倒：朝下游一方跌下，避免冲到倒木下</p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0/%E6%AD%A5%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0/%E6%AD%A5%E8%A1%8C/" class="post-title-link" itemprop="url">步行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-01 13:00:36" itemprop="dateCreated datePublished" datetime="2022-10-01T13:00:36+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/" itemprop="url" rel="index"><span itemprop="name">户外</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">登山知识与技巧</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E8%A1%8C%E8%B5%B0/" itemprop="url" rel="index"><span itemprop="name">行走</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>1.6k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="步行"><a href="#步行" class="headerlink" title="步行"></a>步行</h2><p>踏上山径之前，先舒展双跟、臀部、背部和肩膀；多喝水；在容易起水泡的部位贴好斜纹布条；花点时间调整背包与登山鞋，免太紧导致肌肉酸痛而在行进途中停下来调整。</p>
<p>出发前就要做好途中休息的准备。将-一整天会反复用到的东再，.例如爱食、水、外套、帽子、手套、绑腿、太阳眼镜与买灯等放在背包外面便于取放的口袋里。这不仅方便你本人取放，也方便队友取放，并且不用卸下背包或是停下来。把冰斧和登山挂在背包上并绑好，在遇到崎岖地形可直接取下使用。就算尚未进入雪地，冰斧也相当有用。</p>
<h2 id="设定速度"><a href="#设定速度" class="headerlink" title="设定速度"></a>设定速度</h2><p>从一天始就要设定好攀登速度，适当的速度可以让一天的攀登都保持愉快</p>
<p>如果你不能在接下来的几个小时里维持相同的速度，又或者你无法在交谈时维持正常的呼吸，那就说明你的速度太快了</p>
<p>另一个常见的错误就是速度太慢。这不仅会延长行进的时间，也会压缩处理行程中需要技术性攀登路线的时间。如果你是因为疲倦而放慢脚步，请记得身体还有很大的潜能。肌肉开始酸痛的时候，人其实还能继续走16公里</p>
<p>在登山途中，一定程度的不适是无法避免的。走得太快或太慢都会让你更加疲倦。</p>
<p>刚出发时，慢慢地走，可以当做热身。在开始流汗时，休息一会儿并脱掉一些衣服。之后就可以加快步伐，忍受身体的疼痛，让身体进入“重新振作”阶段。此时，你的心跳加快，血液循环加速，肌肉放松。当脑内啡开始起作用之后，身体的压力会减小，你会觉得自己不仅强壮有力，而且心情也很放松。</p>
<p>依据具体的山径情况调整速度。上坡时步调缓慢而有条不紊，在台阶变缓的时候要加快行进步伐。综合考虑背包的重量、地、气和其他因素后，确定一个适宜的行进速度。</p>
<p>疲惫会让一天行程的最后阶段的速度不可避免地慢下来。肾上腺素虽然可以暂时微发身体能量，但“重新振作”状态在一天之内只会出现一次。</p>
<h2 id="休息步法"><a href="#休息步法" class="headerlink" title="休息步法"></a>休息步法</h2><p>休息步法的精髓在于每踏出一步后都会伴随一次短暂的停顿，但并非完全停下</p>
<p>使用休总步法时要有耐心。这种单调重复的步骤很可能让队伍士气低落，尤其是当你只是单纯地在雪地跟随着另一位队友向上行进，而不用寻找攀登路线或踢步阶的时候。在脑子里哼一首轻快的歌曲吧，特别是在离登顶还很远的时候，相信这个步法能带领你成功登顶。</p>
<p>休息步法：a.把全身重量集中在右腿，呼气，放松左腿：b.吸气并迈出右腿走下一一步，将身体重量集中在左腿上：C呼气，放松右腿。</p>
<h2 id="途中休息"><a href="#途中休息" class="headerlink" title="途中休息"></a>途中休息</h2><p>在队伍行进半小时后，要停下来让队员调整鞋带和背包带，增减衣服。在行进之初，身体很精神，每隔一小时或一个半小时可以短暂休总一次。采用站立或半躺的姿势休息，靠着树或坡以减轻背包给肩膀带来的负重。保持顺畅的呼吸，吃点零食或喝点水。要注意预防脱水，最好每次休息时都要补充水分。</p>
<p>在队伍行进一段时间后，就可能需要更长的休息时间了，此时可以每隔两小时就充分休息一次。找一个环境较好的地方，例如水边、容易卸卜背包的斜坡、风景优美的地方等。舒展舒展筋骨，可以适当添加衣物，但在出发时要脱掉，不要才走几步就停下来脱衣服。</p>
<h2 id="下坡要领"><a href="#下坡要领" class="headerlink" title="下坡要领"></a>下坡要领</h2><p>长时间下坡会给登山者的身体带来疼痛。这是因为在下坡时，身休和背包的重量都压在了双腿、膝盖与脚上，脚趾不但会受到挤压，走路时的震动甚至会通过脊椎传遍整个身体。通过以下几个技巧，可以避免很多伤害，例如起水泡、膝盖软骨受伤、脚趾痛、趾甲出血变黑、头痛、背痛等。</p>
<ul>
<li>出发前修剪脚趾甲。</li>
<li>绑紧鞋带，防止脚在鞋子里滑来滑去，</li>
<li>避免脚趾受到挤压。</li>
<li>落步时膝盖略弯，可以诚缓震动。</li>
<li>如果脚开始有痛感，下脚时要轻。</li>
<li>使用雪杖或登山杖，减轻膝盖的负担，还能稳定身体</li>
<li>下坡的速度要慢一些 ，不要一时兴起就冲下去</li>
<li>必要时使用冰斧保持平衡或制动。冰斧的使用范围不限于雪地，在陡峭的草坡上、森林里或灌木丛中都可以用来辅助攀登。</li>
</ul>
<h2 id="横渡的注意事项"><a href="#横渡的注意事项" class="headerlink" title="横渡的注意事项"></a>横渡的注意事项</h2><p>上攀或下坡都远不如横渡困难。沿着斜坡一侧行走容易扭伤脚踝、髋部，并且不易保持身体平衡如果可能，不要横渡，改为下降到无灌木的山谷或爬上圆缓的山脊。无可避免，寻找岩点、兽迹、灌木丛上方易同行地面，使用之字形走法</p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E5%AF%BB%E8%B7%AF/%E8%A7%82%E5%AF%9F%E8%B7%AF%E7%BA%BF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E5%AF%BB%E8%B7%AF/%E8%A7%82%E5%AF%9F%E8%B7%AF%E7%BA%BF/" class="post-title-link" itemprop="url">观察路线</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-01 11:26:13" itemprop="dateCreated datePublished" datetime="2022-10-01T11:26:13+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/" itemprop="url" rel="index"><span itemprop="name">户外</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">登山知识与技巧</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E5%AF%BB%E8%B7%AF/" itemprop="url" rel="index"><span itemprop="name">寻路</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>458</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>先用你的眼睛攀登。远距离眺望可以看到到山脊、悬崖、雪原、冰川的大致走势以及坡度。近距离观察，可以看见断层线、悬崖带和出现的裂隙。从以下方面寻找路线索：较两边山坡平缓的棱线；可以向上或横越坡面的岩隙、岩石凸出点或烟囱状局部地形，雪原或冰河易于通行的区位。找出攀登路段，然后将其连接起来。随着经验的积累，你将拥有一双可以轻易地找到与自己的攀登能力相适应的攀登路线的眼睛。</p>
<p>如果路线是从山脚开始，尝试从不同的角度去观察。当你从正面观察时，即使是平缓的斜坡看起来也十分陡峭。有时，从正面来断崖壁面上没办法清晰分辨的连串岩块凸点，从侧面就能看得一清二楚。</p>
<h2 id="注意危险地形"><a href="#注意危险地形" class="headerlink" title="注意危险地形"></a>注意危险地形</h2><p>休息时间应安排在穿过危险地形之前或之后。当你进人危险地带后，尽量不要被其他速度较的队员拖慢你的速度。如果可能，尽量不要在下大雨时通过危险路段。</p>
<p>对危险地形要随时保持警惕，并继续寻找安全前进的路线，如果目前线路存在隐患，就要今早寻找替代路线</p>
<h2 id="规划回程路线"><a href="#规划回程路线" class="headerlink" title="规划回程路线"></a>规划回程路线</h2><p>适合上攀并不意味着容易下行。行进途中要经常回头看看，携带好GPS和高度计，对一些标志景物做好笔记。随时考虑安全问题</p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E5%AF%BB%E8%B7%AF/%E6%90%9C%E9%9B%86%E8%B7%AF%E7%BA%BF%E4%BF%A1%E6%81%AF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="liaozonglong">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LZL">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/01/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E5%AF%BB%E8%B7%AF/%E6%90%9C%E9%9B%86%E8%B7%AF%E7%BA%BF%E4%BF%A1%E6%81%AF/" class="post-title-link" itemprop="url">搜集路线信息</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-01 11:21:16" itemprop="dateCreated datePublished" datetime="2022-10-01T11:21:16+08:00">2022-10-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-04-23 09:06:00" itemprop="dateModified" datetime="2023-04-23T09:06:00+08:00">2023-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/" itemprop="url" rel="index"><span itemprop="name">户外</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/" itemprop="url" rel="index"><span itemprop="name">登山知识与技巧</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%88%B7%E5%A4%96/%E7%99%BB%E5%B1%B1%E7%9F%A5%E8%AF%86%E4%B8%8E%E6%8A%80%E5%B7%A7/%E5%AF%BB%E8%B7%AF/" itemprop="url" rel="index"><span itemprop="name">寻路</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>142</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>登山前搜集的信息越多，越有利于在登山过程中作出正确的判断。多花时间研究准备攀登地区的地质和气候。每条山脉都有自己的特性</p>
<p>登山指南提供了详细的信息，线路。预计时间，海拔高度，路线长度</p>
<p>不同的地图都可以提供有用的细节（航拍、登山者自绘、地形图）</p>
<p>一些有用的额路线信息通畅是通过与当地人交谈获取的</p>

      
    </div>

    <div>
        
     </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">liaozonglong</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">106</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">66</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">61</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/liaozonglong" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;liaozonglong" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">liaozonglong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">368k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">5:35</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
